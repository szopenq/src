; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\UserInterface\PythonApplicationModule.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?bVisibleNotice@@3HA				; bVisibleNotice
PUBLIC	?bTestServerFlag@@3HA				; bTestServerFlag
PUBLIC	?TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE@@3HA ; TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE
_BSS	SEGMENT
?bTestServerFlag@@3HA DD 01H DUP (?)			; bTestServerFlag
?TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE@@3HA DD 01H DUP (?) ; TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE
_BSS	ENDS
_DATA	SEGMENT
?bVisibleNotice@@3HA DD 01H				; bVisibleNotice
_DATA	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?strstr@@YAPADPADPBD@Z				; strstr
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXCOLOR@@QAE@MMMM@Z			; D3DXCOLOR::D3DXCOLOR
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?Instance@?$CSingleton@VCPythonLauncher@@@@SAAAVCPythonLauncher@@XZ ; CSingleton<CPythonLauncher>::Instance
PUBLIC	?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ ; CSingleton<UI::CWindowManager>::Instance
PUBLIC	?initapp@@YAXXZ					; initapp
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	?Instance@?$singleton@VCGuildMarkManager@@@@SAAAVCGuildMarkManager@@XZ ; singleton<CGuildMarkManager>::Instance
PUBLIC	??0SCameraPos@IAbstractApplication@@QAE@XZ	; IAbstractApplication::SCameraPos::SCameraPos
PUBLIC	??0SCameraSetting@IAbstractApplication@@QAE@XZ	; IAbstractApplication::SCameraSetting::SCameraSetting
PUBLIC	?Instance@?$CSingleton@VCMovieMan@@@@SAAAVCMovieMan@@XZ ; CSingleton<CMovieMan>::Instance
PUBLIC	?Instance@CPythonApplication@@SAAAV1@XZ		; CPythonApplication::Instance
PUBLIC	?GetCursorNum@CPythonApplication@@QAEHXZ	; CPythonApplication::GetCursorNum
PUBLIC	?GetFaceSpeed@CPythonApplication@@QAEMXZ	; CPythonApplication::GetFaceSpeed
PUBLIC	?GetAveRenderTime@CPythonApplication@@QAEMXZ	; CPythonApplication::GetAveRenderTime
PUBLIC	?GetCurRenderTime@CPythonApplication@@QAEKXZ	; CPythonApplication::GetCurRenderTime
PUBLIC	?GetCurUpdateTime@CPythonApplication@@QAEKXZ	; CPythonApplication::GetCurUpdateTime
PUBLIC	?GetUpdateFPS@CPythonApplication@@QAEKXZ	; CPythonApplication::GetUpdateFPS
PUBLIC	?GetRenderFPS@CPythonApplication@@QAEKXZ	; CPythonApplication::GetRenderFPS
PUBLIC	?GetLoad@CPythonApplication@@QAEKXZ		; CPythonApplication::GetLoad
PUBLIC	?GetFaceCount@CPythonApplication@@QAEKXZ	; CPythonApplication::GetFaceCount
PUBLIC	?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ; CSingleton<CCameraManager>::Instance
PUBLIC	?appShowWebPage@@YAPAU_object@@PAU1@0@Z		; appShowWebPage
PUBLIC	?appMoveWebPage@@YAPAU_object@@PAU1@0@Z		; appMoveWebPage
PUBLIC	?appHideWebPage@@YAPAU_object@@PAU1@0@Z		; appHideWebPage
PUBLIC	?appIsWebPageMode@@YAPAU_object@@PAU1@0@Z	; appIsWebPageMode
PUBLIC	?appEnablePerformanceTime@@YAPAU_object@@PAU1@0@Z ; appEnablePerformanceTime
PUBLIC	?appSetTextTailLivingTime@@YAPAU_object@@PAU1@0@Z ; appSetTextTailLivingTime
PUBLIC	?appSetHairColorEnable@@YAPAU_object@@PAU1@0@Z	; appSetHairColorEnable
PUBLIC	?appSetArmorSpecularEnable@@YAPAU_object@@PAU1@0@Z ; appSetArmorSpecularEnable
PUBLIC	?appSetWeaponSpecularEnable@@YAPAU_object@@PAU1@0@Z ; appSetWeaponSpecularEnable
PUBLIC	?appSetSkillEffectUpgradeEnable@@YAPAU_object@@PAU1@0@Z ; appSetSkillEffectUpgradeEnable
PUBLIC	?SetTwoHandedWeaponAttSpeedDecreaseValue@@YAPAU_object@@PAU1@0@Z ; SetTwoHandedWeaponAttSpeedDecreaseValue
PUBLIC	?appSetRideHorseEnable@@YAPAU_object@@PAU1@0@Z	; appSetRideHorseEnable
PUBLIC	?appSetCameraMaxDistance@@YAPAU_object@@PAU1@0@Z ; appSetCameraMaxDistance
PUBLIC	?appSetControlFP@@YAPAU_object@@PAU1@0@Z	; appSetControlFP
PUBLIC	?appSetSpecularSpeed@@YAPAU_object@@PAU1@0@Z	; appSetSpecularSpeed
PUBLIC	?appSetMinFog@@YAPAU_object@@PAU1@0@Z		; appSetMinFog
PUBLIC	?appSetFrameSkip@@YAPAU_object@@PAU1@0@Z	; appSetFrameSkip
PUBLIC	?appForceSetLocale@@YAPAU_object@@PAU1@0@Z	; appForceSetLocale
PUBLIC	?appGetLocaleServiceName@@YAPAU_object@@PAU1@0@Z ; appGetLocaleServiceName
PUBLIC	?appSetCHEONMA@@YAPAU_object@@PAU1@0@Z		; appSetCHEONMA
PUBLIC	?appIsCHEONMA@@YAPAU_object@@PAU1@0@Z		; appIsCHEONMA
PUBLIC	?appLoadLocaleAddr@@YAPAU_object@@PAU1@0@Z	; appLoadLocaleAddr
PUBLIC	?appLoadLocaleData@@YAPAU_object@@PAU1@0@Z	; appLoadLocaleData
PUBLIC	?appGetLocaleName@@YAPAU_object@@PAU1@0@Z	; appGetLocaleName
PUBLIC	?appGetLocalePath@@YAPAU_object@@PAU1@0@Z	; appGetLocalePath
PUBLIC	?appGetDefaultCodePage@@YAPAU_object@@PAU1@0@Z	; appGetDefaultCodePage
PUBLIC	?appGetImageInfo@@YAPAU_object@@PAU1@0@Z	; appGetImageInfo
PUBLIC	?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ ; CSingleton<CEterPackManager>::Instance
PUBLIC	?appIsExistFile@@YAPAU_object@@PAU1@0@Z		; appIsExistFile
PUBLIC	?appGetFileList@@YAPAU_object@@PAU1@0@Z		; appGetFileList
PUBLIC	?appUpdateGame@@YAPAU_object@@PAU1@0@Z		; appUpdateGame
PUBLIC	?appRenderGame@@YAPAU_object@@PAU1@0@Z		; appRenderGame
PUBLIC	?appSetMouseHandler@@YAPAU_object@@PAU1@0@Z	; appSetMouseHandler
PUBLIC	?appCreate@@YAPAU_object@@PAU1@0@Z		; appCreate
PUBLIC	?appLoop@@YAPAU_object@@PAU1@0@Z		; appLoop
PUBLIC	?appGetInfo@@YAPAU_object@@PAU1@0@Z		; appGetInfo
PUBLIC	?appProcess@@YAPAU_object@@PAU1@0@Z		; appProcess
PUBLIC	?appAbort@@YAPAU_object@@PAU1@0@Z		; appAbort
PUBLIC	?appExit@@YAPAU_object@@PAU1@0@Z		; appExit
PUBLIC	?appSetCamera@@YAPAU_object@@PAU1@0@Z		; appSetCamera
PUBLIC	?appGetCamera@@YAPAU_object@@PAU1@0@Z		; appGetCamera
PUBLIC	?appGetCameraPitch@@YAPAU_object@@PAU1@0@Z	; appGetCameraPitch
PUBLIC	?appGetCameraRotation@@YAPAU_object@@PAU1@0@Z	; appGetCameraRotation
PUBLIC	?appGetTime@@YAPAU_object@@PAU1@0@Z		; appGetTime
PUBLIC	?appGetGlobalTime@@YAPAU_object@@PAU1@0@Z	; appGetGlobalTime
PUBLIC	?appGetGlobalTimeStamp@@YAPAU_object@@PAU1@0@Z	; appGetGlobalTimeStamp
PUBLIC	?appGetUpdateFPS@@YAPAU_object@@PAU1@0@Z	; appGetUpdateFPS
PUBLIC	?appGetRenderFPS@@YAPAU_object@@PAU1@0@Z	; appGetRenderFPS
PUBLIC	?appRotateCamera@@YAPAU_object@@PAU1@0@Z	; appRotateCamera
PUBLIC	?appPitchCamera@@YAPAU_object@@PAU1@0@Z		; appPitchCamera
PUBLIC	?appZoomCamera@@YAPAU_object@@PAU1@0@Z		; appZoomCamera
PUBLIC	?appMovieRotateCamera@@YAPAU_object@@PAU1@0@Z	; appMovieRotateCamera
PUBLIC	?appMoviePitchCamera@@YAPAU_object@@PAU1@0@Z	; appMoviePitchCamera
PUBLIC	?appMovieZoomCamera@@YAPAU_object@@PAU1@0@Z	; appMovieZoomCamera
PUBLIC	?appMovieResetCamera@@YAPAU_object@@PAU1@0@Z	; appMovieResetCamera
PUBLIC	?appGetFaceSpeed@@YAPAU_object@@PAU1@0@Z	; appGetFaceSpeed
PUBLIC	?appGetRenderTime@@YAPAU_object@@PAU1@0@Z	; appGetRenderTime
PUBLIC	?appGetUpdateTime@@YAPAU_object@@PAU1@0@Z	; appGetUpdateTime
PUBLIC	?appGetLoad@@YAPAU_object@@PAU1@0@Z		; appGetLoad
PUBLIC	?appGetFaceCount@@YAPAU_object@@PAU1@0@Z	; appGetFaceCount
PUBLIC	?appGetAvaiableTextureMememory@@YAPAU_object@@PAU1@0@Z ; appGetAvaiableTextureMememory
PUBLIC	?appSetFPS@@YAPAU_object@@PAU1@0@Z		; appSetFPS
PUBLIC	?appSetGlobalCenterPosition@@YAPAU_object@@PAU1@0@Z ; appSetGlobalCenterPosition
PUBLIC	?appSetCenterPosition@@YAPAU_object@@PAU1@0@Z	; appSetCenterPosition
PUBLIC	?appGetCursorPosition@@YAPAU_object@@PAU1@0@Z	; appGetCursorPosition
PUBLIC	?appRunPythonFile@@YAPAU_object@@PAU1@0@Z	; appRunPythonFile
PUBLIC	?appIsPressed@@YAPAU_object@@PAU1@0@Z		; appIsPressed
PUBLIC	?appSetCursor@@YAPAU_object@@PAU1@0@Z		; appSetCursor
PUBLIC	?appGetCursor@@YAPAU_object@@PAU1@0@Z		; appGetCursor
PUBLIC	?appShowCursor@@YAPAU_object@@PAU1@0@Z		; appShowCursor
PUBLIC	?appHideCursor@@YAPAU_object@@PAU1@0@Z		; appHideCursor
PUBLIC	?appIsShowCursor@@YAPAU_object@@PAU1@0@Z	; appIsShowCursor
PUBLIC	?appIsLiarCursorOn@@YAPAU_object@@PAU1@0@Z	; appIsLiarCursorOn
PUBLIC	?appSetSoftwareCursor@@YAPAU_object@@PAU1@0@Z	; appSetSoftwareCursor
PUBLIC	?appSetHardwareCursor@@YAPAU_object@@PAU1@0@Z	; appSetHardwareCursor
PUBLIC	?appSetConnectData@@YAPAU_object@@PAU1@0@Z	; appSetConnectData
PUBLIC	?appGetConnectData@@YAPAU_object@@PAU1@0@Z	; appGetConnectData
PUBLIC	?appGetRandom@@YAPAU_object@@PAU1@0@Z		; appGetRandom
PUBLIC	?appGetRotatingDirection@@YAPAU_object@@PAU1@0@Z ; appGetRotatingDirection
PUBLIC	?appGetDegreeDifference@@YAPAU_object@@PAU1@0@Z	; appGetDegreeDifference
PUBLIC	?appSleep@@YAPAU_object@@PAU1@0@Z		; appSleep
PUBLIC	?appSetDefaultFontName@@YAPAU_object@@PAU1@0@Z	; appSetDefaultFontName
PUBLIC	?appSetGuildSymbolPath@@YAPAU_object@@PAU1@0@Z	; appSetGuildSymbolPath
PUBLIC	?appEnableSpecialCameraMode@@YAPAU_object@@PAU1@0@Z ; appEnableSpecialCameraMode
PUBLIC	?appSetCameraSpeed@@YAPAU_object@@PAU1@0@Z	; appSetCameraSpeed
PUBLIC	?appIsFileExist@@YAPAU_object@@PAU1@0@Z		; appIsFileExist
PUBLIC	?appSetCameraSetting@@YAPAU_object@@PAU1@0@Z	; appSetCameraSetting
PUBLIC	?appSaveCameraSetting@@YAPAU_object@@PAU1@0@Z	; appSaveCameraSetting
PUBLIC	?appLoadCameraSetting@@YAPAU_object@@PAU1@0@Z	; appLoadCameraSetting
PUBLIC	?appSetDefaultCamera@@YAPAU_object@@PAU1@0@Z	; appSetDefaultCamera
PUBLIC	?appSetSightRange@@YAPAU_object@@PAU1@0@Z	; appSetSightRange
PUBLIC	?apptestGetAccumulationTime@@YAPAU_object@@PAU1@0@Z ; apptestGetAccumulationTime
PUBLIC	?apptestResetAccumulationTime@@YAPAU_object@@PAU1@0@Z ; apptestResetAccumulationTime
PUBLIC	?apptestSetSpecularColor@@YAPAU_object@@PAU1@0@Z ; apptestSetSpecularColor
PUBLIC	?appSetVisibleNotice@@YAPAU_object@@PAU1@0@Z	; appSetVisibleNotice
PUBLIC	?appIsVisibleNotice@@YAPAU_object@@PAU1@0@Z	; appIsVisibleNotice
PUBLIC	?appEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z ; appEnableTestServerFlag
PUBLIC	?appIsEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z ; appIsEnableTestServerFlag
PUBLIC	??0CTextLineLoader@@QAE@PBD@Z			; CTextLineLoader::CTextLineLoader
PUBLIC	?GetLineCount@CTextLineLoader@@QAEKXZ		; CTextLineLoader::GetLineCount
PUBLIC	?GetLine@CTextLineLoader@@QAEPBDK@Z		; CTextLineLoader::GetLine
PUBLIC	??1CTextLineLoader@@QAE@XZ			; CTextLineLoader::~CTextLineLoader
PUBLIC	??_GCTextLineLoader@@QAEPAXI@Z			; CTextLineLoader::`scalar deleting destructor'
PUBLIC	?appOpenTextFile@@YAPAU_object@@PAU1@0@Z	; appOpenTextFile
PUBLIC	?appCloseTextFile@@YAPAU_object@@PAU1@0@Z	; appCloseTextFile
PUBLIC	?appGetTextFileLineCount@@YAPAU_object@@PAU1@0@Z ; appGetTextFileLineCount
PUBLIC	?appGetTextFileLine@@YAPAU_object@@PAU1@0@Z	; appGetTextFileLine
PUBLIC	?appSetGuildMarkPath@@YAPAU_object@@PAU1@0@Z	; appSetGuildMarkPath
PUBLIC	?appIsDevStage@@YAPAU_object@@PAU1@0@Z		; appIsDevStage
PUBLIC	?appIsTestStage@@YAPAU_object@@PAU1@0@Z		; appIsTestStage
PUBLIC	?appIsLiveStage@@YAPAU_object@@PAU1@0@Z		; appIsLiveStage
PUBLIC	?appLogoOpen@@YAPAU_object@@PAU1@0@Z		; appLogoOpen
PUBLIC	?appLogoUpdate@@YAPAU_object@@PAU1@0@Z		; appLogoUpdate
PUBLIC	?appLogoRender@@YAPAU_object@@PAU1@0@Z		; appLogoRender
PUBLIC	?appLogoClose@@YAPAU_object@@PAU1@0@Z		; appLogoClose
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A ; CSingleton<CPythonLauncher>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	?ms_singleton@?$singleton@VCGuildMarkManager@@@@0PAVCGuildMarkManager@@A ; singleton<CGuildMarkManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A ; CSingleton<CMovieMan>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_0M@OEKALNFB@RENDER_GAME?$AA@		; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_02OIKAIHIF@s?$CD?$AA@			; `string'
PUBLIC	??_C@_03GLKMLICL@iii?$AA@			; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	??_C@_04EOBPFJGD@ffff?$AA@			; `string'
PUBLIC	??_C@_01INIBCBCB@f?$AA@				; `string'
PUBLIC	??_C@_02PINLEBJB@fi?$AA@			; `string'
PUBLIC	??_C@_02PDIHAGKM@ii?$AA@			; `string'
PUBLIC	??_C@_0BH@GNAGLJEE@Wrong?5Cursor?5Name?5?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_02OCDGCAAK@si?$AA@			; `string'
PUBLIC	??_C@_04JCAPCJAP@?4tga?$AA@			; `string'
PUBLIC	??_C@_0L@OAAOKAFA@IsDevStage?$AA@		; `string'
PUBLIC	??_C@_0M@ICBDOOOG@IsTestStage?$AA@		; `string'
PUBLIC	??_C@_0M@NJBHEFPA@IsLiveStage?$AA@		; `string'
PUBLIC	??_C@_0BG@EOCGHNJF@SetTextTailLivingTime?$AA@	; `string'
PUBLIC	??_C@_0BG@DEJFIMMP@EnablePerformanceTime?$AA@	; `string'
PUBLIC	??_C@_0BD@PILPKKLH@SetHairColorEnable?$AA@	; `string'
PUBLIC	??_C@_0BH@PJOFIHBE@SetArmorSpecularEnable?$AA@	; `string'
PUBLIC	??_C@_0BI@ONHBEMJA@SetWeaponSpecularEnable?$AA@	; `string'
PUBLIC	??_C@_0BM@CMPMDOBN@SetSkillEffectUpgradeEnable?$AA@ ; `string'
PUBLIC	??_C@_0CI@KEKBEMLJ@SetTwoHandedWeaponAttSpeedDecrea@ ; `string'
PUBLIC	??_C@_0BD@CPFDKOFJ@SetRideHorseEnable?$AA@	; `string'
PUBLIC	??_C@_0BF@CEAHHILA@SetCameraMaxDistance?$AA@	; `string'
PUBLIC	??_C@_09ILNFAENI@SetMinFog?$AA@			; `string'
PUBLIC	??_C@_0N@KCIEBLLG@SetFrameSkip?$AA@		; `string'
PUBLIC	??_C@_0N@CLLAGICL@GetImageInfo?$AA@		; `string'
PUBLIC	??_C@_07NAJNLNAF@GetInfo?$AA@			; `string'
PUBLIC	??_C@_0L@HMEHDBP@UpdateGame?$AA@		; `string'
PUBLIC	??_C@_0L@ONMMANJD@RenderGame?$AA@		; `string'
PUBLIC	??_C@_04KLCPKPBE@Loop?$AA@			; `string'
PUBLIC	??_C@_06MIKANEJK@Create?$AA@			; `string'
PUBLIC	??_C@_07MNGBFJEN@Process?$AA@			; `string'
PUBLIC	??_C@_04LBABLPF@Exit?$AA@			; `string'
PUBLIC	??_C@_05BGKIEECB@Abort?$AA@			; `string'
PUBLIC	??_C@_0BA@PPCHHCMN@SetMouseHandler?$AA@		; `string'
PUBLIC	??_C@_0M@DHIFKLBN@IsExistFile?$AA@		; `string'
PUBLIC	??_C@_0M@KODKGGCI@GetFileList?$AA@		; `string'
PUBLIC	??_C@_09IADKBAEN@SetCamera?$AA@			; `string'
PUBLIC	??_C@_09KOHPDBNP@GetCamera?$AA@			; `string'
PUBLIC	??_C@_0P@LHFPHHJA@GetCameraPitch?$AA@		; `string'
PUBLIC	??_C@_0BC@JICDJDCH@GetCameraRotation?$AA@	; `string'
PUBLIC	??_C@_07CDIANBOE@GetTime?$AA@			; `string'
PUBLIC	??_C@_0O@JKNDJHIN@GetGlobalTime?$AA@		; `string'
PUBLIC	??_C@_0BD@HGCMJHC@GetGlobalTimeStamp?$AA@	; `string'
PUBLIC	??_C@_0N@JKLFODAC@GetUpdateFPS?$AA@		; `string'
PUBLIC	??_C@_0N@EHIMFGIG@GetRenderFPS?$AA@		; `string'
PUBLIC	??_C@_0N@HGIDFLAJ@RotateCamera?$AA@		; `string'
PUBLIC	??_C@_0M@PKAIAJKC@PitchCamera?$AA@		; `string'
PUBLIC	??_C@_0L@BGDDIOFP@ZoomCamera?$AA@		; `string'
PUBLIC	??_C@_0BC@FCGIGAKD@MovieRotateCamera?$AA@	; `string'
PUBLIC	??_C@_0BB@KFJAAFFB@MoviePitchCamera?$AA@	; `string'
PUBLIC	??_C@_0BA@ILLHHFGG@MovieZoomCamera?$AA@		; `string'
PUBLIC	??_C@_0BB@PJGDEPJO@MovieResetCamera?$AA@	; `string'
PUBLIC	??_C@_0BK@PBNANFFG@GetAvailableTextureMemory?$AA@ ; `string'
PUBLIC	??_C@_0O@KFOAIOPC@GetRenderTime?$AA@		; `string'
PUBLIC	??_C@_0O@EPOIPAHO@GetUpdateTime?$AA@		; `string'
PUBLIC	??_C@_07EGHKJKFO@GetLoad?$AA@			; `string'
PUBLIC	??_C@_0N@KBJEAIDC@GetFaceSpeed?$AA@		; `string'
PUBLIC	??_C@_0N@FGHMKANF@GetFaceCount?$AA@		; `string'
PUBLIC	??_C@_06GHJACMIL@SetFPS?$AA@			; `string'
PUBLIC	??_C@_0BI@BPPNOEKE@SetGlobalCenterPosition?$AA@	; `string'
PUBLIC	??_C@_0BC@MCKFCFLJ@SetCenterPosition?$AA@	; `string'
PUBLIC	??_C@_0BC@DJJGDMOB@GetCursorPosition?$AA@	; `string'
PUBLIC	??_C@_09CIIBMEDP@GetRandom?$AA@			; `string'
PUBLIC	??_C@_0O@NFOAEJMI@RunPythonFile?$AA@		; `string'
PUBLIC	??_C@_0O@JGKOEJBF@IsWebPageMode?$AA@		; `string'
PUBLIC	??_C@_0M@LMDMBNNG@ShowWebPage?$AA@		; `string'
PUBLIC	??_C@_0M@CJKDPGGC@MoveWebPage?$AA@		; `string'
PUBLIC	??_C@_0M@HKOOBKOE@HideWebPage?$AA@		; `string'
PUBLIC	??_C@_09EJGJNKNL@IsPressed?$AA@			; `string'
PUBLIC	??_C@_09PKKOCJGB@SetCursor?$AA@			; `string'
PUBLIC	??_C@_09NEOLAIPD@GetCursor?$AA@			; `string'
PUBLIC	??_C@_0L@BIENLPGM@ShowCursor?$AA@		; `string'
PUBLIC	??_C@_0L@MGJDDPFG@HideCursor?$AA@		; `string'
PUBLIC	??_C@_0N@BFHCIAEF@IsShowCursor?$AA@		; `string'
PUBLIC	??_C@_0P@FMIDHOAE@IsLiarCursorOn?$AA@		; `string'
PUBLIC	??_C@_0BC@IDNDDKLI@SetSoftwareCursor?$AA@	; `string'
PUBLIC	??_C@_0BC@KKHIHHDJ@SetHardwareCursor?$AA@	; `string'
PUBLIC	??_C@_0P@KJLEKPPL@SetConnectData?$AA@		; `string'
PUBLIC	??_C@_0P@GHKKFFNH@GetConnectData?$AA@		; `string'
PUBLIC	??_C@_0BF@IMHAMDDH@GetRotatingDirection?$AA@	; `string'
PUBLIC	??_C@_0BE@JKNPCCAK@GetDegreeDifference?$AA@	; `string'
PUBLIC	??_C@_05PFDOMJEF@Sleep?$AA@			; `string'
PUBLIC	??_C@_0BD@CKMKHHJC@SetDefaultFontName?$AA@	; `string'
PUBLIC	??_C@_0BD@CENDFAOC@SetGuildSymbolPath?$AA@	; `string'
PUBLIC	??_C@_0BI@LNMJCGJN@EnableSpecialCameraMode?$AA@	; `string'
PUBLIC	??_C@_0P@NCLIAJKF@SetCameraSpeed?$AA@		; `string'
PUBLIC	??_C@_0BC@JPDLAHCD@SaveCameraSetting?$AA@	; `string'
PUBLIC	??_C@_0BC@KEOGBKMG@LoadCameraSetting?$AA@	; `string'
PUBLIC	??_C@_0BB@IPPGJFKO@SetDefaultCamera?$AA@	; `string'
PUBLIC	??_C@_0BB@JANPDNEC@SetCameraSetting?$AA@	; `string'
PUBLIC	??_C@_0O@MFMELJAK@SetSightRange?$AA@		; `string'
PUBLIC	??_C@_0M@LOHDPEAO@IsFileExist?$AA@		; `string'
PUBLIC	??_C@_0N@JAMKKFFG@OpenTextFile?$AA@		; `string'
PUBLIC	??_C@_0O@LNEGOIPA@CloseTextFile?$AA@		; `string'
PUBLIC	??_C@_0BF@BNHHEKFO@GetTextFileLineCount?$AA@	; `string'
PUBLIC	??_C@_0BA@HHNFKANE@GetTextFileLine?$AA@		; `string'
PUBLIC	??_C@_0BF@PBACFPCP@GetLocaleServiceName?$AA@	; `string'
PUBLIC	??_C@_0O@JDECMIPJ@GetLocaleName?$AA@		; `string'
PUBLIC	??_C@_0O@OKMLAHKI@GetLocalePath?$AA@		; `string'
PUBLIC	??_C@_0P@KMAINBBA@ForceSetLocale?$AA@		; `string'
PUBLIC	??_C@_0P@JHGEFJDO@LoadLocaleAddr?$AA@		; `string'
PUBLIC	??_C@_0P@BFJDMEJO@LoadLocaleData?$AA@		; `string'
PUBLIC	??_C@_0L@FAIOENFF@SetCHEONMA?$AA@		; `string'
PUBLIC	??_C@_09INPKBHN@IsCHEONMA?$AA@			; `string'
PUBLIC	??_C@_0BD@CEMKCGHA@GetDefaultCodePage?$AA@	; `string'
PUBLIC	??_C@_0N@HDAEMEAH@SetControlFP?$AA@		; `string'
PUBLIC	??_C@_0BB@IFMAFIHG@SetSpecularSpeed?$AA@	; `string'
PUBLIC	??_C@_0BI@DNKBNLNC@testGetAccumulationTime?$AA@	; `string'
PUBLIC	??_C@_0BK@PLDHJGMN@testResetAccumulationTime?$AA@ ; `string'
PUBLIC	??_C@_0BF@KHKICLKO@testSetSpecularColor?$AA@	; `string'
PUBLIC	??_C@_0BB@MMPIECKB@SetVisibleNotice?$AA@	; `string'
PUBLIC	??_C@_0BA@NLDNPIOL@IsVisibleNotice?$AA@		; `string'
PUBLIC	??_C@_0BF@BOMOCGIP@EnableTestServerFlag?$AA@	; `string'
PUBLIC	??_C@_0BH@GBDECBIH@IsEnableTestServerFlag?$AA@	; `string'
PUBLIC	??_C@_0BB@DLDOCGLL@SetGuildMarkPath?$AA@	; `string'
PUBLIC	??_C@_0N@LIPHBNAO@OnLogoUpdate?$AA@		; `string'
PUBLIC	??_C@_0N@ELECBFOK@OnLogoRender?$AA@		; `string'
PUBLIC	??_C@_0L@JMMGDKPP@OnLogoOpen?$AA@		; `string'
PUBLIC	??_C@_0M@JMIFNMOK@OnLogoClose?$AA@		; `string'
PUBLIC	??_C@_03CGOPKBCD@app?$AA@			; `string'
PUBLIC	??_C@_09OKOJMLAA@INFO_ITEM?$AA@			; `string'
PUBLIC	??_C@_0L@FNNFPLHG@INFO_ACTOR?$AA@		; `string'
PUBLIC	??_C@_0M@KLBHMBMD@INFO_EFFECT?$AA@		; `string'
PUBLIC	??_C@_0O@FAGLOALJ@INFO_TEXTTAIL?$AA@		; `string'
PUBLIC	??_C@_0BG@KEIJCHNJ@DEGREE_DIRECTION_SAME?$AA@	; `string'
PUBLIC	??_C@_0BH@LNDFJAFE@DEGREE_DIRECTION_RIGHT?$AA@	; `string'
PUBLIC	??_C@_0BG@JGNHHMCM@DEGREE_DIRECTION_LEFT?$AA@	; `string'
PUBLIC	??_C@_07CJEJDFBD@VK_LEFT?$AA@			; `string'
PUBLIC	??_C@_08LOMCDCA@VK_RIGHT?$AA@			; `string'
PUBLIC	??_C@_05PIGLHCBF@VK_UP?$AA@			; `string'
PUBLIC	??_C@_07NLENKNCK@VK_DOWN?$AA@			; `string'
PUBLIC	??_C@_07OMPILPEG@VK_HOME?$AA@			; `string'
PUBLIC	??_C@_06LPJBNMHN@VK_END?$AA@			; `string'
PUBLIC	??_C@_09EABNPHOI@VK_DELETE?$AA@			; `string'
PUBLIC	??_C@_0L@BOHNMBC@DIK_ESCAPE?$AA@		; `string'
PUBLIC	??_C@_07CACBFKLO@DIK_ESC?$AA@			; `string'
PUBLIC	??_C@_05GCLPJNBN@DIK_1?$AA@			; `string'
PUBLIC	??_C@_05EJJCMONO@DIK_2?$AA@			; `string'
PUBLIC	??_C@_05FAIJPPJP@DIK_3?$AA@			; `string'
PUBLIC	??_C@_05BPMIGJFI@DIK_4?$AA@			; `string'
PUBLIC	??_C@_05GNDFIBJ@DIK_5?$AA@			; `string'
PUBLIC	??_C@_05CNPOALNK@DIK_6?$AA@			; `string'
PUBLIC	??_C@_05DEOFDKJL@DIK_7?$AA@			; `string'
PUBLIC	??_C@_05LDHNCGFE@DIK_8?$AA@			; `string'
PUBLIC	??_C@_05KKGGBHBF@DIK_9?$AA@			; `string'
PUBLIC	??_C@_05HLKEKMFM@DIK_0?$AA@			; `string'
PUBLIC	??_C@_09DOHACMKC@DIK_MINUS?$AA@			; `string'
PUBLIC	??_C@_0L@KKCLPAPI@DIK_EQUALS?$AA@		; `string'
PUBLIC	??_C@_08HHEEGKBL@DIK_BACK?$AA@			; `string'
PUBLIC	??_C@_07MODNCMBL@DIK_TAB?$AA@			; `string'
PUBLIC	??_C@_05HECPGLK@DIK_Q?$AA@			; `string'
PUBLIC	??_C@_05FBBIFBDM@DIK_W?$AA@			; `string'
PUBLIC	??_C@_05CJOMCBOP@DIK_E?$AA@			; `string'
PUBLIC	??_C@_05CMGPKFHJ@DIK_R?$AA@			; `string'
PUBLIC	??_C@_05HKDFACPP@DIK_T?$AA@			; `string'
PUBLIC	??_C@_05MPJLHMLC@DIK_Y?$AA@			; `string'
PUBLIC	??_C@_05GDCODDLO@DIK_U?$AA@			; `string'
PUBLIC	??_C@_05IFFJGOOD@DIK_I?$AA@			; `string'
PUBLIC	??_C@_05NDADMJGF@DIK_O?$AA@			; `string'
PUBLIC	??_C@_05BOFJMHPL@DIK_P?$AA@			; `string'
PUBLIC	??_C@_0N@EFJDLCEF@DIK_LBRACKET?$AA@		; `string'
PUBLIC	??_C@_0N@CBJBCLKG@DIK_RBRACKET?$AA@		; `string'
PUBLIC	??_C@_0L@JLNKBJCL@DIK_RETURN?$AA@		; `string'
PUBLIC	??_C@_0N@ODLLDAI@DIK_LCONTROL?$AA@		; `string'
PUBLIC	??_C@_05ENIAOEOL@DIK_A?$AA@			; `string'
PUBLIC	??_C@_05DFHEJEDI@DIK_S?$AA@			; `string'
PUBLIC	??_C@_05DAPHBAKO@DIK_D?$AA@			; `string'
PUBLIC	??_C@_05CMBHCCM@DIK_F?$AA@			; `string'
PUBLIC	??_C@_05BLNKEDGN@DIK_G?$AA@			; `string'
PUBLIC	??_C@_05JMECFPKC@DIK_H?$AA@			; `string'
PUBLIC	??_C@_05KOHEDNCA@DIK_J?$AA@			; `string'
PUBLIC	??_C@_05LHGPAMGB@DIK_K?$AA@			; `string'
PUBLIC	??_C@_05PICOJKKG@DIK_L?$AA@			; `string'
PUBLIC	??_C@_0O@NEECDLLB@DIK_SEMICOLON?$AA@		; `string'
PUBLIC	??_C@_0P@JDEKLKAM@DIK_APOSTROPHE?$AA@		; `string'
PUBLIC	??_C@_09MOGGLCIP@DIK_GRAVE?$AA@			; `string'
PUBLIC	??_C@_0L@GNGJHMON@DIK_LSHIFT?$AA@		; `string'
PUBLIC	??_C@_0O@DGKNNOHE@DIK_BACKSLASH?$AA@		; `string'
PUBLIC	??_C@_05OELGCPHB@DIK_Z?$AA@			; `string'
PUBLIC	??_C@_05NGIAENPD@DIK_X?$AA@			; `string'
PUBLIC	??_C@_05HPLGIGGJ@DIK_C?$AA@			; `string'
PUBLIC	??_C@_05EIADGAHN@DIK_V?$AA@			; `string'
PUBLIC	??_C@_05GGKNLHCI@DIK_B?$AA@			; `string'
PUBLIC	??_C@_05MKBIPICE@DIK_N?$AA@			; `string'
PUBLIC	??_C@_05OBDFKLOH@DIK_M?$AA@			; `string'
PUBLIC	??_C@_09PDEOJFIH@DIK_COMMA?$AA@			; `string'
PUBLIC	??_C@_0L@HHNLMNCM@DIK_PERIOD?$AA@		; `string'
PUBLIC	??_C@_09DKJEGHEH@DIK_SLASH?$AA@			; `string'
PUBLIC	??_C@_0L@FKIIJLHO@DIK_RSHIFT?$AA@		; `string'
PUBLIC	??_C@_0N@DHLLGHHC@DIK_MULTIPLY?$AA@		; `string'
PUBLIC	??_C@_08OHCJNNJ@DIK_LALT?$AA@			; `string'
PUBLIC	??_C@_09DGAMMAPJ@DIK_SPACE?$AA@			; `string'
PUBLIC	??_C@_0M@KEADBGIC@DIK_CAPITAL?$AA@		; `string'
PUBLIC	??_C@_06PEIHKKCD@DIK_F1?$AA@			; `string'
PUBLIC	??_C@_06NPKKPJOA@DIK_F2?$AA@			; `string'
PUBLIC	??_C@_06MGLBMIKB@DIK_F3?$AA@			; `string'
PUBLIC	??_C@_06IJPAFOGG@DIK_F4?$AA@			; `string'
PUBLIC	??_C@_06JAOLGPCH@DIK_F5?$AA@			; `string'
PUBLIC	??_C@_06LLMGDMOE@DIK_F6?$AA@			; `string'
PUBLIC	??_C@_06KCNNANKF@DIK_F7?$AA@			; `string'
PUBLIC	??_C@_06CFEFBBGK@DIK_F8?$AA@			; `string'
PUBLIC	??_C@_06DMFOCACL@DIK_F9?$AA@			; `string'
PUBLIC	??_C@_07HNNFMACL@DIK_F10?$AA@			; `string'
PUBLIC	??_C@_0M@BAOCLHIM@DIK_NUMLOCK?$AA@		; `string'
PUBLIC	??_C@_0L@HPJOFPCB@DIK_SCROLL?$AA@		; `string'
PUBLIC	??_C@_0M@NDOIJKED@DIK_NUMPAD7?$AA@		; `string'
PUBLIC	??_C@_0M@FEHAIGIM@DIK_NUMPAD8?$AA@		; `string'
PUBLIC	??_C@_0M@ENGLLHMN@DIK_NUMPAD9?$AA@		; `string'
PUBLIC	??_C@_0N@ECOBCKNF@DIK_SUBTRACT?$AA@		; `string'
PUBLIC	??_C@_0M@PIMFMJIA@DIK_NUMPAD4?$AA@		; `string'
PUBLIC	??_C@_0M@OBNOPIMB@DIK_NUMPAD5?$AA@		; `string'
PUBLIC	??_C@_0M@MKPDKLAC@DIK_NUMPAD6?$AA@		; `string'
PUBLIC	??_C@_07PJGLOONL@DIK_ADD?$AA@			; `string'
PUBLIC	??_C@_0M@IFLCDNMF@DIK_NUMPAD1?$AA@		; `string'
PUBLIC	??_C@_0M@KOJPGOAG@DIK_NUMPAD2?$AA@		; `string'
PUBLIC	??_C@_0M@LHIEFPEH@DIK_NUMPAD3?$AA@		; `string'
PUBLIC	??_C@_0M@JMKJAMIE@DIK_NUMPAD0?$AA@		; `string'
PUBLIC	??_C@_0M@PCNKFDKI@DIK_DECIMAL?$AA@		; `string'
PUBLIC	??_C@_07GEMOPBGK@DIK_F11?$AA@			; `string'
PUBLIC	??_C@_07EPODKCKJ@DIK_F12?$AA@			; `string'
PUBLIC	??_C@_0O@DEOEEHEE@DIK_NEXTTRACK?$AA@		; `string'
PUBLIC	??_C@_0BA@OLMCJCJF@DIK_NUMPADENTER?$AA@		; `string'
PUBLIC	??_C@_0N@GKDJCKOL@DIK_RCONTROL?$AA@		; `string'
PUBLIC	??_C@_08KNIFKFHJ@DIK_MUTE?$AA@			; `string'
PUBLIC	??_C@_0P@OJEJDHIP@DIK_CALCULATOR?$AA@		; `string'
PUBLIC	??_C@_0O@ECAMOKPG@DIK_PLAYPAUSE?$AA@		; `string'
PUBLIC	??_C@_0O@FLFOAKOG@DIK_MEDIASTOP?$AA@		; `string'
PUBLIC	??_C@_0P@FKHBCEAD@DIK_VOLUMEDOWN?$AA@		; `string'
PUBLIC	??_C@_0N@GPHLGHED@DIK_VOLUMEUP?$AA@		; `string'
PUBLIC	??_C@_0M@IEADBFND@DIK_WEBHOME?$AA@		; `string'
PUBLIC	??_C@_0BA@ECBGFAAH@DIK_NUMPADCOMMA?$AA@		; `string'
PUBLIC	??_C@_0L@HDEGMNOK@DIK_DIVIDE?$AA@		; `string'
PUBLIC	??_C@_09PCEGCDIO@DIK_SYSRQ?$AA@			; `string'
PUBLIC	??_C@_08NBKCLEDK@DIK_RALT?$AA@			; `string'
PUBLIC	??_C@_09COEFGPNN@DIK_PAUSE?$AA@			; `string'
PUBLIC	??_C@_08EJDGAFAN@DIK_HOME?$AA@			; `string'
PUBLIC	??_C@_06JGABONOM@DIK_UP?$AA@			; `string'
PUBLIC	??_C@_08PJJCOFHN@DIK_PGUP?$AA@			; `string'
PUBLIC	??_C@_08IMIHIPFI@DIK_LEFT?$AA@			; `string'
PUBLIC	??_C@_09OKEHHFIC@DIK_RIGHT?$AA@			; `string'
PUBLIC	??_C@_07HLJOPMFK@DIK_END?$AA@			; `string'
PUBLIC	??_C@_08HOIDBHGB@DIK_DOWN?$AA@			; `string'
PUBLIC	??_C@_08DADHBDOF@DIK_PGDN?$AA@			; `string'
PUBLIC	??_C@_0L@MGNAFAII@DIK_INSERT?$AA@		; `string'
PUBLIC	??_C@_0L@HICEJOHK@DIK_DELETE?$AA@		; `string'
PUBLIC	??_C@_08MNOGKNKK@DIK_LWIN?$AA@			; `string'
PUBLIC	??_C@_08BCDGIEEJ@DIK_RWIN?$AA@			; `string'
PUBLIC	??_C@_08EEDKKFEB@DIK_APPS?$AA@			; `string'
PUBLIC	??_C@_06IOJAGNKJ@NORMAL?$AA@			; `string'
PUBLIC	??_C@_06JIJKOHKJ@ATTACK?$AA@			; `string'
PUBLIC	??_C@_06JNJLBPLI@TARGET?$AA@			; `string'
PUBLIC	??_C@_04LNOLLMNL@TALK?$AA@			; `string'
PUBLIC	??_C@_07LGCIEODJ@CANT_GO?$AA@			; `string'
PUBLIC	??_C@_04IGIDHFMJ@PICK?$AA@			; `string'
PUBLIC	??_C@_04KEJCELCL@DOOR?$AA@			; `string'
PUBLIC	??_C@_05HLBMIDNH@CHAIR?$AA@			; `string'
PUBLIC	??_C@_05DKLEPMBK@MAGIC?$AA@			; `string'
PUBLIC	??_C@_03OOKILKBD@BUY?$AA@			; `string'
PUBLIC	??_C@_04MPOIGBFL@SELL?$AA@			; `string'
PUBLIC	??_C@_0O@MAJOJEIM@CAMERA_ROTATE?$AA@		; `string'
PUBLIC	??_C@_05NILMGENH@HSIZE?$AA@			; `string'
PUBLIC	??_C@_05OBGAAHDM@VSIZE?$AA@			; `string'
PUBLIC	??_C@_06LKCKECPP@HVSIZE?$AA@			; `string'
PUBLIC	??_C@_0BD@BFBNCJCC@CAMERA_TO_POSITIVE?$AA@	; `string'
PUBLIC	??_C@_0BD@JPBNJGLJ@CAMERA_TO_NEGATIVE?$AA@	; `string'
PUBLIC	??_C@_0M@NJFGNKPE@CAMERA_STOP?$AA@		; `string'
PUBLIC	??_C@_0BG@NNONEOJP@ENABLE_COSTUME_SYSTEM?$AA@	; `string'
PUBLIC	??_C@_0BF@JNPGDOCA@ENABLE_ENERGY_SYSTEM?$AA@	; `string'
PUBLIC	??_C@_0BK@MHKPDOOB@ENABLE_DRAGON_SOUL_SYSTEM?$AA@ ; `string'
PUBLIC	??_C@_0BM@LNFCINHP@ENABLE_NEW_EQUIPMENT_SYSTEM?$AA@ ; `string'
PUBLIC	??_C@_0L@GJPKGMAC@USE_OPENID?$AA@		; `string'
PUBLIC	??_C@_0M@HKJKCDHH@OPENID_TEST?$AA@		; `string'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@42c80000
PUBLIC	__real@447a0000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strncpy:PROC
EXTRN	_strstr:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__controlfp:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	__access:PROC
EXTRN	__imp__PyInt_AsLong:PROC
EXTRN	__imp__PyString_FromString:PROC
EXTRN	__imp__PyTuple_GetItem:PROC
EXTRN	__imp__PyList_New:PROC
EXTRN	__imp__PyList_Append:PROC
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	__imp__PyModule_AddIntConstant:PROC
EXTRN	__imp__Py_InitModule4:PROC
EXTRN	?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z:PROC ; PyTuple_GetString
EXTRN	?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z:PROC ; PyTuple_GetInteger
EXTRN	?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z:PROC	; PyTuple_GetFloat
EXTRN	?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z:PROC ; PyTuple_GetObject
EXTRN	?Py_BuildException@@YAPAU_object@@PBDZZ:PROC	; Py_BuildException
EXTRN	?Py_BuildNone@@YAPAU_object@@XZ:PROC		; Py_BuildNone
EXTRN	?RunFile@CPythonLauncher@@QAE_NPBD@Z:PROC	; CPythonLauncher::RunFile
EXTRN	??0CMemoryTextFileLoader@@QAE@XZ:PROC		; CMemoryTextFileLoader::CMemoryTextFileLoader
EXTRN	??1CMemoryTextFileLoader@@UAE@XZ:PROC		; CMemoryTextFileLoader::~CMemoryTextFileLoader
EXTRN	?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z:PROC	; CMemoryTextFileLoader::Bind
EXTRN	?GetLineCount@CMemoryTextFileLoader@@QAEKXZ:PROC ; CMemoryTextFileLoader::GetLineCount
EXTRN	?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z:PROC ; CMemoryTextFileLoader::GetLineString
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?GetAvailableTextureMemory@CGraphicBase@@SAKXZ:PROC ; CGraphicBase::GetAvailableTextureMemory
EXTRN	?GetMousePosition@CWindowManager@UI@@QAEXAAJ0@Z:PROC ; UI::CWindowManager::GetMousePosition
EXTRN	?random_range@@YAJJJ@Z:PROC			; random_range
EXTRN	?GetDegreeDifference@@YAMMM@Z:PROC		; GetDegreeDifference
EXTRN	?GetRotatingDirection@@YAHMM@Z:PROC		; GetRotatingDirection
EXTRN	?LocaleService_GetCodePage@@YAIXZ:PROC		; LocaleService_GetCodePage
EXTRN	?LocaleService_GetName@@YAPBDXZ:PROC		; LocaleService_GetName
EXTRN	?LocaleService_GetLocaleName@@YAPBDXZ:PROC	; LocaleService_GetLocaleName
EXTRN	?LocaleService_GetLocalePath@@YAPBDXZ:PROC	; LocaleService_GetLocalePath
EXTRN	?LocaleService_ForceSetLocale@@YAXPBD0@Z:PROC	; LocaleService_ForceSetLocale
EXTRN	?LocaleService_SetCHEONMA@@YAX_N@Z:PROC		; LocaleService_SetCHEONMA
EXTRN	?LocaleService_IsCHEONMA@@YA_NXZ:PROC		; LocaleService_IsCHEONMA
EXTRN	?DefaultFont_SetName@@YAXPBD@Z:PROC		; DefaultFont_SetName
EXTRN	?SetGuildSymbolPath@@YAXPBD@Z:PROC		; SetGuildSymbolPath
EXTRN	?IsPressed@CInputKeyboard@@QAE_NH@Z:PROC	; CInputKeyboard::IsPressed
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	_tea_decrypt:PROC
EXTRN	__imp__ilBindImage@4:PROC
EXTRN	__imp__ilDeleteImages@8:PROC
EXTRN	__imp__ilGenImages@8:PROC
EXTRN	__imp__ilGetInteger@4:PROC
EXTRN	__imp__ilLoad@8:PROC
EXTRN	?SetMarkPathPrefix@CGuildMarkManager@@QAEXPBD@Z:PROC ; CGuildMarkManager::SetMarkPathPrefix
EXTRN	?PlayLogo@CMovieMan@@QAEXPBD@Z:PROC		; CMovieMan::PlayLogo
EXTRN	?ShowWebPage@CPythonApplication@@QAEXPBDABUtagRECT@@@Z:PROC ; CPythonApplication::ShowWebPage
EXTRN	?MoveWebPage@CPythonApplication@@QAEXABUtagRECT@@@Z:PROC ; CPythonApplication::MoveWebPage
EXTRN	?HideWebPage@CPythonApplication@@QAEXXZ:PROC	; CPythonApplication::HideWebPage
EXTRN	?IsWebPageMode@CPythonApplication@@QAE_NXZ:PROC	; CPythonApplication::IsWebPageMode
EXTRN	?GetInfo@CPythonApplication@@QAEXIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CPythonApplication::GetInfo
EXTRN	?Loop@CPythonApplication@@QAEXXZ:PROC		; CPythonApplication::Loop
EXTRN	?Exit@CPythonApplication@@QAEXXZ:PROC		; CPythonApplication::Exit
EXTRN	?Abort@CPythonApplication@@QAEXXZ:PROC		; CPythonApplication::Abort
EXTRN	?SetMinFog@CPythonApplication@@QAEXM@Z:PROC	; CPythonApplication::SetMinFog
EXTRN	?SetFrameSkip@CPythonApplication@@QAEX_N@Z:PROC	; CPythonApplication::SetFrameSkip
EXTRN	?Create@CPythonApplication@@QAE_NPAU_object@@PBDHHH@Z:PROC ; CPythonApplication::Create
EXTRN	?UpdateGame@CPythonApplication@@QAEXXZ:PROC	; CPythonApplication::UpdateGame
EXTRN	?RenderGame@CPythonApplication@@QAEXXZ:PROC	; CPythonApplication::RenderGame
EXTRN	?Process@CPythonApplication@@QAE_NXZ:PROC	; CPythonApplication::Process
EXTRN	?SetCursorNum@CPythonApplication@@QAEHH@Z:PROC	; CPythonApplication::SetCursorNum
EXTRN	?SetCursorVisible@CPythonApplication@@QAEXH_N@Z:PROC ; CPythonApplication::SetCursorVisible
EXTRN	?GetCursorVisible@CPythonApplication@@QAEHXZ:PROC ; CPythonApplication::GetCursorVisible
EXTRN	?GetLiarCursorOn@CPythonApplication@@QAE_NXZ:PROC ; CPythonApplication::GetLiarCursorOn
EXTRN	?SetCursorMode@CPythonApplication@@QAEXH@Z:PROC	; CPythonApplication::SetCursorMode
EXTRN	?SetMouseHandler@CPythonApplication@@QAEXPAU_object@@@Z:PROC ; CPythonApplication::SetMouseHandler
EXTRN	?SetGlobalCenterPosition@CPythonApplication@@QAEXJJ@Z:PROC ; CPythonApplication::SetGlobalCenterPosition
EXTRN	?SetCamera@CPythonApplication@@QAEXMMMM@Z:PROC	; CPythonApplication::SetCamera
EXTRN	?GetCamera@CPythonApplication@@QAEXPAM000@Z:PROC ; CPythonApplication::GetCamera
EXTRN	?RotateCamera@CPythonApplication@@QAEXH@Z:PROC	; CPythonApplication::RotateCamera
EXTRN	?PitchCamera@CPythonApplication@@QAEXH@Z:PROC	; CPythonApplication::PitchCamera
EXTRN	?ZoomCamera@CPythonApplication@@QAEXH@Z:PROC	; CPythonApplication::ZoomCamera
EXTRN	?MovieRotateCamera@CPythonApplication@@QAEXH@Z:PROC ; CPythonApplication::MovieRotateCamera
EXTRN	?MoviePitchCamera@CPythonApplication@@QAEXH@Z:PROC ; CPythonApplication::MoviePitchCamera
EXTRN	?MovieZoomCamera@CPythonApplication@@QAEXH@Z:PROC ; CPythonApplication::MovieZoomCamera
EXTRN	?MovieResetCamera@CPythonApplication@@QAEXXZ:PROC ; CPythonApplication::MovieResetCamera
EXTRN	?GetRotation@CPythonApplication@@QAEMXZ:PROC	; CPythonApplication::GetRotation
EXTRN	?GetPitch@CPythonApplication@@QAEMXZ:PROC	; CPythonApplication::GetPitch
EXTRN	?SetFPS@CPythonApplication@@QAEXH@Z:PROC	; CPythonApplication::SetFPS
EXTRN	?GetServerTime@CPythonApplication@@QAEJXZ:PROC	; CPythonApplication::GetServerTime
EXTRN	?GetServerTimeStamp@CPythonApplication@@QAEJXZ:PROC ; CPythonApplication::GetServerTimeStamp
EXTRN	?SetConnectData@CPythonApplication@@QAEXPBDH@Z:PROC ; CPythonApplication::SetConnectData
EXTRN	?GetConnectData@CPythonApplication@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH@Z:PROC ; CPythonApplication::GetConnectData
EXTRN	?EnableSpecialCameraMode@CPythonApplication@@QAEXXZ:PROC ; CPythonApplication::EnableSpecialCameraMode
EXTRN	?SetCameraSpeed@CPythonApplication@@QAEXH@Z:PROC ; CPythonApplication::SetCameraSpeed
EXTRN	?SaveCameraSetting@CPythonApplication@@QAEXPBD@Z:PROC ; CPythonApplication::SaveCameraSetting
EXTRN	?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z:PROC ; CPythonApplication::LoadCameraSetting
EXTRN	?SetForceSightRange@CPythonApplication@@QAEXH@Z:PROC ; CPythonApplication::SetForceSightRange
EXTRN	?SetCameraMaxDistance@CCamera@@SAXM@Z:PROC	; CCamera::SetCameraMaxDistance
EXTRN	?SetResistance@CCamera@@QAEXM@Z:PROC		; CCamera::SetResistance
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	?TextTail_SetLivingTime@@YAXJ@Z:PROC		; TextTail_SetLivingTime
EXTRN	?LoadLocaleData@@YA_NPBD@Z:PROC			; LoadLocaleData
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	?isExist@CEterPackManager@@QAE_NPBD@Z:PROC	; CEterPackManager::isExist
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_pInstance@CPythonApplication@@1PAV1@A:DWORD	; CPythonApplication::ms_pInstance
EXTRN	?PERF_CHECKER_RENDER_GAME@@3_NA:BYTE		; PERF_CHECKER_RENDER_GAME
EXTRN	?g_fSpecularColor@@3UD3DXCOLOR@@A:BYTE		; g_fSpecularColor
EXTRN	?HAIR_COLOR_ENABLE@@3HA:DWORD			; HAIR_COLOR_ENABLE
EXTRN	?USE_ARMOR_SPECULAR@@3HA:DWORD			; USE_ARMOR_SPECULAR
EXTRN	?USE_WEAPON_SPECULAR@@3HA:DWORD			; USE_WEAPON_SPECULAR
EXTRN	?SKILL_EFFECT_UPGRADE_ENABLE@@3HA:DWORD		; SKILL_EFFECT_UPGRADE_ENABLE
EXTRN	?RIDE_HORSE_ENABLE@@3HA:DWORD			; RIDE_HORSE_ENABLE
EXTRN	?g_specularSpd@@3NA:QWORD			; g_specularSpd
EXTRN	?g_iAccumulationTime@@3HA:DWORD			; g_iAccumulationTime
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A DD 01H DUP (?) ; CSingleton<CPythonLauncher>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A DD 01H DUP (?) ; CSingleton<UI::CWindowManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$singleton@VCGuildMarkManager@@@@0PAVCGuildMarkManager@@A
_BSS	SEGMENT
?ms_singleton@?$singleton@VCGuildMarkManager@@@@0PAVCGuildMarkManager@@A DD 01H DUP (?) ; singleton<CGuildMarkManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A DD 01H DUP (?) ; CSingleton<CMovieMan>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0M@HKJKCDHH@OPENID_TEST?$AA@
CONST	SEGMENT
??_C@_0M@HKJKCDHH@OPENID_TEST?$AA@ DB 'OPENID_TEST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJPKGMAC@USE_OPENID?$AA@
CONST	SEGMENT
??_C@_0L@GJPKGMAC@USE_OPENID?$AA@ DB 'USE_OPENID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LNFCINHP@ENABLE_NEW_EQUIPMENT_SYSTEM?$AA@
CONST	SEGMENT
??_C@_0BM@LNFCINHP@ENABLE_NEW_EQUIPMENT_SYSTEM?$AA@ DB 'ENABLE_NEW_EQUIPM'
	DB	'ENT_SYSTEM', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MHKPDOOB@ENABLE_DRAGON_SOUL_SYSTEM?$AA@
CONST	SEGMENT
??_C@_0BK@MHKPDOOB@ENABLE_DRAGON_SOUL_SYSTEM?$AA@ DB 'ENABLE_DRAGON_SOUL_'
	DB	'SYSTEM', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JNPGDOCA@ENABLE_ENERGY_SYSTEM?$AA@
CONST	SEGMENT
??_C@_0BF@JNPGDOCA@ENABLE_ENERGY_SYSTEM?$AA@ DB 'ENABLE_ENERGY_SYSTEM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NNONEOJP@ENABLE_COSTUME_SYSTEM?$AA@
CONST	SEGMENT
??_C@_0BG@NNONEOJP@ENABLE_COSTUME_SYSTEM?$AA@ DB 'ENABLE_COSTUME_SYSTEM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJFGNKPE@CAMERA_STOP?$AA@
CONST	SEGMENT
??_C@_0M@NJFGNKPE@CAMERA_STOP?$AA@ DB 'CAMERA_STOP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JPBNJGLJ@CAMERA_TO_NEGATIVE?$AA@
CONST	SEGMENT
??_C@_0BD@JPBNJGLJ@CAMERA_TO_NEGATIVE?$AA@ DB 'CAMERA_TO_NEGATIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BFBNCJCC@CAMERA_TO_POSITIVE?$AA@
CONST	SEGMENT
??_C@_0BD@BFBNCJCC@CAMERA_TO_POSITIVE?$AA@ DB 'CAMERA_TO_POSITIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LKCKECPP@HVSIZE?$AA@
CONST	SEGMENT
??_C@_06LKCKECPP@HVSIZE?$AA@ DB 'HVSIZE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OBGAAHDM@VSIZE?$AA@
CONST	SEGMENT
??_C@_05OBGAAHDM@VSIZE?$AA@ DB 'VSIZE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NILMGENH@HSIZE?$AA@
CONST	SEGMENT
??_C@_05NILMGENH@HSIZE?$AA@ DB 'HSIZE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MAJOJEIM@CAMERA_ROTATE?$AA@
CONST	SEGMENT
??_C@_0O@MAJOJEIM@CAMERA_ROTATE?$AA@ DB 'CAMERA_ROTATE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MPOIGBFL@SELL?$AA@
CONST	SEGMENT
??_C@_04MPOIGBFL@SELL?$AA@ DB 'SELL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OOKILKBD@BUY?$AA@
CONST	SEGMENT
??_C@_03OOKILKBD@BUY?$AA@ DB 'BUY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKLEPMBK@MAGIC?$AA@
CONST	SEGMENT
??_C@_05DKLEPMBK@MAGIC?$AA@ DB 'MAGIC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HLBMIDNH@CHAIR?$AA@
CONST	SEGMENT
??_C@_05HLBMIDNH@CHAIR?$AA@ DB 'CHAIR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KEJCELCL@DOOR?$AA@
CONST	SEGMENT
??_C@_04KEJCELCL@DOOR?$AA@ DB 'DOOR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IGIDHFMJ@PICK?$AA@
CONST	SEGMENT
??_C@_04IGIDHFMJ@PICK?$AA@ DB 'PICK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGCIEODJ@CANT_GO?$AA@
CONST	SEGMENT
??_C@_07LGCIEODJ@CANT_GO?$AA@ DB 'CANT_GO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNOLLMNL@TALK?$AA@
CONST	SEGMENT
??_C@_04LNOLLMNL@TALK?$AA@ DB 'TALK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JNJLBPLI@TARGET?$AA@
CONST	SEGMENT
??_C@_06JNJLBPLI@TARGET?$AA@ DB 'TARGET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JIJKOHKJ@ATTACK?$AA@
CONST	SEGMENT
??_C@_06JIJKOHKJ@ATTACK?$AA@ DB 'ATTACK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IOJAGNKJ@NORMAL?$AA@
CONST	SEGMENT
??_C@_06IOJAGNKJ@NORMAL?$AA@ DB 'NORMAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEDKKFEB@DIK_APPS?$AA@
CONST	SEGMENT
??_C@_08EEDKKFEB@DIK_APPS?$AA@ DB 'DIK_APPS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BCDGIEEJ@DIK_RWIN?$AA@
CONST	SEGMENT
??_C@_08BCDGIEEJ@DIK_RWIN?$AA@ DB 'DIK_RWIN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNOGKNKK@DIK_LWIN?$AA@
CONST	SEGMENT
??_C@_08MNOGKNKK@DIK_LWIN?$AA@ DB 'DIK_LWIN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HICEJOHK@DIK_DELETE?$AA@
CONST	SEGMENT
??_C@_0L@HICEJOHK@DIK_DELETE?$AA@ DB 'DIK_DELETE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MGNAFAII@DIK_INSERT?$AA@
CONST	SEGMENT
??_C@_0L@MGNAFAII@DIK_INSERT?$AA@ DB 'DIK_INSERT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DADHBDOF@DIK_PGDN?$AA@
CONST	SEGMENT
??_C@_08DADHBDOF@DIK_PGDN?$AA@ DB 'DIK_PGDN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HOIDBHGB@DIK_DOWN?$AA@
CONST	SEGMENT
??_C@_08HOIDBHGB@DIK_DOWN?$AA@ DB 'DIK_DOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HLJOPMFK@DIK_END?$AA@
CONST	SEGMENT
??_C@_07HLJOPMFK@DIK_END?$AA@ DB 'DIK_END', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OKEHHFIC@DIK_RIGHT?$AA@
CONST	SEGMENT
??_C@_09OKEHHFIC@DIK_RIGHT?$AA@ DB 'DIK_RIGHT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IMIHIPFI@DIK_LEFT?$AA@
CONST	SEGMENT
??_C@_08IMIHIPFI@DIK_LEFT?$AA@ DB 'DIK_LEFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJJCOFHN@DIK_PGUP?$AA@
CONST	SEGMENT
??_C@_08PJJCOFHN@DIK_PGUP?$AA@ DB 'DIK_PGUP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGABONOM@DIK_UP?$AA@
CONST	SEGMENT
??_C@_06JGABONOM@DIK_UP?$AA@ DB 'DIK_UP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EJDGAFAN@DIK_HOME?$AA@
CONST	SEGMENT
??_C@_08EJDGAFAN@DIK_HOME?$AA@ DB 'DIK_HOME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09COEFGPNN@DIK_PAUSE?$AA@
CONST	SEGMENT
??_C@_09COEFGPNN@DIK_PAUSE?$AA@ DB 'DIK_PAUSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBKCLEDK@DIK_RALT?$AA@
CONST	SEGMENT
??_C@_08NBKCLEDK@DIK_RALT?$AA@ DB 'DIK_RALT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PCEGCDIO@DIK_SYSRQ?$AA@
CONST	SEGMENT
??_C@_09PCEGCDIO@DIK_SYSRQ?$AA@ DB 'DIK_SYSRQ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDEGMNOK@DIK_DIVIDE?$AA@
CONST	SEGMENT
??_C@_0L@HDEGMNOK@DIK_DIVIDE?$AA@ DB 'DIK_DIVIDE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ECBGFAAH@DIK_NUMPADCOMMA?$AA@
CONST	SEGMENT
??_C@_0BA@ECBGFAAH@DIK_NUMPADCOMMA?$AA@ DB 'DIK_NUMPADCOMMA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IEADBFND@DIK_WEBHOME?$AA@
CONST	SEGMENT
??_C@_0M@IEADBFND@DIK_WEBHOME?$AA@ DB 'DIK_WEBHOME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GPHLGHED@DIK_VOLUMEUP?$AA@
CONST	SEGMENT
??_C@_0N@GPHLGHED@DIK_VOLUMEUP?$AA@ DB 'DIK_VOLUMEUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FKHBCEAD@DIK_VOLUMEDOWN?$AA@
CONST	SEGMENT
??_C@_0P@FKHBCEAD@DIK_VOLUMEDOWN?$AA@ DB 'DIK_VOLUMEDOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FLFOAKOG@DIK_MEDIASTOP?$AA@
CONST	SEGMENT
??_C@_0O@FLFOAKOG@DIK_MEDIASTOP?$AA@ DB 'DIK_MEDIASTOP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ECAMOKPG@DIK_PLAYPAUSE?$AA@
CONST	SEGMENT
??_C@_0O@ECAMOKPG@DIK_PLAYPAUSE?$AA@ DB 'DIK_PLAYPAUSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OJEJDHIP@DIK_CALCULATOR?$AA@
CONST	SEGMENT
??_C@_0P@OJEJDHIP@DIK_CALCULATOR?$AA@ DB 'DIK_CALCULATOR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNIFKFHJ@DIK_MUTE?$AA@
CONST	SEGMENT
??_C@_08KNIFKFHJ@DIK_MUTE?$AA@ DB 'DIK_MUTE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKDJCKOL@DIK_RCONTROL?$AA@
CONST	SEGMENT
??_C@_0N@GKDJCKOL@DIK_RCONTROL?$AA@ DB 'DIK_RCONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OLMCJCJF@DIK_NUMPADENTER?$AA@
CONST	SEGMENT
??_C@_0BA@OLMCJCJF@DIK_NUMPADENTER?$AA@ DB 'DIK_NUMPADENTER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DEOEEHEE@DIK_NEXTTRACK?$AA@
CONST	SEGMENT
??_C@_0O@DEOEEHEE@DIK_NEXTTRACK?$AA@ DB 'DIK_NEXTTRACK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EPODKCKJ@DIK_F12?$AA@
CONST	SEGMENT
??_C@_07EPODKCKJ@DIK_F12?$AA@ DB 'DIK_F12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GEMOPBGK@DIK_F11?$AA@
CONST	SEGMENT
??_C@_07GEMOPBGK@DIK_F11?$AA@ DB 'DIK_F11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCNKFDKI@DIK_DECIMAL?$AA@
CONST	SEGMENT
??_C@_0M@PCNKFDKI@DIK_DECIMAL?$AA@ DB 'DIK_DECIMAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMKJAMIE@DIK_NUMPAD0?$AA@
CONST	SEGMENT
??_C@_0M@JMKJAMIE@DIK_NUMPAD0?$AA@ DB 'DIK_NUMPAD0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHIEFPEH@DIK_NUMPAD3?$AA@
CONST	SEGMENT
??_C@_0M@LHIEFPEH@DIK_NUMPAD3?$AA@ DB 'DIK_NUMPAD3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KOJPGOAG@DIK_NUMPAD2?$AA@
CONST	SEGMENT
??_C@_0M@KOJPGOAG@DIK_NUMPAD2?$AA@ DB 'DIK_NUMPAD2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFLCDNMF@DIK_NUMPAD1?$AA@
CONST	SEGMENT
??_C@_0M@IFLCDNMF@DIK_NUMPAD1?$AA@ DB 'DIK_NUMPAD1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJGLOONL@DIK_ADD?$AA@
CONST	SEGMENT
??_C@_07PJGLOONL@DIK_ADD?$AA@ DB 'DIK_ADD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MKPDKLAC@DIK_NUMPAD6?$AA@
CONST	SEGMENT
??_C@_0M@MKPDKLAC@DIK_NUMPAD6?$AA@ DB 'DIK_NUMPAD6', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBNOPIMB@DIK_NUMPAD5?$AA@
CONST	SEGMENT
??_C@_0M@OBNOPIMB@DIK_NUMPAD5?$AA@ DB 'DIK_NUMPAD5', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIMFMJIA@DIK_NUMPAD4?$AA@
CONST	SEGMENT
??_C@_0M@PIMFMJIA@DIK_NUMPAD4?$AA@ DB 'DIK_NUMPAD4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECOBCKNF@DIK_SUBTRACT?$AA@
CONST	SEGMENT
??_C@_0N@ECOBCKNF@DIK_SUBTRACT?$AA@ DB 'DIK_SUBTRACT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENGLLHMN@DIK_NUMPAD9?$AA@
CONST	SEGMENT
??_C@_0M@ENGLLHMN@DIK_NUMPAD9?$AA@ DB 'DIK_NUMPAD9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FEHAIGIM@DIK_NUMPAD8?$AA@
CONST	SEGMENT
??_C@_0M@FEHAIGIM@DIK_NUMPAD8?$AA@ DB 'DIK_NUMPAD8', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDOIJKED@DIK_NUMPAD7?$AA@
CONST	SEGMENT
??_C@_0M@NDOIJKED@DIK_NUMPAD7?$AA@ DB 'DIK_NUMPAD7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPJOFPCB@DIK_SCROLL?$AA@
CONST	SEGMENT
??_C@_0L@HPJOFPCB@DIK_SCROLL?$AA@ DB 'DIK_SCROLL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BAOCLHIM@DIK_NUMLOCK?$AA@
CONST	SEGMENT
??_C@_0M@BAOCLHIM@DIK_NUMLOCK?$AA@ DB 'DIK_NUMLOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HNNFMACL@DIK_F10?$AA@
CONST	SEGMENT
??_C@_07HNNFMACL@DIK_F10?$AA@ DB 'DIK_F10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DMFOCACL@DIK_F9?$AA@
CONST	SEGMENT
??_C@_06DMFOCACL@DIK_F9?$AA@ DB 'DIK_F9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CFEFBBGK@DIK_F8?$AA@
CONST	SEGMENT
??_C@_06CFEFBBGK@DIK_F8?$AA@ DB 'DIK_F8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KCNNANKF@DIK_F7?$AA@
CONST	SEGMENT
??_C@_06KCNNANKF@DIK_F7?$AA@ DB 'DIK_F7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLMGDMOE@DIK_F6?$AA@
CONST	SEGMENT
??_C@_06LLMGDMOE@DIK_F6?$AA@ DB 'DIK_F6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JAOLGPCH@DIK_F5?$AA@
CONST	SEGMENT
??_C@_06JAOLGPCH@DIK_F5?$AA@ DB 'DIK_F5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJPAFOGG@DIK_F4?$AA@
CONST	SEGMENT
??_C@_06IJPAFOGG@DIK_F4?$AA@ DB 'DIK_F4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MGLBMIKB@DIK_F3?$AA@
CONST	SEGMENT
??_C@_06MGLBMIKB@DIK_F3?$AA@ DB 'DIK_F3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NPKKPJOA@DIK_F2?$AA@
CONST	SEGMENT
??_C@_06NPKKPJOA@DIK_F2?$AA@ DB 'DIK_F2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PEIHKKCD@DIK_F1?$AA@
CONST	SEGMENT
??_C@_06PEIHKKCD@DIK_F1?$AA@ DB 'DIK_F1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEADBGIC@DIK_CAPITAL?$AA@
CONST	SEGMENT
??_C@_0M@KEADBGIC@DIK_CAPITAL?$AA@ DB 'DIK_CAPITAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGAMMAPJ@DIK_SPACE?$AA@
CONST	SEGMENT
??_C@_09DGAMMAPJ@DIK_SPACE?$AA@ DB 'DIK_SPACE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OHCJNNJ@DIK_LALT?$AA@
CONST	SEGMENT
??_C@_08OHCJNNJ@DIK_LALT?$AA@ DB 'DIK_LALT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DHLLGHHC@DIK_MULTIPLY?$AA@
CONST	SEGMENT
??_C@_0N@DHLLGHHC@DIK_MULTIPLY?$AA@ DB 'DIK_MULTIPLY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FKIIJLHO@DIK_RSHIFT?$AA@
CONST	SEGMENT
??_C@_0L@FKIIJLHO@DIK_RSHIFT?$AA@ DB 'DIK_RSHIFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DKJEGHEH@DIK_SLASH?$AA@
CONST	SEGMENT
??_C@_09DKJEGHEH@DIK_SLASH?$AA@ DB 'DIK_SLASH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HHNLMNCM@DIK_PERIOD?$AA@
CONST	SEGMENT
??_C@_0L@HHNLMNCM@DIK_PERIOD?$AA@ DB 'DIK_PERIOD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDEOJFIH@DIK_COMMA?$AA@
CONST	SEGMENT
??_C@_09PDEOJFIH@DIK_COMMA?$AA@ DB 'DIK_COMMA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OBDFKLOH@DIK_M?$AA@
CONST	SEGMENT
??_C@_05OBDFKLOH@DIK_M?$AA@ DB 'DIK_M', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKBIPICE@DIK_N?$AA@
CONST	SEGMENT
??_C@_05MKBIPICE@DIK_N?$AA@ DB 'DIK_N', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGKNLHCI@DIK_B?$AA@
CONST	SEGMENT
??_C@_05GGKNLHCI@DIK_B?$AA@ DB 'DIK_B', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EIADGAHN@DIK_V?$AA@
CONST	SEGMENT
??_C@_05EIADGAHN@DIK_V?$AA@ DB 'DIK_V', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPLGIGGJ@DIK_C?$AA@
CONST	SEGMENT
??_C@_05HPLGIGGJ@DIK_C?$AA@ DB 'DIK_C', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGIAENPD@DIK_X?$AA@
CONST	SEGMENT
??_C@_05NGIAENPD@DIK_X?$AA@ DB 'DIK_X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OELGCPHB@DIK_Z?$AA@
CONST	SEGMENT
??_C@_05OELGCPHB@DIK_Z?$AA@ DB 'DIK_Z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DGKNNOHE@DIK_BACKSLASH?$AA@
CONST	SEGMENT
??_C@_0O@DGKNNOHE@DIK_BACKSLASH?$AA@ DB 'DIK_BACKSLASH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GNGJHMON@DIK_LSHIFT?$AA@
CONST	SEGMENT
??_C@_0L@GNGJHMON@DIK_LSHIFT?$AA@ DB 'DIK_LSHIFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOGGLCIP@DIK_GRAVE?$AA@
CONST	SEGMENT
??_C@_09MOGGLCIP@DIK_GRAVE?$AA@ DB 'DIK_GRAVE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JDEKLKAM@DIK_APOSTROPHE?$AA@
CONST	SEGMENT
??_C@_0P@JDEKLKAM@DIK_APOSTROPHE?$AA@ DB 'DIK_APOSTROPHE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NEECDLLB@DIK_SEMICOLON?$AA@
CONST	SEGMENT
??_C@_0O@NEECDLLB@DIK_SEMICOLON?$AA@ DB 'DIK_SEMICOLON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PICOJKKG@DIK_L?$AA@
CONST	SEGMENT
??_C@_05PICOJKKG@DIK_L?$AA@ DB 'DIK_L', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHGPAMGB@DIK_K?$AA@
CONST	SEGMENT
??_C@_05LHGPAMGB@DIK_K?$AA@ DB 'DIK_K', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KOHEDNCA@DIK_J?$AA@
CONST	SEGMENT
??_C@_05KOHEDNCA@DIK_J?$AA@ DB 'DIK_J', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMECFPKC@DIK_H?$AA@
CONST	SEGMENT
??_C@_05JMECFPKC@DIK_H?$AA@ DB 'DIK_H', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLNKEDGN@DIK_G?$AA@
CONST	SEGMENT
??_C@_05BLNKEDGN@DIK_G?$AA@ DB 'DIK_G', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMBHCCM@DIK_F?$AA@
CONST	SEGMENT
??_C@_05CMBHCCM@DIK_F?$AA@ DB 'DIK_F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DAPHBAKO@DIK_D?$AA@
CONST	SEGMENT
??_C@_05DAPHBAKO@DIK_D?$AA@ DB 'DIK_D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFHEJEDI@DIK_S?$AA@
CONST	SEGMENT
??_C@_05DFHEJEDI@DIK_S?$AA@ DB 'DIK_S', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ENIAOEOL@DIK_A?$AA@
CONST	SEGMENT
??_C@_05ENIAOEOL@DIK_A?$AA@ DB 'DIK_A', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ODLLDAI@DIK_LCONTROL?$AA@
CONST	SEGMENT
??_C@_0N@ODLLDAI@DIK_LCONTROL?$AA@ DB 'DIK_LCONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JLNKBJCL@DIK_RETURN?$AA@
CONST	SEGMENT
??_C@_0L@JLNKBJCL@DIK_RETURN?$AA@ DB 'DIK_RETURN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBJBCLKG@DIK_RBRACKET?$AA@
CONST	SEGMENT
??_C@_0N@CBJBCLKG@DIK_RBRACKET?$AA@ DB 'DIK_RBRACKET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EFJDLCEF@DIK_LBRACKET?$AA@
CONST	SEGMENT
??_C@_0N@EFJDLCEF@DIK_LBRACKET?$AA@ DB 'DIK_LBRACKET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BOFJMHPL@DIK_P?$AA@
CONST	SEGMENT
??_C@_05BOFJMHPL@DIK_P?$AA@ DB 'DIK_P', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NDADMJGF@DIK_O?$AA@
CONST	SEGMENT
??_C@_05NDADMJGF@DIK_O?$AA@ DB 'DIK_O', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFFJGOOD@DIK_I?$AA@
CONST	SEGMENT
??_C@_05IFFJGOOD@DIK_I?$AA@ DB 'DIK_I', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GDCODDLO@DIK_U?$AA@
CONST	SEGMENT
??_C@_05GDCODDLO@DIK_U?$AA@ DB 'DIK_U', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MPJLHMLC@DIK_Y?$AA@
CONST	SEGMENT
??_C@_05MPJLHMLC@DIK_Y?$AA@ DB 'DIK_Y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKDFACPP@DIK_T?$AA@
CONST	SEGMENT
??_C@_05HKDFACPP@DIK_T?$AA@ DB 'DIK_T', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMGPKFHJ@DIK_R?$AA@
CONST	SEGMENT
??_C@_05CMGPKFHJ@DIK_R?$AA@ DB 'DIK_R', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CJOMCBOP@DIK_E?$AA@
CONST	SEGMENT
??_C@_05CJOMCBOP@DIK_E?$AA@ DB 'DIK_E', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBBIFBDM@DIK_W?$AA@
CONST	SEGMENT
??_C@_05FBBIFBDM@DIK_W?$AA@ DB 'DIK_W', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HECPGLK@DIK_Q?$AA@
CONST	SEGMENT
??_C@_05HECPGLK@DIK_Q?$AA@ DB 'DIK_Q', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MODNCMBL@DIK_TAB?$AA@
CONST	SEGMENT
??_C@_07MODNCMBL@DIK_TAB?$AA@ DB 'DIK_TAB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HHEEGKBL@DIK_BACK?$AA@
CONST	SEGMENT
??_C@_08HHEEGKBL@DIK_BACK?$AA@ DB 'DIK_BACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KKCLPAPI@DIK_EQUALS?$AA@
CONST	SEGMENT
??_C@_0L@KKCLPAPI@DIK_EQUALS?$AA@ DB 'DIK_EQUALS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DOHACMKC@DIK_MINUS?$AA@
CONST	SEGMENT
??_C@_09DOHACMKC@DIK_MINUS?$AA@ DB 'DIK_MINUS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HLKEKMFM@DIK_0?$AA@
CONST	SEGMENT
??_C@_05HLKEKMFM@DIK_0?$AA@ DB 'DIK_0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKGGBHBF@DIK_9?$AA@
CONST	SEGMENT
??_C@_05KKGGBHBF@DIK_9?$AA@ DB 'DIK_9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDHNCGFE@DIK_8?$AA@
CONST	SEGMENT
??_C@_05LDHNCGFE@DIK_8?$AA@ DB 'DIK_8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DEOFDKJL@DIK_7?$AA@
CONST	SEGMENT
??_C@_05DEOFDKJL@DIK_7?$AA@ DB 'DIK_7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNPOALNK@DIK_6?$AA@
CONST	SEGMENT
??_C@_05CNPOALNK@DIK_6?$AA@ DB 'DIK_6', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GNDFIBJ@DIK_5?$AA@
CONST	SEGMENT
??_C@_05GNDFIBJ@DIK_5?$AA@ DB 'DIK_5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BPMIGJFI@DIK_4?$AA@
CONST	SEGMENT
??_C@_05BPMIGJFI@DIK_4?$AA@ DB 'DIK_4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAIJPPJP@DIK_3?$AA@
CONST	SEGMENT
??_C@_05FAIJPPJP@DIK_3?$AA@ DB 'DIK_3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EJJCMONO@DIK_2?$AA@
CONST	SEGMENT
??_C@_05EJJCMONO@DIK_2?$AA@ DB 'DIK_2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCLPJNBN@DIK_1?$AA@
CONST	SEGMENT
??_C@_05GCLPJNBN@DIK_1?$AA@ DB 'DIK_1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CACBFKLO@DIK_ESC?$AA@
CONST	SEGMENT
??_C@_07CACBFKLO@DIK_ESC?$AA@ DB 'DIK_ESC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOHNMBC@DIK_ESCAPE?$AA@
CONST	SEGMENT
??_C@_0L@BOHNMBC@DIK_ESCAPE?$AA@ DB 'DIK_ESCAPE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EABNPHOI@VK_DELETE?$AA@
CONST	SEGMENT
??_C@_09EABNPHOI@VK_DELETE?$AA@ DB 'VK_DELETE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPJBNMHN@VK_END?$AA@
CONST	SEGMENT
??_C@_06LPJBNMHN@VK_END?$AA@ DB 'VK_END', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OMPILPEG@VK_HOME?$AA@
CONST	SEGMENT
??_C@_07OMPILPEG@VK_HOME?$AA@ DB 'VK_HOME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NLENKNCK@VK_DOWN?$AA@
CONST	SEGMENT
??_C@_07NLENKNCK@VK_DOWN?$AA@ DB 'VK_DOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PIGLHCBF@VK_UP?$AA@
CONST	SEGMENT
??_C@_05PIGLHCBF@VK_UP?$AA@ DB 'VK_UP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LOMCDCA@VK_RIGHT?$AA@
CONST	SEGMENT
??_C@_08LOMCDCA@VK_RIGHT?$AA@ DB 'VK_RIGHT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CJEJDFBD@VK_LEFT?$AA@
CONST	SEGMENT
??_C@_07CJEJDFBD@VK_LEFT?$AA@ DB 'VK_LEFT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JGNHHMCM@DEGREE_DIRECTION_LEFT?$AA@
CONST	SEGMENT
??_C@_0BG@JGNHHMCM@DEGREE_DIRECTION_LEFT?$AA@ DB 'DEGREE_DIRECTION_LEFT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LNDFJAFE@DEGREE_DIRECTION_RIGHT?$AA@
CONST	SEGMENT
??_C@_0BH@LNDFJAFE@DEGREE_DIRECTION_RIGHT?$AA@ DB 'DEGREE_DIRECTION_RIGHT'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KEIJCHNJ@DEGREE_DIRECTION_SAME?$AA@
CONST	SEGMENT
??_C@_0BG@KEIJCHNJ@DEGREE_DIRECTION_SAME?$AA@ DB 'DEGREE_DIRECTION_SAME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FAGLOALJ@INFO_TEXTTAIL?$AA@
CONST	SEGMENT
??_C@_0O@FAGLOALJ@INFO_TEXTTAIL?$AA@ DB 'INFO_TEXTTAIL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLBHMBMD@INFO_EFFECT?$AA@
CONST	SEGMENT
??_C@_0M@KLBHMBMD@INFO_EFFECT?$AA@ DB 'INFO_EFFECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNNFPLHG@INFO_ACTOR?$AA@
CONST	SEGMENT
??_C@_0L@FNNFPLHG@INFO_ACTOR?$AA@ DB 'INFO_ACTOR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OKOJMLAA@INFO_ITEM?$AA@
CONST	SEGMENT
??_C@_09OKOJMLAA@INFO_ITEM?$AA@ DB 'INFO_ITEM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGOPKBCD@app?$AA@
CONST	SEGMENT
??_C@_03CGOPKBCD@app?$AA@ DB 'app', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMIFNMOK@OnLogoClose?$AA@
CONST	SEGMENT
??_C@_0M@JMIFNMOK@OnLogoClose?$AA@ DB 'OnLogoClose', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JMMGDKPP@OnLogoOpen?$AA@
CONST	SEGMENT
??_C@_0L@JMMGDKPP@OnLogoOpen?$AA@ DB 'OnLogoOpen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ELECBFOK@OnLogoRender?$AA@
CONST	SEGMENT
??_C@_0N@ELECBFOK@OnLogoRender?$AA@ DB 'OnLogoRender', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LIPHBNAO@OnLogoUpdate?$AA@
CONST	SEGMENT
??_C@_0N@LIPHBNAO@OnLogoUpdate?$AA@ DB 'OnLogoUpdate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DLDOCGLL@SetGuildMarkPath?$AA@
CONST	SEGMENT
??_C@_0BB@DLDOCGLL@SetGuildMarkPath?$AA@ DB 'SetGuildMarkPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GBDECBIH@IsEnableTestServerFlag?$AA@
CONST	SEGMENT
??_C@_0BH@GBDECBIH@IsEnableTestServerFlag?$AA@ DB 'IsEnableTestServerFlag'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOMOCGIP@EnableTestServerFlag?$AA@
CONST	SEGMENT
??_C@_0BF@BOMOCGIP@EnableTestServerFlag?$AA@ DB 'EnableTestServerFlag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NLDNPIOL@IsVisibleNotice?$AA@
CONST	SEGMENT
??_C@_0BA@NLDNPIOL@IsVisibleNotice?$AA@ DB 'IsVisibleNotice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MMPIECKB@SetVisibleNotice?$AA@
CONST	SEGMENT
??_C@_0BB@MMPIECKB@SetVisibleNotice?$AA@ DB 'SetVisibleNotice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KHKICLKO@testSetSpecularColor?$AA@
CONST	SEGMENT
??_C@_0BF@KHKICLKO@testSetSpecularColor?$AA@ DB 'testSetSpecularColor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLDHJGMN@testResetAccumulationTime?$AA@
CONST	SEGMENT
??_C@_0BK@PLDHJGMN@testResetAccumulationTime?$AA@ DB 'testResetAccumulati'
	DB	'onTime', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DNKBNLNC@testGetAccumulationTime?$AA@
CONST	SEGMENT
??_C@_0BI@DNKBNLNC@testGetAccumulationTime?$AA@ DB 'testGetAccumulationTi'
	DB	'me', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IFMAFIHG@SetSpecularSpeed?$AA@
CONST	SEGMENT
??_C@_0BB@IFMAFIHG@SetSpecularSpeed?$AA@ DB 'SetSpecularSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HDAEMEAH@SetControlFP?$AA@
CONST	SEGMENT
??_C@_0N@HDAEMEAH@SetControlFP?$AA@ DB 'SetControlFP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CEMKCGHA@GetDefaultCodePage?$AA@
CONST	SEGMENT
??_C@_0BD@CEMKCGHA@GetDefaultCodePage?$AA@ DB 'GetDefaultCodePage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09INPKBHN@IsCHEONMA?$AA@
CONST	SEGMENT
??_C@_09INPKBHN@IsCHEONMA?$AA@ DB 'IsCHEONMA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FAIOENFF@SetCHEONMA?$AA@
CONST	SEGMENT
??_C@_0L@FAIOENFF@SetCHEONMA?$AA@ DB 'SetCHEONMA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFJDMEJO@LoadLocaleData?$AA@
CONST	SEGMENT
??_C@_0P@BFJDMEJO@LoadLocaleData?$AA@ DB 'LoadLocaleData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JHGEFJDO@LoadLocaleAddr?$AA@
CONST	SEGMENT
??_C@_0P@JHGEFJDO@LoadLocaleAddr?$AA@ DB 'LoadLocaleAddr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KMAINBBA@ForceSetLocale?$AA@
CONST	SEGMENT
??_C@_0P@KMAINBBA@ForceSetLocale?$AA@ DB 'ForceSetLocale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OKMLAHKI@GetLocalePath?$AA@
CONST	SEGMENT
??_C@_0O@OKMLAHKI@GetLocalePath?$AA@ DB 'GetLocalePath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDECMIPJ@GetLocaleName?$AA@
CONST	SEGMENT
??_C@_0O@JDECMIPJ@GetLocaleName?$AA@ DB 'GetLocaleName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PBACFPCP@GetLocaleServiceName?$AA@
CONST	SEGMENT
??_C@_0BF@PBACFPCP@GetLocaleServiceName?$AA@ DB 'GetLocaleServiceName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HHNFKANE@GetTextFileLine?$AA@
CONST	SEGMENT
??_C@_0BA@HHNFKANE@GetTextFileLine?$AA@ DB 'GetTextFileLine', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BNHHEKFO@GetTextFileLineCount?$AA@
CONST	SEGMENT
??_C@_0BF@BNHHEKFO@GetTextFileLineCount?$AA@ DB 'GetTextFileLineCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LNEGOIPA@CloseTextFile?$AA@
CONST	SEGMENT
??_C@_0O@LNEGOIPA@CloseTextFile?$AA@ DB 'CloseTextFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JAMKKFFG@OpenTextFile?$AA@
CONST	SEGMENT
??_C@_0N@JAMKKFFG@OpenTextFile?$AA@ DB 'OpenTextFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LOHDPEAO@IsFileExist?$AA@
CONST	SEGMENT
??_C@_0M@LOHDPEAO@IsFileExist?$AA@ DB 'IsFileExist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MFMELJAK@SetSightRange?$AA@
CONST	SEGMENT
??_C@_0O@MFMELJAK@SetSightRange?$AA@ DB 'SetSightRange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JANPDNEC@SetCameraSetting?$AA@
CONST	SEGMENT
??_C@_0BB@JANPDNEC@SetCameraSetting?$AA@ DB 'SetCameraSetting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPPGJFKO@SetDefaultCamera?$AA@
CONST	SEGMENT
??_C@_0BB@IPPGJFKO@SetDefaultCamera?$AA@ DB 'SetDefaultCamera', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KEOGBKMG@LoadCameraSetting?$AA@
CONST	SEGMENT
??_C@_0BC@KEOGBKMG@LoadCameraSetting?$AA@ DB 'LoadCameraSetting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JPDLAHCD@SaveCameraSetting?$AA@
CONST	SEGMENT
??_C@_0BC@JPDLAHCD@SaveCameraSetting?$AA@ DB 'SaveCameraSetting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCLIAJKF@SetCameraSpeed?$AA@
CONST	SEGMENT
??_C@_0P@NCLIAJKF@SetCameraSpeed?$AA@ DB 'SetCameraSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LNMJCGJN@EnableSpecialCameraMode?$AA@
CONST	SEGMENT
??_C@_0BI@LNMJCGJN@EnableSpecialCameraMode?$AA@ DB 'EnableSpecialCameraMo'
	DB	'de', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CENDFAOC@SetGuildSymbolPath?$AA@
CONST	SEGMENT
??_C@_0BD@CENDFAOC@SetGuildSymbolPath?$AA@ DB 'SetGuildSymbolPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKMKHHJC@SetDefaultFontName?$AA@
CONST	SEGMENT
??_C@_0BD@CKMKHHJC@SetDefaultFontName?$AA@ DB 'SetDefaultFontName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PFDOMJEF@Sleep?$AA@
CONST	SEGMENT
??_C@_05PFDOMJEF@Sleep?$AA@ DB 'Sleep', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JKNPCCAK@GetDegreeDifference?$AA@
CONST	SEGMENT
??_C@_0BE@JKNPCCAK@GetDegreeDifference?$AA@ DB 'GetDegreeDifference', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IMHAMDDH@GetRotatingDirection?$AA@
CONST	SEGMENT
??_C@_0BF@IMHAMDDH@GetRotatingDirection?$AA@ DB 'GetRotatingDirection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GHKKFFNH@GetConnectData?$AA@
CONST	SEGMENT
??_C@_0P@GHKKFFNH@GetConnectData?$AA@ DB 'GetConnectData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KJLEKPPL@SetConnectData?$AA@
CONST	SEGMENT
??_C@_0P@KJLEKPPL@SetConnectData?$AA@ DB 'SetConnectData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KKHIHHDJ@SetHardwareCursor?$AA@
CONST	SEGMENT
??_C@_0BC@KKHIHHDJ@SetHardwareCursor?$AA@ DB 'SetHardwareCursor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDNDDKLI@SetSoftwareCursor?$AA@
CONST	SEGMENT
??_C@_0BC@IDNDDKLI@SetSoftwareCursor?$AA@ DB 'SetSoftwareCursor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FMIDHOAE@IsLiarCursorOn?$AA@
CONST	SEGMENT
??_C@_0P@FMIDHOAE@IsLiarCursorOn?$AA@ DB 'IsLiarCursorOn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BFHCIAEF@IsShowCursor?$AA@
CONST	SEGMENT
??_C@_0N@BFHCIAEF@IsShowCursor?$AA@ DB 'IsShowCursor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MGJDDPFG@HideCursor?$AA@
CONST	SEGMENT
??_C@_0L@MGJDDPFG@HideCursor?$AA@ DB 'HideCursor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BIENLPGM@ShowCursor?$AA@
CONST	SEGMENT
??_C@_0L@BIENLPGM@ShowCursor?$AA@ DB 'ShowCursor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NEOLAIPD@GetCursor?$AA@
CONST	SEGMENT
??_C@_09NEOLAIPD@GetCursor?$AA@ DB 'GetCursor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKKOCJGB@SetCursor?$AA@
CONST	SEGMENT
??_C@_09PKKOCJGB@SetCursor?$AA@ DB 'SetCursor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EJGJNKNL@IsPressed?$AA@
CONST	SEGMENT
??_C@_09EJGJNKNL@IsPressed?$AA@ DB 'IsPressed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKOOBKOE@HideWebPage?$AA@
CONST	SEGMENT
??_C@_0M@HKOOBKOE@HideWebPage?$AA@ DB 'HideWebPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJKDPGGC@MoveWebPage?$AA@
CONST	SEGMENT
??_C@_0M@CJKDPGGC@MoveWebPage?$AA@ DB 'MoveWebPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMDMBNNG@ShowWebPage?$AA@
CONST	SEGMENT
??_C@_0M@LMDMBNNG@ShowWebPage?$AA@ DB 'ShowWebPage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JGKOEJBF@IsWebPageMode?$AA@
CONST	SEGMENT
??_C@_0O@JGKOEJBF@IsWebPageMode?$AA@ DB 'IsWebPageMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NFOAEJMI@RunPythonFile?$AA@
CONST	SEGMENT
??_C@_0O@NFOAEJMI@RunPythonFile?$AA@ DB 'RunPythonFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CIIBMEDP@GetRandom?$AA@
CONST	SEGMENT
??_C@_09CIIBMEDP@GetRandom?$AA@ DB 'GetRandom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DJJGDMOB@GetCursorPosition?$AA@
CONST	SEGMENT
??_C@_0BC@DJJGDMOB@GetCursorPosition?$AA@ DB 'GetCursorPosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MCKFCFLJ@SetCenterPosition?$AA@
CONST	SEGMENT
??_C@_0BC@MCKFCFLJ@SetCenterPosition?$AA@ DB 'SetCenterPosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BPPNOEKE@SetGlobalCenterPosition?$AA@
CONST	SEGMENT
??_C@_0BI@BPPNOEKE@SetGlobalCenterPosition?$AA@ DB 'SetGlobalCenterPositi'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06GHJACMIL@SetFPS?$AA@
CONST	SEGMENT
??_C@_06GHJACMIL@SetFPS?$AA@ DB 'SetFPS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FGHMKANF@GetFaceCount?$AA@
CONST	SEGMENT
??_C@_0N@FGHMKANF@GetFaceCount?$AA@ DB 'GetFaceCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBJEAIDC@GetFaceSpeed?$AA@
CONST	SEGMENT
??_C@_0N@KBJEAIDC@GetFaceSpeed?$AA@ DB 'GetFaceSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGHKJKFO@GetLoad?$AA@
CONST	SEGMENT
??_C@_07EGHKJKFO@GetLoad?$AA@ DB 'GetLoad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EPOIPAHO@GetUpdateTime?$AA@
CONST	SEGMENT
??_C@_0O@EPOIPAHO@GetUpdateTime?$AA@ DB 'GetUpdateTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KFOAIOPC@GetRenderTime?$AA@
CONST	SEGMENT
??_C@_0O@KFOAIOPC@GetRenderTime?$AA@ DB 'GetRenderTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PBNANFFG@GetAvailableTextureMemory?$AA@
CONST	SEGMENT
??_C@_0BK@PBNANFFG@GetAvailableTextureMemory?$AA@ DB 'GetAvailableTexture'
	DB	'Memory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PJGDEPJO@MovieResetCamera?$AA@
CONST	SEGMENT
??_C@_0BB@PJGDEPJO@MovieResetCamera?$AA@ DB 'MovieResetCamera', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILLHHFGG@MovieZoomCamera?$AA@
CONST	SEGMENT
??_C@_0BA@ILLHHFGG@MovieZoomCamera?$AA@ DB 'MovieZoomCamera', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFJAAFFB@MoviePitchCamera?$AA@
CONST	SEGMENT
??_C@_0BB@KFJAAFFB@MoviePitchCamera?$AA@ DB 'MoviePitchCamera', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FCGIGAKD@MovieRotateCamera?$AA@
CONST	SEGMENT
??_C@_0BC@FCGIGAKD@MovieRotateCamera?$AA@ DB 'MovieRotateCamera', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BGDDIOFP@ZoomCamera?$AA@
CONST	SEGMENT
??_C@_0L@BGDDIOFP@ZoomCamera?$AA@ DB 'ZoomCamera', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKAIAJKC@PitchCamera?$AA@
CONST	SEGMENT
??_C@_0M@PKAIAJKC@PitchCamera?$AA@ DB 'PitchCamera', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGIDFLAJ@RotateCamera?$AA@
CONST	SEGMENT
??_C@_0N@HGIDFLAJ@RotateCamera?$AA@ DB 'RotateCamera', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHIMFGIG@GetRenderFPS?$AA@
CONST	SEGMENT
??_C@_0N@EHIMFGIG@GetRenderFPS?$AA@ DB 'GetRenderFPS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JKLFODAC@GetUpdateFPS?$AA@
CONST	SEGMENT
??_C@_0N@JKLFODAC@GetUpdateFPS?$AA@ DB 'GetUpdateFPS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGCMJHC@GetGlobalTimeStamp?$AA@
CONST	SEGMENT
??_C@_0BD@HGCMJHC@GetGlobalTimeStamp?$AA@ DB 'GetGlobalTimeStamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JKNDJHIN@GetGlobalTime?$AA@
CONST	SEGMENT
??_C@_0O@JKNDJHIN@GetGlobalTime?$AA@ DB 'GetGlobalTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CDIANBOE@GetTime?$AA@
CONST	SEGMENT
??_C@_07CDIANBOE@GetTime?$AA@ DB 'GetTime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JICDJDCH@GetCameraRotation?$AA@
CONST	SEGMENT
??_C@_0BC@JICDJDCH@GetCameraRotation?$AA@ DB 'GetCameraRotation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LHFPHHJA@GetCameraPitch?$AA@
CONST	SEGMENT
??_C@_0P@LHFPHHJA@GetCameraPitch?$AA@ DB 'GetCameraPitch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KOHPDBNP@GetCamera?$AA@
CONST	SEGMENT
??_C@_09KOHPDBNP@GetCamera?$AA@ DB 'GetCamera', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IADKBAEN@SetCamera?$AA@
CONST	SEGMENT
??_C@_09IADKBAEN@SetCamera?$AA@ DB 'SetCamera', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KODKGGCI@GetFileList?$AA@
CONST	SEGMENT
??_C@_0M@KODKGGCI@GetFileList?$AA@ DB 'GetFileList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DHIFKLBN@IsExistFile?$AA@
CONST	SEGMENT
??_C@_0M@DHIFKLBN@IsExistFile?$AA@ DB 'IsExistFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PPCHHCMN@SetMouseHandler?$AA@
CONST	SEGMENT
??_C@_0BA@PPCHHCMN@SetMouseHandler?$AA@ DB 'SetMouseHandler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BGKIEECB@Abort?$AA@
CONST	SEGMENT
??_C@_05BGKIEECB@Abort?$AA@ DB 'Abort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBABLPF@Exit?$AA@
CONST	SEGMENT
??_C@_04LBABLPF@Exit?$AA@ DB 'Exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNGBFJEN@Process?$AA@
CONST	SEGMENT
??_C@_07MNGBFJEN@Process?$AA@ DB 'Process', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIKANEJK@Create?$AA@
CONST	SEGMENT
??_C@_06MIKANEJK@Create?$AA@ DB 'Create', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLCPKPBE@Loop?$AA@
CONST	SEGMENT
??_C@_04KLCPKPBE@Loop?$AA@ DB 'Loop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ONMMANJD@RenderGame?$AA@
CONST	SEGMENT
??_C@_0L@ONMMANJD@RenderGame?$AA@ DB 'RenderGame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HMEHDBP@UpdateGame?$AA@
CONST	SEGMENT
??_C@_0L@HMEHDBP@UpdateGame?$AA@ DB 'UpdateGame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAJNLNAF@GetInfo?$AA@
CONST	SEGMENT
??_C@_07NAJNLNAF@GetInfo?$AA@ DB 'GetInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLLAGICL@GetImageInfo?$AA@
CONST	SEGMENT
??_C@_0N@CLLAGICL@GetImageInfo?$AA@ DB 'GetImageInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCIEBLLG@SetFrameSkip?$AA@
CONST	SEGMENT
??_C@_0N@KCIEBLLG@SetFrameSkip?$AA@ DB 'SetFrameSkip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILNFAENI@SetMinFog?$AA@
CONST	SEGMENT
??_C@_09ILNFAENI@SetMinFog?$AA@ DB 'SetMinFog', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CEAHHILA@SetCameraMaxDistance?$AA@
CONST	SEGMENT
??_C@_0BF@CEAHHILA@SetCameraMaxDistance?$AA@ DB 'SetCameraMaxDistance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPFDKOFJ@SetRideHorseEnable?$AA@
CONST	SEGMENT
??_C@_0BD@CPFDKOFJ@SetRideHorseEnable?$AA@ DB 'SetRideHorseEnable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KEKBEMLJ@SetTwoHandedWeaponAttSpeedDecrea@
CONST	SEGMENT
??_C@_0CI@KEKBEMLJ@SetTwoHandedWeaponAttSpeedDecrea@ DB 'SetTwoHandedWeap'
	DB	'onAttSpeedDecreaseValue', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CMPMDOBN@SetSkillEffectUpgradeEnable?$AA@
CONST	SEGMENT
??_C@_0BM@CMPMDOBN@SetSkillEffectUpgradeEnable?$AA@ DB 'SetSkillEffectUpg'
	DB	'radeEnable', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ONHBEMJA@SetWeaponSpecularEnable?$AA@
CONST	SEGMENT
??_C@_0BI@ONHBEMJA@SetWeaponSpecularEnable?$AA@ DB 'SetWeaponSpecularEnab'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJOFIHBE@SetArmorSpecularEnable?$AA@
CONST	SEGMENT
??_C@_0BH@PJOFIHBE@SetArmorSpecularEnable?$AA@ DB 'SetArmorSpecularEnable'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PILPKKLH@SetHairColorEnable?$AA@
CONST	SEGMENT
??_C@_0BD@PILPKKLH@SetHairColorEnable?$AA@ DB 'SetHairColorEnable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DEJFIMMP@EnablePerformanceTime?$AA@
CONST	SEGMENT
??_C@_0BG@DEJFIMMP@EnablePerformanceTime?$AA@ DB 'EnablePerformanceTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EOCGHNJF@SetTextTailLivingTime?$AA@
CONST	SEGMENT
??_C@_0BG@EOCGHNJF@SetTextTailLivingTime?$AA@ DB 'SetTextTailLivingTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJBHEFPA@IsLiveStage?$AA@
CONST	SEGMENT
??_C@_0M@NJBHEFPA@IsLiveStage?$AA@ DB 'IsLiveStage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICBDOOOG@IsTestStage?$AA@
CONST	SEGMENT
??_C@_0M@ICBDOOOG@IsTestStage?$AA@ DB 'IsTestStage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OAAOKAFA@IsDevStage?$AA@
CONST	SEGMENT
??_C@_0L@OAAOKAFA@IsDevStage?$AA@ DB 'IsDevStage', 00H	; `string'
CONST	ENDS
;	COMDAT ?s_methods@?1??initapp@@YAXXZ@4PAUPyMethodDef@@A
_DATA	SEGMENT
?s_methods@?1??initapp@@YAXXZ@4PAUPyMethodDef@@A DD FLAT:??_C@_0L@OAAOKAFA@IsDevStage?$AA@ ; `initapp'::`2'::s_methods
	DD	FLAT:?appIsDevStage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@ICBDOOOG@IsTestStage?$AA@
	DD	FLAT:?appIsTestStage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@NJBHEFPA@IsLiveStage?$AA@
	DD	FLAT:?appIsLiveStage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@EOCGHNJF@SetTextTailLivingTime?$AA@
	DD	FLAT:?appSetTextTailLivingTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@DEJFIMMP@EnablePerformanceTime?$AA@
	DD	FLAT:?appEnablePerformanceTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@PILPKKLH@SetHairColorEnable?$AA@
	DD	FLAT:?appSetHairColorEnable@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BH@PJOFIHBE@SetArmorSpecularEnable?$AA@
	DD	FLAT:?appSetArmorSpecularEnable@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@ONHBEMJA@SetWeaponSpecularEnable?$AA@
	DD	FLAT:?appSetWeaponSpecularEnable@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BM@CMPMDOBN@SetSkillEffectUpgradeEnable?$AA@
	DD	FLAT:?appSetSkillEffectUpgradeEnable@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0CI@KEKBEMLJ@SetTwoHandedWeaponAttSpeedDecrea@
	DD	FLAT:?SetTwoHandedWeaponAttSpeedDecreaseValue@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@CPFDKOFJ@SetRideHorseEnable?$AA@
	DD	FLAT:?appSetRideHorseEnable@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@CEAHHILA@SetCameraMaxDistance?$AA@
	DD	FLAT:?appSetCameraMaxDistance@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09ILNFAENI@SetMinFog?$AA@
	DD	FLAT:?appSetMinFog@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@KCIEBLLG@SetFrameSkip?$AA@
	DD	FLAT:?appSetFrameSkip@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@CLLAGICL@GetImageInfo?$AA@
	DD	FLAT:?appGetImageInfo@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07NAJNLNAF@GetInfo?$AA@
	DD	FLAT:?appGetInfo@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@HMEHDBP@UpdateGame?$AA@
	DD	FLAT:?appUpdateGame@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@ONMMANJD@RenderGame?$AA@
	DD	FLAT:?appRenderGame@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04KLCPKPBE@Loop?$AA@
	DD	FLAT:?appLoop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06MIKANEJK@Create?$AA@
	DD	FLAT:?appCreate@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07MNGBFJEN@Process?$AA@
	DD	FLAT:?appProcess@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_04LBABLPF@Exit?$AA@
	DD	FLAT:?appExit@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_05BGKIEECB@Abort?$AA@
	DD	FLAT:?appAbort@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@PPCHHCMN@SetMouseHandler?$AA@
	DD	FLAT:?appSetMouseHandler@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@DHIFKLBN@IsExistFile?$AA@
	DD	FLAT:?appIsExistFile@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@KODKGGCI@GetFileList?$AA@
	DD	FLAT:?appGetFileList@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09IADKBAEN@SetCamera?$AA@
	DD	FLAT:?appSetCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09KOHPDBNP@GetCamera?$AA@
	DD	FLAT:?appGetCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@LHFPHHJA@GetCameraPitch?$AA@
	DD	FLAT:?appGetCameraPitch@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@JICDJDCH@GetCameraRotation?$AA@
	DD	FLAT:?appGetCameraRotation@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07CDIANBOE@GetTime?$AA@
	DD	FLAT:?appGetTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@JKNDJHIN@GetGlobalTime?$AA@
	DD	FLAT:?appGetGlobalTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@HGCMJHC@GetGlobalTimeStamp?$AA@
	DD	FLAT:?appGetGlobalTimeStamp@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@JKLFODAC@GetUpdateFPS?$AA@
	DD	FLAT:?appGetUpdateFPS@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@EHIMFGIG@GetRenderFPS?$AA@
	DD	FLAT:?appGetRenderFPS@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@HGIDFLAJ@RotateCamera?$AA@
	DD	FLAT:?appRotateCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@PKAIAJKC@PitchCamera?$AA@
	DD	FLAT:?appPitchCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@BGDDIOFP@ZoomCamera?$AA@
	DD	FLAT:?appZoomCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@FCGIGAKD@MovieRotateCamera?$AA@
	DD	FLAT:?appMovieRotateCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@KFJAAFFB@MoviePitchCamera?$AA@
	DD	FLAT:?appMoviePitchCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@ILLHHFGG@MovieZoomCamera?$AA@
	DD	FLAT:?appMovieZoomCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@PJGDEPJO@MovieResetCamera?$AA@
	DD	FLAT:?appMovieResetCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BK@PBNANFFG@GetAvailableTextureMemory?$AA@
	DD	FLAT:?appGetAvaiableTextureMememory@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@KFOAIOPC@GetRenderTime?$AA@
	DD	FLAT:?appGetRenderTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@EPOIPAHO@GetUpdateTime?$AA@
	DD	FLAT:?appGetUpdateTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_07EGHKJKFO@GetLoad?$AA@
	DD	FLAT:?appGetLoad@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@KBJEAIDC@GetFaceSpeed?$AA@
	DD	FLAT:?appGetFaceSpeed@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@FGHMKANF@GetFaceCount?$AA@
	DD	FLAT:?appGetFaceCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06GHJACMIL@SetFPS?$AA@
	DD	FLAT:?appSetFPS@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@BPPNOEKE@SetGlobalCenterPosition?$AA@
	DD	FLAT:?appSetGlobalCenterPosition@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@MCKFCFLJ@SetCenterPosition?$AA@
	DD	FLAT:?appSetCenterPosition@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@DJJGDMOB@GetCursorPosition?$AA@
	DD	FLAT:?appGetCursorPosition@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09CIIBMEDP@GetRandom?$AA@
	DD	FLAT:?appGetRandom@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@NFOAEJMI@RunPythonFile?$AA@
	DD	FLAT:?appRunPythonFile@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@JGKOEJBF@IsWebPageMode?$AA@
	DD	FLAT:?appIsWebPageMode@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@LMDMBNNG@ShowWebPage?$AA@
	DD	FLAT:?appShowWebPage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@CJKDPGGC@MoveWebPage?$AA@
	DD	FLAT:?appMoveWebPage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@HKOOBKOE@HideWebPage?$AA@
	DD	FLAT:?appHideWebPage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09EJGJNKNL@IsPressed?$AA@
	DD	FLAT:?appIsPressed@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09PKKOCJGB@SetCursor?$AA@
	DD	FLAT:?appSetCursor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09NEOLAIPD@GetCursor?$AA@
	DD	FLAT:?appGetCursor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@BIENLPGM@ShowCursor?$AA@
	DD	FLAT:?appShowCursor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@MGJDDPFG@HideCursor?$AA@
	DD	FLAT:?appHideCursor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@BFHCIAEF@IsShowCursor?$AA@
	DD	FLAT:?appIsShowCursor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@FMIDHOAE@IsLiarCursorOn?$AA@
	DD	FLAT:?appIsLiarCursorOn@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@IDNDDKLI@SetSoftwareCursor?$AA@
	DD	FLAT:?appSetSoftwareCursor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@KKHIHHDJ@SetHardwareCursor?$AA@
	DD	FLAT:?appSetHardwareCursor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@KJLEKPPL@SetConnectData?$AA@
	DD	FLAT:?appSetConnectData@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@GHKKFFNH@GetConnectData?$AA@
	DD	FLAT:?appGetConnectData@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@IMHAMDDH@GetRotatingDirection?$AA@
	DD	FLAT:?appGetRotatingDirection@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BE@JKNPCCAK@GetDegreeDifference?$AA@
	DD	FLAT:?appGetDegreeDifference@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_05PFDOMJEF@Sleep?$AA@
	DD	FLAT:?appSleep@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@CKMKHHJC@SetDefaultFontName?$AA@
	DD	FLAT:?appSetDefaultFontName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@CENDFAOC@SetGuildSymbolPath?$AA@
	DD	FLAT:?appSetGuildSymbolPath@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@LNMJCGJN@EnableSpecialCameraMode?$AA@
	DD	FLAT:?appEnableSpecialCameraMode@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@NCLIAJKF@SetCameraSpeed?$AA@
	DD	FLAT:?appSetCameraSpeed@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@JPDLAHCD@SaveCameraSetting?$AA@
	DD	FLAT:?appSaveCameraSetting@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BC@KEOGBKMG@LoadCameraSetting?$AA@
	DD	FLAT:?appLoadCameraSetting@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@IPPGJFKO@SetDefaultCamera?$AA@
	DD	FLAT:?appSetDefaultCamera@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@JANPDNEC@SetCameraSetting?$AA@
	DD	FLAT:?appSetCameraSetting@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@MFMELJAK@SetSightRange?$AA@
	DD	FLAT:?appSetSightRange@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@LOHDPEAO@IsFileExist?$AA@
	DD	FLAT:?appIsFileExist@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@JAMKKFFG@OpenTextFile?$AA@
	DD	FLAT:?appOpenTextFile@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@LNEGOIPA@CloseTextFile?$AA@
	DD	FLAT:?appCloseTextFile@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@BNHHEKFO@GetTextFileLineCount?$AA@
	DD	FLAT:?appGetTextFileLineCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@HHNFKANE@GetTextFileLine?$AA@
	DD	FLAT:?appGetTextFileLine@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@PBACFPCP@GetLocaleServiceName?$AA@
	DD	FLAT:?appGetLocaleServiceName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@JDECMIPJ@GetLocaleName?$AA@
	DD	FLAT:?appGetLocaleName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@OKMLAHKI@GetLocalePath?$AA@
	DD	FLAT:?appGetLocalePath@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@KMAINBBA@ForceSetLocale?$AA@
	DD	FLAT:?appForceSetLocale@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@JHGEFJDO@LoadLocaleAddr?$AA@
	DD	FLAT:?appLoadLocaleAddr@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@BFJDMEJO@LoadLocaleData?$AA@
	DD	FLAT:?appLoadLocaleData@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@FAIOENFF@SetCHEONMA?$AA@
	DD	FLAT:?appSetCHEONMA@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09INPKBHN@IsCHEONMA?$AA@
	DD	FLAT:?appIsCHEONMA@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@CEMKCGHA@GetDefaultCodePage?$AA@
	DD	FLAT:?appGetDefaultCodePage@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@HDAEMEAH@SetControlFP?$AA@
	DD	FLAT:?appSetControlFP@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@IFMAFIHG@SetSpecularSpeed?$AA@
	DD	FLAT:?appSetSpecularSpeed@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@DNKBNLNC@testGetAccumulationTime?$AA@
	DD	FLAT:?apptestGetAccumulationTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BK@PLDHJGMN@testResetAccumulationTime?$AA@
	DD	FLAT:?apptestResetAccumulationTime@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@KHKICLKO@testSetSpecularColor?$AA@
	DD	FLAT:?apptestSetSpecularColor@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@MMPIECKB@SetVisibleNotice?$AA@
	DD	FLAT:?appSetVisibleNotice@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BA@NLDNPIOL@IsVisibleNotice?$AA@
	DD	FLAT:?appIsVisibleNotice@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BF@BOMOCGIP@EnableTestServerFlag?$AA@
	DD	FLAT:?appEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BH@GBDECBIH@IsEnableTestServerFlag?$AA@
	DD	FLAT:?appIsEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@DLDOCGLL@SetGuildMarkPath?$AA@
	DD	FLAT:?appSetGuildMarkPath@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@LIPHBNAO@OnLogoUpdate?$AA@
	DD	FLAT:?appLogoUpdate@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@ELECBFOK@OnLogoRender?$AA@
	DD	FLAT:?appLogoRender@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@JMMGDKPP@OnLogoOpen?$AA@
	DD	FLAT:?appLogoOpen@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@JMIFNMOK@OnLogoClose?$AA@
	DD	FLAT:?appLogoClose@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	00H
	DD	00H
	ORG $+8
_DATA	ENDS
;	COMDAT ??_C@_04JCAPCJAP@?4tga?$AA@
CONST	SEGMENT
??_C@_04JCAPCJAP@?4tga?$AA@ DB '.tga', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02OCDGCAAK@si?$AA@
CONST	SEGMENT
??_C@_02OCDGCAAK@si?$AA@ DB 'si', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GNAGLJEE@Wrong?5Cursor?5Name?5?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BH@GNAGLJEE@Wrong?5Cursor?5Name?5?$FL?$CFd?$FN?$AA@ DB 'Wrong Curs'
	DB	'or Name [%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDIHAGKM@ii?$AA@
CONST	SEGMENT
??_C@_02PDIHAGKM@ii?$AA@ DB 'ii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PINLEBJB@fi?$AA@
CONST	SEGMENT
??_C@_02PINLEBJB@fi?$AA@ DB 'fi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01INIBCBCB@f?$AA@
CONST	SEGMENT
??_C@_01INIBCBCB@f?$AA@ DB 'f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EOBPFJGD@ffff?$AA@
CONST	SEGMENT
??_C@_04EOBPFJGD@ffff?$AA@ DB 'ffff', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GLKMLICL@iii?$AA@
CONST	SEGMENT
??_C@_03GLKMLICL@iii?$AA@ DB 'iii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OIKAIHIF@s?$CD?$AA@
CONST	SEGMENT
??_C@_02OIKAIHIF@s?$CD?$AA@ DB 's#', 00H		; `string'
CONST	ENDS
;	COMDAT ?key@?5??appLoadLocaleAddr@@YAPAU_object@@PAU2@0@Z@4QBEB
CONST	SEGMENT
?key@?5??appLoadLocaleAddr@@YAPAU_object@@PAU2@0@Z@4QBEB DB 082H ; `appLoadLocaleAddr'::`6'::key
	DB	01bH
	DB	034H
	DB	0aeH
	DB	012H
	DB	03bH
	DB	0fbH
	DB	017H
	DB	0d7H
	DB	02cH
	DB	039H
	DB	0aeH
	DB	041H
	DB	098H
	DB	0f1H
	DB	063H
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEKALNFB@RENDER_GAME?$AA@
CONST	SEGMENT
??_C@_0M@OEKALNFB@RENDER_GAME?$AA@ DB 'RENDER_GAME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z$0
__ehfuncinfo$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTextLineLoader@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTextLineLoader@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CTextLineLoader@@QAE@PBD@Z$1
__ehfuncinfo$??0CTextLineLoader@@QAE@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CTextLineLoader@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?appGetConnectData@@YAPAU_object@@PAU1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?appGetConnectData@@YAPAU_object@@PAU1@0@Z$0
__ehfuncinfo$?appGetConnectData@@YAPAU_object@@PAU1@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?appGetConnectData@@YAPAU_object@@PAU1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?appGetInfo@@YAPAU_object@@PAU1@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?appGetInfo@@YAPAU_object@@PAU1@0@Z$0
__ehfuncinfo$?appGetInfo@@YAPAU_object@@PAU1@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?appGetInfo@@YAPAU_object@@PAU1@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 611  : 		{	// estimate maximum array size

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLogoClose@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLogoClose@@YAPAU_object@@PAU1@0@Z PROC		; appLogoClose, COMDAT

; 1191 : 	//CPythonApplication::Instance().OnLogoClose();
; 1192 : 	return Py_BuildNone();

  00000	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appLogoClose@@YAPAU_object@@PAU1@0@Z ENDP		; appLogoClose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLogoRender@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLogoRender@@YAPAU_object@@PAU1@0@Z PROC		; appLogoRender, COMDAT

; 1185 : 	//CPythonApplication::Instance().OnLogoRender();
; 1186 : 	return Py_BuildNone();

  00000	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appLogoRender@@YAPAU_object@@PAU1@0@Z ENDP		; appLogoRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLogoUpdate@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLogoUpdate@@YAPAU_object@@PAU1@0@Z PROC		; appLogoUpdate, COMDAT

; 1179 : 	int nIsRun = 0; //CPythonApplication::Instance().OnLogoUpdate();
; 1180 : 	return Py_BuildValue("i", nIsRun);

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000d	83 c4 08	 add	 esp, 8

; 1181 : }

  00010	c3		 ret	 0
?appLogoUpdate@@YAPAU_object@@PAU1@0@Z ENDP		; appLogoUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLogoOpen@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szName$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLogoOpen@@YAPAU_object@@PAU1@0@Z PROC		; appLogoOpen, COMDAT

; 1166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1167 : 	char* szName;
; 1168 : 	if (!PyTuple_GetString(poArgs, 0, &szName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appLogoOpe

; 1169 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1175 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appLogoOpe:

; 1170 : 
; 1171 : 	int nIsSuccess = 1; //CPythonApplication::Instance().OnLogoOpen(szName);
; 1172 : 	CMovieMan::Instance().PlayLogo(szName);

  00027	ff 75 fc	 push	 DWORD PTR _szName$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A ; CSingleton<CMovieMan>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?PlayLogo@CMovieMan@@QAEXPBD@Z ; CMovieMan::PlayLogo

; 1173 : 
; 1174 : 	return Py_BuildValue("i", nIsSuccess);

  00035	6a 01		 push	 1
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00042	83 c4 08	 add	 esp, 8

; 1175 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?appLogoOpen@@YAPAU_object@@PAU1@0@Z ENDP		; appLogoOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsLiveStage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsLiveStage@@YAPAU_object@@PAU1@0@Z PROC		; appIsLiveStage, COMDAT

; 1158 : 	int nIsLiveStage = 0;
; 1159 : #if !defined(LOCALE_SERVICE_STAGE_TEST) && !defined(LOCALE_SERVICE_STAGE_DEVELOPMENT)
; 1160 : 	nIsLiveStage = 1;
; 1161 : #endif
; 1162 : 	return Py_BuildValue("i", nIsLiveStage);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000d	83 c4 08	 add	 esp, 8

; 1163 : }

  00010	c3		 ret	 0
?appIsLiveStage@@YAPAU_object@@PAU1@0@Z ENDP		; appIsLiveStage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsTestStage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsTestStage@@YAPAU_object@@PAU1@0@Z PROC		; appIsTestStage, COMDAT

; 1149 : 	int nIsTestStage = 0;
; 1150 : #if defined(LOCALE_SERVICE_STAGE_TEST)
; 1151 : 	nIsTestStage = 1;
; 1152 : #endif
; 1153 : 	return Py_BuildValue("i", nIsTestStage);

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000d	83 c4 08	 add	 esp, 8

; 1154 : }

  00010	c3		 ret	 0
?appIsTestStage@@YAPAU_object@@PAU1@0@Z ENDP		; appIsTestStage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsDevStage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsDevStage@@YAPAU_object@@PAU1@0@Z PROC		; appIsDevStage, COMDAT

; 1140 : 	int nIsDevelopmentStage = 0;
; 1141 : #if defined(LOCALE_SERVICE_STAGE_DEVELOPMENT)
; 1142 : 	nIsDevelopmentStage = 1;
; 1143 : #endif
; 1144 : 	return Py_BuildValue("i", nIsDevelopmentStage);

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0000d	83 c4 08	 add	 esp, 8

; 1145 : }

  00010	c3		 ret	 0
?appIsDevStage@@YAPAU_object@@PAU1@0@Z ENDP		; appIsDevStage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\string.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\string.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetGuildMarkPath@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_path$ = -264						; size = 4
_newPath$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetGuildMarkPath@@YAPAU_object@@PAU1@0@Z PROC	; appSetGuildMarkPath, COMDAT

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _poArgs$[ebp]

; 1118 : 	char * path;
; 1119 : 	if (!PyTuple_GetString(poArgs, 0, &path))

  00016	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  0001c	51		 push	 ecx
  0001d	6a 00		 push	 0
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	84 c0		 test	 al, al
  0002a	75 18		 jne	 SHORT $LN3@appSetGuil

; 1120 : 		return Py_BuildException();

  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00033	83 c4 04	 add	 esp, 4

; 1136 : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	33 cd		 xor	 ecx, ebp
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN3@appSetGuil:
  00044	56		 push	 esi
; File a:\vs\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_04JCAPCJAP@?4tga?$AA@
  0004a	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _path$[ebp]
  00050	e8 00 00 00 00	 call	 _strstr
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 1123 :     char * ext = strstr(path, ".tga");

  00055	8b f0		 mov	 esi, eax
; File a:\vs\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

  00057	83 c4 08	 add	 esp, 8
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 1128 :         strncpy(newPath, path, extPos);

  0005a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _newPath$[ebp]
  00060	85 f6		 test	 esi, esi
  00062	74 25		 je	 SHORT $LN2@appSetGuil

; 1124 : 
; 1125 :     if (ext)
; 1126 :     {
; 1127 : 		int extPos = ext - path;

  00064	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _path$[ebp]
  0006a	2b f1		 sub	 esi, ecx

; 1128 :         strncpy(newPath, path, extPos);

  0006c	56		 push	 esi
  0006d	51		 push	 ecx
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _strncpy
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1129 :         newPath[extPos] = '\0';

  00077	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  0007d	73 44		 jae	 SHORT $LN13@appSetGuil
  0007f	c6 84 35 fc fe
	ff ff 00	 mov	 BYTE PTR _newPath$[ebp+esi], 0

; 1130 :     }
; 1131 :     else

  00087	eb 14		 jmp	 SHORT $LN1@appSetGuil
$LN2@appSetGuil:

; 1132 :         strncpy(newPath, path, sizeof(newPath)-1);

  00089	68 ff 00 00 00	 push	 255			; 000000ffH
  0008e	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _path$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _strncpy
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@appSetGuil:

; 1133 : 	
; 1134 : 	CGuildMarkManager::Instance().SetMarkPathPrefix(newPath);

  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$singleton@VCGuildMarkManager@@@@0PAVCGuildMarkManager@@A ; singleton<CGuildMarkManager>::ms_singleton
  000a3	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _newPath$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?SetMarkPathPrefix@CGuildMarkManager@@QAEXPBD@Z ; CGuildMarkManager::SetMarkPathPrefix

; 1135 : 	return Py_BuildNone();

  000af	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1136 : }

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	5e		 pop	 esi
  000ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN13@appSetGuil:

; 1129 :         newPath[extPos] = '\0';

  000c3	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN14@appSetGuil:
$LN12@appSetGuil:
  000c8	cc		 int	 3
?appSetGuildMarkPath@@YAPAU_object@@PAU1@0@Z ENDP	; appSetGuildMarkPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\xstddef
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetTextFileLine@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iLineIndex$ = -8					; size = 4
_iHandle$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetTextFileLine@@YAPAU_object@@PAU1@0@Z PROC	; appGetTextFileLine, COMDAT

; 1104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1105 : 	int iHandle;
; 1106 : 	if (!PyTuple_GetInteger(poArgs, 0, &iHandle))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iHandle$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN2@appGetText
$LN18@appGetText:

; 1107 : 		return Py_BuildException();

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4
  00027	5e		 pop	 esi

; 1114 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN2@appGetText:

; 1108 : 	int iLineIndex;
; 1109 : 	if (!PyTuple_GetInteger(poArgs, 1, &iLineIndex))

  0002c	8d 45 f8	 lea	 eax, DWORD PTR _iLineIndex$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN18@appGetText

; 1110 : 		return Py_BuildException();
; 1111 : 
; 1112 : 	CTextLineLoader * pTextFileLoader = (CTextLineLoader *)iHandle;

  0003f	8b 75 fc	 mov	 esi, DWORD PTR _iHandle$[ebp]

; 1055 : 			return m_kTextFileLoader.GetLineCount();

  00042	8b ce		 mov	 ecx, esi
  00044	57		 push	 edi

; 1113 : 	return Py_BuildValue("s", pTextFileLoader->GetLine(iLineIndex));

  00045	8b 7d f8	 mov	 edi, DWORD PTR _iLineIndex$[ebp]

; 1055 : 			return m_kTextFileLoader.GetLineCount();

  00048	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount

; 1056 : 		}
; 1057 : 
; 1058 : 		const char * GetLine(DWORD dwIndex)
; 1059 : 		{
; 1060 : 			if (dwIndex >= GetLineCount())

  0004d	3b f8		 cmp	 edi, eax
  0004f	72 07		 jb	 SHORT $LN5@appGetText

; 1061 : 				return "";

  00051	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00056	eb 10		 jmp	 SHORT $LN14@appGetText
$LN5@appGetText:

; 1062 : 
; 1063 : 			return m_kTextFileLoader.GetLineString(dwIndex).c_str();

  00058	57		 push	 edi
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
; File a:\vs\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00060	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00064	72 02		 jb	 SHORT $LN14@appGetText
; File a:\vs\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00066	8b 00		 mov	 eax, DWORD PTR [eax]
$LN14@appGetText:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 1113 : 	return Py_BuildValue("s", pTextFileLoader->GetLine(iLineIndex));

  00068	50		 push	 eax
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00074	83 c4 08	 add	 esp, 8
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi

; 1114 : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?appGetTextFileLine@@YAPAU_object@@PAU1@0@Z ENDP	; appGetTextFileLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetTextFileLineCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iHandle$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetTextFileLineCount@@YAPAU_object@@PAU1@0@Z PROC	; appGetTextFileLineCount, COMDAT

; 1094 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1095 : 	int iHandle;
; 1096 : 	if (!PyTuple_GetInteger(poArgs, 0, &iHandle))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iHandle$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appGetText

; 1097 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1101 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appGetText:

; 1055 : 			return m_kTextFileLoader.GetLineCount();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _iHandle$[ebp]
  0002a	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount

; 1098 : 
; 1099 : 	CTextLineLoader * pTextFileLoader = (CTextLineLoader *)iHandle;
; 1100 : 	return Py_BuildValue("i", pTextFileLoader->GetLineCount());

  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0003b	83 c4 08	 add	 esp, 8

; 1101 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?appGetTextFileLineCount@@YAPAU_object@@PAU1@0@Z ENDP	; appGetTextFileLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appCloseTextFile@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iHandle$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appCloseTextFile@@YAPAU_object@@PAU1@0@Z PROC		; appCloseTextFile, COMDAT

; 1082 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1083 : 	int iHandle;
; 1084 : 	if (!PyTuple_GetInteger(poArgs, 0, &iHandle))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iHandle$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appCloseTe

; 1085 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1091 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appCloseTe:
  00027	56		 push	 esi

; 1086 : 
; 1087 : 	CTextLineLoader * pTextFileLoader = (CTextLineLoader *)iHandle;
; 1088 : 	delete pTextFileLoader;

  00028	8b 75 fc	 mov	 esi, DWORD PTR _iHandle$[ebp]
  0002b	85 f6		 test	 esi, esi
  0002d	74 10		 je	 SHORT $LN6@appCloseTe
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN6@appCloseTe:

; 1089 : 
; 1090 : 	return Py_BuildNone();

  0003f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  00044	5e		 pop	 esi

; 1091 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?appCloseTextFile@@YAPAU_object@@PAU1@0@Z ENDP		; appCloseTextFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appOpenTextFile@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
_szFileName$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appOpenTextFile@@YAPAU_object@@PAU1@0@Z PROC		; appOpenTextFile, COMDAT

; 1071 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1072 : 	char * szFileName;
; 1073 : 	if (!PyTuple_GetString(poArgs, 0, &szFileName))

  00025	8d 45 f0	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0002e	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	84 c0		 test	 al, al
  00038	75 19		 jne	 SHORT $LN1@appOpenTex

; 1074 : 		return Py_BuildException();

  0003a	6a 00		 push	 0
  0003c	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00041	83 c4 04	 add	 esp, 4

; 1079 : }

  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN1@appOpenTex:

; 1075 : 
; 1076 : 	CTextLineLoader * pTextLineLoader = new CTextLineLoader(szFileName);

  00053	6a 10		 push	 16			; 00000010H
  00055	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00060	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00067	85 c0		 test	 eax, eax
  00069	74 0c		 je	 SHORT $LN4@appOpenTex
  0006b	ff 75 f0	 push	 DWORD PTR _szFileName$[ebp]
  0006e	8b c8		 mov	 ecx, eax
  00070	e8 00 00 00 00	 call	 ??0CTextLineLoader@@QAE@PBD@Z ; CTextLineLoader::CTextLineLoader
  00075	eb 02		 jmp	 SHORT $LN5@appOpenTex
$LN4@appOpenTex:
  00077	33 c0		 xor	 eax, eax
$LN5@appOpenTex:

; 1077 : 
; 1078 : 	return Py_BuildValue("i", (int)pTextLineLoader);

  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00085	83 c4 08	 add	 esp, 8

; 1079 : }

  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z$0:
  00000	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?appOpenTextFile@@YAPAU_object@@PAU1@0@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?appOpenTextFile@@YAPAU_object@@PAU1@0@Z ENDP		; appOpenTextFile
; Function compile flags: /Ogtp
;	COMDAT ??_GCTextLineLoader@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTextLineLoader@@QAEPAXI@Z PROC			; CTextLineLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN7@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN7@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCTextLineLoader@@QAEPAXI@Z ENDP			; CTextLineLoader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1CTextLineLoader@@QAE@XZ
_TEXT	SEGMENT
??1CTextLineLoader@@QAE@XZ PROC				; CTextLineLoader::~CTextLineLoader, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
??1CTextLineLoader@@QAE@XZ ENDP				; CTextLineLoader::~CTextLineLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\xstddef
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?GetLine@CTextLineLoader@@QAEPBDK@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
?GetLine@CTextLineLoader@@QAEPBDK@Z PROC		; CTextLineLoader::GetLine, COMDAT
; _this$ = ecx

; 1059 : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1055 : 			return m_kTextFileLoader.GetLineCount();

  00006	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount

; 1060 : 			if (dwIndex >= GetLineCount())

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	72 0a		 jb	 SHORT $LN1@GetLine

; 1061 : 				return "";

  00012	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00017	5e		 pop	 esi

; 1064 : 		}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN1@GetLine:

; 1062 : 
; 1063 : 			return m_kTextFileLoader.GetLineString(dwIndex).c_str();

  0001c	51		 push	 ecx
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
; File a:\vs\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 02		 jb	 SHORT $LN2@GetLine
; File a:\vs\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2@GetLine:
  0002c	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 1064 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetLine@CTextLineLoader@@QAEPBDK@Z ENDP		; CTextLineLoader::GetLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?GetLineCount@CTextLineLoader@@QAEKXZ
_TEXT	SEGMENT
?GetLineCount@CTextLineLoader@@QAEKXZ PROC		; CTextLineLoader::GetLineCount, COMDAT
; _this$ = ecx

; 1055 : 			return m_kTextFileLoader.GetLineCount();

  00000	e9 00 00 00 00	 jmp	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
?GetLineCount@CTextLineLoader@@QAEKXZ ENDP		; CTextLineLoader::GetLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ??0CTextLineLoader@@QAE@PBD@Z
_TEXT	SEGMENT
_this$GSCopy$ = -348					; size = 4
_pvData$ = -344						; size = 4
_kFile$ = -340						; size = 324
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
??0CTextLineLoader@@QAE@PBD@Z PROC			; CTextLineLoader::CTextLineLoader, COMDAT
; _this$ = ecx

; 1043 : 		CTextLineLoader(const char * c_szFileName)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTextLineLoader@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
  00032	89 bd a4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00038	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader

; 1044 : 		{
; 1045 : 			const VOID* pvData;
; 1046 : 			CMappedFile kFile;

  0003d	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _kFile$[ebp]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 1047 : 			if (!CEterPackManager::Instance().Get(kFile, c_szFileName, &pvData))

  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00055	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pvData$[ebp]
  0005b	50		 push	 eax
  0005c	56		 push	 esi
  0005d	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _kFile$[ebp]
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get

; 1048 : 				return;

  0006d	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _kFile$[ebp]
  00073	84 c0		 test	 al, al
  00075	74 19		 je	 SHORT $LN9@CTextLineL

; 1049 : 
; 1050 : 			m_kTextFileLoader.Bind(kFile.Size(), pvData);

  00077	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _pvData$[ebp]
  0007d	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  00082	50		 push	 eax
  00083	8b cf		 mov	 ecx, edi
  00085	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind

; 1051 : 		}

  0008a	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _kFile$[ebp]
$LN9@CTextLineL:
  00090	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00094	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00099	8b c7		 mov	 eax, edi
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a5	59		 pop	 ecx
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ab	33 cd		 xor	 ecx, ebp
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTextLineLoader@@QAE@PBD@Z$0:
  00000	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$??0CTextLineLoader@@QAE@PBD@Z$1:
  0000b	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _kFile$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__ehhandler$??0CTextLineLoader@@QAE@PBD@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTextLineLoader@@QAE@PBD@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTextLineLoader@@QAE@PBD@Z ENDP			; CTextLineLoader::CTextLineLoader
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z PROC	; appIsEnableTestServerFlag, COMDAT

; 1037 : 	return Py_BuildValue("i", bTestServerFlag);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?bTestServerFlag@@3HA ; bTestServerFlag
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 1038 : }

  00014	c3		 ret	 0
?appIsEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z ENDP	; appIsEnableTestServerFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z PROC	; appEnableTestServerFlag, COMDAT

; 1031 : 	bTestServerFlag = TRUE;

  00000	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bTestServerFlag@@3HA, 1 ; bTestServerFlag

; 1032 : 	return Py_BuildNone();

  0000a	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appEnableTestServerFlag@@YAPAU_object@@PAU1@0@Z ENDP	; appEnableTestServerFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsVisibleNotice@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsVisibleNotice@@YAPAU_object@@PAU1@0@Z PROC	; appIsVisibleNotice, COMDAT

; 1026 : 	return Py_BuildValue("i", bVisibleNotice);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?bVisibleNotice@@3HA ; bVisibleNotice
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 1027 : }

  00014	c3		 ret	 0
?appIsVisibleNotice@@YAPAU_object@@PAU1@0@Z ENDP	; appIsVisibleNotice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetVisibleNotice@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iFlag$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetVisibleNotice@@YAPAU_object@@PAU1@0@Z PROC	; appSetVisibleNotice, COMDAT

; 1016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1017 : 	int iFlag;
; 1018 : 	if (!PyTuple_GetInteger(poArgs, 0, &iFlag))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iFlag$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetVisi

; 1019 : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 1022 : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetVisi:

; 1020 : 	bVisibleNotice = iFlag;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _iFlag$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?bVisibleNotice@@3HA, eax ; bVisibleNotice

; 1021 : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 1022 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?appSetVisibleNotice@@YAPAU_object@@PAU1@0@Z ENDP	; appSetVisibleNotice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?apptestSetSpecularColor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fb$ = -12						; size = 4
_fg$ = -8						; size = 4
_fr$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?apptestSetSpecularColor@@YAPAU_object@@PAU1@0@Z PROC	; apptestSetSpecularColor, COMDAT

; 1001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1002 : 	float fr;
; 1003 : 	if (!PyTuple_GetFloat(poArgs, 0, &fr))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _fr$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN3@apptestSet
$LN19@apptestSet:

; 1004 : 		return Py_BuildException();

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4
  00027	5e		 pop	 esi

; 1013 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN3@apptestSet:

; 1005 : 	float fg;
; 1006 : 	if (!PyTuple_GetFloat(poArgs, 1, &fg))

  0002c	8d 45 f8	 lea	 eax, DWORD PTR _fg$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN19@apptestSet

; 1007 : 		return Py_BuildException();
; 1008 : 	float fb;
; 1009 : 	if (!PyTuple_GetFloat(poArgs, 2, &fb))

  0003f	8d 45 f4	 lea	 eax, DWORD PTR _fb$[ebp]
  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 cb		 je	 SHORT $LN19@apptestSet

; 1010 : 		return Py_BuildException();
; 1011 : 	g_fSpecularColor = D3DXCOLOR(fr, fg, fb, 1.0f);

  00052	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fr$[ebp]
  00057	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?g_fSpecularColor@@3UD3DXCOLOR@@A, xmm0
  0005f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fg$[ebp]
  00064	f3 0f 11 05 04
	00 00 00	 movss	 DWORD PTR ?g_fSpecularColor@@3UD3DXCOLOR@@A+4, xmm0
  0006c	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fb$[ebp]
  00071	f3 0f 11 05 08
	00 00 00	 movss	 DWORD PTR ?g_fSpecularColor@@3UD3DXCOLOR@@A+8, xmm0
  00079	c7 05 0c 00 00
	00 00 00 80 3f	 mov	 DWORD PTR ?g_fSpecularColor@@3UD3DXCOLOR@@A+12, 1065353216 ; 3f800000H

; 1012 : 	return Py_BuildNone();

  00083	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  00088	5e		 pop	 esi

; 1013 : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?apptestSetSpecularColor@@YAPAU_object@@PAU1@0@Z ENDP	; apptestSetSpecularColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?apptestResetAccumulationTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?apptestResetAccumulationTime@@YAPAU_object@@PAU1@0@Z PROC ; apptestResetAccumulationTime, COMDAT

; 996  : 	g_iAccumulationTime = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_iAccumulationTime@@3HA, 0 ; g_iAccumulationTime

; 997  : 	return Py_BuildNone();

  0000a	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?apptestResetAccumulationTime@@YAPAU_object@@PAU1@0@Z ENDP ; apptestResetAccumulationTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?apptestGetAccumulationTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?apptestGetAccumulationTime@@YAPAU_object@@PAU1@0@Z PROC ; apptestGetAccumulationTime, COMDAT

; 991  : 	return Py_BuildValue("i", g_iAccumulationTime);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_iAccumulationTime@@3HA ; g_iAccumulationTime
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 992  : }

  00014	c3		 ret	 0
?apptestGetAccumulationTime@@YAPAU_object@@PAU1@0@Z ENDP ; apptestGetAccumulationTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetSightRange@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iRange$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetSightRange@@YAPAU_object@@PAU1@0@Z PROC		; appSetSightRange, COMDAT

; 978  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 979  : 	int iRange;
; 980  : 	if (!PyTuple_GetInteger(poArgs, 0, &iRange))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iRange$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetSigh

; 981  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 985  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetSigh:

; 982  : 
; 983  : 	CPythonApplication::Instance().SetForceSightRange(iRange);

  00027	ff 75 fc	 push	 DWORD PTR _iRange$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?SetForceSightRange@CPythonApplication@@QAEXH@Z ; CPythonApplication::SetForceSightRange

; 984  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 985  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appSetSightRange@@YAPAU_object@@PAU1@0@Z ENDP		; appSetSightRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetDefaultCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetDefaultCamera@@YAPAU_object@@PAU1@0@Z PROC	; appSetDefaultCamera, COMDAT

; 973  : 	CPythonApplication::Instance().SetDefaultCamera();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	83 c1 20	 add	 ecx, 32			; 00000020H
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	ff 50 24	 call	 DWORD PTR [eax+36]

; 974  : 	return Py_BuildNone();

  0000e	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appSetDefaultCamera@@YAPAU_object@@PAU1@0@Z ENDP	; appSetDefaultCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLoadCameraSetting@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLoadCameraSetting@@YAPAU_object@@PAU1@0@Z PROC	; appLoadCameraSetting, COMDAT

; 962  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  : 	char * szFileName;
; 964  : 	if (!PyTuple_GetString(poArgs, 0, &szFileName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appLoadCam

; 965  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 969  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appLoadCam:

; 966  : 
; 967  : 	bool bResult = CPythonApplication::Instance().LoadCameraSetting(szFileName);

  00027	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?LoadCameraSetting@CPythonApplication@@QAE_NPBD@Z ; CPythonApplication::LoadCameraSetting

; 968  : 	return Py_BuildValue("i", bResult);

  00035	0f b6 c0	 movzx	 eax, al
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00044	83 c4 08	 add	 esp, 8

; 969  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?appLoadCameraSetting@@YAPAU_object@@PAU1@0@Z ENDP	; appLoadCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSaveCameraSetting@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSaveCameraSetting@@YAPAU_object@@PAU1@0@Z PROC	; appSaveCameraSetting, COMDAT

; 952  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 953  : 	char * szFileName;
; 954  : 	if (!PyTuple_GetString(poArgs, 0, &szFileName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSaveCam

; 955  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 959  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSaveCam:

; 956  : 
; 957  : 	CPythonApplication::Instance().SaveCameraSetting(szFileName);

  00027	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?SaveCameraSetting@CPythonApplication@@QAEXPBD@Z ; CPythonApplication::SaveCameraSetting

; 958  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 959  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appSaveCameraSetting@@YAPAU_object@@PAU1@0@Z ENDP	; appSaveCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetCameraSetting@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iy$ = -64						; size = 4
_ix$ = -60						; size = 4
_iPitch$ = -56						; size = 4
_iz$ = -52						; size = 4
_iRotation$ = -48					; size = 4
_iZoom$ = -44						; size = 4
_CameraSetting$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetCameraSetting@@YAPAU_object@@PAU1@0@Z PROC	; appSetCameraSetting, COMDAT

; 918  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]

; 919  : 	int ix;
; 920  : 	if (!PyTuple_GetInteger(poArgs, 0, &ix))

  00014	8d 45 c4	 lea	 eax, DWORD PTR _ix$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	84 c0		 test	 al, al
  00025	75 19		 jne	 SHORT $LN6@appSetCame
$LN11@appSetCame:

; 921  : 		return Py_BuildException();

  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0002e	83 c4 04	 add	 esp, 4
  00031	5e		 pop	 esi

; 949  : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN6@appSetCame:

; 922  : 	int iy;
; 923  : 	if (!PyTuple_GetInteger(poArgs, 1, &iy))

  00040	8d 45 c0	 lea	 eax, DWORD PTR _iy$[ebp]
  00043	50		 push	 eax
  00044	6a 01		 push	 1
  00046	56		 push	 esi
  00047	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	84 c0		 test	 al, al
  00051	74 d4		 je	 SHORT $LN11@appSetCame

; 924  : 		return Py_BuildException();
; 925  : 	int iz;
; 926  : 	if (!PyTuple_GetInteger(poArgs, 2, &iz))

  00053	8d 45 cc	 lea	 eax, DWORD PTR _iz$[ebp]
  00056	50		 push	 eax
  00057	6a 02		 push	 2
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	84 c0		 test	 al, al
  00064	74 c1		 je	 SHORT $LN11@appSetCame

; 927  : 		return Py_BuildException();
; 928  : 
; 929  : 	int iZoom;
; 930  : 	if (!PyTuple_GetInteger(poArgs, 3, &iZoom))

  00066	8d 45 d4	 lea	 eax, DWORD PTR _iZoom$[ebp]
  00069	50		 push	 eax
  0006a	6a 03		 push	 3
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	84 c0		 test	 al, al
  00077	74 ae		 je	 SHORT $LN11@appSetCame

; 931  : 		return Py_BuildException();
; 932  : 	int iRotation;
; 933  : 	if (!PyTuple_GetInteger(poArgs, 4, &iRotation))

  00079	8d 45 d0	 lea	 eax, DWORD PTR _iRotation$[ebp]
  0007c	50		 push	 eax
  0007d	6a 04		 push	 4
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	84 c0		 test	 al, al
  0008a	74 9b		 je	 SHORT $LN11@appSetCame

; 934  : 		return Py_BuildException();
; 935  : 	int iPitch;
; 936  : 	if (!PyTuple_GetInteger(poArgs, 5, &iPitch))

  0008c	8d 45 c8	 lea	 eax, DWORD PTR _iPitch$[ebp]
  0008f	50		 push	 eax
  00090	6a 05		 push	 5
  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	84 c0		 test	 al, al
  0009d	74 88		 je	 SHORT $LN11@appSetCame

; 937  : 		return Py_BuildException();
; 938  : 
; 939  : 	CPythonApplication::SCameraSetting CameraSetting;

  0009f	8d 4d d8	 lea	 ecx, DWORD PTR _CameraSetting$[ebp]
  000a2	e8 00 00 00 00	 call	 ??0SCameraSetting@IAbstractApplication@@QAE@XZ ; IAbstractApplication::SCameraSetting::SCameraSetting
  000a7	0f 57 c0	 xorps	 xmm0, xmm0

; 940  : 	ZeroMemory(&CameraSetting, sizeof(CameraSetting));
; 941  : 	CameraSetting.v3CenterPosition.x = float(ix);
; 942  : 	CameraSetting.v3CenterPosition.y = float(iy);
; 943  : 	CameraSetting.v3CenterPosition.z = float(iz);
; 944  : 	CameraSetting.fZoom = float(iZoom);
; 945  : 	CameraSetting.fRotation = float(iRotation);
; 946  : 	CameraSetting.fPitch = float(iPitch);
; 947  : 	CPythonApplication::Instance().SetEventCamera(CameraSetting);

  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  000b0	f3 0f 7f 45 d8	 movdqu	 XMMWORD PTR _CameraSetting$[ebp], xmm0
  000b5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _CameraSetting$[ebp+32], 0
  000bc	83 c1 20	 add	 ecx, 32			; 00000020H
  000bf	f3 0f 7f 45 e8	 movdqu	 XMMWORD PTR _CameraSetting$[ebp+16], xmm0
  000c4	8d 55 d8	 lea	 edx, DWORD PTR _CameraSetting$[ebp]
  000c7	66 0f 6e 45 c4	 movd	 xmm0, DWORD PTR _ix$[ebp]
  000cc	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000cf	52		 push	 edx
  000d0	f3 0f 11 45 d8	 movss	 DWORD PTR _CameraSetting$[ebp], xmm0
  000d5	66 0f 6e 45 c0	 movd	 xmm0, DWORD PTR _iy$[ebp]
  000da	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000dd	f3 0f 11 45 dc	 movss	 DWORD PTR _CameraSetting$[ebp+4], xmm0
  000e2	66 0f 6e 45 cc	 movd	 xmm0, DWORD PTR _iz$[ebp]
  000e7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ea	f3 0f 11 45 e0	 movss	 DWORD PTR _CameraSetting$[ebp+8], xmm0
  000ef	66 0f 6e 45 d4	 movd	 xmm0, DWORD PTR _iZoom$[ebp]
  000f4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f7	f3 0f 11 45 f8	 movss	 DWORD PTR _CameraSetting$[ebp+32], xmm0
  000fc	66 0f 6e 45 d0	 movd	 xmm0, DWORD PTR _iRotation$[ebp]
  00101	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00104	f3 0f 11 45 f0	 movss	 DWORD PTR _CameraSetting$[ebp+24], xmm0
  00109	66 0f 6e 45 c8	 movd	 xmm0, DWORD PTR _iPitch$[ebp]
  0010e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00111	f3 0f 11 45 f4	 movss	 DWORD PTR _CameraSetting$[ebp+28], xmm0
  00116	8b 01		 mov	 eax, DWORD PTR [ecx]
  00118	ff 50 1c	 call	 DWORD PTR [eax+28]

; 948  : 	return Py_BuildNone();

  0011b	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 949  : }

  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	33 cd		 xor	 ecx, ebp
  00125	5e		 pop	 esi
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
?appSetCameraSetting@@YAPAU_object@@PAU1@0@Z ENDP	; appSetCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsFileExist@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsFileExist@@YAPAU_object@@PAU1@0@Z PROC		; appIsFileExist, COMDAT

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 910  : 	char * szFileName;
; 911  : 	if (!PyTuple_GetString(poArgs, 0, &szFileName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 912  : 		return Py_BuildException();

  00015	6a 00		 push	 0
  00017	84 c0		 test	 al, al
  00019	75 0c		 jne	 SHORT $LN1@appIsFileE
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 915  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appIsFileE:

; 913  : 
; 914  : 	return Py_BuildValue("i", -1 != _access(szFileName, 0));

  00027	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  0002a	e8 00 00 00 00	 call	 __access
  0002f	33 c9		 xor	 ecx, ecx
  00031	83 f8 ff	 cmp	 eax, -1
  00034	0f 95 c1	 setne	 cl
  00037	51		 push	 ecx
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 915  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?appIsFileExist@@YAPAU_object@@PAU1@0@Z ENDP		; appIsFileExist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetCameraSpeed@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iPercentage$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetCameraSpeed@@YAPAU_object@@PAU1@0@Z PROC		; appSetCameraSpeed, COMDAT

; 895  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 896  : 	int iPercentage;
; 897  : 	if (!PyTuple_GetInteger(poArgs, 0, &iPercentage))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iPercentage$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@appSetCame

; 898  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 906  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@appSetCame:

; 899  : 
; 900  : 	CPythonApplication::Instance().SetCameraSpeed(iPercentage);

  00027	ff 75 fc	 push	 DWORD PTR _iPercentage$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?SetCameraSpeed@CPythonApplication@@QAEXH@Z ; CPythonApplication::SetCameraSpeed

; 901  : 
; 902  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0003b	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 903  : 	if (pCamera)

  00040	85 c0		 test	 eax, eax
  00042	74 1d		 je	 SHORT $LN1@appSetCame

; 904  : 		pCamera->SetResistance(float(iPercentage) / 100.0f);

  00044	66 0f 6e 45 fc	 movd	 xmm0, DWORD PTR _iPercentage$[ebp]
  00049	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0004c	51		 push	 ecx
  0004d	8b c8		 mov	 ecx, eax
  0004f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00057	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005c	e8 00 00 00 00	 call	 ?SetResistance@CCamera@@QAEXM@Z ; CCamera::SetResistance
$LN1@appSetCame:

; 905  : 	return Py_BuildNone();

  00061	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 906  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?appSetCameraSpeed@@YAPAU_object@@PAU1@0@Z ENDP		; appSetCameraSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appEnableSpecialCameraMode@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appEnableSpecialCameraMode@@YAPAU_object@@PAU1@0@Z PROC ; appEnableSpecialCameraMode, COMDAT

; 890  : 	CPythonApplication::Instance().EnableSpecialCameraMode();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?EnableSpecialCameraMode@CPythonApplication@@QAEXXZ ; CPythonApplication::EnableSpecialCameraMode

; 891  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appEnableSpecialCameraMode@@YAPAU_object@@PAU1@0@Z ENDP ; appEnableSpecialCameraMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetGuildSymbolPath@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szPathName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetGuildSymbolPath@@YAPAU_object@@PAU1@0@Z PROC	; appSetGuildSymbolPath, COMDAT

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 879  : 	char * szPathName;
; 880  : 	if (!PyTuple_GetString(poArgs, 0, &szPathName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szPathName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetGuil

; 881  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 886  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetGuil:

; 882  : 
; 883  : 	SetGuildSymbolPath(szPathName);

  00027	ff 75 fc	 push	 DWORD PTR _szPathName$[ebp]
  0002a	e8 00 00 00 00	 call	 ?SetGuildSymbolPath@@YAXPBD@Z ; SetGuildSymbolPath
  0002f	83 c4 04	 add	 esp, 4

; 884  : 
; 885  : 	return Py_BuildNone();

  00032	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 886  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?appSetGuildSymbolPath@@YAPAU_object@@PAU1@0@Z ENDP	; appSetGuildSymbolPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetDefaultFontName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFontName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetDefaultFontName@@YAPAU_object@@PAU1@0@Z PROC	; appSetDefaultFontName, COMDAT

; 865  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 866  : 	char * szFontName;
; 867  : 	if (!PyTuple_GetString(poArgs, 0, &szFontName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szFontName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetDefa

; 868  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 875  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetDefa:

; 869  : 
; 870  : 	// DEFAULT_FONT
; 871  : 	DefaultFont_SetName(szFontName);

  00027	ff 75 fc	 push	 DWORD PTR _szFontName$[ebp]
  0002a	e8 00 00 00 00	 call	 ?DefaultFont_SetName@@YAXPBD@Z ; DefaultFont_SetName
  0002f	83 c4 04	 add	 esp, 4

; 872  : 	// END_OF_DEFAULT_FONT
; 873  : 
; 874  : 	return Py_BuildNone();

  00032	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 875  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?appSetDefaultFontName@@YAPAU_object@@PAU1@0@Z ENDP	; appSetDefaultFontName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSleep@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iTime$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSleep@@YAPAU_object@@PAU1@0@Z PROC			; appSleep, COMDAT

; 854  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 855  : 	int	iTime;
; 856  : 	if (!PyTuple_GetInteger(poArgs, 0, &iTime))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iTime$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSleep

; 857  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 862  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSleep:

; 858  : 
; 859  : 	Sleep(iTime);

  00027	ff 75 fc	 push	 DWORD PTR _iTime$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 860  : 
; 861  : 	return Py_BuildNone();

  00030	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 862  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?appSleep@@YAPAU_object@@PAU1@0@Z ENDP			; appSleep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetDegreeDifference@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fSource$ = -8						; size = 4
_fTarget$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetDegreeDifference@@YAPAU_object@@PAU1@0@Z PROC	; appGetDegreeDifference, COMDAT

; 842  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 843  : 	float fSource;
; 844  : 	if (!PyTuple_GetFloat(poArgs, 0, &fSource))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fSource$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@appGetDegr
$LN5@appGetDegr:

; 845  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 851  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@appGetDegr:

; 846  : 	float fTarget;
; 847  : 	if (!PyTuple_GetFloat(poArgs, 1, &fTarget))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fTarget$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN5@appGetDegr

; 848  : 		return Py_BuildException();
; 849  : 
; 850  : 	return Py_BuildValue("f", GetDegreeDifference(fSource, fTarget));

  0003e	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTarget$[ebp]
  00043	83 ec 08	 sub	 esp, 8
  00046	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0004c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fSource$[ebp]
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	e8 00 00 00 00	 call	 ?GetDegreeDifference@@YAMMM@Z ; GetDegreeDifference
  0005b	dd 1c 24	 fstp	 QWORD PTR [esp]
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 851  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?appGetDegreeDifference@@YAPAU_object@@PAU1@0@Z ENDP	; appGetDegreeDifference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetRotatingDirection@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fSource$ = -8						; size = 4
_fTarget$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetRotatingDirection@@YAPAU_object@@PAU1@0@Z PROC	; appGetRotatingDirection, COMDAT

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 831  : 	float fSource;
; 832  : 	if (!PyTuple_GetFloat(poArgs, 0, &fSource))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _fSource$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@appGetRota
$LN5@appGetRota:

; 833  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 839  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@appGetRota:

; 834  : 	float fTarget;
; 835  : 	if (!PyTuple_GetFloat(poArgs, 1, &fTarget))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _fTarget$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN5@appGetRota

; 836  : 		return Py_BuildException();
; 837  : 
; 838  : 	return Py_BuildValue("i", GetRotatingDirection(fSource, fTarget));

  0003e	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTarget$[ebp]
  00043	83 ec 08	 sub	 esp, 8
  00046	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0004c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fSource$[ebp]
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	e8 00 00 00 00	 call	 ?GetRotatingDirection@@YAHMM@Z ; GetRotatingDirection
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00067	83 c4 10	 add	 esp, 16			; 00000010H

; 839  : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?appGetRotatingDirection@@YAPAU_object@@PAU1@0@Z ENDP	; appGetRotatingDirection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetRandom@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_to$ = -8						; size = 4
_from$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetRandom@@YAPAU_object@@PAU1@0@Z PROC		; appGetRandom, COMDAT

; 810  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 811  : 	int from;
; 812  : 	if (!PyTuple_GetInteger(poArgs, 0, &from))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _from$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN3@appGetRand
$LN6@appGetRand:

; 813  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 827  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN3@appGetRand:

; 814  : 
; 815  : 	int	to;
; 816  : 	if (!PyTuple_GetInteger(poArgs, 1, &to))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _to$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN6@appGetRand

; 817  : 		return Py_BuildException();
; 818  : 
; 819  : 	if (from > to)

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _from$[ebp]
  00041	8b 55 f8	 mov	 edx, DWORD PTR _to$[ebp]
  00044	3b ca		 cmp	 ecx, edx
  00046	7e 0c		 jle	 SHORT $LN1@appGetRand

; 820  : 	{
; 821  : 		int tmp = from;

  00048	8b c1		 mov	 eax, ecx

; 822  : 		from = to;

  0004a	8b ca		 mov	 ecx, edx

; 823  : 		to = tmp;

  0004c	8b d0		 mov	 edx, eax
  0004e	89 4d fc	 mov	 DWORD PTR _from$[ebp], ecx
  00051	89 55 f8	 mov	 DWORD PTR _to$[ebp], edx
$LN1@appGetRand:

; 824  : 	}
; 825  : 
; 826  : 	return Py_BuildValue("i", random_range(from, to));

  00054	52		 push	 edx
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ?random_range@@YAJJJ@Z	; random_range
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00067	83 c4 10	 add	 esp, 16			; 00000010H

; 827  : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?appGetRandom@@YAPAU_object@@PAU1@0@Z ENDP		; appGetRandom
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\iosfwd
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetConnectData@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iPort$ = -44						; size = 4
_strIP$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetConnectData@@YAPAU_object@@PAU1@0@Z PROC		; appGetConnectData, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?appGetConnectData@@YAPAU_object@@PAU1@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File a:\vs\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00029	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strIP$[ebp+20], 15 ; 0000000fH

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00030	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strIP$[ebp+16], 0
; File a:\vs\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00037	c6 45 d8 00	 mov	 BYTE PTR _strIP$[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 804  : 	CPythonApplication::Instance().GetConnectData(strIP, iPort);

  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00041	8d 45 d4	 lea	 eax, DWORD PTR _iPort$[ebp]
  00044	50		 push	 eax
  00045	8d 45 d8	 lea	 eax, DWORD PTR _strIP$[ebp]
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?GetConnectData@CPythonApplication@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH@Z ; CPythonApplication::GetConnectData
; File a:\vs\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00055	83 7d ec 10	 cmp	 DWORD PTR _strIP$[ebp+20], 16 ; 00000010H
  00059	8d 45 d8	 lea	 eax, DWORD PTR _strIP$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 806  : 	return Py_BuildValue("si", strIP.c_str(), iPort);

  0005c	ff 75 d4	 push	 DWORD PTR _iPort$[ebp]
; File a:\vs\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0005f	0f 43 45 d8	 cmovae	 eax, DWORD PTR _strIP$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 806  : 	return Py_BuildValue("si", strIP.c_str(), iPort);

  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_02OCDGCAAK@si?$AA@
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	8b f0		 mov	 esi, eax
; File a:\vs\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00074	83 7d ec 10	 cmp	 DWORD PTR _strIP$[ebp+20], 16 ; 00000010H
  00078	72 0d		 jb	 SHORT $LN72@appGetConn
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007a	ff 75 d8	 push	 DWORD PTR _strIP$[ebp]
  0007d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00082	83 c4 04	 add	 esp, 4
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 806  : 	return Py_BuildValue("si", strIP.c_str(), iPort);

  00085	8b c6		 mov	 eax, esi
$LN72@appGetConn:

; 807  : }

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5e		 pop	 esi
  00093	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?appGetConnectData@@YAPAU_object@@PAU1@0@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _strIP$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?appGetConnectData@@YAPAU_object@@PAU1@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?appGetConnectData@@YAPAU_object@@PAU1@0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?appGetConnectData@@YAPAU_object@@PAU1@0@Z ENDP		; appGetConnectData
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetConnectData@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szIP$ = -8						; size = 4
_iPort$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetConnectData@@YAPAU_object@@PAU1@0@Z PROC		; appSetConnectData, COMDAT

; 785  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 786  : 	char * szIP;
; 787  : 	if (!PyTuple_GetString(poArgs, 0, &szIP))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _szIP$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@appSetConn
$LN7@appSetConn:

; 788  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 797  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@appSetConn:

; 789  : 
; 790  : 	int	iPort;
; 791  : 	if (!PyTuple_GetInteger(poArgs, 1, &iPort))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _iPort$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@appSetConn

; 792  : 		return Py_BuildException();
; 793  : 
; 794  : 	CPythonApplication::Instance().SetConnectData(szIP, iPort);

  0003e	ff 75 fc	 push	 DWORD PTR _iPort$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00047	ff 75 f8	 push	 DWORD PTR _szIP$[ebp]
  0004a	e8 00 00 00 00	 call	 ?SetConnectData@CPythonApplication@@QAEXPBDH@Z ; CPythonApplication::SetConnectData

; 795  : 
; 796  : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 797  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?appSetConnectData@@YAPAU_object@@PAU1@0@Z ENDP		; appSetConnectData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetHardwareCursor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetHardwareCursor@@YAPAU_object@@PAU1@0@Z PROC	; appSetHardwareCursor, COMDAT

; 780  : 	CPythonApplication::Instance().SetCursorMode(CPythonApplication::CURSOR_MODE_HARDWARE);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	6a 00		 push	 0
  00008	e8 00 00 00 00	 call	 ?SetCursorMode@CPythonApplication@@QAEXH@Z ; CPythonApplication::SetCursorMode

; 781  : 	return Py_BuildNone();

  0000d	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appSetHardwareCursor@@YAPAU_object@@PAU1@0@Z ENDP	; appSetHardwareCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetSoftwareCursor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetSoftwareCursor@@YAPAU_object@@PAU1@0@Z PROC	; appSetSoftwareCursor, COMDAT

; 774  : 	CPythonApplication::Instance().SetCursorMode(CPythonApplication::CURSOR_MODE_SOFTWARE);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 ?SetCursorMode@CPythonApplication@@QAEXH@Z ; CPythonApplication::SetCursorMode

; 775  : 	return Py_BuildNone();

  0000d	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appSetSoftwareCursor@@YAPAU_object@@PAU1@0@Z ENDP	; appSetSoftwareCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsLiarCursorOn@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsLiarCursorOn@@YAPAU_object@@PAU1@0@Z PROC		; appIsLiarCursorOn, COMDAT

; 769  : 	return Py_BuildValue("i", TRUE == CPythonApplication::Instance().GetLiarCursorOn());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?GetLiarCursorOn@CPythonApplication@@QAE_NXZ ; CPythonApplication::GetLiarCursorOn
  0000b	33 c9		 xor	 ecx, ecx
  0000d	3c 01		 cmp	 al, 1
  0000f	0f 94 c1	 sete	 cl
  00012	51		 push	 ecx
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001e	83 c4 08	 add	 esp, 8

; 770  : }

  00021	c3		 ret	 0
?appIsLiarCursorOn@@YAPAU_object@@PAU1@0@Z ENDP		; appIsLiarCursorOn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsShowCursor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsShowCursor@@YAPAU_object@@PAU1@0@Z PROC		; appIsShowCursor, COMDAT

; 764  : 	return Py_BuildValue("i", TRUE == CPythonApplication::Instance().GetCursorVisible());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?GetCursorVisible@CPythonApplication@@QAEHXZ ; CPythonApplication::GetCursorVisible
  0000b	48		 dec	 eax
  0000c	f7 d8		 neg	 eax
  0000e	1b c0		 sbb	 eax, eax
  00010	40		 inc	 eax
  00011	50		 push	 eax
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001d	83 c4 08	 add	 esp, 8

; 765  : }

  00020	c3		 ret	 0
?appIsShowCursor@@YAPAU_object@@PAU1@0@Z ENDP		; appIsShowCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appHideCursor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appHideCursor@@YAPAU_object@@PAU1@0@Z PROC		; appHideCursor, COMDAT

; 757  : 	CPythonApplication::Instance().SetCursorVisible(FALSE);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	e8 00 00 00 00	 call	 ?SetCursorVisible@CPythonApplication@@QAEXH_N@Z ; CPythonApplication::SetCursorVisible

; 758  : 
; 759  : 	return Py_BuildNone();

  0000f	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appHideCursor@@YAPAU_object@@PAU1@0@Z ENDP		; appHideCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appShowCursor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appShowCursor@@YAPAU_object@@PAU1@0@Z PROC		; appShowCursor, COMDAT

; 750  : 	CPythonApplication::Instance().SetCursorVisible(TRUE);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	6a 00		 push	 0
  00008	6a 01		 push	 1
  0000a	e8 00 00 00 00	 call	 ?SetCursorVisible@CPythonApplication@@QAEXH_N@Z ; CPythonApplication::SetCursorVisible

; 751  : 
; 752  : 	return Py_BuildNone();

  0000f	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appShowCursor@@YAPAU_object@@PAU1@0@Z ENDP		; appShowCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetCursor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetCursor@@YAPAU_object@@PAU1@0@Z PROC		; appGetCursor, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 178  : 		int GetCursorNum() { return m_iCursorNum; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 745  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetCursorNum());

  00005	ff b0 cc fd 01
	00		 push	 DWORD PTR [eax+130508]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00016	83 c4 08	 add	 esp, 8

; 746  : }

  00019	c3		 ret	 0
?appGetCursor@@YAPAU_object@@PAU1@0@Z ENDP		; appGetCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetCursor@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iCursorNum$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetCursor@@YAPAU_object@@PAU1@0@Z PROC		; appSetCursor, COMDAT

; 724  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 725  : /*
; 726  : 	char * szName;
; 727  : 	if (!PyTuple_GetString(poArgs, 0, &szName))
; 728  : 		return Py_BuildException();
; 729  : 
; 730  : 	if (!CPythonApplication::Instance().SetHardwareCursor(szName))
; 731  : 		return Py_BuildException("Wrong Cursor Name [%s]", szName);
; 732  : */
; 733  : 	int iCursorNum;
; 734  : 	if (!PyTuple_GetInteger(poArgs, 0, &iCursorNum))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iCursorNum$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@appSetCurs

; 735  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 741  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@appSetCurs:

; 736  : 	
; 737  : 	if (!CPythonApplication::Instance().SetCursorNum(iCursorNum))

  00027	ff 75 fc	 push	 DWORD PTR _iCursorNum$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?SetCursorNum@CPythonApplication@@QAEHH@Z ; CPythonApplication::SetCursorNum
  00035	85 c0		 test	 eax, eax
  00037	75 14		 jne	 SHORT $LN1@appSetCurs

; 738  : 		return Py_BuildException("Wrong Cursor Name [%d]", iCursorNum);

  00039	ff 75 fc	 push	 DWORD PTR _iCursorNum$[ebp]
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GNAGLJEE@Wrong?5Cursor?5Name?5?$FL?$CFd?$FN?$AA@
  00041	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00046	83 c4 08	 add	 esp, 8

; 741  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN1@appSetCurs:

; 739  : 
; 740  : 	return Py_BuildNone();

  0004d	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 741  : }

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?appSetCursor@@YAPAU_object@@PAU1@0@Z ENDP		; appSetCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsPressed@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iKey$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsPressed@@YAPAU_object@@PAU1@0@Z PROC		; appIsPressed, COMDAT

; 715  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 716  : 	int iKey;
; 717  : 	if (!PyTuple_GetInteger(poArgs, 0, &iKey))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iKey$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appIsPress

; 718  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 721  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appIsPress:

; 719  : 
; 720  : 	return Py_BuildValue("i", CPythonApplication::Instance().IsPressed(iKey));

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  0002d	ff 75 fc	 push	 DWORD PTR _iKey$[ebp]
  00030	8d 49 1c	 lea	 ecx, DWORD PTR [ecx+28]
  00033	e8 00 00 00 00	 call	 ?IsPressed@CInputKeyboard@@QAE_NH@Z ; CInputKeyboard::IsPressed
  00038	0f b6 c0	 movzx	 eax, al
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00047	83 c4 08	 add	 esp, 8

; 721  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?appIsPressed@@YAPAU_object@@PAU1@0@Z ENDP		; appIsPressed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appRunPythonFile@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appRunPythonFile@@YAPAU_object@@PAU1@0@Z PROC		; appRunPythonFile, COMDAT

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 706  : 	char *szFileName;
; 707  : 	if (!PyTuple_GetString(poArgs, 0, &szFileName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appRunPyth

; 708  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 712  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appRunPyth:

; 709  : 
; 710  : 	bool ret = CPythonLauncher::Instance().RunFile(szFileName);

  00027	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A ; CSingleton<CPythonLauncher>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?RunFile@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::RunFile

; 711  : 	return Py_BuildValue("i", ret);

  00035	0f b6 c0	 movzx	 eax, al
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00044	83 c4 08	 add	 esp, 8

; 712  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?appRunPythonFile@@YAPAU_object@@PAU1@0@Z ENDP		; appRunPythonFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetCursorPosition@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_lx$ = -8						; size = 4
_ly$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetCursorPosition@@YAPAU_object@@PAU1@0@Z PROC	; appGetCursorPosition, COMDAT

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 697  : 	long lx, ly;
; 698  : 	UI::CWindowManager& rkWndMgr=UI::CWindowManager::Instance();
; 699  : 	rkWndMgr.GetMousePosition(lx, ly);

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0000c	8d 45 fc	 lea	 eax, DWORD PTR _ly$[ebp]
  0000f	50		 push	 eax
  00010	8d 45 f8	 lea	 eax, DWORD PTR _lx$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?GetMousePosition@CWindowManager@UI@@QAEXAAJ0@Z ; UI::CWindowManager::GetMousePosition

; 700  : 
; 701  : 	return Py_BuildValue("ii", lx, ly);

  00019	ff 75 fc	 push	 DWORD PTR _ly$[ebp]
  0001c	ff 75 f8	 push	 DWORD PTR _lx$[ebp]
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii?$AA@
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?appGetCursorPosition@@YAPAU_object@@PAU1@0@Z ENDP	; appGetCursorPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetCenterPosition@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fx$ = -12						; size = 4
_fy$ = -8						; size = 4
_fz$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetCenterPosition@@YAPAU_object@@PAU1@0@Z PROC	; appSetCenterPosition, COMDAT

; 678  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 679  : 	float fx;
; 680  : 	if (!PyTuple_GetFloat(poArgs, 0, &fx))

  00006	8d 45 f4	 lea	 eax, DWORD PTR _fx$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN3@appSetCent
$LN8@appSetCent:

; 681  : 		return Py_BuildException();

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4
  00027	5e		 pop	 esi

; 693  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN3@appSetCent:

; 682  : 
; 683  : 	float fy;
; 684  : 	if (!PyTuple_GetFloat(poArgs, 1, &fy))

  0002c	8d 45 f8	 lea	 eax, DWORD PTR _fy$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN8@appSetCent

; 685  : 		return Py_BuildException();
; 686  : 
; 687  : 	float fz;
; 688  : 	if (!PyTuple_GetFloat(poArgs, 2, &fz))

  0003f	8d 45 fc	 lea	 eax, DWORD PTR _fz$[ebp]
  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 cb		 je	 SHORT $LN8@appSetCent

; 689  : 		return Py_BuildException();
; 690  : 
; 691  : 	CPythonApplication::Instance().SetCenterPosition(fx, -fy, fz);

  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00058	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0005b	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00060	83 c1 20	 add	 ecx, 32			; 00000020H
  00063	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00069	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0006e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00075	8b 01		 mov	 eax, DWORD PTR [ecx]
  00077	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0007d	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00082	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00087	ff 50 18	 call	 DWORD PTR [eax+24]

; 692  : 	return Py_BuildNone();

  0008a	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  0008f	5e		 pop	 esi

; 693  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?appSetCenterPosition@@YAPAU_object@@PAU1@0@Z ENDP	; appSetCenterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetGlobalCenterPosition@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_x$ = -8						; size = 4
_y$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetGlobalCenterPosition@@YAPAU_object@@PAU1@0@Z PROC ; appSetGlobalCenterPosition, COMDAT

; 663  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 664  : 	int x;
; 665  : 	if (!PyTuple_GetInteger(poArgs, 0, &x))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _x$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@appSetGlob
$LN7@appSetGlob:

; 666  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 674  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@appSetGlob:

; 667  : 
; 668  : 	int y;
; 669  : 	if (!PyTuple_GetInteger(poArgs, 1, &y))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _y$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@appSetGlob

; 670  : 		return Py_BuildException();
; 671  : 
; 672  : 	CPythonApplication::Instance().SetGlobalCenterPosition(x, y);

  0003e	ff 75 fc	 push	 DWORD PTR _y$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00047	ff 75 f8	 push	 DWORD PTR _x$[ebp]
  0004a	e8 00 00 00 00	 call	 ?SetGlobalCenterPosition@CPythonApplication@@QAEXJJ@Z ; CPythonApplication::SetGlobalCenterPosition

; 673  : 	return Py_BuildNone();

  0004f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 674  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?appSetGlobalCenterPosition@@YAPAU_object@@PAU1@0@Z ENDP ; appSetGlobalCenterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetFPS@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iFPS$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetFPS@@YAPAU_object@@PAU1@0@Z PROC			; appSetFPS, COMDAT

; 652  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 653  : 	int	iFPS;
; 654  : 	if (!PyTuple_GetInteger(poArgs, 0, &iFPS))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iFPS$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetFPS

; 655  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 660  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetFPS:

; 656  : 
; 657  : 	CPythonApplication::Instance().SetFPS(iFPS);

  00027	ff 75 fc	 push	 DWORD PTR _iFPS$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?SetFPS@CPythonApplication@@QAEXH@Z ; CPythonApplication::SetFPS

; 658  : 
; 659  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 660  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appSetFPS@@YAPAU_object@@PAU1@0@Z ENDP			; appSetFPS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetAvaiableTextureMememory@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetAvaiableTextureMememory@@YAPAU_object@@PAU1@0@Z PROC ; appGetAvaiableTextureMememory, COMDAT

; 648  : 	return Py_BuildValue("i", CGraphicBase::GetAvailableTextureMemory());

  00000	e8 00 00 00 00	 call	 ?GetAvailableTextureMemory@CGraphicBase@@SAKXZ ; CGraphicBase::GetAvailableTextureMemory
  00005	50		 push	 eax
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 649  : }

  00014	c3		 ret	 0
?appGetAvaiableTextureMememory@@YAPAU_object@@PAU1@0@Z ENDP ; appGetAvaiableTextureMememory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetFaceCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetFaceCount@@YAPAU_object@@PAU1@0@Z PROC		; appGetFaceCount, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 217  : 		DWORD GetFaceCount()	{ return m_dwFaceCount; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 643  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetFaceCount());

  00005	ff b0 74 fd 01
	00		 push	 DWORD PTR [eax+130420]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00016	83 c4 08	 add	 esp, 8

; 644  : }

  00019	c3		 ret	 0
?appGetFaceCount@@YAPAU_object@@PAU1@0@Z ENDP		; appGetFaceCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetLoad@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetLoad@@YAPAU_object@@PAU1@0@Z PROC		; appGetLoad, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 216  : 		DWORD GetLoad()			{ return m_dwLoad; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 639  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetLoad());

  00005	ff b0 88 fc 01
	00		 push	 DWORD PTR [eax+130184]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00016	83 c4 08	 add	 esp, 8

; 640  : }

  00019	c3		 ret	 0
?appGetLoad@@YAPAU_object@@PAU1@0@Z ENDP		; appGetLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetUpdateTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetUpdateTime@@YAPAU_object@@PAU1@0@Z PROC		; appGetUpdateTime, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 213  : 		DWORD GetCurUpdateTime()	{ return m_dwCurUpdateTime; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 634  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetCurUpdateTime());

  00005	ff b0 84 fc 01
	00		 push	 DWORD PTR [eax+130180]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00016	83 c4 08	 add	 esp, 8

; 635  : }

  00019	c3		 ret	 0
?appGetUpdateTime@@YAPAU_object@@PAU1@0@Z ENDP		; appGetUpdateTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetRenderTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetRenderTime@@YAPAU_object@@PAU1@0@Z PROC		; appGetRenderTime, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 212  : 		DWORD GetCurRenderTime()	{ return m_dwCurRenderTime; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00005	f3 0f 10 80 7c
	fc 01 00	 movss	 xmm0, DWORD PTR [eax+130172]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 629  : 		CPythonApplication::Instance().GetCurRenderTime());

  0000d	ff b0 80 fc 01
	00		 push	 DWORD PTR [eax+130176]
  00013	0f 5a c0	 cvtps2pd xmm0, xmm0
  00016	83 ec 08	 sub	 esp, 8
  00019	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_02PINLEBJB@fi?$AA@
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00029	83 c4 10	 add	 esp, 16			; 00000010H

; 630  : }

  0002c	c3		 ret	 0
?appGetRenderTime@@YAPAU_object@@PAU1@0@Z ENDP		; appGetRenderTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetFaceSpeed@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetFaceSpeed@@YAPAU_object@@PAU1@0@Z PROC		; appGetFaceSpeed, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 210  : 		float GetFaceSpeed()		{ return m_fFaceSpd; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 622  : 	return Py_BuildValue("f", CPythonApplication::Instance().GetFaceSpeed());

  00005	83 ec 08	 sub	 esp, 8
  00008	f3 0f 10 80 58
	fd 01 00	 movss	 xmm0, DWORD PTR [eax+130392]
  00010	0f 5a c0	 cvtps2pd xmm0, xmm0
  00013	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 623  : }

  00026	c3		 ret	 0
?appGetFaceSpeed@@YAPAU_object@@PAU1@0@Z ENDP		; appGetFaceSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appMovieResetCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appMovieResetCamera@@YAPAU_object@@PAU1@0@Z PROC	; appMovieResetCamera, COMDAT

; 616  : 	CPythonApplication::Instance().MovieResetCamera();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?MovieResetCamera@CPythonApplication@@QAEXXZ ; CPythonApplication::MovieResetCamera

; 617  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appMovieResetCamera@@YAPAU_object@@PAU1@0@Z ENDP	; appMovieResetCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appMovieZoomCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iDirection$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appMovieZoomCamera@@YAPAU_object@@PAU1@0@Z PROC	; appMovieZoomCamera, COMDAT

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 607  : 	int iDirection;
; 608  : 	if (!PyTuple_GetInteger(poArgs, 0, &iDirection))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iDirection$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appMovieZo

; 609  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 612  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appMovieZo:

; 610  : 	CPythonApplication::Instance().MovieZoomCamera(iDirection);

  00027	ff 75 fc	 push	 DWORD PTR _iDirection$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?MovieZoomCamera@CPythonApplication@@QAEXH@Z ; CPythonApplication::MovieZoomCamera

; 611  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 612  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appMovieZoomCamera@@YAPAU_object@@PAU1@0@Z ENDP	; appMovieZoomCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appMoviePitchCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iDirection$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appMoviePitchCamera@@YAPAU_object@@PAU1@0@Z PROC	; appMoviePitchCamera, COMDAT

; 597  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 598  : 	int iDirection;
; 599  : 	if (!PyTuple_GetInteger(poArgs, 0, &iDirection))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iDirection$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appMoviePi

; 600  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 603  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appMoviePi:

; 601  : 	CPythonApplication::Instance().MoviePitchCamera(iDirection);

  00027	ff 75 fc	 push	 DWORD PTR _iDirection$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?MoviePitchCamera@CPythonApplication@@QAEXH@Z ; CPythonApplication::MoviePitchCamera

; 602  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 603  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appMoviePitchCamera@@YAPAU_object@@PAU1@0@Z ENDP	; appMoviePitchCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appMovieRotateCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iDirection$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appMovieRotateCamera@@YAPAU_object@@PAU1@0@Z PROC	; appMovieRotateCamera, COMDAT

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 589  : 	int iDirection;
; 590  : 	if (!PyTuple_GetInteger(poArgs, 0, &iDirection))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iDirection$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appMovieRo

; 591  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 594  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appMovieRo:

; 592  : 	CPythonApplication::Instance().MovieRotateCamera(iDirection);

  00027	ff 75 fc	 push	 DWORD PTR _iDirection$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?MovieRotateCamera@CPythonApplication@@QAEXH@Z ; CPythonApplication::MovieRotateCamera

; 593  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 594  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appMovieRotateCamera@@YAPAU_object@@PAU1@0@Z ENDP	; appMovieRotateCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appZoomCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iDirection$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appZoomCamera@@YAPAU_object@@PAU1@0@Z PROC		; appZoomCamera, COMDAT

; 579  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 580  : 	int iDirection;
; 581  : 	if (!PyTuple_GetInteger(poArgs, 0, &iDirection))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iDirection$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appZoomCam

; 582  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 585  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appZoomCam:

; 583  : 	CPythonApplication::Instance().ZoomCamera(iDirection);

  00027	ff 75 fc	 push	 DWORD PTR _iDirection$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?ZoomCamera@CPythonApplication@@QAEXH@Z ; CPythonApplication::ZoomCamera

; 584  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 585  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appZoomCamera@@YAPAU_object@@PAU1@0@Z ENDP		; appZoomCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appPitchCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iDirection$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appPitchCamera@@YAPAU_object@@PAU1@0@Z PROC		; appPitchCamera, COMDAT

; 570  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 571  : 	int iDirection;
; 572  : 	if (!PyTuple_GetInteger(poArgs, 0, &iDirection))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iDirection$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appPitchCa

; 573  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 576  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appPitchCa:

; 574  : 	CPythonApplication::Instance().PitchCamera(iDirection);

  00027	ff 75 fc	 push	 DWORD PTR _iDirection$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?PitchCamera@CPythonApplication@@QAEXH@Z ; CPythonApplication::PitchCamera

; 575  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 576  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appPitchCamera@@YAPAU_object@@PAU1@0@Z ENDP		; appPitchCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appRotateCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iDirection$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appRotateCamera@@YAPAU_object@@PAU1@0@Z PROC		; appRotateCamera, COMDAT

; 561  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 562  : 	int iDirection;
; 563  : 	if (!PyTuple_GetInteger(poArgs, 0, &iDirection))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iDirection$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appRotateC

; 564  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 567  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appRotateC:

; 565  : 	CPythonApplication::Instance().RotateCamera(iDirection);

  00027	ff 75 fc	 push	 DWORD PTR _iDirection$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?RotateCamera@CPythonApplication@@QAEXH@Z ; CPythonApplication::RotateCamera

; 566  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 567  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appRotateCamera@@YAPAU_object@@PAU1@0@Z ENDP		; appRotateCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetRenderFPS@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetRenderFPS@@YAPAU_object@@PAU1@0@Z PROC		; appGetRenderFPS, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 215  : 		DWORD GetRenderFPS()		{ return m_dwRenderFPS; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 557  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetRenderFPS());

  00005	ff b0 70 fd 01
	00		 push	 DWORD PTR [eax+130416]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00016	83 c4 08	 add	 esp, 8

; 558  : }

  00019	c3		 ret	 0
?appGetRenderFPS@@YAPAU_object@@PAU1@0@Z ENDP		; appGetRenderFPS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetUpdateFPS@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetUpdateFPS@@YAPAU_object@@PAU1@0@Z PROC		; appGetUpdateFPS, COMDAT
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h

; 214  : 		DWORD GetUpdateFPS()		{ return m_dwUpdateFPS; }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 552  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetUpdateFPS());

  00005	ff b0 6c fd 01
	00		 push	 DWORD PTR [eax+130412]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00016	83 c4 08	 add	 esp, 8

; 553  : }

  00019	c3		 ret	 0
?appGetUpdateFPS@@YAPAU_object@@PAU1@0@Z ENDP		; appGetUpdateFPS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetGlobalTimeStamp@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetGlobalTimeStamp@@YAPAU_object@@PAU1@0@Z PROC	; appGetGlobalTimeStamp, COMDAT

; 547  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetServerTimeStamp());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?GetServerTimeStamp@CPythonApplication@@QAEJXZ ; CPythonApplication::GetServerTimeStamp
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 548  : }

  0001a	c3		 ret	 0
?appGetGlobalTimeStamp@@YAPAU_object@@PAU1@0@Z ENDP	; appGetGlobalTimeStamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetGlobalTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetGlobalTime@@YAPAU_object@@PAU1@0@Z PROC		; appGetGlobalTime, COMDAT

; 542  : 	return Py_BuildValue("i", CPythonApplication::Instance().GetServerTime());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?GetServerTime@CPythonApplication@@QAEJXZ ; CPythonApplication::GetServerTime
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 543  : }

  0001a	c3		 ret	 0
?appGetGlobalTime@@YAPAU_object@@PAU1@0@Z ENDP		; appGetGlobalTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetTime@@YAPAU_object@@PAU1@0@Z PROC		; appGetTime, COMDAT

; 537  : 	return Py_BuildValue("f", CPythonApplication::Instance().GetGlobalTime());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	83 c1 20	 add	 ecx, 32			; 00000020H
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	ff d0		 call	 eax
  00010	83 ec 08	 sub	 esp, 8
  00013	dd 1c 24	 fstp	 QWORD PTR [esp]
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 538  : }

  00024	c3		 ret	 0
?appGetTime@@YAPAU_object@@PAU1@0@Z ENDP		; appGetTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetCameraRotation@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetCameraRotation@@YAPAU_object@@PAU1@0@Z PROC	; appGetCameraRotation, COMDAT

; 532  : 	return Py_BuildValue("f", CPythonApplication::Instance().GetRotation());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?GetRotation@CPythonApplication@@QAEMXZ ; CPythonApplication::GetRotation
  0000b	83 ec 08	 sub	 esp, 8
  0000e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 533  : }

  0001f	c3		 ret	 0
?appGetCameraRotation@@YAPAU_object@@PAU1@0@Z ENDP	; appGetCameraRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetCameraPitch@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetCameraPitch@@YAPAU_object@@PAU1@0@Z PROC		; appGetCameraPitch, COMDAT

; 527  : 	return Py_BuildValue("f", CPythonApplication::Instance().GetPitch());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?GetPitch@CPythonApplication@@QAEMXZ ; CPythonApplication::GetPitch
  0000b	83 ec 08	 sub	 esp, 8
  0000e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 528  : }

  0001f	c3		 ret	 0
?appGetCameraPitch@@YAPAU_object@@PAU1@0@Z ENDP		; appGetCameraPitch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_Distance$ = -16					; size = 4
_Pitch$ = -12						; size = 4
_Rotation$ = -8						; size = 4
_DestinationHeight$ = -4				; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetCamera@@YAPAU_object@@PAU1@0@Z PROC		; appGetCamera, COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 519  : 	float Distance, Pitch, Rotation, DestinationHeight;
; 520  :     CPythonApplication::Instance().GetCamera(&Distance, &Pitch, &Rotation, &DestinationHeight);

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  0000c	8d 45 fc	 lea	 eax, DWORD PTR _DestinationHeight$[ebp]
  0000f	50		 push	 eax
  00010	8d 45 f8	 lea	 eax, DWORD PTR _Rotation$[ebp]
  00013	50		 push	 eax
  00014	8d 45 f4	 lea	 eax, DWORD PTR _Pitch$[ebp]
  00017	50		 push	 eax
  00018	8d 45 f0	 lea	 eax, DWORD PTR _Distance$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?GetCamera@CPythonApplication@@QAEXPAM000@Z ; CPythonApplication::GetCamera
  00021	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _DestinationHeight$[ebp]

; 521  : 
; 522  : 	return Py_BuildValue("ffff", Distance, Pitch, Rotation, DestinationHeight);

  00026	83 ec 20	 sub	 esp, 32			; 00000020H
  00029	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002c	f2 0f 11 44 24
	18		 movsd	 QWORD PTR [esp+24], xmm0
  00032	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _Rotation$[ebp]
  00037	0f 5a c0	 cvtps2pd xmm0, xmm0
  0003a	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  00040	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _Pitch$[ebp]
  00045	0f 5a c0	 cvtps2pd xmm0, xmm0
  00048	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  0004e	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _Distance$[ebp]
  00053	0f 5a c0	 cvtps2pd xmm0, xmm0
  00056	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_04EOBPFJGD@ffff?$AA@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00066	83 c4 24	 add	 esp, 36			; 00000024H

; 523  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?appGetCamera@@YAPAU_object@@PAU1@0@Z ENDP		; appGetCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetCamera@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_Distance$ = -16					; size = 4
_Pitch$ = -12						; size = 4
_Rotation$ = -8						; size = 4
_fDestinationHeight$ = -4				; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetCamera@@YAPAU_object@@PAU1@0@Z PROC		; appSetCamera, COMDAT

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 497  : 	float Distance;
; 498  : 	if (!PyTuple_GetFloat(poArgs, 0, &Distance))

  00006	8d 45 f0	 lea	 eax, DWORD PTR _Distance$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN4@appSetCame
$LN9@appSetCame:

; 499  : 		return Py_BuildException();

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4
  00027	5e		 pop	 esi

; 515  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN4@appSetCame:

; 500  : 
; 501  : 	float Pitch;
; 502  : 	if (!PyTuple_GetFloat(poArgs, 1, &Pitch))

  0002c	8d 45 f4	 lea	 eax, DWORD PTR _Pitch$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN9@appSetCame

; 503  : 		return Py_BuildException();
; 504  : 
; 505  : 	float Rotation;
; 506  : 	if (!PyTuple_GetFloat(poArgs, 2, &Rotation))

  0003f	8d 45 f8	 lea	 eax, DWORD PTR _Rotation$[ebp]
  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 cb		 je	 SHORT $LN9@appSetCame

; 507  : 		return Py_BuildException();
; 508  : 
; 509  : 	float fDestinationHeight;
; 510  : 	if (!PyTuple_GetFloat(poArgs, 3, &fDestinationHeight))

  00052	8d 45 fc	 lea	 eax, DWORD PTR _fDestinationHeight$[ebp]
  00055	50		 push	 eax
  00056	6a 03		 push	 3
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	84 c0		 test	 al, al
  00063	74 b8		 je	 SHORT $LN9@appSetCame

; 511  : 		return Py_BuildException();
; 512  : 
; 513  : 	CPythonApplication::Instance().SetCamera(Distance, Pitch, Rotation, fDestinationHeight);

  00065	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fDestinationHeight$[ebp]
  0006a	83 ec 10	 sub	 esp, 16			; 00000010H
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00073	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00079	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _Rotation$[ebp]
  0007e	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00084	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _Pitch$[ebp]
  00089	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0008f	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _Distance$[ebp]
  00094	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00099	e8 00 00 00 00	 call	 ?SetCamera@CPythonApplication@@QAEXMMMM@Z ; CPythonApplication::SetCamera

; 514  : 	return Py_BuildNone();

  0009e	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  000a3	5e		 pop	 esi

; 515  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?appSetCamera@@YAPAU_object@@PAU1@0@Z ENDP		; appSetCamera
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appExit@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appExit@@YAPAU_object@@PAU1@0@Z PROC			; appExit, COMDAT

; 491  : 	CPythonApplication::Instance().Exit();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?Exit@CPythonApplication@@QAEXXZ ; CPythonApplication::Exit

; 492  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appExit@@YAPAU_object@@PAU1@0@Z ENDP			; appExit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appAbort@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appAbort@@YAPAU_object@@PAU1@0@Z PROC			; appAbort, COMDAT

; 485  : 	CPythonApplication::Instance().Abort();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?Abort@CPythonApplication@@QAEXXZ ; CPythonApplication::Abort

; 486  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appAbort@@YAPAU_object@@PAU1@0@Z ENDP			; appAbort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appProcess@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appProcess@@YAPAU_object@@PAU1@0@Z PROC		; appProcess, COMDAT

; 477  : 	if (CPythonApplication::Instance().Process())

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?Process@CPythonApplication@@QAE_NXZ ; CPythonApplication::Process
  0000b	84 c0		 test	 al, al
  0000d	74 11		 je	 SHORT $LN1@appProcess

; 478  : 		return Py_BuildValue("i", 1);

  0000f	6a 01		 push	 1

; 479  : 
; 480  : 	return Py_BuildValue("i", 0);

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001c	83 c4 08	 add	 esp, 8

; 481  : }

  0001f	c3		 ret	 0
$LN1@appProcess:

; 479  : 
; 480  : 	return Py_BuildValue("i", 0);

  00020	6a 00		 push	 0
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002d	83 c4 08	 add	 esp, 8

; 481  : }

  00030	c3		 ret	 0
?appProcess@@YAPAU_object@@PAU1@0@Z ENDP		; appProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\iosfwd
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetInfo@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nInfo$ = -44						; size = 4
_stInfo$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetInfo@@YAPAU_object@@PAU1@0@Z PROC		; appGetInfo, COMDAT

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?appGetInfo@@YAPAU_object@@PAU1@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b 45 0c	 mov	 eax, DWORD PTR _poArgs$[ebp]

; 466  : 	int nInfo;
; 467  : 	if (!PyTuple_GetInteger(poArgs, 0, &nInfo))

  0002c	8d 4d d4	 lea	 ecx, DWORD PTR _nInfo$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	75 0c		 jne	 SHORT $LN1@appGetInfo

; 468  : 		return Py_BuildException();

  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00046	83 c4 04	 add	 esp, 4
  00049	eb 5a		 jmp	 SHORT $LN2@appGetInfo
$LN1@appGetInfo:
; File a:\vs\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  0004b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _stInfo$[ebp+20], 15 ; 0000000fH

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00052	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stInfo$[ebp+16], 0
; File a:\vs\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00059	c6 45 d8 00	 mov	 BYTE PTR _stInfo$[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 471  : 	CPythonApplication::Instance().GetInfo(nInfo, &stInfo);

  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00063	8d 45 d8	 lea	 eax, DWORD PTR _stInfo$[ebp]
  00066	50		 push	 eax
  00067	ff 75 d4	 push	 DWORD PTR _nInfo$[ebp]
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00071	e8 00 00 00 00	 call	 ?GetInfo@CPythonApplication@@QAEXIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CPythonApplication::GetInfo
; File a:\vs\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00076	83 7d ec 10	 cmp	 DWORD PTR _stInfo$[ebp+20], 16 ; 00000010H
  0007a	8d 45 d8	 lea	 eax, DWORD PTR _stInfo$[ebp]
  0007d	0f 43 45 d8	 cmovae	 eax, DWORD PTR _stInfo$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 472  : 	return Py_BuildValue("s", stInfo.c_str());

  00081	50		 push	 eax
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0008d	83 c4 08	 add	 esp, 8
  00090	8b f0		 mov	 esi, eax
; File a:\vs\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00092	83 7d ec 10	 cmp	 DWORD PTR _stInfo$[ebp+20], 16 ; 00000010H
  00096	72 0b		 jb	 SHORT $LN73@appGetInfo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00098	ff 75 d8	 push	 DWORD PTR _stInfo$[ebp]
  0009b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a0	83 c4 04	 add	 esp, 4
$LN73@appGetInfo:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp

; 472  : 	return Py_BuildValue("s", stInfo.c_str());

  000a3	8b c6		 mov	 eax, esi
$LN2@appGetInfo:

; 473  : }

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5e		 pop	 esi
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	33 cd		 xor	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?appGetInfo@@YAPAU_object@@PAU1@0@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _stInfo$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?appGetInfo@@YAPAU_object@@PAU1@0@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?appGetInfo@@YAPAU_object@@PAU1@0@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?appGetInfo@@YAPAU_object@@PAU1@0@Z ENDP		; appGetInfo
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLoop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLoop@@YAPAU_object@@PAU1@0@Z PROC			; appLoop, COMDAT

; 459  : 	CPythonApplication::Instance().Loop();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?Loop@CPythonApplication@@QAEXXZ ; CPythonApplication::Loop

; 460  : 		
; 461  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appLoop@@YAPAU_object@@PAU1@0@Z ENDP			; appLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appCreate@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szName$ = -16						; size = 4
_width$ = -12						; size = 4
_height$ = -8						; size = 4
_Windowed$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appCreate@@YAPAU_object@@PAU1@0@Z PROC			; appCreate, COMDAT

; 430  : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 431  : 	char* szName;
; 432  : 	if (!PyTuple_GetString(poArgs, 0, &szName))

  00006	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	84 c0		 test	 al, al
  0001b	75 0f		 jne	 SHORT $LN5@appCreate
$LN10@appCreate:

; 433  : 		return Py_BuildException();

  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00024	83 c4 04	 add	 esp, 4
  00027	5e		 pop	 esi

; 455  : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN5@appCreate:

; 434  : 
; 435  : 	int width;
; 436  : 	if (!PyTuple_GetInteger(poArgs, 1, &width))

  0002c	8d 45 f4	 lea	 eax, DWORD PTR _width$[ebp]
  0002f	50		 push	 eax
  00030	6a 01		 push	 1
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	84 c0		 test	 al, al
  0003d	74 de		 je	 SHORT $LN10@appCreate

; 437  : 		return Py_BuildException();
; 438  : 
; 439  : 	int height;
; 440  : 	if (!PyTuple_GetInteger(poArgs, 2, &height))

  0003f	8d 45 f8	 lea	 eax, DWORD PTR _height$[ebp]
  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	84 c0		 test	 al, al
  00050	74 cb		 je	 SHORT $LN10@appCreate

; 441  : 		return Py_BuildException();
; 442  : 
; 443  : 	int Windowed;
; 444  : 	if (!PyTuple_GetInteger(poArgs, 3, &Windowed))

  00052	8d 45 fc	 lea	 eax, DWORD PTR _Windowed$[ebp]
  00055	50		 push	 eax
  00056	6a 03		 push	 3
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	84 c0		 test	 al, al
  00063	74 b8		 je	 SHORT $LN10@appCreate

; 445  : 		return Py_BuildException();
; 446  : 
; 447  : 	CPythonApplication& rkApp=CPythonApplication::Instance();
; 448  : 	if (!rkApp.Create(poSelf, szName, width, height, Windowed))

  00065	ff 75 fc	 push	 DWORD PTR _Windowed$[ebp]
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  0006e	ff 75 f8	 push	 DWORD PTR _height$[ebp]
  00071	ff 75 f4	 push	 DWORD PTR _width$[ebp]
  00074	ff 75 f0	 push	 DWORD PTR _szName$[ebp]
  00077	ff 75 08	 push	 DWORD PTR _poSelf$[ebp]
  0007a	e8 00 00 00 00	 call	 ?Create@CPythonApplication@@QAE_NPAU_object@@PBDHHH@Z ; CPythonApplication::Create
  0007f	84 c0		 test	 al, al
  00081	75 07		 jne	 SHORT $LN1@appCreate

; 449  : 	{
; 450  : 		//return Py_BuildNone();			
; 451  : 		return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	5e		 pop	 esi

; 455  : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN1@appCreate:

; 452  : 	}
; 453  : 
; 454  : 	return Py_BuildNone();

  0008a	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
  0008f	5e		 pop	 esi

; 455  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?appCreate@@YAPAU_object@@PAU1@0@Z ENDP			; appCreate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetMouseHandler@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poHandler$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetMouseHandler@@YAPAU_object@@PAU1@0@Z PROC	; appSetMouseHandler, COMDAT

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 421  : 	PyObject* poHandler;
; 422  : 	if (!PyTuple_GetObject(poArgs, 0, &poHandler))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _poHandler$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ; PyTuple_GetObject
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetMous

; 423  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 427  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetMous:

; 424  : 
; 425  : 	CPythonApplication::Instance().SetMouseHandler(poHandler);

  00027	ff 75 fc	 push	 DWORD PTR _poHandler$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00030	e8 00 00 00 00	 call	 ?SetMouseHandler@CPythonApplication@@QAEXPAU_object@@@Z ; CPythonApplication::SetMouseHandler

; 426  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 427  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?appSetMouseHandler@@YAPAU_object@@PAU1@0@Z ENDP	; appSetMouseHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appRenderGame@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appRenderGame@@YAPAU_object@@PAU1@0@Z PROC		; appRenderGame, COMDAT

; 413  : 	CPythonApplication::Instance().RenderGame();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?RenderGame@CPythonApplication@@QAEXXZ ; CPythonApplication::RenderGame

; 414  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appRenderGame@@YAPAU_object@@PAU1@0@Z ENDP		; appRenderGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appUpdateGame@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appUpdateGame@@YAPAU_object@@PAU1@0@Z PROC		; appUpdateGame, COMDAT

; 407  : 	CPythonApplication::Instance().UpdateGame();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?UpdateGame@CPythonApplication@@QAEXXZ ; CPythonApplication::UpdateGame

; 408  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appUpdateGame@@YAPAU_object@@PAU1@0@Z ENDP		; appUpdateGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetFileList@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFilter$ = -328					; size = 4
_wfd$ = -324						; size = 320
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetFileList@@YAPAU_object@@PAU1@0@Z PROC		; appGetFileList, COMDAT

; 377  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _poArgs$[ebp]

; 378  : 	char* szFilter;
; 379  : 	if (!PyTuple_GetString(poArgs, 0, &szFilter))

  00016	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _szFilter$[ebp]
  0001c	51		 push	 ecx
  0001d	6a 00		 push	 0
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	84 c0		 test	 al, al
  0002a	75 18		 jne	 SHORT $LN5@appGetFile

; 380  : 		return Py_BuildException();

  0002c	6a 00		 push	 0
  0002e	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00033	83 c4 04	 add	 esp, 4

; 399  : 	}
; 400  : 
; 401  : 	return poList;
; 402  : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	33 cd		 xor	 ecx, ebp
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN5@appGetFile:
  00044	56		 push	 esi
  00045	57		 push	 edi

; 381  : 
; 382  : 	PyObject* poList=PyList_New(0);

  00046	6a 00		 push	 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_New

; 383  : 
; 384  : 	WIN32_FIND_DATA wfd;
; 385  : 	memset(&wfd, 0, sizeof(wfd));

  0004e	68 40 01 00 00	 push	 320			; 00000140H
  00053	8b f8		 mov	 edi, eax
  00055	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  0005b	6a 00		 push	 0
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _memset
  00063	83 c4 10	 add	 esp, 16			; 00000010H

; 386  : 
; 387  : 	HANDLE hFind = FindFirstFile(szFilter, &wfd);

  00066	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  0006c	50		 push	 eax
  0006d	ff b5 b8 fe ff
	ff		 push	 DWORD PTR _szFilter$[ebp]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstFileA@8
  00079	8b f0		 mov	 esi, eax

; 388  : 	if (hFind != INVALID_HANDLE_VALUE)

  0007b	83 fe ff	 cmp	 esi, -1
  0007e	74 35		 je	 SHORT $LN4@appGetFile
  00080	53		 push	 ebx
  00081	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__PyString_FromString
$LL3@appGetFile:

; 389  : 	{	
; 390  : 		do
; 391  : 		{
; 392  : 			PyObject* poFileName=PyString_FromString(wfd.cFileName) ;

  00087	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp+44]
  0008d	50		 push	 eax
  0008e	ff d3		 call	 ebx

; 393  : 			PyList_Append(poList, poFileName);

  00090	50		 push	 eax
  00091	57		 push	 edi
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_Append
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH

; 394  : 		} 			
; 395  : 		while (FindNextFile(hFind, &wfd));

  0009b	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _wfd$[ebp]
  000a1	50		 push	 eax
  000a2	56		 push	 esi
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextFileA@8
  000a9	85 c0		 test	 eax, eax
  000ab	75 da		 jne	 SHORT $LL3@appGetFile

; 396  : 		
; 397  : 
; 398  : 		FindClose(hFind);

  000ad	56		 push	 esi
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindClose@4
  000b4	5b		 pop	 ebx
$LN4@appGetFile:

; 399  : 	}
; 400  : 
; 401  : 	return poList;
; 402  : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	8b c7		 mov	 eax, edi
  000ba	5f		 pop	 edi
  000bb	33 cd		 xor	 ecx, ebp
  000bd	5e		 pop	 esi
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?appGetFileList@@YAPAU_object@@PAU1@0@Z ENDP		; appGetFileList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsExistFile@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFileName$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsExistFile@@YAPAU_object@@PAU1@0@Z PROC		; appIsExistFile, COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 367  : 	char* szFileName;
; 368  : 	if (!PyTuple_GetString(poArgs, 0, &szFileName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appIsExist

; 369  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 374  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appIsExist:

; 370  : 
; 371  : 	bool isExist=CEterPackManager::Instance().isExist(szFileName);

  00027	ff 75 fc	 push	 DWORD PTR _szFileName$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?isExist@CEterPackManager@@QAE_NPBD@Z ; CEterPackManager::isExist

; 372  : 
; 373  : 	return Py_BuildValue("i", isExist);

  00035	0f b6 c0	 movzx	 eax, al
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00044	83 c4 08	 add	 esp, 8

; 374  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?appIsExistFile@@YAPAU_object@@PAU1@0@Z ENDP		; appIsExistFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ PROC ; CSingleton<CEterPackManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCEterPackManager@@@@SAAAVCEterPackManager@@XZ ENDP ; CSingleton<CEterPackManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetImageInfo@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szFileName$ = -8					; size = 4
_uImg$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetImageInfo@@YAPAU_object@@PAU1@0@Z PROC		; appGetImageInfo, COMDAT

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 339  : 	char* szFileName;
; 340  : 	if (!PyTuple_GetString(poArgs, 0, &szFileName))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _szFileName$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@appGetImag

; 341  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 360  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@appGetImag:
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi

; 342  : 
; 343  : 	BOOL canLoad=FALSE;
; 344  : 	ILuint uWidth=0;
; 345  : 	ILuint uHeight=0;
; 346  : 
; 347  : 	ILuint uImg;
; 348  : 	ilGenImages(1, &uImg);

  0002c	8d 45 fc	 lea	 eax, DWORD PTR _uImg$[ebp]
  0002f	33 ff		 xor	 edi, edi
  00031	50		 push	 eax
  00032	6a 01		 push	 1
  00034	33 db		 xor	 ebx, ebx
  00036	33 f6		 xor	 esi, esi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilGenImages@8

; 349  : 	ilBindImage(uImg);

  0003e	ff 75 fc	 push	 DWORD PTR _uImg$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilBindImage@4

; 350  : 	if (ilLoad(IL_TYPE_UNKNOWN, szFileName))

  00047	ff 75 f8	 push	 DWORD PTR _szFileName$[ebp]
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilLoad@8
  00051	84 c0		 test	 al, al
  00053	74 1b		 je	 SHORT $LN1@appGetImag

; 351  : 	{
; 352  : 		canLoad=TRUE;
; 353  : 		uWidth=ilGetInteger(IL_IMAGE_WIDTH);

  00055	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ilGetInteger@4
  0005b	8d 7b 01	 lea	 edi, DWORD PTR [ebx+1]
  0005e	68 e4 0d 00 00	 push	 3556			; 00000de4H
  00063	ff d6		 call	 esi

; 354  : 		uHeight=ilGetInteger(IL_IMAGE_HEIGHT);

  00065	68 e5 0d 00 00	 push	 3557			; 00000de5H
  0006a	8b d8		 mov	 ebx, eax
  0006c	ff d6		 call	 esi
  0006e	8b f0		 mov	 esi, eax
$LN1@appGetImag:

; 355  : 	}
; 356  : 
; 357  : 	ilDeleteImages(1, &uImg);

  00070	8d 45 fc	 lea	 eax, DWORD PTR _uImg$[ebp]
  00073	50		 push	 eax
  00074	6a 01		 push	 1
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ilDeleteImages@8

; 358  : 
; 359  : 	return Py_BuildValue("iii", canLoad, uWidth, uHeight);

  0007c	56		 push	 esi
  0007d	53		 push	 ebx
  0007e	57		 push	 edi
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_03GLKMLICL@iii?$AA@
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0008a	83 c4 10	 add	 esp, 16			; 00000010H
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx

; 360  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?appGetImageInfo@@YAPAU_object@@PAU1@0@Z ENDP		; appGetImageInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetDefaultCodePage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetDefaultCodePage@@YAPAU_object@@PAU1@0@Z PROC	; appGetDefaultCodePage, COMDAT

; 319  : 	return Py_BuildValue("i", LocaleService_GetCodePage());

  00000	e8 00 00 00 00	 call	 ?LocaleService_GetCodePage@@YAIXZ ; LocaleService_GetCodePage
  00005	50		 push	 eax
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 320  : }

  00014	c3		 ret	 0
?appGetDefaultCodePage@@YAPAU_object@@PAU1@0@Z ENDP	; appGetDefaultCodePage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetLocalePath@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetLocalePath@@YAPAU_object@@PAU1@0@Z PROC		; appGetLocalePath, COMDAT

; 313  : 	return Py_BuildValue("s", LocaleService_GetLocalePath());

  00000	e8 00 00 00 00	 call	 ?LocaleService_GetLocalePath@@YAPBDXZ ; LocaleService_GetLocalePath
  00005	50		 push	 eax
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 314  : }

  00014	c3		 ret	 0
?appGetLocalePath@@YAPAU_object@@PAU1@0@Z ENDP		; appGetLocalePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetLocaleName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetLocaleName@@YAPAU_object@@PAU1@0@Z PROC		; appGetLocaleName, COMDAT

; 308  : 	return Py_BuildValue("s", LocaleService_GetLocaleName());

  00000	e8 00 00 00 00	 call	 ?LocaleService_GetLocaleName@@YAPBDXZ ; LocaleService_GetLocaleName
  00005	50		 push	 eax
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 309  : }

  00014	c3		 ret	 0
?appGetLocaleName@@YAPAU_object@@PAU1@0@Z ENDP		; appGetLocaleName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLoadLocaleData@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_localePath$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLoadLocaleData@@YAPAU_object@@PAU1@0@Z PROC		; appLoadLocaleData, COMDAT

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 299  : 	char* localePath;
; 300  : 	if (!PyTuple_GetString(poArgs, 0, &localePath))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _localePath$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appLoadLoc

; 301  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 304  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appLoadLoc:

; 302  : 
; 303  : 	return Py_BuildValue("i", LoadLocaleData(localePath));

  00027	ff 75 fc	 push	 DWORD PTR _localePath$[ebp]
  0002a	e8 00 00 00 00	 call	 ?LoadLocaleData@@YA_NPBD@Z ; LoadLocaleData
  0002f	0f b6 c0	 movzx	 eax, al
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 304  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?appLoadLocaleData@@YAPAU_object@@PAU1@0@Z ENDP		; appLoadLocaleData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appLoadLocaleAddr@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_addrPath$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appLoadLocaleAddr@@YAPAU_object@@PAU1@0@Z PROC		; appLoadLocaleAddr, COMDAT

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 266  : 	char* addrPath;
; 267  : 	if (!PyTuple_GetString(poArgs, 0, &addrPath))

  00013	8d 45 f8	 lea	 eax, DWORD PTR _addrPath$[ebp]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0001c	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	84 c0		 test	 al, al
  00026	75 1e		 jne	 SHORT $LN2@appLoadLoc
$LN5@appLoadLoc:

; 268  : 		return Py_BuildException();

  00028	6a 00		 push	 0
  0002a	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0002f	83 c4 04	 add	 esp, 4

; 295  : }

  00032	8d 65 ec	 lea	 esp, DWORD PTR [ebp-20]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN2@appLoadLoc:

; 269  : 
; 270  : 	FILE* fp = fopen(addrPath, "rb");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0004b	ff 75 f8	 push	 DWORD PTR _addrPath$[ebp]
  0004e	e8 00 00 00 00	 call	 _fopen
  00053	8b f0		 mov	 esi, eax
  00055	83 c4 08	 add	 esp, 8

; 271  : 	if (!fp)

  00058	85 f6		 test	 esi, esi
  0005a	74 cc		 je	 SHORT $LN5@appLoadLoc

; 272  : 		return Py_BuildException();
; 273  : 
; 274  : 	fseek(fp, 0, SEEK_END);

  0005c	6a 02		 push	 2
  0005e	6a 00		 push	 0
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 _fseek

; 275  : 
; 276  : 	int size = ftell(fp);

  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 _ftell
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	8b d8		 mov	 ebx, eax

; 277  : 	char* enc = (char*)_alloca(size);

  00071	e8 00 00 00 00	 call	 __alloca_probe_16
  00076	8b fc		 mov	 edi, esp

; 278  : 	fseek(fp, 0, SEEK_SET);

  00078	6a 00		 push	 0
  0007a	6a 00		 push	 0
  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 _fseek

; 279  : 	fread(enc, size, 1, fp);

  00082	56		 push	 esi
  00083	6a 01		 push	 1
  00085	53		 push	 ebx
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 _fread

; 280  : 	fclose(fp);

  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 _fclose
  00092	83 c4 20	 add	 esp, 32			; 00000020H

; 281  : 
; 282  : 	static const unsigned char key[16] = {
; 283  : 		0x82, 0x1b, 0x34, 0xae,
; 284  : 		0x12, 0x3b, 0xfb, 0x17,
; 285  : 		0xd7, 0x2c, 0x39, 0xae,
; 286  : 		0x41, 0x98, 0xf1, 0x63
; 287  : 	};
; 288  : 
; 289  : 	char* buf = (char*)_alloca(size);

  00095	8b c3		 mov	 eax, ebx
  00097	e8 00 00 00 00	 call	 __alloca_probe_16
  0009c	8b f4		 mov	 esi, esp

; 290  : 	//int decSize = 
; 291  : 	tea_decrypt((unsigned long*)buf, (const unsigned long*)enc, (const unsigned long*)key, size);

  0009e	53		 push	 ebx
  0009f	68 00 00 00 00	 push	 OFFSET ?key@?5??appLoadLocaleAddr@@YAPAU_object@@PAU2@0@Z@4QBEB
  000a4	57		 push	 edi
  000a5	56		 push	 esi
  000a6	e8 00 00 00 00	 call	 _tea_decrypt

; 292  : 	unsigned int retSize = *(unsigned int*)buf;
; 293  : 	char* ret = buf + sizeof(unsigned int);
; 294  : 	return Py_BuildValue("s#", ret, retSize);

  000ab	ff 36		 push	 DWORD PTR [esi]
  000ad	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_02OIKAIHIF@s?$CD?$AA@
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000bc	83 c4 1c	 add	 esp, 28			; 0000001cH

; 295  : }

  000bf	8d 65 ec	 lea	 esp, DWORD PTR [ebp-20]
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	33 cd		 xor	 ecx, ebp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
?appLoadLocaleAddr@@YAPAU_object@@PAU1@0@Z ENDP		; appLoadLocaleAddr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsCHEONMA@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsCHEONMA@@YAPAU_object@@PAU1@0@Z PROC		; appIsCHEONMA, COMDAT

; 259  : 	return Py_BuildValue("i", LocaleService_IsCHEONMA());

  00000	e8 00 00 00 00	 call	 ?LocaleService_IsCHEONMA@@YA_NXZ ; LocaleService_IsCHEONMA
  00005	0f b6 c0	 movzx	 eax, al
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00014	83 c4 08	 add	 esp, 8

; 260  : }

  00017	c3		 ret	 0
?appIsCHEONMA@@YAPAU_object@@PAU1@0@Z ENDP		; appIsCHEONMA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetCHEONMA@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_enable$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetCHEONMA@@YAPAU_object@@PAU1@0@Z PROC		; appSetCHEONMA, COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 249  : 	int enable;
; 250  : 	if (!PyTuple_GetInteger(poArgs, 0, &enable))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _enable$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetCHEO

; 251  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 255  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetCHEO:

; 252  : 	
; 253  : 	LocaleService_SetCHEONMA(enable ? true : false);

  00027	83 7d fc 00	 cmp	 DWORD PTR _enable$[ebp], 0
  0002b	0f 95 c0	 setne	 al
  0002e	0f b6 c0	 movzx	 eax, al
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?LocaleService_SetCHEONMA@@YAX_N@Z ; LocaleService_SetCHEONMA
  00037	83 c4 04	 add	 esp, 4

; 254  : 	return Py_BuildNone();

  0003a	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 255  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?appSetCHEONMA@@YAPAU_object@@PAU1@0@Z ENDP		; appSetCHEONMA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appGetLocaleServiceName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appGetLocaleServiceName@@YAPAU_object@@PAU1@0@Z PROC	; appGetLocaleServiceName, COMDAT

; 241  : 	return Py_BuildValue("s", LocaleService_GetName());

  00000	e8 00 00 00 00	 call	 ?LocaleService_GetName@@YAPBDXZ ; LocaleService_GetName
  00005	50		 push	 eax
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00011	83 c4 08	 add	 esp, 8

; 242  : }

  00014	c3		 ret	 0
?appGetLocaleServiceName@@YAPAU_object@@PAU1@0@Z ENDP	; appGetLocaleServiceName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appForceSetLocale@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szName$ = -8						; size = 4
_szLocalePath$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appForceSetLocale@@YAPAU_object@@PAU1@0@Z PROC		; appForceSetLocale, COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 226  : 	char* szName;
; 227  : 	if (!PyTuple_GetString(poArgs, 0, &szName))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _szName$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@appForceSe
$LN5@appForceSe:

; 228  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 237  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@appForceSe:

; 229  : 
; 230  : 	char* szLocalePath;
; 231  : 	if (!PyTuple_GetString(poArgs, 1, &szLocalePath))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _szLocalePath$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN5@appForceSe

; 232  : 		return Py_BuildException();
; 233  : 	
; 234  : 	LocaleService_ForceSetLocale(szName, szLocalePath);

  0003e	ff 75 fc	 push	 DWORD PTR _szLocalePath$[ebp]
  00041	ff 75 f8	 push	 DWORD PTR _szName$[ebp]
  00044	e8 00 00 00 00	 call	 ?LocaleService_ForceSetLocale@@YAXPBD0@Z ; LocaleService_ForceSetLocale
  00049	83 c4 08	 add	 esp, 8

; 235  : 
; 236  : 	return Py_BuildNone();

  0004c	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 237  : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?appForceSetLocale@@YAPAU_object@@PAU1@0@Z ENDP		; appForceSetLocale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetFrameSkip@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nFrameSkip$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetFrameSkip@@YAPAU_object@@PAU1@0@Z PROC		; appSetFrameSkip, COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 214  : 	int nFrameSkip;
; 215  : 	if (!PyTuple_GetInteger(poArgs, 0, &nFrameSkip))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nFrameSkip$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetFram

; 216  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 220  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetFram:

; 217  : 
; 218  : 	CPythonApplication::Instance().SetFrameSkip(nFrameSkip ? true : false);

  00027	83 7d fc 00	 cmp	 DWORD PTR _nFrameSkip$[ebp], 0
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00031	0f 95 c0	 setne	 al
  00034	0f b6 c0	 movzx	 eax, al
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?SetFrameSkip@CPythonApplication@@QAEX_N@Z ; CPythonApplication::SetFrameSkip

; 219  : 	return Py_BuildNone();

  0003d	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 220  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?appSetFrameSkip@@YAPAU_object@@PAU1@0@Z ENDP		; appSetFrameSkip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetMinFog@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fMinFog$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetMinFog@@YAPAU_object@@PAU1@0@Z PROC		; appSetMinFog, COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 204  : 	float fMinFog;
; 205  : 	if (!PyTuple_GetFloat(poArgs, 0, &fMinFog))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _fMinFog$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetMinF

; 206  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 210  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetMinF:

; 207  : 
; 208  : 	CPythonApplication::Instance().SetMinFog(fMinFog);

  00027	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fMinFog$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00033	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00038	e8 00 00 00 00	 call	 ?SetMinFog@CPythonApplication@@QAEXM@Z ; CPythonApplication::SetMinFog

; 209  : 	return Py_BuildNone();

  0003d	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 210  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?appSetMinFog@@YAPAU_object@@PAU1@0@Z ENDP		; appSetMinFog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetSpecularSpeed@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fSpeed$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetSpecularSpeed@@YAPAU_object@@PAU1@0@Z PROC	; appSetSpecularSpeed, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 193  : 	float fSpeed;
; 194  : 	if (!PyTuple_GetFloat(poArgs, 0, &fSpeed))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _fSpeed$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetSpec

; 195  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 200  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetSpec:
  00027	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fSpeed$[ebp]

; 196  : 
; 197  : 	g_specularSpd = fSpeed;

  0002c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0002f	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?g_specularSpd@@3NA, xmm0

; 198  : 
; 199  : 	return Py_BuildNone();

  00037	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 200  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?appSetSpecularSpeed@@YAPAU_object@@PAU1@0@Z ENDP	; appSetSpecularSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetControlFP@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetControlFP@@YAPAU_object@@PAU1@0@Z PROC		; appSetControlFP, COMDAT

; 187  : 	_controlfp( _PC_24, _MCW_PC );

  00000	68 00 00 03 00	 push	 196608			; 00030000H
  00005	68 00 00 02 00	 push	 131072			; 00020000H
  0000a	e8 00 00 00 00	 call	 __controlfp
  0000f	83 c4 08	 add	 esp, 8

; 188  : 	return Py_BuildNone();

  00012	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appSetControlFP@@YAPAU_object@@PAU1@0@Z ENDP		; appSetControlFP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetCameraMaxDistance@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_fMax$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetCameraMaxDistance@@YAPAU_object@@PAU1@0@Z PROC	; appSetCameraMaxDistance, COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 177  : 	float fMax;
; 178  : 	if (!PyTuple_GetFloat(poArgs, 0, &fMax))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _fMax$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetCame

; 179  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 183  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetCame:

; 180  : 
; 181  : 	CCamera::SetCameraMaxDistance(fMax);

  00027	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fMax$[ebp]
  0002c	51		 push	 ecx
  0002d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00032	e8 00 00 00 00	 call	 ?SetCameraMaxDistance@CCamera@@SAXM@Z ; CCamera::SetCameraMaxDistance
  00037	83 c4 04	 add	 esp, 4

; 182  : 	return Py_BuildNone();

  0003a	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 183  : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?appSetCameraMaxDistance@@YAPAU_object@@PAU1@0@Z ENDP	; appSetCameraMaxDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetRideHorseEnable@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nEnable$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetRideHorseEnable@@YAPAU_object@@PAU1@0@Z PROC	; appSetRideHorseEnable, COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 166  : 	int nEnable;
; 167  : 	if (!PyTuple_GetInteger(poArgs, 0, &nEnable))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nEnable$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetRide

; 168  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 173  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetRide:

; 169  : 
; 170  : 	RIDE_HORSE_ENABLE=nEnable;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _nEnable$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?RIDE_HORSE_ENABLE@@3HA, eax ; RIDE_HORSE_ENABLE

; 171  : 
; 172  : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 173  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?appSetRideHorseEnable@@YAPAU_object@@PAU1@0@Z ENDP	; appSetRideHorseEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?SetTwoHandedWeaponAttSpeedDecreaseValue@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_iValue$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?SetTwoHandedWeaponAttSpeedDecreaseValue@@YAPAU_object@@PAU1@0@Z PROC ; SetTwoHandedWeaponAttSpeedDecreaseValue, COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 155  : 	int iValue;
; 156  : 	if (!PyTuple_GetInteger(poArgs, 0, &iValue))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _iValue$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@SetTwoHand

; 157  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 162  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@SetTwoHand:

; 158  : 
; 159  : 	TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE = iValue;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _iValue$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE@@3HA, eax ; TWOHANDED_WEWAPON_ATT_SPEED_DECREASE_VALUE

; 160  : 
; 161  : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 162  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?SetTwoHandedWeaponAttSpeedDecreaseValue@@YAPAU_object@@PAU1@0@Z ENDP ; SetTwoHandedWeaponAttSpeedDecreaseValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetSkillEffectUpgradeEnable@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nEnable$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetSkillEffectUpgradeEnable@@YAPAU_object@@PAU1@0@Z PROC ; appSetSkillEffectUpgradeEnable, COMDAT

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 	int nEnable;
; 145  : 	if (!PyTuple_GetInteger(poArgs, 0, &nEnable))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nEnable$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetSkil

; 146  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 151  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetSkil:

; 147  : 
; 148  : 	SKILL_EFFECT_UPGRADE_ENABLE=nEnable;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _nEnable$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?SKILL_EFFECT_UPGRADE_ENABLE@@3HA, eax ; SKILL_EFFECT_UPGRADE_ENABLE

; 149  : 
; 150  : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 151  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?appSetSkillEffectUpgradeEnable@@YAPAU_object@@PAU1@0@Z ENDP ; appSetSkillEffectUpgradeEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetWeaponSpecularEnable@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nEnable$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetWeaponSpecularEnable@@YAPAU_object@@PAU1@0@Z PROC ; appSetWeaponSpecularEnable, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 133  : 	int nEnable;
; 134  : 	if (!PyTuple_GetInteger(poArgs, 0, &nEnable))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nEnable$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetWeap

; 135  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 140  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetWeap:

; 136  : 
; 137  : 	USE_WEAPON_SPECULAR=nEnable;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _nEnable$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?USE_WEAPON_SPECULAR@@3HA, eax ; USE_WEAPON_SPECULAR

; 138  : 
; 139  : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 140  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?appSetWeaponSpecularEnable@@YAPAU_object@@PAU1@0@Z ENDP ; appSetWeaponSpecularEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetArmorSpecularEnable@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nEnable$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetArmorSpecularEnable@@YAPAU_object@@PAU1@0@Z PROC	; appSetArmorSpecularEnable, COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 122  : 	int nEnable;
; 123  : 	if (!PyTuple_GetInteger(poArgs, 0, &nEnable))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nEnable$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetArmo

; 124  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 129  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetArmo:

; 125  : 
; 126  : 	USE_ARMOR_SPECULAR=nEnable;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _nEnable$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?USE_ARMOR_SPECULAR@@3HA, eax ; USE_ARMOR_SPECULAR

; 127  : 
; 128  : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 129  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?appSetArmorSpecularEnable@@YAPAU_object@@PAU1@0@Z ENDP	; appSetArmorSpecularEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetHairColorEnable@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nEnable$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetHairColorEnable@@YAPAU_object@@PAU1@0@Z PROC	; appSetHairColorEnable, COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 111  : 	int nEnable;
; 112  : 	if (!PyTuple_GetInteger(poArgs, 0, &nEnable))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _nEnable$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetHair

; 113  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 118  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetHair:

; 114  : 
; 115  : 	HAIR_COLOR_ENABLE=nEnable;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _nEnable$[ebp]
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?HAIR_COLOR_ENABLE@@3HA, eax ; HAIR_COLOR_ENABLE

; 116  : 
; 117  : 	return Py_BuildNone();

  0002f	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 118  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?appSetHairColorEnable@@YAPAU_object@@PAU1@0@Z ENDP	; appSetHairColorEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appSetTextTailLivingTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_livingTime$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appSetTextTailLivingTime@@YAPAU_object@@PAU1@0@Z PROC	; appSetTextTailLivingTime, COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 99   : 	float livingTime;
; 100  : 	if (!PyTuple_GetFloat(poArgs, 0, &livingTime))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _livingTime$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ; PyTuple_GetFloat
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN1@appSetText

; 101  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 106  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN1@appSetText:

; 102  : 
; 103  : 	TextTail_SetLivingTime(livingTime*1000);

  00027	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _livingTime$[ebp]
  0002c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@447a0000
  00034	f3 0f 2c c0	 cvttss2si eax, xmm0
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?TextTail_SetLivingTime@@YAXJ@Z ; TextTail_SetLivingTime
  0003e	83 c4 04	 add	 esp, 4

; 104  : 
; 105  : 	return Py_BuildNone();

  00041	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 106  : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?appSetTextTailLivingTime@@YAPAU_object@@PAU1@0@Z ENDP	; appSetTextTailLivingTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appEnablePerformanceTime@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_nEnable$ = -8						; size = 4
_szMode$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appEnablePerformanceTime@@YAPAU_object@@PAU1@0@Z PROC	; appEnablePerformanceTime, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 69   : 	char* szMode;
; 70   : 	if (!PyTuple_GetString(poArgs, 0, &szMode))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _szMode$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN3@appEnableP
$LN10@appEnableP:

; 71   : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 83   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN3@appEnableP:

; 72   : 
; 73   : 	int nEnable;
; 74   : 	if (!PyTuple_GetInteger(poArgs, 1, &nEnable))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _nEnable$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN10@appEnableP

; 78   : 
; 79   : 	if (strcmp(szMode, "RENDER_GAME")==0)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _szMode$[ebp]
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@OEKALNFB@RENDER_GAME?$AA@
$LL6@appEnableP:
  00046	8a 10		 mov	 dl, BYTE PTR [eax]
  00048	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0004a	75 1a		 jne	 SHORT $LN7@appEnableP
  0004c	84 d2		 test	 dl, dl
  0004e	74 12		 je	 SHORT $LN8@appEnableP
  00050	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00053	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00056	75 0e		 jne	 SHORT $LN7@appEnableP
  00058	83 c0 02	 add	 eax, 2
  0005b	83 c1 02	 add	 ecx, 2
  0005e	84 d2		 test	 dl, dl
  00060	75 e4		 jne	 SHORT $LL6@appEnableP
$LN8@appEnableP:
  00062	33 c0		 xor	 eax, eax
  00064	eb 05		 jmp	 SHORT $LN9@appEnableP
$LN7@appEnableP:
  00066	1b c0		 sbb	 eax, eax
  00068	83 c8 01	 or	 eax, 1
$LN9@appEnableP:
  0006b	85 c0		 test	 eax, eax
  0006d	75 0a		 jne	 SHORT $LN1@appEnableP

; 75   : 		return Py_BuildException();
; 76   : 
; 77   : 	bool isEnable=nEnable ? true : false;

  0006f	39 45 f8	 cmp	 DWORD PTR _nEnable$[ebp], eax
  00072	0f 95 05 00 00
	00 00		 setne	 BYTE PTR ?PERF_CHECKER_RENDER_GAME@@3_NA ; PERF_CHECKER_RENDER_GAME
$LN1@appEnableP:

; 80   : 		PERF_CHECKER_RENDER_GAME = isEnable;
; 81   : 	
; 82   : 	return Py_BuildNone();

  00079	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 83   : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?appEnablePerformanceTime@@YAPAU_object@@PAU1@0@Z ENDP	; appEnablePerformanceTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appIsWebPageMode@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appIsWebPageMode@@YAPAU_object@@PAU1@0@Z PROC		; appIsWebPageMode, COMDAT

; 64   : 	return Py_BuildValue("i", CPythonApplication::Instance().IsWebPageMode());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?IsWebPageMode@CPythonApplication@@QAE_NXZ ; CPythonApplication::IsWebPageMode
  0000b	0f b6 c0	 movzx	 eax, al
  0000e	50		 push	 eax
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i?$AA@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001a	83 c4 08	 add	 esp, 8

; 65   : }

  0001d	c3		 ret	 0
?appIsWebPageMode@@YAPAU_object@@PAU1@0@Z ENDP		; appIsWebPageMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appHideWebPage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appHideWebPage@@YAPAU_object@@PAU1@0@Z PROC		; appHideWebPage, COMDAT

; 57   : 	CPythonApplication::Instance().HideWebPage();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00006	e8 00 00 00 00	 call	 ?HideWebPage@CPythonApplication@@QAEXXZ ; CPythonApplication::HideWebPage

; 58   : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?appHideWebPage@@YAPAU_object@@PAU1@0@Z ENDP		; appHideWebPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appMoveWebPage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_rcWebPage$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appMoveWebPage@@YAPAU_object@@PAU1@0@Z PROC		; appMoveWebPage, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00013	53		 push	 ebx
  00014	57		 push	 edi

; 41   : 	PyObject* poRect=PyTuple_GetItem(poArgs, 0);

  00015	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PyTuple_GetItem
  0001b	6a 00		 push	 0
  0001d	50		 push	 eax
  0001e	ff d7		 call	 edi
  00020	8b d8		 mov	 ebx, eax
  00022	83 c4 08	 add	 esp, 8

; 42   : 	if (!PyTuple_Check(poRect))

  00025	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00028	f7 41 54 00 00
	00 04		 test	 DWORD PTR [ecx+84], 67108864 ; 04000000H
  0002f	75 1a		 jne	 SHORT $LN1@appMoveWeb

; 43   : 		return Py_BuildException();	

  00031	6a 00		 push	 0
  00033	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00038	83 c4 04	 add	 esp, 4
  0003b	5f		 pop	 edi
  0003c	5b		 pop	 ebx

; 53   : }

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN1@appMoveWeb:
  0004b	56		 push	 esi

; 44   : 
; 45   : 	RECT rcWebPage;
; 46   : 	rcWebPage.left=PyInt_AsLong(PyTuple_GetItem(poRect, 0));

  0004c	6a 00		 push	 0
  0004e	53		 push	 ebx
  0004f	ff d7		 call	 edi
  00051	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PyInt_AsLong
  00057	50		 push	 eax
  00058	ff d6		 call	 esi

; 47   : 	rcWebPage.top=PyInt_AsLong(PyTuple_GetItem(poRect, 1));

  0005a	6a 01		 push	 1
  0005c	53		 push	 ebx
  0005d	89 45 ec	 mov	 DWORD PTR _rcWebPage$[ebp], eax
  00060	ff d7		 call	 edi
  00062	50		 push	 eax
  00063	ff d6		 call	 esi

; 48   : 	rcWebPage.right=PyInt_AsLong(PyTuple_GetItem(poRect, 2));

  00065	6a 02		 push	 2
  00067	53		 push	 ebx
  00068	89 45 f0	 mov	 DWORD PTR _rcWebPage$[ebp+4], eax
  0006b	ff d7		 call	 edi
  0006d	50		 push	 eax
  0006e	ff d6		 call	 esi

; 49   : 	rcWebPage.bottom=PyInt_AsLong(PyTuple_GetItem(poRect, 3));

  00070	6a 03		 push	 3
  00072	53		 push	 ebx
  00073	89 45 f4	 mov	 DWORD PTR _rcWebPage$[ebp+8], eax
  00076	ff d7		 call	 edi
  00078	50		 push	 eax
  00079	ff d6		 call	 esi

; 50   : 
; 51   : 	CPythonApplication::Instance().MoveWebPage(rcWebPage);

  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  00081	83 c4 30	 add	 esp, 48			; 00000030H
  00084	89 45 f8	 mov	 DWORD PTR _rcWebPage$[ebp+12], eax
  00087	8d 45 ec	 lea	 eax, DWORD PTR _rcWebPage$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?MoveWebPage@CPythonApplication@@QAEXABUtagRECT@@@Z ; CPythonApplication::MoveWebPage

; 52   : 	return Py_BuildNone();

  00090	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 53   : }

  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	5e		 pop	 esi
  00099	5f		 pop	 edi
  0009a	33 cd		 xor	 ecx, ebp
  0009c	5b		 pop	 ebx
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?appMoveWebPage@@YAPAU_object@@PAU1@0@Z ENDP		; appMoveWebPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?appShowWebPage@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szWebPage$ = -24					; size = 4
_rcWebPage$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?appShowWebPage@@YAPAU_object@@PAU1@0@Z PROC		; appShowWebPage, COMDAT

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]

; 18   : 	char* szWebPage;
; 19   : 	if (!PyTuple_GetString(poArgs, 0, &szWebPage))

  00014	8d 45 e8	 lea	 eax, DWORD PTR _szWebPage$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	84 c0		 test	 al, al
  00025	75 19		 jne	 SHORT $LN2@appShowWeb

; 20   : 		return Py_BuildException();

  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  0002e	83 c4 04	 add	 esp, 4
  00031	5e		 pop	 esi

; 37   : }

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00035	33 cd		 xor	 ecx, ebp
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN2@appShowWeb:
  00040	53		 push	 ebx
  00041	57		 push	 edi

; 21   : 
; 22   : 	PyObject* poRect=PyTuple_GetItem(poArgs, 1);

  00042	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__PyTuple_GetItem
  00048	6a 01		 push	 1
  0004a	56		 push	 esi
  0004b	ff d7		 call	 edi
  0004d	8b d8		 mov	 ebx, eax
  0004f	83 c4 08	 add	 esp, 8

; 23   : 	if (!PyTuple_Check(poRect))

  00052	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 24   : 		return Py_BuildException();	

  00055	6a 00		 push	 0
  00057	f7 41 54 00 00
	00 04		 test	 DWORD PTR [ecx+84], 67108864 ; 04000000H
  0005e	75 19		 jne	 SHORT $LN1@appShowWeb
  00060	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00065	83 c4 04	 add	 esp, 4
  00068	5f		 pop	 edi
  00069	5b		 pop	 ebx
  0006a	5e		 pop	 esi

; 37   : }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN1@appShowWeb:

; 25   : 
; 26   : 	RECT rcWebPage;
; 27   : 	rcWebPage.left=PyInt_AsLong(PyTuple_GetItem(poRect, 0));

  00079	53		 push	 ebx
  0007a	ff d7		 call	 edi
  0007c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PyInt_AsLong
  00082	50		 push	 eax
  00083	ff d6		 call	 esi

; 28   : 	rcWebPage.top=PyInt_AsLong(PyTuple_GetItem(poRect, 1));

  00085	6a 01		 push	 1
  00087	53		 push	 ebx
  00088	89 45 ec	 mov	 DWORD PTR _rcWebPage$[ebp], eax
  0008b	ff d7		 call	 edi
  0008d	50		 push	 eax
  0008e	ff d6		 call	 esi

; 29   : 	rcWebPage.right=PyInt_AsLong(PyTuple_GetItem(poRect, 2));

  00090	6a 02		 push	 2
  00092	53		 push	 ebx
  00093	89 45 f0	 mov	 DWORD PTR _rcWebPage$[ebp+4], eax
  00096	ff d7		 call	 edi
  00098	50		 push	 eax
  00099	ff d6		 call	 esi

; 30   : 	rcWebPage.bottom=PyInt_AsLong(PyTuple_GetItem(poRect, 3));

  0009b	6a 03		 push	 3
  0009d	53		 push	 ebx
  0009e	89 45 f4	 mov	 DWORD PTR _rcWebPage$[ebp+8], eax
  000a1	ff d7		 call	 edi
  000a3	50		 push	 eax
  000a4	ff d6		 call	 esi

; 31   : 
; 32   : 	CPythonApplication::Instance().ShowWebPage(
; 33   : 		szWebPage,
; 34   : 		rcWebPage		
; 35   : 	);

  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance
  000ac	83 c4 30	 add	 esp, 48			; 00000030H
  000af	89 45 f8	 mov	 DWORD PTR _rcWebPage$[ebp+12], eax
  000b2	8d 45 ec	 lea	 eax, DWORD PTR _rcWebPage$[ebp]
  000b5	50		 push	 eax
  000b6	ff 75 e8	 push	 DWORD PTR _szWebPage$[ebp]
  000b9	e8 00 00 00 00	 call	 ?ShowWebPage@CPythonApplication@@QAEXPBDABUtagRECT@@@Z ; CPythonApplication::ShowWebPage

; 36   : 	return Py_BuildNone();

  000be	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 37   : }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	5f		 pop	 edi
  000c7	5b		 pop	 ebx
  000c8	33 cd		 xor	 ecx, ebp
  000ca	5e		 pop	 esi
  000cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?appShowWebPage@@YAPAU_object@@PAU1@0@Z ENDP		; appShowWebPage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ PROC ; CSingleton<CCameraManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ENDP ; CSingleton<CCameraManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetFaceCount@CPythonApplication@@QAEKXZ
_TEXT	SEGMENT
?GetFaceCount@CPythonApplication@@QAEKXZ PROC		; CPythonApplication::GetFaceCount, COMDAT
; _this$ = ecx

; 217  : 		DWORD GetFaceCount()	{ return m_dwFaceCount; }

  00000	8b 81 74 fd 01
	00		 mov	 eax, DWORD PTR [ecx+130420]
  00006	c3		 ret	 0
?GetFaceCount@CPythonApplication@@QAEKXZ ENDP		; CPythonApplication::GetFaceCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetLoad@CPythonApplication@@QAEKXZ
_TEXT	SEGMENT
?GetLoad@CPythonApplication@@QAEKXZ PROC		; CPythonApplication::GetLoad, COMDAT
; _this$ = ecx

; 216  : 		DWORD GetLoad()			{ return m_dwLoad; }

  00000	8b 81 88 fc 01
	00		 mov	 eax, DWORD PTR [ecx+130184]
  00006	c3		 ret	 0
?GetLoad@CPythonApplication@@QAEKXZ ENDP		; CPythonApplication::GetLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetRenderFPS@CPythonApplication@@QAEKXZ
_TEXT	SEGMENT
?GetRenderFPS@CPythonApplication@@QAEKXZ PROC		; CPythonApplication::GetRenderFPS, COMDAT
; _this$ = ecx

; 215  : 		DWORD GetRenderFPS()		{ return m_dwRenderFPS; }

  00000	8b 81 70 fd 01
	00		 mov	 eax, DWORD PTR [ecx+130416]
  00006	c3		 ret	 0
?GetRenderFPS@CPythonApplication@@QAEKXZ ENDP		; CPythonApplication::GetRenderFPS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetUpdateFPS@CPythonApplication@@QAEKXZ
_TEXT	SEGMENT
?GetUpdateFPS@CPythonApplication@@QAEKXZ PROC		; CPythonApplication::GetUpdateFPS, COMDAT
; _this$ = ecx

; 214  : 		DWORD GetUpdateFPS()		{ return m_dwUpdateFPS; }

  00000	8b 81 6c fd 01
	00		 mov	 eax, DWORD PTR [ecx+130412]
  00006	c3		 ret	 0
?GetUpdateFPS@CPythonApplication@@QAEKXZ ENDP		; CPythonApplication::GetUpdateFPS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetCurUpdateTime@CPythonApplication@@QAEKXZ
_TEXT	SEGMENT
?GetCurUpdateTime@CPythonApplication@@QAEKXZ PROC	; CPythonApplication::GetCurUpdateTime, COMDAT
; _this$ = ecx

; 213  : 		DWORD GetCurUpdateTime()	{ return m_dwCurUpdateTime; }

  00000	8b 81 84 fc 01
	00		 mov	 eax, DWORD PTR [ecx+130180]
  00006	c3		 ret	 0
?GetCurUpdateTime@CPythonApplication@@QAEKXZ ENDP	; CPythonApplication::GetCurUpdateTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetCurRenderTime@CPythonApplication@@QAEKXZ
_TEXT	SEGMENT
?GetCurRenderTime@CPythonApplication@@QAEKXZ PROC	; CPythonApplication::GetCurRenderTime, COMDAT
; _this$ = ecx

; 212  : 		DWORD GetCurRenderTime()	{ return m_dwCurRenderTime; }

  00000	8b 81 80 fc 01
	00		 mov	 eax, DWORD PTR [ecx+130176]
  00006	c3		 ret	 0
?GetCurRenderTime@CPythonApplication@@QAEKXZ ENDP	; CPythonApplication::GetCurRenderTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetAveRenderTime@CPythonApplication@@QAEMXZ
_TEXT	SEGMENT
?GetAveRenderTime@CPythonApplication@@QAEMXZ PROC	; CPythonApplication::GetAveRenderTime, COMDAT
; _this$ = ecx

; 211  : 		float GetAveRenderTime()	{ return m_fAveRenderTime; }

  00000	d9 81 7c fc 01
	00		 fld	 DWORD PTR [ecx+130172]
  00006	c3		 ret	 0
?GetAveRenderTime@CPythonApplication@@QAEMXZ ENDP	; CPythonApplication::GetAveRenderTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetFaceSpeed@CPythonApplication@@QAEMXZ
_TEXT	SEGMENT
?GetFaceSpeed@CPythonApplication@@QAEMXZ PROC		; CPythonApplication::GetFaceSpeed, COMDAT
; _this$ = ecx

; 210  : 		float GetFaceSpeed()		{ return m_fFaceSpd; }

  00000	d9 81 58 fd 01
	00		 fld	 DWORD PTR [ecx+130392]
  00006	c3		 ret	 0
?GetFaceSpeed@CPythonApplication@@QAEMXZ ENDP		; CPythonApplication::GetFaceSpeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?GetCursorNum@CPythonApplication@@QAEHXZ
_TEXT	SEGMENT
?GetCursorNum@CPythonApplication@@QAEHXZ PROC		; CPythonApplication::GetCursorNum, COMDAT
; _this$ = ecx

; 178  : 		int GetCursorNum() { return m_iCursorNum; }

  00000	8b 81 cc fd 01
	00		 mov	 eax, DWORD PTR [ecx+130508]
  00006	c3		 ret	 0
?GetCursorNum@CPythonApplication@@QAEHXZ ENDP		; CPythonApplication::GetCursorNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplication.h
;	COMDAT ?Instance@CPythonApplication@@SAAAV1@XZ
_TEXT	SEGMENT
?Instance@CPythonApplication@@SAAAV1@XZ PROC		; CPythonApplication::Instance, COMDAT

; 142  : 			assert(ms_pInstance != NULL);
; 143  : 			return *ms_pInstance;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pInstance@CPythonApplication@@1PAV1@A ; CPythonApplication::ms_pInstance

; 144  : 		}

  00005	c3		 ret	 0
?Instance@CPythonApplication@@SAAAV1@XZ ENDP		; CPythonApplication::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCMovieMan@@@@SAAAVCMovieMan@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCMovieMan@@@@SAAAVCMovieMan@@XZ PROC ; CSingleton<CMovieMan>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCMovieMan@@@@0PAVCMovieMan@@A ; CSingleton<CMovieMan>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCMovieMan@@@@SAAAVCMovieMan@@XZ ENDP ; CSingleton<CMovieMan>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\abstractapplication.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\abstractapplication.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\abstractapplication.h
;	COMDAT ??0SCameraSetting@IAbstractApplication@@QAE@XZ
_TEXT	SEGMENT
??0SCameraSetting@IAbstractApplication@@QAE@XZ PROC	; IAbstractApplication::SCameraSetting::SCameraSetting, COMDAT
; _this$ = ecx
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\abstractapplication.h

; 28   : 								fZoom(0.0f) {}

  00006	8b c1		 mov	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 182  :     z = fz;

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\abstractapplication.h

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 28   : 								fZoom(0.0f) {}

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00040	c3		 ret	 0
??0SCameraSetting@IAbstractApplication@@QAE@XZ ENDP	; IAbstractApplication::SCameraSetting::SCameraSetting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\abstractapplication.h
;	COMDAT ??0SCameraPos@IAbstractApplication@@QAE@XZ
_TEXT	SEGMENT
??0SCameraPos@IAbstractApplication@@QAE@XZ PROC		; IAbstractApplication::SCameraPos::SCameraPos, COMDAT
; _this$ = ecx

; 14   : 			SCameraPos() : m_fUpDir(0.0f), m_fViewDir(0.0f), m_fCrossDir(0.0f) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0SCameraPos@IAbstractApplication@@QAE@XZ ENDP		; IAbstractApplication::SCameraPos::SCameraPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$singleton@VCGuildMarkManager@@@@SAAAVCGuildMarkManager@@XZ
_TEXT	SEGMENT
?Instance@?$singleton@VCGuildMarkManager@@@@SAAAVCGuildMarkManager@@XZ PROC ; singleton<CGuildMarkManager>::Instance, COMDAT

; 67   : 		assert(ms_singleton);
; 68   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$singleton@VCGuildMarkManager@@@@0PAVCGuildMarkManager@@A ; singleton<CGuildMarkManager>::ms_singleton

; 69   : 	}

  00005	c3		 ret	 0
?Instance@?$singleton@VCGuildMarkManager@@@@SAAAVCGuildMarkManager@@XZ ENDP ; singleton<CGuildMarkManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\pythonapplicationmodule.cpp
;	COMDAT ?initapp@@YAXXZ
_TEXT	SEGMENT
?initapp@@YAXXZ PROC					; initapp, COMDAT

; 1196 : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1197 : 	static PyMethodDef s_methods[] =
; 1198 : 	{	
; 1199 : 		{ "IsDevStage",					appIsDevStage,					METH_VARARGS },
; 1200 : 		{ "IsTestStage",				appIsTestStage,					METH_VARARGS },
; 1201 : 		{ "IsLiveStage",				appIsLiveStage,					METH_VARARGS },
; 1202 : 
; 1203 : 		// TEXTTAIL_LIVINGTIME_CONTROL
; 1204 : 		{ "SetTextTailLivingTime",		appSetTextTailLivingTime,		METH_VARARGS },
; 1205 : 		// END_OF_TEXTTAIL_LIVINGTIME_CONTROL
; 1206 : 		
; 1207 : 		{ "EnablePerformanceTime",		appEnablePerformanceTime,		METH_VARARGS },
; 1208 : 		{ "SetHairColorEnable",			appSetHairColorEnable,			METH_VARARGS },
; 1209 : 		
; 1210 : 		{ "SetArmorSpecularEnable",		appSetArmorSpecularEnable,		METH_VARARGS },
; 1211 : 		{ "SetWeaponSpecularEnable",	appSetWeaponSpecularEnable,		METH_VARARGS },
; 1212 : 		{ "SetSkillEffectUpgradeEnable",appSetSkillEffectUpgradeEnable,	METH_VARARGS },
; 1213 : 		{ "SetTwoHandedWeaponAttSpeedDecreaseValue", SetTwoHandedWeaponAttSpeedDecreaseValue, METH_VARARGS },
; 1214 : 		{ "SetRideHorseEnable",			appSetRideHorseEnable,			METH_VARARGS },
; 1215 : 
; 1216 : 		{ "SetCameraMaxDistance",		appSetCameraMaxDistance,		METH_VARARGS },
; 1217 : 		{ "SetMinFog",					appSetMinFog,					METH_VARARGS },
; 1218 : 		{ "SetFrameSkip",				appSetFrameSkip,				METH_VARARGS },
; 1219 : 		{ "GetImageInfo",				appGetImageInfo,				METH_VARARGS },
; 1220 : 		{ "GetInfo",					appGetInfo,						METH_VARARGS },
; 1221 : 		{ "UpdateGame",					appUpdateGame,					METH_VARARGS },
; 1222 : 		{ "RenderGame",					appRenderGame,					METH_VARARGS },
; 1223 : 		{ "Loop",						appLoop,						METH_VARARGS },
; 1224 : 		{ "Create",						appCreate,						METH_VARARGS },
; 1225 : 		{ "Process",					appProcess,						METH_VARARGS },
; 1226 : 		{ "Exit",						appExit,						METH_VARARGS },
; 1227 : 		{ "Abort",						appAbort,						METH_VARARGS },
; 1228 : 		{ "SetMouseHandler",			appSetMouseHandler,				METH_VARARGS },		
; 1229 : 		{ "IsExistFile",				appIsExistFile,					METH_VARARGS },
; 1230 : 		{ "GetFileList",				appGetFileList,					METH_VARARGS },
; 1231 : 
; 1232 : 		{ "SetCamera",					appSetCamera,					METH_VARARGS },
; 1233 : 		{ "GetCamera",					appGetCamera,					METH_VARARGS },
; 1234 : 		{ "GetCameraPitch",				appGetCameraPitch,				METH_VARARGS },
; 1235 : 		{ "GetCameraRotation",			appGetCameraRotation,			METH_VARARGS },
; 1236 : 		{ "GetTime",					appGetTime,						METH_VARARGS },
; 1237 : 		{ "GetGlobalTime",				appGetGlobalTime,				METH_VARARGS },
; 1238 : 		{ "GetGlobalTimeStamp",			appGetGlobalTimeStamp,			METH_VARARGS },
; 1239 : 		{ "GetUpdateFPS",				appGetUpdateFPS,				METH_VARARGS },
; 1240 : 		{ "GetRenderFPS",				appGetRenderFPS,				METH_VARARGS },
; 1241 : 		{ "RotateCamera",				appRotateCamera,				METH_VARARGS },
; 1242 : 		{ "PitchCamera",				appPitchCamera,					METH_VARARGS },
; 1243 : 		{ "ZoomCamera",					appZoomCamera,					METH_VARARGS },
; 1244 : 		{ "MovieRotateCamera",			appMovieRotateCamera,			METH_VARARGS },
; 1245 : 		{ "MoviePitchCamera",			appMoviePitchCamera,			METH_VARARGS },
; 1246 : 		{ "MovieZoomCamera",			appMovieZoomCamera,				METH_VARARGS },
; 1247 : 		{ "MovieResetCamera",			appMovieResetCamera,			METH_VARARGS },
; 1248 : 
; 1249 : 		{ "GetAvailableTextureMemory",	appGetAvaiableTextureMememory,	METH_VARARGS },
; 1250 : 		{ "GetRenderTime",				appGetRenderTime,				METH_VARARGS },
; 1251 : 		{ "GetUpdateTime",				appGetUpdateTime,				METH_VARARGS },
; 1252 : 		{ "GetLoad",					appGetLoad,						METH_VARARGS },
; 1253 : 		{ "GetFaceSpeed",				appGetFaceSpeed,				METH_VARARGS },
; 1254 : 		{ "GetFaceCount",				appGetFaceCount,				METH_VARARGS },
; 1255 : 		{ "SetFPS",						appSetFPS,						METH_VARARGS },
; 1256 : 		{ "SetGlobalCenterPosition",	appSetGlobalCenterPosition,		METH_VARARGS },
; 1257 : 		{ "SetCenterPosition",			appSetCenterPosition,			METH_VARARGS },
; 1258 : 		{ "GetCursorPosition",			appGetCursorPosition,			METH_VARARGS },
; 1259 : 
; 1260 : 		{ "GetRandom",					appGetRandom,					METH_VARARGS },
; 1261 : 		{ "RunPythonFile",				appRunPythonFile,				METH_VARARGS },
; 1262 : 		{ "IsWebPageMode",				appIsWebPageMode,				METH_VARARGS },		
; 1263 : 		{ "ShowWebPage",				appShowWebPage,					METH_VARARGS },		
; 1264 : 		{ "MoveWebPage",				appMoveWebPage,					METH_VARARGS },		
; 1265 : 		{ "HideWebPage",				appHideWebPage,					METH_VARARGS },	
; 1266 : 		{ "IsPressed",					appIsPressed,					METH_VARARGS },
; 1267 : 		{ "SetCursor",					appSetCursor,					METH_VARARGS },
; 1268 : 		{ "GetCursor",					appGetCursor,					METH_VARARGS },
; 1269 : 		{ "ShowCursor",					appShowCursor,					METH_VARARGS },
; 1270 : 		{ "HideCursor",					appHideCursor,					METH_VARARGS },
; 1271 : 		{ "IsShowCursor",				appIsShowCursor,				METH_VARARGS },
; 1272 : 		{ "IsLiarCursorOn",				appIsLiarCursorOn,				METH_VARARGS },
; 1273 : 		{ "SetSoftwareCursor",			appSetSoftwareCursor,			METH_VARARGS },
; 1274 : 		{ "SetHardwareCursor",			appSetHardwareCursor,			METH_VARARGS },
; 1275 : 
; 1276 : 		{ "SetConnectData",				appSetConnectData,				METH_VARARGS },
; 1277 : 		{ "GetConnectData",				appGetConnectData,				METH_VARARGS },
; 1278 : 
; 1279 : 		{ "GetRotatingDirection",		appGetRotatingDirection,		METH_VARARGS },
; 1280 : 		{ "GetDegreeDifference",		appGetDegreeDifference,			METH_VARARGS },
; 1281 : 		{ "Sleep",						appSleep,						METH_VARARGS },
; 1282 : 		{ "SetDefaultFontName",			appSetDefaultFontName,			METH_VARARGS },
; 1283 : 		{ "SetGuildSymbolPath",			appSetGuildSymbolPath,			METH_VARARGS },
; 1284 : 
; 1285 : 		{ "EnableSpecialCameraMode",	appEnableSpecialCameraMode,		METH_VARARGS },
; 1286 : 		{ "SetCameraSpeed",				appSetCameraSpeed,				METH_VARARGS },
; 1287 : 
; 1288 : 		{ "SaveCameraSetting",			appSaveCameraSetting,			METH_VARARGS },
; 1289 : 		{ "LoadCameraSetting",			appLoadCameraSetting,			METH_VARARGS },
; 1290 : 		{ "SetDefaultCamera",			appSetDefaultCamera,			METH_VARARGS },
; 1291 : 		{ "SetCameraSetting",			appSetCameraSetting,			METH_VARARGS },
; 1292 : 
; 1293 : 		{ "SetSightRange",				appSetSightRange,				METH_VARARGS },
; 1294 : 
; 1295 : 		{ "IsFileExist",				appIsFileExist,					METH_VARARGS },
; 1296 : 		{ "OpenTextFile",				appOpenTextFile,				METH_VARARGS },
; 1297 : 		{ "CloseTextFile",				appCloseTextFile,				METH_VARARGS },
; 1298 : 		{ "GetTextFileLineCount",		appGetTextFileLineCount,		METH_VARARGS },
; 1299 : 		{ "GetTextFileLine",			appGetTextFileLine,				METH_VARARGS },
; 1300 : 
; 1301 : 		// LOCALE
; 1302 : 		{ "GetLocaleServiceName",		appGetLocaleServiceName,		METH_VARARGS },
; 1303 : 		{ "GetLocaleName",				appGetLocaleName,				METH_VARARGS },
; 1304 : 		{ "GetLocalePath",				appGetLocalePath,				METH_VARARGS },
; 1305 : 		{ "ForceSetLocale",				appForceSetLocale,				METH_VARARGS },
; 1306 : 		// END_OF_LOCALE
; 1307 : 
; 1308 : 		// CHEONMA
; 1309 : 		{ "LoadLocaleAddr",				appLoadLocaleAddr,				METH_VARARGS },
; 1310 : 		{ "LoadLocaleData",				appLoadLocaleData,				METH_VARARGS },
; 1311 : 		{ "SetCHEONMA",					appSetCHEONMA,					METH_VARARGS },
; 1312 : 		{ "IsCHEONMA",					appIsCHEONMA,					METH_VARARGS },
; 1313 : 		// END_OF_CHEONMA
; 1314 : 		
; 1315 : 		{ "GetDefaultCodePage",			appGetDefaultCodePage,			METH_VARARGS },
; 1316 : 		{ "SetControlFP",				appSetControlFP,				METH_VARARGS },
; 1317 : 		{ "SetSpecularSpeed",			appSetSpecularSpeed,			METH_VARARGS },
; 1318 : 
; 1319 : 		{ "testGetAccumulationTime",	apptestGetAccumulationTime,		METH_VARARGS },
; 1320 : 		{ "testResetAccumulationTime",	apptestResetAccumulationTime,	METH_VARARGS },
; 1321 : 		{ "testSetSpecularColor",		apptestSetSpecularColor,		METH_VARARGS },
; 1322 : 
; 1323 : 		{ "SetVisibleNotice",			appSetVisibleNotice,			METH_VARARGS },
; 1324 : 		{ "IsVisibleNotice",			appIsVisibleNotice,				METH_VARARGS },
; 1325 : 		{ "EnableTestServerFlag",		appEnableTestServerFlag,		METH_VARARGS },
; 1326 : 		{ "IsEnableTestServerFlag",		appIsEnableTestServerFlag,		METH_VARARGS },
; 1327 : 
; 1328 : 		{ "SetGuildMarkPath",			appSetGuildMarkPath,			METH_VARARGS },
; 1329 : 
; 1330 : 		{ "OnLogoUpdate",				appLogoUpdate,					METH_VARARGS },
; 1331 : 		{ "OnLogoRender",				appLogoRender,					METH_VARARGS },
; 1332 : 		{ "OnLogoOpen",					appLogoOpen,					METH_VARARGS },
; 1333 : 		{ "OnLogoClose",				appLogoClose,					METH_VARARGS },
; 1334 : 	
; 1335 : 
; 1336 : 		{ NULL, NULL },
; 1337 : 	};
; 1338 : 
; 1339 : 	PyObject * poModule = Py_InitModule("app", s_methods);

  00002	68 f5 03 00 00	 push	 1013			; 000003f5H
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET ?s_methods@?1??initapp@@YAXXZ@4PAUPyMethodDef@@A
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_03CGOPKBCD@app?$AA@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_InitModule4

; 1340 : 
; 1341 : 	PyModule_AddIntConstant(poModule, "INFO_ITEM",		CPythonApplication::INFO_ITEM);

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PyModule_AddIntConstant
  00021	8b f8		 mov	 edi, eax
  00023	6a 02		 push	 2
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_09OKOJMLAA@INFO_ITEM?$AA@
  0002a	57		 push	 edi
  0002b	ff d6		 call	 esi

; 1342 : 	PyModule_AddIntConstant(poModule, "INFO_ACTOR",		CPythonApplication::INFO_ACTOR);

  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FNNFPLHG@INFO_ACTOR?$AA@
  00034	57		 push	 edi
  00035	ff d6		 call	 esi

; 1343 : 	PyModule_AddIntConstant(poModule, "INFO_EFFECT",	CPythonApplication::INFO_EFFECT);

  00037	6a 01		 push	 1
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KLBHMBMD@INFO_EFFECT?$AA@
  0003e	57		 push	 edi
  0003f	ff d6		 call	 esi

; 1344 : 	PyModule_AddIntConstant(poModule, "INFO_TEXTTAIL",	CPythonApplication::INFO_TEXTTAIL);

  00041	6a 03		 push	 3
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FAGLOALJ@INFO_TEXTTAIL?$AA@
  00048	57		 push	 edi
  00049	ff d6		 call	 esi
  0004b	83 c4 44	 add	 esp, 68			; 00000044H

; 1345 : 
; 1346 : 	PyModule_AddIntConstant(poModule, "DEGREE_DIRECTION_SAME",		DEGREE_DIRECTION_SAME);

  0004e	6a 00		 push	 0
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KEIJCHNJ@DEGREE_DIRECTION_SAME?$AA@
  00055	57		 push	 edi
  00056	ff d6		 call	 esi

; 1347 : 	PyModule_AddIntConstant(poModule, "DEGREE_DIRECTION_RIGHT",		DEGREE_DIRECTION_RIGHT);

  00058	6a 01		 push	 1
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LNDFJAFE@DEGREE_DIRECTION_RIGHT?$AA@
  0005f	57		 push	 edi
  00060	ff d6		 call	 esi

; 1348 : 	PyModule_AddIntConstant(poModule, "DEGREE_DIRECTION_LEFT",		DEGREE_DIRECTION_LEFT);

  00062	6a 02		 push	 2
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JGNHHMCM@DEGREE_DIRECTION_LEFT?$AA@
  00069	57		 push	 edi
  0006a	ff d6		 call	 esi

; 1349 : 
; 1350 : 	PyModule_AddIntConstant(poModule, "VK_LEFT",	     VK_LEFT);

  0006c	6a 25		 push	 37			; 00000025H
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_07CJEJDFBD@VK_LEFT?$AA@
  00073	57		 push	 edi
  00074	ff d6		 call	 esi

; 1351 : 	PyModule_AddIntConstant(poModule, "VK_RIGHT",	     VK_RIGHT);

  00076	6a 27		 push	 39			; 00000027H
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_08LOMCDCA@VK_RIGHT?$AA@
  0007d	57		 push	 edi
  0007e	ff d6		 call	 esi

; 1352 : 	PyModule_AddIntConstant(poModule, "VK_UP",		     VK_UP);

  00080	6a 26		 push	 38			; 00000026H
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_05PIGLHCBF@VK_UP?$AA@
  00087	57		 push	 edi
  00088	ff d6		 call	 esi
  0008a	83 c4 48	 add	 esp, 72			; 00000048H

; 1353 : 	PyModule_AddIntConstant(poModule, "VK_DOWN",	     VK_DOWN);

  0008d	6a 28		 push	 40			; 00000028H
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_07NLENKNCK@VK_DOWN?$AA@
  00094	57		 push	 edi
  00095	ff d6		 call	 esi

; 1354 : 	PyModule_AddIntConstant(poModule, "VK_HOME",	     VK_HOME);

  00097	6a 24		 push	 36			; 00000024H
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_07OMPILPEG@VK_HOME?$AA@
  0009e	57		 push	 edi
  0009f	ff d6		 call	 esi

; 1355 : 	PyModule_AddIntConstant(poModule, "VK_END",          VK_END);

  000a1	6a 23		 push	 35			; 00000023H
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_06LPJBNMHN@VK_END?$AA@
  000a8	57		 push	 edi
  000a9	ff d6		 call	 esi

; 1356 : 	PyModule_AddIntConstant(poModule, "VK_DELETE",	     VK_DELETE);

  000ab	6a 2e		 push	 46			; 0000002eH
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_09EABNPHOI@VK_DELETE?$AA@
  000b2	57		 push	 edi
  000b3	ff d6		 call	 esi

; 1357 : 
; 1358 : 	PyModule_AddIntConstant(poModule, "DIK_ESCAPE",      DIK_ESCAPE);

  000b5	6a 01		 push	 1
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BOHNMBC@DIK_ESCAPE?$AA@
  000bc	57		 push	 edi
  000bd	ff d6		 call	 esi

; 1359 : 	PyModule_AddIntConstant(poModule, "DIK_ESC",         DIK_ESCAPE);	//  

  000bf	6a 01		 push	 1
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_07CACBFKLO@DIK_ESC?$AA@
  000c6	57		 push	 edi
  000c7	ff d6		 call	 esi
  000c9	83 c4 48	 add	 esp, 72			; 00000048H

; 1360 : 	PyModule_AddIntConstant(poModule, "DIK_1",           DIK_1);

  000cc	6a 02		 push	 2
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_05GCLPJNBN@DIK_1?$AA@
  000d3	57		 push	 edi
  000d4	ff d6		 call	 esi

; 1361 : 	PyModule_AddIntConstant(poModule, "DIK_2",           DIK_2);

  000d6	6a 03		 push	 3
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_05EJJCMONO@DIK_2?$AA@
  000dd	57		 push	 edi
  000de	ff d6		 call	 esi

; 1362 : 	PyModule_AddIntConstant(poModule, "DIK_3",           DIK_3);

  000e0	6a 04		 push	 4
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_05FAIJPPJP@DIK_3?$AA@
  000e7	57		 push	 edi
  000e8	ff d6		 call	 esi

; 1363 : 	PyModule_AddIntConstant(poModule, "DIK_4",           DIK_4);

  000ea	6a 05		 push	 5
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_05BPMIGJFI@DIK_4?$AA@
  000f1	57		 push	 edi
  000f2	ff d6		 call	 esi

; 1364 : 	PyModule_AddIntConstant(poModule, "DIK_5",           DIK_5);

  000f4	6a 06		 push	 6
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_05GNDFIBJ@DIK_5?$AA@
  000fb	57		 push	 edi
  000fc	ff d6		 call	 esi

; 1365 : 	PyModule_AddIntConstant(poModule, "DIK_6",           DIK_6);

  000fe	6a 07		 push	 7
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_05CNPOALNK@DIK_6?$AA@
  00105	57		 push	 edi
  00106	ff d6		 call	 esi
  00108	83 c4 48	 add	 esp, 72			; 00000048H

; 1366 : 	PyModule_AddIntConstant(poModule, "DIK_7",           DIK_7);

  0010b	6a 08		 push	 8
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_05DEOFDKJL@DIK_7?$AA@
  00112	57		 push	 edi
  00113	ff d6		 call	 esi

; 1367 : 	PyModule_AddIntConstant(poModule, "DIK_8",           DIK_8);

  00115	6a 09		 push	 9
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_05LDHNCGFE@DIK_8?$AA@
  0011c	57		 push	 edi
  0011d	ff d6		 call	 esi

; 1368 : 	PyModule_AddIntConstant(poModule, "DIK_9",           DIK_9);

  0011f	6a 0a		 push	 10			; 0000000aH
  00121	68 00 00 00 00	 push	 OFFSET ??_C@_05KKGGBHBF@DIK_9?$AA@
  00126	57		 push	 edi
  00127	ff d6		 call	 esi

; 1369 : 	PyModule_AddIntConstant(poModule, "DIK_0",           DIK_0);

  00129	6a 0b		 push	 11			; 0000000bH
  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_05HLKEKMFM@DIK_0?$AA@
  00130	57		 push	 edi
  00131	ff d6		 call	 esi

; 1370 : 	PyModule_AddIntConstant(poModule, "DIK_MINUS",       DIK_MINUS);        /* - on main keyboard */

  00133	6a 0c		 push	 12			; 0000000cH
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_09DOHACMKC@DIK_MINUS?$AA@
  0013a	57		 push	 edi
  0013b	ff d6		 call	 esi

; 1371 : 	PyModule_AddIntConstant(poModule, "DIK_EQUALS",      DIK_EQUALS);         

  0013d	6a 0d		 push	 13			; 0000000dH
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KKCLPAPI@DIK_EQUALS?$AA@
  00144	57		 push	 edi
  00145	ff d6		 call	 esi
  00147	83 c4 48	 add	 esp, 72			; 00000048H

; 1372 : 	PyModule_AddIntConstant(poModule, "DIK_BACK",        DIK_BACK);           /* backspace */

  0014a	6a 0e		 push	 14			; 0000000eH
  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_08HHEEGKBL@DIK_BACK?$AA@
  00151	57		 push	 edi
  00152	ff d6		 call	 esi

; 1373 : 	PyModule_AddIntConstant(poModule, "DIK_TAB",         DIK_TAB);            

  00154	6a 0f		 push	 15			; 0000000fH
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_07MODNCMBL@DIK_TAB?$AA@
  0015b	57		 push	 edi
  0015c	ff d6		 call	 esi

; 1374 : 	PyModule_AddIntConstant(poModule, "DIK_Q",           DIK_Q);

  0015e	6a 10		 push	 16			; 00000010H
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_05HECPGLK@DIK_Q?$AA@
  00165	57		 push	 edi
  00166	ff d6		 call	 esi

; 1375 : 	PyModule_AddIntConstant(poModule, "DIK_W",           DIK_W);

  00168	6a 11		 push	 17			; 00000011H
  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_05FBBIFBDM@DIK_W?$AA@
  0016f	57		 push	 edi
  00170	ff d6		 call	 esi

; 1376 : 	PyModule_AddIntConstant(poModule, "DIK_E",           DIK_E);

  00172	6a 12		 push	 18			; 00000012H
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_05CJOMCBOP@DIK_E?$AA@
  00179	57		 push	 edi
  0017a	ff d6		 call	 esi

; 1377 : 	PyModule_AddIntConstant(poModule, "DIK_R",           DIK_R);

  0017c	6a 13		 push	 19			; 00000013H
  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_05CMGPKFHJ@DIK_R?$AA@
  00183	57		 push	 edi
  00184	ff d6		 call	 esi
  00186	83 c4 48	 add	 esp, 72			; 00000048H

; 1378 : 	PyModule_AddIntConstant(poModule, "DIK_T",           DIK_T);

  00189	6a 14		 push	 20			; 00000014H
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_05HKDFACPP@DIK_T?$AA@
  00190	57		 push	 edi
  00191	ff d6		 call	 esi

; 1379 : 	PyModule_AddIntConstant(poModule, "DIK_Y",           DIK_Y);

  00193	6a 15		 push	 21			; 00000015H
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_05MPJLHMLC@DIK_Y?$AA@
  0019a	57		 push	 edi
  0019b	ff d6		 call	 esi

; 1380 : 	PyModule_AddIntConstant(poModule, "DIK_U",           DIK_U);

  0019d	6a 16		 push	 22			; 00000016H
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_05GDCODDLO@DIK_U?$AA@
  001a4	57		 push	 edi
  001a5	ff d6		 call	 esi

; 1381 : 	PyModule_AddIntConstant(poModule, "DIK_I",           DIK_I);

  001a7	6a 17		 push	 23			; 00000017H
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_05IFFJGOOD@DIK_I?$AA@
  001ae	57		 push	 edi
  001af	ff d6		 call	 esi

; 1382 : 	PyModule_AddIntConstant(poModule, "DIK_O",           DIK_O);

  001b1	6a 18		 push	 24			; 00000018H
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_05NDADMJGF@DIK_O?$AA@
  001b8	57		 push	 edi
  001b9	ff d6		 call	 esi

; 1383 : 	PyModule_AddIntConstant(poModule, "DIK_P",           DIK_P);

  001bb	6a 19		 push	 25			; 00000019H
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_05BOFJMHPL@DIK_P?$AA@
  001c2	57		 push	 edi
  001c3	ff d6		 call	 esi
  001c5	83 c4 48	 add	 esp, 72			; 00000048H

; 1384 : 	PyModule_AddIntConstant(poModule, "DIK_LBRACKET",    DIK_LBRACKET);       

  001c8	6a 1a		 push	 26			; 0000001aH
  001ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EFJDLCEF@DIK_LBRACKET?$AA@
  001cf	57		 push	 edi
  001d0	ff d6		 call	 esi

; 1385 : 	PyModule_AddIntConstant(poModule, "DIK_RBRACKET",    DIK_RBRACKET);       

  001d2	6a 1b		 push	 27			; 0000001bH
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CBJBCLKG@DIK_RBRACKET?$AA@
  001d9	57		 push	 edi
  001da	ff d6		 call	 esi

; 1386 : 	PyModule_AddIntConstant(poModule, "DIK_RETURN",      DIK_RETURN);         /* Enter on main keyboard */

  001dc	6a 1c		 push	 28			; 0000001cH
  001de	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JLNKBJCL@DIK_RETURN?$AA@
  001e3	57		 push	 edi
  001e4	ff d6		 call	 esi

; 1387 : 	PyModule_AddIntConstant(poModule, "DIK_LCONTROL",    DIK_LCONTROL);       

  001e6	6a 1d		 push	 29			; 0000001dH
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ODLLDAI@DIK_LCONTROL?$AA@
  001ed	57		 push	 edi
  001ee	ff d6		 call	 esi

; 1388 : 	PyModule_AddIntConstant(poModule, "DIK_A",           DIK_A);

  001f0	6a 1e		 push	 30			; 0000001eH
  001f2	68 00 00 00 00	 push	 OFFSET ??_C@_05ENIAOEOL@DIK_A?$AA@
  001f7	57		 push	 edi
  001f8	ff d6		 call	 esi

; 1389 : 	PyModule_AddIntConstant(poModule, "DIK_S",           DIK_S);

  001fa	6a 1f		 push	 31			; 0000001fH
  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_05DFHEJEDI@DIK_S?$AA@
  00201	57		 push	 edi
  00202	ff d6		 call	 esi
  00204	83 c4 48	 add	 esp, 72			; 00000048H

; 1390 : 	PyModule_AddIntConstant(poModule, "DIK_D",           DIK_D);

  00207	6a 20		 push	 32			; 00000020H
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_05DAPHBAKO@DIK_D?$AA@
  0020e	57		 push	 edi
  0020f	ff d6		 call	 esi

; 1391 : 	PyModule_AddIntConstant(poModule, "DIK_F",           DIK_F);

  00211	6a 21		 push	 33			; 00000021H
  00213	68 00 00 00 00	 push	 OFFSET ??_C@_05CMBHCCM@DIK_F?$AA@
  00218	57		 push	 edi
  00219	ff d6		 call	 esi

; 1392 : 	PyModule_AddIntConstant(poModule, "DIK_G",           DIK_G);

  0021b	6a 22		 push	 34			; 00000022H
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_05BLNKEDGN@DIK_G?$AA@
  00222	57		 push	 edi
  00223	ff d6		 call	 esi

; 1393 : 	PyModule_AddIntConstant(poModule, "DIK_H",           DIK_H);

  00225	6a 23		 push	 35			; 00000023H
  00227	68 00 00 00 00	 push	 OFFSET ??_C@_05JMECFPKC@DIK_H?$AA@
  0022c	57		 push	 edi
  0022d	ff d6		 call	 esi

; 1394 : 	PyModule_AddIntConstant(poModule, "DIK_J",           DIK_J);

  0022f	6a 24		 push	 36			; 00000024H
  00231	68 00 00 00 00	 push	 OFFSET ??_C@_05KOHEDNCA@DIK_J?$AA@
  00236	57		 push	 edi
  00237	ff d6		 call	 esi

; 1395 : 	PyModule_AddIntConstant(poModule, "DIK_K",           DIK_K);

  00239	6a 25		 push	 37			; 00000025H
  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_05LHGPAMGB@DIK_K?$AA@
  00240	57		 push	 edi
  00241	ff d6		 call	 esi
  00243	83 c4 48	 add	 esp, 72			; 00000048H

; 1396 : 	PyModule_AddIntConstant(poModule, "DIK_L",           DIK_L);

  00246	6a 26		 push	 38			; 00000026H
  00248	68 00 00 00 00	 push	 OFFSET ??_C@_05PICOJKKG@DIK_L?$AA@
  0024d	57		 push	 edi
  0024e	ff d6		 call	 esi

; 1397 : 	PyModule_AddIntConstant(poModule, "DIK_SEMICOLON",   DIK_SEMICOLON);      

  00250	6a 27		 push	 39			; 00000027H
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NEECDLLB@DIK_SEMICOLON?$AA@
  00257	57		 push	 edi
  00258	ff d6		 call	 esi

; 1398 : 	PyModule_AddIntConstant(poModule, "DIK_APOSTROPHE",  DIK_APOSTROPHE);     

  0025a	6a 28		 push	 40			; 00000028H
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JDEKLKAM@DIK_APOSTROPHE?$AA@
  00261	57		 push	 edi
  00262	ff d6		 call	 esi

; 1399 : 	PyModule_AddIntConstant(poModule, "DIK_GRAVE",       DIK_GRAVE);          /* accent grave */

  00264	6a 29		 push	 41			; 00000029H
  00266	68 00 00 00 00	 push	 OFFSET ??_C@_09MOGGLCIP@DIK_GRAVE?$AA@
  0026b	57		 push	 edi
  0026c	ff d6		 call	 esi

; 1400 : 	PyModule_AddIntConstant(poModule, "DIK_LSHIFT",      DIK_LSHIFT);         

  0026e	6a 2a		 push	 42			; 0000002aH
  00270	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GNGJHMON@DIK_LSHIFT?$AA@
  00275	57		 push	 edi
  00276	ff d6		 call	 esi

; 1401 : 	PyModule_AddIntConstant(poModule, "DIK_BACKSLASH",   DIK_BACKSLASH);      

  00278	6a 2b		 push	 43			; 0000002bH
  0027a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DGKNNOHE@DIK_BACKSLASH?$AA@
  0027f	57		 push	 edi
  00280	ff d6		 call	 esi
  00282	83 c4 48	 add	 esp, 72			; 00000048H

; 1402 : 	PyModule_AddIntConstant(poModule, "DIK_Z",           DIK_Z);

  00285	6a 2c		 push	 44			; 0000002cH
  00287	68 00 00 00 00	 push	 OFFSET ??_C@_05OELGCPHB@DIK_Z?$AA@
  0028c	57		 push	 edi
  0028d	ff d6		 call	 esi

; 1403 : 	PyModule_AddIntConstant(poModule, "DIK_X",           DIK_X);

  0028f	6a 2d		 push	 45			; 0000002dH
  00291	68 00 00 00 00	 push	 OFFSET ??_C@_05NGIAENPD@DIK_X?$AA@
  00296	57		 push	 edi
  00297	ff d6		 call	 esi

; 1404 : 	PyModule_AddIntConstant(poModule, "DIK_C",           DIK_C);

  00299	6a 2e		 push	 46			; 0000002eH
  0029b	68 00 00 00 00	 push	 OFFSET ??_C@_05HPLGIGGJ@DIK_C?$AA@
  002a0	57		 push	 edi
  002a1	ff d6		 call	 esi

; 1405 : 	PyModule_AddIntConstant(poModule, "DIK_V",           DIK_V);

  002a3	6a 2f		 push	 47			; 0000002fH
  002a5	68 00 00 00 00	 push	 OFFSET ??_C@_05EIADGAHN@DIK_V?$AA@
  002aa	57		 push	 edi
  002ab	ff d6		 call	 esi

; 1406 : 	PyModule_AddIntConstant(poModule, "DIK_B",           DIK_B);

  002ad	6a 30		 push	 48			; 00000030H
  002af	68 00 00 00 00	 push	 OFFSET ??_C@_05GGKNLHCI@DIK_B?$AA@
  002b4	57		 push	 edi
  002b5	ff d6		 call	 esi

; 1407 : 	PyModule_AddIntConstant(poModule, "DIK_N",           DIK_N);

  002b7	6a 31		 push	 49			; 00000031H
  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_05MKBIPICE@DIK_N?$AA@
  002be	57		 push	 edi
  002bf	ff d6		 call	 esi
  002c1	83 c4 48	 add	 esp, 72			; 00000048H

; 1408 : 	PyModule_AddIntConstant(poModule, "DIK_M",           DIK_M);

  002c4	6a 32		 push	 50			; 00000032H
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_05OBDFKLOH@DIK_M?$AA@
  002cb	57		 push	 edi
  002cc	ff d6		 call	 esi

; 1409 : 	PyModule_AddIntConstant(poModule, "DIK_COMMA",       DIK_COMMA);          

  002ce	6a 33		 push	 51			; 00000033H
  002d0	68 00 00 00 00	 push	 OFFSET ??_C@_09PDEOJFIH@DIK_COMMA?$AA@
  002d5	57		 push	 edi
  002d6	ff d6		 call	 esi

; 1410 : 	PyModule_AddIntConstant(poModule, "DIK_PERIOD",      DIK_PERIOD);         /* . on main keyboard */

  002d8	6a 34		 push	 52			; 00000034H
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHNLMNCM@DIK_PERIOD?$AA@
  002df	57		 push	 edi
  002e0	ff d6		 call	 esi

; 1411 : 	PyModule_AddIntConstant(poModule, "DIK_SLASH",       DIK_SLASH);          /* / on main keyboard */

  002e2	6a 35		 push	 53			; 00000035H
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_09DKJEGHEH@DIK_SLASH?$AA@
  002e9	57		 push	 edi
  002ea	ff d6		 call	 esi

; 1412 : 	PyModule_AddIntConstant(poModule, "DIK_RSHIFT",      DIK_RSHIFT);         

  002ec	6a 36		 push	 54			; 00000036H
  002ee	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FKIIJLHO@DIK_RSHIFT?$AA@
  002f3	57		 push	 edi
  002f4	ff d6		 call	 esi

; 1413 : 	PyModule_AddIntConstant(poModule, "DIK_MULTIPLY",    DIK_MULTIPLY);       /* * on numeric keypad */

  002f6	6a 37		 push	 55			; 00000037H
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DHLLGHHC@DIK_MULTIPLY?$AA@
  002fd	57		 push	 edi
  002fe	ff d6		 call	 esi
  00300	83 c4 48	 add	 esp, 72			; 00000048H

; 1414 : 	PyModule_AddIntConstant(poModule, "DIK_LALT",        DIK_LMENU);          /* left Alt */

  00303	6a 38		 push	 56			; 00000038H
  00305	68 00 00 00 00	 push	 OFFSET ??_C@_08OHCJNNJ@DIK_LALT?$AA@
  0030a	57		 push	 edi
  0030b	ff d6		 call	 esi

; 1415 : 	PyModule_AddIntConstant(poModule, "DIK_SPACE",       DIK_SPACE);          

  0030d	6a 39		 push	 57			; 00000039H
  0030f	68 00 00 00 00	 push	 OFFSET ??_C@_09DGAMMAPJ@DIK_SPACE?$AA@
  00314	57		 push	 edi
  00315	ff d6		 call	 esi

; 1416 : 	PyModule_AddIntConstant(poModule, "DIK_CAPITAL",     DIK_CAPITAL);        

  00317	6a 3a		 push	 58			; 0000003aH
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KEADBGIC@DIK_CAPITAL?$AA@
  0031e	57		 push	 edi
  0031f	ff d6		 call	 esi

; 1417 : 	PyModule_AddIntConstant(poModule, "DIK_F1",          DIK_F1);

  00321	6a 3b		 push	 59			; 0000003bH
  00323	68 00 00 00 00	 push	 OFFSET ??_C@_06PEIHKKCD@DIK_F1?$AA@
  00328	57		 push	 edi
  00329	ff d6		 call	 esi

; 1418 : 	PyModule_AddIntConstant(poModule, "DIK_F2",          DIK_F2);

  0032b	6a 3c		 push	 60			; 0000003cH
  0032d	68 00 00 00 00	 push	 OFFSET ??_C@_06NPKKPJOA@DIK_F2?$AA@
  00332	57		 push	 edi
  00333	ff d6		 call	 esi

; 1419 : 	PyModule_AddIntConstant(poModule, "DIK_F3",          DIK_F3);

  00335	6a 3d		 push	 61			; 0000003dH
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_06MGLBMIKB@DIK_F3?$AA@
  0033c	57		 push	 edi
  0033d	ff d6		 call	 esi
  0033f	83 c4 48	 add	 esp, 72			; 00000048H

; 1420 : 	PyModule_AddIntConstant(poModule, "DIK_F4",          DIK_F4);

  00342	6a 3e		 push	 62			; 0000003eH
  00344	68 00 00 00 00	 push	 OFFSET ??_C@_06IJPAFOGG@DIK_F4?$AA@
  00349	57		 push	 edi
  0034a	ff d6		 call	 esi

; 1421 : 	PyModule_AddIntConstant(poModule, "DIK_F5",          DIK_F5);

  0034c	6a 3f		 push	 63			; 0000003fH
  0034e	68 00 00 00 00	 push	 OFFSET ??_C@_06JAOLGPCH@DIK_F5?$AA@
  00353	57		 push	 edi
  00354	ff d6		 call	 esi

; 1422 : 	PyModule_AddIntConstant(poModule, "DIK_F6",          DIK_F6);

  00356	6a 40		 push	 64			; 00000040H
  00358	68 00 00 00 00	 push	 OFFSET ??_C@_06LLMGDMOE@DIK_F6?$AA@
  0035d	57		 push	 edi
  0035e	ff d6		 call	 esi

; 1423 : 	PyModule_AddIntConstant(poModule, "DIK_F7",          DIK_F7);

  00360	6a 41		 push	 65			; 00000041H
  00362	68 00 00 00 00	 push	 OFFSET ??_C@_06KCNNANKF@DIK_F7?$AA@
  00367	57		 push	 edi
  00368	ff d6		 call	 esi

; 1424 : 	PyModule_AddIntConstant(poModule, "DIK_F8",          DIK_F8);

  0036a	6a 42		 push	 66			; 00000042H
  0036c	68 00 00 00 00	 push	 OFFSET ??_C@_06CFEFBBGK@DIK_F8?$AA@
  00371	57		 push	 edi
  00372	ff d6		 call	 esi

; 1425 : 	PyModule_AddIntConstant(poModule, "DIK_F9",          DIK_F9);

  00374	6a 43		 push	 67			; 00000043H
  00376	68 00 00 00 00	 push	 OFFSET ??_C@_06DMFOCACL@DIK_F9?$AA@
  0037b	57		 push	 edi
  0037c	ff d6		 call	 esi
  0037e	83 c4 48	 add	 esp, 72			; 00000048H

; 1426 : 	PyModule_AddIntConstant(poModule, "DIK_F10",         DIK_F10);

  00381	6a 44		 push	 68			; 00000044H
  00383	68 00 00 00 00	 push	 OFFSET ??_C@_07HNNFMACL@DIK_F10?$AA@
  00388	57		 push	 edi
  00389	ff d6		 call	 esi

; 1427 : 	PyModule_AddIntConstant(poModule, "DIK_NUMLOCK",     DIK_NUMLOCK);

  0038b	6a 45		 push	 69			; 00000045H
  0038d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BAOCLHIM@DIK_NUMLOCK?$AA@
  00392	57		 push	 edi
  00393	ff d6		 call	 esi

; 1428 : 	PyModule_AddIntConstant(poModule, "DIK_SCROLL",      DIK_SCROLL);         /* Scroll Lock */

  00395	6a 46		 push	 70			; 00000046H
  00397	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HPJOFPCB@DIK_SCROLL?$AA@
  0039c	57		 push	 edi
  0039d	ff d6		 call	 esi

; 1429 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD7",     DIK_NUMPAD7);        

  0039f	6a 47		 push	 71			; 00000047H
  003a1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NDOIJKED@DIK_NUMPAD7?$AA@
  003a6	57		 push	 edi
  003a7	ff d6		 call	 esi

; 1430 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD8",     DIK_NUMPAD8);        

  003a9	6a 48		 push	 72			; 00000048H
  003ab	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FEHAIGIM@DIK_NUMPAD8?$AA@
  003b0	57		 push	 edi
  003b1	ff d6		 call	 esi

; 1431 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD9",     DIK_NUMPAD9);        

  003b3	6a 49		 push	 73			; 00000049H
  003b5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@ENGLLHMN@DIK_NUMPAD9?$AA@
  003ba	57		 push	 edi
  003bb	ff d6		 call	 esi
  003bd	83 c4 48	 add	 esp, 72			; 00000048H

; 1432 : 	PyModule_AddIntConstant(poModule, "DIK_SUBTRACT",    DIK_SUBTRACT);       /* - on numeric keypad */

  003c0	6a 4a		 push	 74			; 0000004aH
  003c2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ECOBCKNF@DIK_SUBTRACT?$AA@
  003c7	57		 push	 edi
  003c8	ff d6		 call	 esi

; 1433 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD4",     DIK_NUMPAD4);        

  003ca	6a 4b		 push	 75			; 0000004bH
  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PIMFMJIA@DIK_NUMPAD4?$AA@
  003d1	57		 push	 edi
  003d2	ff d6		 call	 esi

; 1434 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD5",     DIK_NUMPAD5);        

  003d4	6a 4c		 push	 76			; 0000004cH
  003d6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OBNOPIMB@DIK_NUMPAD5?$AA@
  003db	57		 push	 edi
  003dc	ff d6		 call	 esi

; 1435 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD6",     DIK_NUMPAD6);        

  003de	6a 4d		 push	 77			; 0000004dH
  003e0	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MKPDKLAC@DIK_NUMPAD6?$AA@
  003e5	57		 push	 edi
  003e6	ff d6		 call	 esi

; 1436 : 	PyModule_AddIntConstant(poModule, "DIK_ADD",         DIK_ADD);            /* + on numeric keypad */

  003e8	6a 4e		 push	 78			; 0000004eH
  003ea	68 00 00 00 00	 push	 OFFSET ??_C@_07PJGLOONL@DIK_ADD?$AA@
  003ef	57		 push	 edi
  003f0	ff d6		 call	 esi

; 1437 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD1",     DIK_NUMPAD1);        

  003f2	6a 4f		 push	 79			; 0000004fH
  003f4	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IFLCDNMF@DIK_NUMPAD1?$AA@
  003f9	57		 push	 edi
  003fa	ff d6		 call	 esi
  003fc	83 c4 48	 add	 esp, 72			; 00000048H

; 1438 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD2",     DIK_NUMPAD2);        

  003ff	6a 50		 push	 80			; 00000050H
  00401	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KOJPGOAG@DIK_NUMPAD2?$AA@
  00406	57		 push	 edi
  00407	ff d6		 call	 esi

; 1439 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD3",     DIK_NUMPAD3);        

  00409	6a 51		 push	 81			; 00000051H
  0040b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LHIEFPEH@DIK_NUMPAD3?$AA@
  00410	57		 push	 edi
  00411	ff d6		 call	 esi

; 1440 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPAD0",     DIK_NUMPAD0);        

  00413	6a 52		 push	 82			; 00000052H
  00415	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JMKJAMIE@DIK_NUMPAD0?$AA@
  0041a	57		 push	 edi
  0041b	ff d6		 call	 esi

; 1441 : 	PyModule_AddIntConstant(poModule, "DIK_DECIMAL",     DIK_DECIMAL);        /* . on numeric keypad */

  0041d	6a 53		 push	 83			; 00000053H
  0041f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PCNKFDKI@DIK_DECIMAL?$AA@
  00424	57		 push	 edi
  00425	ff d6		 call	 esi

; 1442 : 	PyModule_AddIntConstant(poModule, "DIK_F11",         DIK_F11);            

  00427	6a 57		 push	 87			; 00000057H
  00429	68 00 00 00 00	 push	 OFFSET ??_C@_07GEMOPBGK@DIK_F11?$AA@
  0042e	57		 push	 edi
  0042f	ff d6		 call	 esi

; 1443 : 	PyModule_AddIntConstant(poModule, "DIK_F12",         DIK_F12);            

  00431	6a 58		 push	 88			; 00000058H
  00433	68 00 00 00 00	 push	 OFFSET ??_C@_07EPODKCKJ@DIK_F12?$AA@
  00438	57		 push	 edi
  00439	ff d6		 call	 esi
  0043b	83 c4 48	 add	 esp, 72			; 00000048H

; 1444 : 	PyModule_AddIntConstant(poModule, "DIK_NEXTTRACK",   DIK_NEXTTRACK);      /* Next Track */

  0043e	68 99 00 00 00	 push	 153			; 00000099H
  00443	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DEOEEHEE@DIK_NEXTTRACK?$AA@
  00448	57		 push	 edi
  00449	ff d6		 call	 esi

; 1445 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPADENTER", DIK_NUMPADENTER);    /* Enter on numeric keypad */

  0044b	68 9c 00 00 00	 push	 156			; 0000009cH
  00450	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OLMCJCJF@DIK_NUMPADENTER?$AA@
  00455	57		 push	 edi
  00456	ff d6		 call	 esi

; 1446 : 	PyModule_AddIntConstant(poModule, "DIK_RCONTROL",    DIK_RCONTROL);       

  00458	68 9d 00 00 00	 push	 157			; 0000009dH
  0045d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GKDJCKOL@DIK_RCONTROL?$AA@
  00462	57		 push	 edi
  00463	ff d6		 call	 esi

; 1447 : 	PyModule_AddIntConstant(poModule, "DIK_MUTE",        DIK_MUTE);           /* Mute */

  00465	68 a0 00 00 00	 push	 160			; 000000a0H
  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_08KNIFKFHJ@DIK_MUTE?$AA@
  0046f	57		 push	 edi
  00470	ff d6		 call	 esi

; 1448 : 	PyModule_AddIntConstant(poModule, "DIK_CALCULATOR",  DIK_CALCULATOR);     /* Calculator */

  00472	68 a1 00 00 00	 push	 161			; 000000a1H
  00477	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OJEJDHIP@DIK_CALCULATOR?$AA@
  0047c	57		 push	 edi
  0047d	ff d6		 call	 esi

; 1449 : 	PyModule_AddIntConstant(poModule, "DIK_PLAYPAUSE",   DIK_PLAYPAUSE);      /* Play / Pause */

  0047f	68 a2 00 00 00	 push	 162			; 000000a2H
  00484	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ECAMOKPG@DIK_PLAYPAUSE?$AA@
  00489	57		 push	 edi
  0048a	ff d6		 call	 esi
  0048c	83 c4 48	 add	 esp, 72			; 00000048H

; 1450 : 	PyModule_AddIntConstant(poModule, "DIK_MEDIASTOP",   DIK_MEDIASTOP);      /* Media Stop */

  0048f	68 a4 00 00 00	 push	 164			; 000000a4H
  00494	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FLFOAKOG@DIK_MEDIASTOP?$AA@
  00499	57		 push	 edi
  0049a	ff d6		 call	 esi

; 1451 : 	PyModule_AddIntConstant(poModule, "DIK_VOLUMEDOWN",  DIK_VOLUMEDOWN);     /* Volume - */

  0049c	68 ae 00 00 00	 push	 174			; 000000aeH
  004a1	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FKHBCEAD@DIK_VOLUMEDOWN?$AA@
  004a6	57		 push	 edi
  004a7	ff d6		 call	 esi

; 1452 : 	PyModule_AddIntConstant(poModule, "DIK_VOLUMEUP",    DIK_VOLUMEUP);       /* Volume + */

  004a9	68 b0 00 00 00	 push	 176			; 000000b0H
  004ae	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GPHLGHED@DIK_VOLUMEUP?$AA@
  004b3	57		 push	 edi
  004b4	ff d6		 call	 esi

; 1453 : 	PyModule_AddIntConstant(poModule, "DIK_WEBHOME",     DIK_WEBHOME);        /* Web home */

  004b6	68 b2 00 00 00	 push	 178			; 000000b2H
  004bb	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IEADBFND@DIK_WEBHOME?$AA@
  004c0	57		 push	 edi
  004c1	ff d6		 call	 esi

; 1454 : 	PyModule_AddIntConstant(poModule, "DIK_NUMPADCOMMA", DIK_NUMPADCOMMA);    /* , on numeric keypad (NEC PC98) */

  004c3	68 b3 00 00 00	 push	 179			; 000000b3H
  004c8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ECBGFAAH@DIK_NUMPADCOMMA?$AA@
  004cd	57		 push	 edi
  004ce	ff d6		 call	 esi

; 1455 : 	PyModule_AddIntConstant(poModule, "DIK_DIVIDE",      DIK_DIVIDE);         /* / on numeric keypad */

  004d0	68 b5 00 00 00	 push	 181			; 000000b5H
  004d5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HDEGMNOK@DIK_DIVIDE?$AA@
  004da	57		 push	 edi
  004db	ff d6		 call	 esi
  004dd	83 c4 48	 add	 esp, 72			; 00000048H

; 1456 : 	PyModule_AddIntConstant(poModule, "DIK_SYSRQ",       DIK_SYSRQ);          

  004e0	68 b7 00 00 00	 push	 183			; 000000b7H
  004e5	68 00 00 00 00	 push	 OFFSET ??_C@_09PCEGCDIO@DIK_SYSRQ?$AA@
  004ea	57		 push	 edi
  004eb	ff d6		 call	 esi

; 1457 : 	PyModule_AddIntConstant(poModule, "DIK_RALT",        DIK_RMENU);          /* right Alt */

  004ed	68 b8 00 00 00	 push	 184			; 000000b8H
  004f2	68 00 00 00 00	 push	 OFFSET ??_C@_08NBKCLEDK@DIK_RALT?$AA@
  004f7	57		 push	 edi
  004f8	ff d6		 call	 esi

; 1458 : 	PyModule_AddIntConstant(poModule, "DIK_PAUSE",       DIK_PAUSE);          /* Pause */

  004fa	68 c5 00 00 00	 push	 197			; 000000c5H
  004ff	68 00 00 00 00	 push	 OFFSET ??_C@_09COEFGPNN@DIK_PAUSE?$AA@
  00504	57		 push	 edi
  00505	ff d6		 call	 esi

; 1459 : 	PyModule_AddIntConstant(poModule, "DIK_HOME",        DIK_HOME);           /* Home on arrow keypad */

  00507	68 c7 00 00 00	 push	 199			; 000000c7H
  0050c	68 00 00 00 00	 push	 OFFSET ??_C@_08EJDGAFAN@DIK_HOME?$AA@
  00511	57		 push	 edi
  00512	ff d6		 call	 esi

; 1460 : 	PyModule_AddIntConstant(poModule, "DIK_UP",          DIK_UP);             /* UpArrow on arrow keypad */

  00514	68 c8 00 00 00	 push	 200			; 000000c8H
  00519	68 00 00 00 00	 push	 OFFSET ??_C@_06JGABONOM@DIK_UP?$AA@
  0051e	57		 push	 edi
  0051f	ff d6		 call	 esi

; 1461 : 	PyModule_AddIntConstant(poModule, "DIK_PGUP",        DIK_PRIOR);          /* PgUp on arrow keypad */

  00521	68 c9 00 00 00	 push	 201			; 000000c9H
  00526	68 00 00 00 00	 push	 OFFSET ??_C@_08PJJCOFHN@DIK_PGUP?$AA@
  0052b	57		 push	 edi
  0052c	ff d6		 call	 esi
  0052e	83 c4 48	 add	 esp, 72			; 00000048H

; 1462 : 	PyModule_AddIntConstant(poModule, "DIK_LEFT",        DIK_LEFT);           /* LeftArrow on arrow keypad */

  00531	68 cb 00 00 00	 push	 203			; 000000cbH
  00536	68 00 00 00 00	 push	 OFFSET ??_C@_08IMIHIPFI@DIK_LEFT?$AA@
  0053b	57		 push	 edi
  0053c	ff d6		 call	 esi

; 1463 : 	PyModule_AddIntConstant(poModule, "DIK_RIGHT",       DIK_RIGHT);          /* RightArrow on arrow keypad */

  0053e	68 cd 00 00 00	 push	 205			; 000000cdH
  00543	68 00 00 00 00	 push	 OFFSET ??_C@_09OKEHHFIC@DIK_RIGHT?$AA@
  00548	57		 push	 edi
  00549	ff d6		 call	 esi

; 1464 : 	PyModule_AddIntConstant(poModule, "DIK_END",         DIK_END);            /* End on arrow keypad */

  0054b	68 cf 00 00 00	 push	 207			; 000000cfH
  00550	68 00 00 00 00	 push	 OFFSET ??_C@_07HLJOPMFK@DIK_END?$AA@
  00555	57		 push	 edi
  00556	ff d6		 call	 esi

; 1465 : 	PyModule_AddIntConstant(poModule, "DIK_DOWN",        DIK_DOWN);           /* DownArrow on arrow keypad */

  00558	68 d0 00 00 00	 push	 208			; 000000d0H
  0055d	68 00 00 00 00	 push	 OFFSET ??_C@_08HOIDBHGB@DIK_DOWN?$AA@
  00562	57		 push	 edi
  00563	ff d6		 call	 esi

; 1466 : 	PyModule_AddIntConstant(poModule, "DIK_PGDN",        DIK_NEXT);           /* PgDn on arrow keypad */

  00565	68 d1 00 00 00	 push	 209			; 000000d1H
  0056a	68 00 00 00 00	 push	 OFFSET ??_C@_08DADHBDOF@DIK_PGDN?$AA@
  0056f	57		 push	 edi
  00570	ff d6		 call	 esi

; 1467 : 	PyModule_AddIntConstant(poModule, "DIK_INSERT",      DIK_INSERT);         /* Insert on arrow keypad */

  00572	68 d2 00 00 00	 push	 210			; 000000d2H
  00577	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MGNAFAII@DIK_INSERT?$AA@
  0057c	57		 push	 edi
  0057d	ff d6		 call	 esi
  0057f	83 c4 48	 add	 esp, 72			; 00000048H

; 1468 : 	PyModule_AddIntConstant(poModule, "DIK_DELETE",      DIK_DELETE);         /* Delete on arrow keypad */

  00582	68 d3 00 00 00	 push	 211			; 000000d3H
  00587	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HICEJOHK@DIK_DELETE?$AA@
  0058c	57		 push	 edi
  0058d	ff d6		 call	 esi

; 1469 : 	PyModule_AddIntConstant(poModule, "DIK_LWIN",        DIK_LWIN);           /* Left Windows key */

  0058f	68 db 00 00 00	 push	 219			; 000000dbH
  00594	68 00 00 00 00	 push	 OFFSET ??_C@_08MNOGKNKK@DIK_LWIN?$AA@
  00599	57		 push	 edi
  0059a	ff d6		 call	 esi

; 1470 : 	PyModule_AddIntConstant(poModule, "DIK_RWIN",        DIK_RWIN);           /* Right Windows key */

  0059c	68 dc 00 00 00	 push	 220			; 000000dcH
  005a1	68 00 00 00 00	 push	 OFFSET ??_C@_08BCDGIEEJ@DIK_RWIN?$AA@
  005a6	57		 push	 edi
  005a7	ff d6		 call	 esi

; 1471 : 	PyModule_AddIntConstant(poModule, "DIK_APPS",        DIK_APPS);           /* AppMenu key */

  005a9	68 dd 00 00 00	 push	 221			; 000000ddH
  005ae	68 00 00 00 00	 push	 OFFSET ??_C@_08EEDKKFEB@DIK_APPS?$AA@
  005b3	57		 push	 edi
  005b4	ff d6		 call	 esi

; 1472 : 
; 1473 : 	// Cursor
; 1474 : 	PyModule_AddIntConstant(poModule, "NORMAL",			CPythonApplication::CURSOR_SHAPE_NORMAL);

  005b6	6a 00		 push	 0
  005b8	68 00 00 00 00	 push	 OFFSET ??_C@_06IOJAGNKJ@NORMAL?$AA@
  005bd	57		 push	 edi
  005be	ff d6		 call	 esi

; 1475 : 	PyModule_AddIntConstant(poModule, "ATTACK",			CPythonApplication::CURSOR_SHAPE_ATTACK);

  005c0	6a 01		 push	 1
  005c2	68 00 00 00 00	 push	 OFFSET ??_C@_06JIJKOHKJ@ATTACK?$AA@
  005c7	57		 push	 edi
  005c8	ff d6		 call	 esi
  005ca	83 c4 48	 add	 esp, 72			; 00000048H

; 1476 : 	PyModule_AddIntConstant(poModule, "TARGET",			CPythonApplication::CURSOR_SHAPE_TARGET);

  005cd	6a 02		 push	 2
  005cf	68 00 00 00 00	 push	 OFFSET ??_C@_06JNJLBPLI@TARGET?$AA@
  005d4	57		 push	 edi
  005d5	ff d6		 call	 esi

; 1477 : 	PyModule_AddIntConstant(poModule, "TALK",			CPythonApplication::CURSOR_SHAPE_TALK);

  005d7	6a 03		 push	 3
  005d9	68 00 00 00 00	 push	 OFFSET ??_C@_04LNOLLMNL@TALK?$AA@
  005de	57		 push	 edi
  005df	ff d6		 call	 esi

; 1478 : 	PyModule_AddIntConstant(poModule, "CANT_GO",		CPythonApplication::CURSOR_SHAPE_CANT_GO);

  005e1	6a 04		 push	 4
  005e3	68 00 00 00 00	 push	 OFFSET ??_C@_07LGCIEODJ@CANT_GO?$AA@
  005e8	57		 push	 edi
  005e9	ff d6		 call	 esi

; 1479 : 	PyModule_AddIntConstant(poModule, "PICK",			CPythonApplication::CURSOR_SHAPE_PICK);

  005eb	6a 05		 push	 5
  005ed	68 00 00 00 00	 push	 OFFSET ??_C@_04IGIDHFMJ@PICK?$AA@
  005f2	57		 push	 edi
  005f3	ff d6		 call	 esi

; 1480 : 
; 1481 : 	PyModule_AddIntConstant(poModule, "DOOR",			CPythonApplication::CURSOR_SHAPE_DOOR);

  005f5	6a 06		 push	 6
  005f7	68 00 00 00 00	 push	 OFFSET ??_C@_04KEJCELCL@DOOR?$AA@
  005fc	57		 push	 edi
  005fd	ff d6		 call	 esi

; 1482 : 	PyModule_AddIntConstant(poModule, "CHAIR",			CPythonApplication::CURSOR_SHAPE_CHAIR);

  005ff	6a 07		 push	 7
  00601	68 00 00 00 00	 push	 OFFSET ??_C@_05HLBMIDNH@CHAIR?$AA@
  00606	57		 push	 edi
  00607	ff d6		 call	 esi
  00609	83 c4 48	 add	 esp, 72			; 00000048H

; 1483 : 	PyModule_AddIntConstant(poModule, "MAGIC",			CPythonApplication::CURSOR_SHAPE_MAGIC);

  0060c	6a 08		 push	 8
  0060e	68 00 00 00 00	 push	 OFFSET ??_C@_05DKLEPMBK@MAGIC?$AA@
  00613	57		 push	 edi
  00614	ff d6		 call	 esi

; 1484 : 	PyModule_AddIntConstant(poModule, "BUY",			CPythonApplication::CURSOR_SHAPE_BUY);

  00616	6a 09		 push	 9
  00618	68 00 00 00 00	 push	 OFFSET ??_C@_03OOKILKBD@BUY?$AA@
  0061d	57		 push	 edi
  0061e	ff d6		 call	 esi

; 1485 : 	PyModule_AddIntConstant(poModule, "SELL",			CPythonApplication::CURSOR_SHAPE_SELL);

  00620	6a 0a		 push	 10			; 0000000aH
  00622	68 00 00 00 00	 push	 OFFSET ??_C@_04MPOIGBFL@SELL?$AA@
  00627	57		 push	 edi
  00628	ff d6		 call	 esi

; 1486 : 
; 1487 : 	PyModule_AddIntConstant(poModule, "CAMERA_ROTATE",	CPythonApplication::CURSOR_SHAPE_CAMERA_ROTATE);

  0062a	6a 0b		 push	 11			; 0000000bH
  0062c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MAJOJEIM@CAMERA_ROTATE?$AA@
  00631	57		 push	 edi
  00632	ff d6		 call	 esi

; 1488 : 	PyModule_AddIntConstant(poModule, "HSIZE",			CPythonApplication::CURSOR_SHAPE_HSIZE);

  00634	6a 0c		 push	 12			; 0000000cH
  00636	68 00 00 00 00	 push	 OFFSET ??_C@_05NILMGENH@HSIZE?$AA@
  0063b	57		 push	 edi
  0063c	ff d6		 call	 esi

; 1489 : 	PyModule_AddIntConstant(poModule, "VSIZE",			CPythonApplication::CURSOR_SHAPE_VSIZE);

  0063e	6a 0d		 push	 13			; 0000000dH
  00640	68 00 00 00 00	 push	 OFFSET ??_C@_05OBGAAHDM@VSIZE?$AA@
  00645	57		 push	 edi
  00646	ff d6		 call	 esi
  00648	83 c4 48	 add	 esp, 72			; 00000048H

; 1490 : 	PyModule_AddIntConstant(poModule, "HVSIZE",			CPythonApplication::CURSOR_SHAPE_HVSIZE);

  0064b	6a 0e		 push	 14			; 0000000eH
  0064d	68 00 00 00 00	 push	 OFFSET ??_C@_06LKCKECPP@HVSIZE?$AA@
  00652	57		 push	 edi
  00653	ff d6		 call	 esi

; 1491 : 
; 1492 : 	PyModule_AddIntConstant(poModule, "CAMERA_TO_POSITIVE",		CPythonApplication::CAMERA_TO_POSITIVE);

  00655	6a 01		 push	 1
  00657	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BFBNCJCC@CAMERA_TO_POSITIVE?$AA@
  0065c	57		 push	 edi
  0065d	ff d6		 call	 esi

; 1493 : 	PyModule_AddIntConstant(poModule, "CAMERA_TO_NEGATIVE",		CPythonApplication::CAMERA_TO_NEGITIVE);

  0065f	6a ff		 push	 -1
  00661	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JPBNJGLJ@CAMERA_TO_NEGATIVE?$AA@
  00666	57		 push	 edi
  00667	ff d6		 call	 esi

; 1494 : 	PyModule_AddIntConstant(poModule, "CAMERA_STOP",			CPythonApplication::CAMERA_STOP);

  00669	6a 00		 push	 0
  0066b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJFGNKPE@CAMERA_STOP?$AA@
  00670	57		 push	 edi
  00671	ff d6		 call	 esi

; 1495 : 
; 1496 : #ifdef ENABLE_COSTUME_SYSTEM
; 1497 : 	PyModule_AddIntConstant(poModule, "ENABLE_COSTUME_SYSTEM",	1);

  00673	6a 01		 push	 1
  00675	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NNONEOJP@ENABLE_COSTUME_SYSTEM?$AA@
  0067a	57		 push	 edi
  0067b	ff d6		 call	 esi

; 1498 : #else
; 1499 : 	PyModule_AddIntConstant(poModule, "ENABLE_COSTUME_SYSTEM",	0);
; 1500 : #endif
; 1501 : 
; 1502 : #ifdef ENABLE_ENERGY_SYSTEM
; 1503 : 	PyModule_AddIntConstant(poModule, "ENABLE_ENERGY_SYSTEM",	1);

  0067d	6a 01		 push	 1
  0067f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JNPGDOCA@ENABLE_ENERGY_SYSTEM?$AA@
  00684	57		 push	 edi
  00685	ff d6		 call	 esi
  00687	83 c4 48	 add	 esp, 72			; 00000048H

; 1504 : #else
; 1505 : 	PyModule_AddIntConstant(poModule, "ENABLE_ENERGY_SYSTEM",	0);
; 1506 : #endif
; 1507 : 
; 1508 : #ifdef ENABLE_DRAGON_SOUL_SYSTEM
; 1509 : 	PyModule_AddIntConstant(poModule, "ENABLE_DRAGON_SOUL_SYSTEM",	1);

  0068a	6a 01		 push	 1
  0068c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MHKPDOOB@ENABLE_DRAGON_SOUL_SYSTEM?$AA@
  00691	57		 push	 edi
  00692	ff d6		 call	 esi

; 1510 : #else
; 1511 : 	PyModule_AddIntConstant(poModule, "ENABLE_DRAGON_SOUL_SYSTEM",	0);
; 1512 : #endif
; 1513 : 
; 1514 : #ifdef ENABLE_NEW_EQUIPMENT_SYSTEM
; 1515 : 	PyModule_AddIntConstant(poModule, "ENABLE_NEW_EQUIPMENT_SYSTEM",	1);

  00694	6a 01		 push	 1
  00696	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LNFCINHP@ENABLE_NEW_EQUIPMENT_SYSTEM?$AA@
  0069b	57		 push	 edi
  0069c	ff d6		 call	 esi

; 1516 : #else
; 1517 : 	PyModule_AddIntConstant(poModule, "ENABLE_NEW_EQUIPMENT_SYSTEM",	0);
; 1518 : #endif
; 1519 : 
; 1520 : #ifdef USE_OPENID
; 1521 : 	PyModule_AddIntConstant(poModule, "USE_OPENID",	1);
; 1522 : 	if (openid_test)
; 1523 : 		PyModule_AddIntConstant(poModule, "OPENID_TEST",	1);
; 1524 : 	else
; 1525 : 		PyModule_AddIntConstant(poModule, "OPENID_TEST",	0);
; 1526 : #else
; 1527 : 	PyModule_AddIntConstant(poModule, "USE_OPENID",	0);

  0069e	6a 00		 push	 0
  006a0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GJPKGMAC@USE_OPENID?$AA@
  006a5	57		 push	 edi
  006a6	ff d6		 call	 esi

; 1528 : 	PyModule_AddIntConstant(poModule, "OPENID_TEST",	0);

  006a8	6a 00		 push	 0
  006aa	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HKJKCDHH@OPENID_TEST?$AA@
  006af	57		 push	 edi
  006b0	ff d6		 call	 esi
  006b2	83 c4 30	 add	 esp, 48			; 00000030H
  006b5	5f		 pop	 edi
  006b6	5e		 pop	 esi

; 1529 : #endif /* USE_OPENID */
; 1530 : }

  006b7	c3		 ret	 0
?initapp@@YAXXZ ENDP					; initapp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ PROC ; CSingleton<UI::CWindowManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCWindowManager@UI@@@@SAAAVCWindowManager@UI@@XZ ENDP ; CSingleton<UI::CWindowManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonLauncher@@@@SAAAVCPythonLauncher@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonLauncher@@@@SAAAVCPythonLauncher@@XZ PROC ; CSingleton<CPythonLauncher>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A ; CSingleton<CPythonLauncher>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonLauncher@@@@SAAAVCPythonLauncher@@XZ ENDP ; CSingleton<CPythonLauncher>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\iosfwd
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\iosfwd
; File a:\vs\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2273 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 22		 je	 SHORT $LN19@Tidy

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 1c		 jb	 SHORT $LN19@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN14@Tidy
; File a:\vs\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@Tidy:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00028	53		 push	 ebx
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4
  00031	5b		 pop	 ebx
$LN19@Tidy:
; File a:\vs\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00032	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00035	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File a:\vs\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0003c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
; File a:\vs\vc\include\xstring

; 2286 : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\iosfwd
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\iosfwd
; File a:\vs\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 513  : 			: this->_Bx._Buf);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 513  : 			: this->_Bx._Buf);

  0000d	72 0a		 jb	 SHORT $LN5@Eos
; File a:\vs\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
; File a:\vs\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
; File a:\vs\vc\include\xstring

; 2238 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN5@Eos:
; File a:\vs\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
; File a:\vs\vc\include\xstring

; 2238 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 520  : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN5@c_str

; 1739 : 		return (this->_Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1740 : 		}

  00008	c3		 ret	 0
$LN5@c_str:

; 1739 : 		return (this->_Myptr());

  00009	8b c1		 mov	 eax, ecx

; 1740 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\iosfwd
; File a:\vs\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00003	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00007	72 0a		 jb	 SHORT $LN21@basic_stri
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN21@basic_stri:
; File a:\vs\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00013	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File a:\vs\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00021	c6 06 00	 mov	 BYTE PTR [esi], 0
  00024	5e		 pop	 esi
; File a:\vs\vc\include\xstring

; 992  : 		}

  00025	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\iosfwd
; File a:\vs\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 740  : 		}

  00007	8b c1		 mov	 eax, ecx

; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File a:\vs\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File a:\vs\vc\include\xstring

; 740  : 		}

  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 684  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 494  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

  00007	8b c1		 mov	 eax, ecx

; 495  : 		_Myres = 0;

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

  00010	c2 04 00	 ret	 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 521  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

  00009	8b c1		 mov	 eax, ecx

; 521  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 514  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

  00009	8b c1		 mov	 eax, ecx

; 514  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 495  : 		_Myres = 0;
; 496  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 564  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 565  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 		}

  00012	5d		 pop	 ebp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT
_fr$ = 8						; size = 4
_fg$ = 12						; size = 4
_fb$ = 16						; size = 4
_fa$ = 20						; size = 4
??0D3DXCOLOR@@QAE@MMMM@Z PROC				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 919  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 920  :     r = fr;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fr$[ebp]

; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fg$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fb$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fa$[ebp]
  00027	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??0D3DXCOLOR@@QAE@MMMM@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\string.h
;	COMDAT ?strstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__SubStr$ = 12						; size = 4
?strstr@@YAPADPADPBD@Z PROC				; strstr, COMDAT

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 _strstr
?strstr@@YAPADPADPBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
