; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\UserInterface\CameraProcedure.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?CAMERA_MIN_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MIN_DISTANCE
PUBLIC	?CAMERA_MAX_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MAX_DISTANCE
_DATA	SEGMENT
?CAMERA_MIN_DISTANCE@CCamera@@0MA DD 043480000r	; 200	; CCamera::CAMERA_MIN_DISTANCE
?CAMERA_MAX_DISTANCE@CCamera@@0MA DD 0451c4000r	; 2500	; CCamera::CAMERA_MAX_DISTANCE
_DATA	ENDS
CONST	SEGMENT
_CAMERA_TARGET_STANDARD DD 042c80000r		; 100
_CAMERA_TARGET_FACE DD 043160000r		; 150
CONST	ENDS
PUBLIC	_fabsf
PUBLIC	_floorf
PUBLIC	_sqrtf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??XD3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator*=
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
PUBLIC	?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z		; D3DXVec3Length
PUBLIC	?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z		; D3DXVec3Dot
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??0Vector3d@@QAE@XZ				; Vector3d::Vector3d
PUBLIC	?Set@Vector3d@@QAEXMMM@Z			; Vector3d::Set
PUBLIC	??0SpherePackCallback@@QAE@XZ			; SpherePackCallback::SpherePackCallback
PUBLIC	??1SpherePackCallback@@UAE@XZ			; SpherePackCallback::~SpherePackCallback
PUBLIC	?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::VisibilityCallback
PUBLIC	?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; SpherePackCallback::RayTraceCallback
PUBLIC	?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::RangeTestCallback
PUBLIC	?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::PointTest2dCallback
PUBLIC	??_GSpherePackCallback@@UAEPAXI@Z		; SpherePackCallback::`scalar deleting destructor'
PUBLIC	?GetUserData@SpherePack@@QBEPAXXZ		; SpherePack::GetUserData
PUBLIC	?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ; CSingleton<CCullingManager>::Instance
PUBLIC	??0CDynamicSphereInstance@@QAE@XZ		; CDynamicSphereInstance::CDynamicSphereInstance
PUBLIC	??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ	; std::allocator<D3DXVECTOR3>::allocator<D3DXVECTOR3>
PUBLIC	?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::deallocate
PUBLIC	?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::allocate
PUBLIC	?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z ; std::allocator<D3DXVECTOR3>::construct
PUBLIC	?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ ; std::allocator<D3DXVECTOR3>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::_Wrap_alloc<std::allocator<D3DXVECTOR3> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAE@ABV?$allocator@UD3DXVECTOR3@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Getal
PUBLIC	??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity
PUBLIC	?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Unused_capacity
PUBLIC	?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::size
PUBLIC	?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size
PUBLIC	??A?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEAAUD3DXVECTOR3@@I@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::operator[]
PUBLIC	?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back
PUBLIC	?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
PUBLIC	?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Grow_to
PUBLIC	?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Inside
PUBLIC	?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
PUBLIC	?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
PUBLIC	?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range
PUBLIC	?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ ; CSingleton<CPythonBackground>::Instance
PUBLIC	?Update@CCamera@@QAEXXZ				; CCamera::Update
PUBLIC	?GetDistance@CCamera@@QBEMXZ			; CCamera::GetDistance
PUBLIC	?ProcessTerrainCollision@CCamera@@AAEXXZ	; CCamera::ProcessTerrainCollision
PUBLIC	?ProcessBuildingCollision@CCamera@@AAEXXZ	; CCamera::ProcessBuildingCollision
PUBLIC	??0CameraCollisionChecker@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@Z ; CameraCollisionChecker::CameraCollisionChecker
PUBLIC	??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
PUBLIC	??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ; CCullingManager::ForInRange<CameraCollisionChecker>
PUBLIC	??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z ; std::addressof<D3DXVECTOR3 const >
PUBLIC	??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
PUBLIC	??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Umove<D3DXVECTOR3 *>
PUBLIC	??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z ; std::_Allocate<D3DXVECTOR3>
PUBLIC	??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>
PUBLIC	??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
PUBLIC	?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<CameraCollisionChecker>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
PUBLIC	??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
PUBLIC	??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z ; std::forward<D3DXVECTOR3 &>
PUBLIC	??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
PUBLIC	??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z ; std::forward<D3DXVECTOR3 const &>
PUBLIC	??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
PUBLIC	??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z ; std::_Ptr_cat<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3 &>
PUBLIC	??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
PUBLIC	??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ; std::_Unchecked<D3DXVECTOR3 *>
PUBLIC	??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
PUBLIC	??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z ; std::_Rechecked<D3DXVECTOR3 *,D3DXVECTOR3 *>
PUBLIC	??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
PUBLIC	??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ; std::_Val_type<D3DXVECTOR3 *>
PUBLIC	??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
PUBLIC	??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z ; std::allocator<D3DXVECTOR3>::destroy<D3DXVECTOR3>
PUBLIC	??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ; std::forward<D3DXVECTOR3>
PUBLIC	??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3>
PUBLIC	??_7SpherePackCallback@@6B@			; SpherePackCallback::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4SpherePackCallback@@6B@			; SpherePackCallback::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSpherePackCallback@@@8			; SpherePackCallback `RTTI Type Descriptor'
PUBLIC	??_R3SpherePackCallback@@8			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SpherePackCallback@@8			; SpherePackCallback::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SpherePackCallback@@8		; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
PUBLIC	??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
PUBLIC	??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
PUBLIC	??_R3?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?fMIN@@YAMMM@Z:PROC				; fMIN
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	??_ESpherePackCallback@@UAEPAXI@Z:PROC		; SpherePackCallback::`vector deleting destructor'
EXTRN	?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z:PROC ; SpherePackFactory::RangeTest
EXTRN	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ:PROC ; CGraphicObjectInstance::GetPosition
EXTRN	?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z:PROC ; CGraphicObjectInstance::CollisionDynamicSphere
EXTRN	?GetHeight@CMapManager@@QAEMMM@Z:PROC		; CMapManager::GetHeight
EXTRN	?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z:PROC ; CPythonBackground::GetPickingPointWithRayOnlyTerrain
EXTRN	?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z:PROC ; CCamera::SetCameraState
EXTRN	?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z:PROC	; CCamera::SetEye
EXTRN	?SetDistance@CCamera@@QAEXM@Z:PROC		; CCamera::SetDistance
EXTRN	?RotateEyeAroundTarget@CCamera@@QAEXMM@Z:PROC	; CCamera::RotateEyeAroundTarget
EXTRN	?SetTargetHeight@CCamera@@QAEXM@Z:PROC		; CCamera::SetTargetHeight
EXTRN	??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z:PROC ; RangeTester<CameraCollisionChecker>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_floor:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A DD 01H DUP (?) ; CSingleton<CCullingManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A DD 01H DUP (?) ; CSingleton<CPythonBackground>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UCameraCollisionChecker@@@@8 DD 00H	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
data$r	SEGMENT
??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UCameraCollisionChecker@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ DD 00H ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ DD FLAT:??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
	DD	FLAT:??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SpherePackCallback@@8 DD FLAT:??_R0?AVSpherePackCallback@@@8 ; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R2SpherePackCallback@@8
rdata$r	SEGMENT
??_R2SpherePackCallback@@8 DD FLAT:??_R1A@?0A@EA@SpherePackCallback@@8 ; SpherePackCallback::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SpherePackCallback@@8
rdata$r	SEGMENT
??_R3SpherePackCallback@@8 DD 00H			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSpherePackCallback@@@8
data$r	SEGMENT
??_R0?AVSpherePackCallback@@@8 DD FLAT:??_7type_info@@6B@ ; SpherePackCallback `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSpherePackCallback@@', 00H
data$r	ENDS
;	COMDAT ??_R4SpherePackCallback@@6B@
rdata$r	SEGMENT
??_R4SpherePackCallback@@6B@ DD 00H			; SpherePackCallback::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSpherePackCallback@@@8
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7SpherePackCallback@@6B@
CONST	SEGMENT
??_7SpherePackCallback@@6B@ DD FLAT:??_R4SpherePackCallback@@6B@ ; SpherePackCallback::`vftable'
	DD	FLAT:??_ESpherePackCallback@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z$0
__ehfuncinfo$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ProcessBuildingCollision@CCamera@@AAEXXZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?ProcessBuildingCollision@CCamera@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ProcessBuildingCollision@CCamera@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$2
	DD	04H
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$3
	DD	06H
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$4
	DD	08H
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$5
	DD	0aH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z PROC ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 601  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@U1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ENDP ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UD3DXVECTOR3@@U1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z PROC ; std::forward<D3DXVECTOR3>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UD3DXVECTOR3@@@std@@YA$$QAUD3DXVECTOR3@@AAU1@@Z ENDP ; std::forward<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@U1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z PROC ; std::allocator<D3DXVECTOR3>::destroy<D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UD3DXVECTOR3@@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z ENDP ; std::allocator<D3DXVECTOR3>::destroy<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 1c		 je	 SHORT $LN4@Uninit_mov
$LL6@Uninit_mov:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN24@Uninit_mov
  00015	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00019	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN24@Uninit_mov:
; File a:\vs\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00023	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00026	83 c0 0c	 add	 eax, 12			; 0000000cH
  00029	3b ce		 cmp	 ecx, esi
  0002b	75 e4		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:
  0002d	5e		 pop	 esi

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);
; 451  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z PROC ; std::_Val_type<D3DXVECTOR3 *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ENDP ; std::_Val_type<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@UD3DXVECTOR3@@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<D3DXVECTOR3 *,D3DXVECTOR3 *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUD3DXVECTOR3@@PAU1@@std@@YAAAPAUD3DXVECTOR3@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<D3DXVECTOR3 *,D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z PROC ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 485  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ENDP ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z PROC ; std::_Unchecked<D3DXVECTOR3 *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@PAU1@@Z ENDP ; std::_Unchecked<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UD3DXVECTOR3@@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::destroy<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z PROC ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3 &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 601  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ENDP ; std::allocator<D3DXVECTOR3>::construct<D3DXVECTOR3,D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z PROC ; std::_Uninitialized_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUD3DXVECTOR3@@PAU1@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z PROC ; std::_Ptr_cat<D3DXVECTOR3,D3DXVECTOR3>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UD3DXVECTOR3@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUD3DXVECTOR3@@0@Z ENDP ; std::_Ptr_cat<D3DXVECTOR3,D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UD3DXVECTOR3@@ABU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z PROC ; std::forward<D3DXVECTOR3 const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUD3DXVECTOR3@@@std@@YAABUD3DXVECTOR3@@ABU1@@Z ENDP ; std::forward<D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@UD3DXVECTOR3@@AAU1@@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAXAAV?$allocator@UD3DXVECTOR3@@@1@PAUD3DXVECTOR3@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z PROC ; std::forward<D3DXVECTOR3 &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUD3DXVECTOR3@@@std@@YAAAUD3DXVECTOR3@@AAU1@@Z ENDP ; std::forward<D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z PROC ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ENDP ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 2e		 je	 SHORT $LN6@PointTest2
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00009	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00010	57		 push	 edi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00011	8b 78 44	 mov	 edi, DWORD PTR [eax+68]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00014	8b cf		 mov	 ecx, edi
  00016	ff 76 08	 push	 DWORD PTR [esi+8]
  00019	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0001e	84 c0		 test	 al, al
  00020	74 13		 je	 SHORT $LN9@PointTest2

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  00032	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN9@PointTest2:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
$LN6@PointTest2:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 62   : 	}

  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00003	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  00007	74 2e		 je	 SHORT $LN6@RangeTestC
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00009	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  0000c	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00010	57		 push	 edi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00011	8b 78 44	 mov	 edi, DWORD PTR [eax+68]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00014	8b cf		 mov	 ecx, edi
  00016	ff 76 08	 push	 DWORD PTR [esi+8]
  00019	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0001e	84 c0		 test	 al, al
  00020	74 13		 je	 SHORT $LN9@RangeTestC

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00029	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  00032	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN9@RangeTestC:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
$LN6@RangeTestC:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 47   : 	}

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<CameraCollisionChecker>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00003	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	0f 2f c1	 comiss	 xmm0, xmm1
  0000e	73 06		 jae	 SHORT $LN1@RayTraceCa
  00010	0f 2f 4d 10	 comiss	 xmm1, DWORD PTR _distance$[ebp]
  00014	72 2e		 jb	 SHORT $LN7@RayTraceCa
$LN1@RayTraceCa:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00016	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00019	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0001a	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0001d	57		 push	 edi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0001e	8b 78 44	 mov	 edi, DWORD PTR [eax+68]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00021	8b cf		 mov	 ecx, edi
  00023	ff 76 08	 push	 DWORD PTR [esi+8]
  00026	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  0002b	84 c0		 test	 al, al
  0002d	74 13		 je	 SHORT $LN10@RayTraceCa

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  0002f	8b cf		 mov	 ecx, edi
  00031	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00036	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  0003f	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN10@RayTraceCa:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
$LN7@RayTraceCa:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 34   : 	};

  00044	5d		 pop	 ebp
  00045	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ
_TEXT	SEGMENT
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ PROC	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>, COMDAT
; _this$ = ecx
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 19   : 	{}

  00006	c3		 ret	 0
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ENDP	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z
_TEXT	SEGMENT
_fn$ = 8						; size = 4
_distance$ = 12						; size = 4
??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z PROC ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>, COMDAT
; _this$ = ecx

; 16   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _fn$[ebp]
  00006	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _distance$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b c1		 mov	 eax, ecx
  00010	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  00016	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z ENDP ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z PROC ; std::_Allocate<D3DXVECTOR3>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 21		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 15		 ja	 SHORT $LN1@Allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00028	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002d	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Allocate@UD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@IPAU1@@Z ENDP ; std::_Allocate<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Umove<D3DXVECTOR3 *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1649 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEPAUD3DXVECTOR3@@PAU2@00@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Umove<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@ABU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@UD3DXVECTOR3@@AAU1@@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::construct<D3DXVECTOR3,D3DXVECTOR3 &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z PROC ; std::addressof<D3DXVECTOR3 const >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUD3DXVECTOR3@@@std@@YAPBUD3DXVECTOR3@@ABU1@@Z ENDP ; std::addressof<D3DXVECTOR3 const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
;	COMDAT ??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
_TEXT	SEGMENT
_r$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_radius$ = 12						; size = 4
_pFunc$ = 16						; size = 4
??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z PROC ; CCullingManager::ForInRange<CameraCollisionChecker>, COMDAT
; _this$ = ecx

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 16   : 	{}

  00025	8b 45 10	 mov	 eax, DWORD PTR _pFunc$[ebp]
  00028	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  0002f	89 45 ec	 mov	 DWORD PTR _r$[ebp+4], eax
  00032	c7 45 f0 00 00
	80 bf		 mov	 DWORD PTR _r$[ebp+8], -1082130432 ; bf800000H

; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  00039	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  0003e	8d 45 e8	 lea	 eax, DWORD PTR _r$[ebp]
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00046	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004b	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest

; 115  : 	}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _r$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__ehhandler$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ENDP ; CCullingManager::ForInRange<CameraCollisionChecker>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
;	COMDAT ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pOpponent$ = 8						; size = 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; CameraCollisionChecker::operator(), COMDAT
; _this$ = ecx

; 115  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00009	ff 76 08	 push	 DWORD PTR [esi+8]
  0000c	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  00011	84 c0		 test	 al, al
  00013	74 14		 je	 SHORT $LN1@operator

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0001d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back

; 119  : 			m_isBlocked = true;

  00026	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN1@operator:
  00029	5e		 pop	 esi

; 120  :  		}
; 121  : 	}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; CameraCollisionChecker::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
;	COMDAT ??0CameraCollisionChecker@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@Z
_TEXT	SEGMENT
_pdsi$ = 8						; size = 4
_pkVct_v3Position$ = 12					; size = 4
??0CameraCollisionChecker@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@Z PROC ; CameraCollisionChecker::CameraCollisionChecker, COMDAT
; _this$ = ecx

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _pkVct_v3Position$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00009	8b 45 08	 mov	 eax, DWORD PTR _pdsi$[ebp]
  0000c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 113  : 	}

  0000f	8b c1		 mov	 eax, ecx
  00011	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0CameraCollisionChecker@@QAE@PAUCDynamicSphereInstance@@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@Z ENDP ; CameraCollisionChecker::CameraCollisionChecker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
;	COMDAT ?ProcessBuildingCollision@CCamera@@AAEXXZ
_TEXT	SEGMENT
_v$3$ = -96						; size = 4
_kCameraCollisionChecker$2 = -92			; size = 12
_kCameraCollisionChecker$3 = -92			; size = 12
_kCameraCollisionChecker$4 = -92			; size = 12
_kCameraCollisionChecker$5 = -92			; size = 12
_kCameraCollisionChecker$6 = -92			; size = 12
_kCameraCollisionChecker$7 = -92			; size = 12
_kVct_kPosition$8 = -80					; size = 12
_kVct_kPosition$9 = -80					; size = 12
_kVct_kPosition$10 = -80				; size = 12
_kVct_kPosition$11 = -80				; size = 12
_kVct_kPosition$12 = -80				; size = 12
_kVct_kPosition$13 = -80				; size = 12
_r$14 = -68						; size = 12
_r$15 = -68						; size = 12
_r$16 = -68						; size = 12
_r$17 = -68						; size = 12
_r$18 = -68						; size = 12
_r$19 = -68						; size = 12
$T20 = -68						; size = 12
$T21 = -68						; size = 12
$T22 = -68						; size = 12
$T23 = -68						; size = 12
$T24 = -68						; size = 12
$T25 = -68						; size = 12
_s$ = -56						; size = 28
_aVector3d$ = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ProcessBuildingCollision@CCamera@@AAEXXZ PROC		; CCamera::ProcessBuildingCollision, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ProcessBuildingCollision@CCamera@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx

; 133  : 	s.v3LastPosition = m_v3Eye;

  0002d	f3 0f 7e 46 30	 movq	 xmm0, QWORD PTR [esi+48]
  00032	f3 0f 10 ae f4
	02 00 00	 movss	 xmm5, DWORD PTR [esi+756]

; 134  : 
; 135  : 	Vector3d aVector3d;
; 136  : 	aVector3d.Set(m_v3Eye.x, m_v3Eye.y, m_v3Eye.z);

  0003a	f3 0f 10 4e 34	 movss	 xmm1, DWORD PTR [esi+52]
  0003f	f3 0f 10 56 38	 movss	 xmm2, DWORD PTR [esi+56]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00044	f3 0f 10 66 30	 movss	 xmm4, DWORD PTR [esi+48]
  00049	f3 0f 10 5e 34	 movss	 xmm3, DWORD PTR [esi+52]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 133  : 	s.v3LastPosition = m_v3Eye;

  0004e	8b 46 38	 mov	 eax, DWORD PTR [esi+56]

; 137  : 
; 138  : 	// 
; 139  : 
; 140  : 	CCullingManager & rkCullingMgr = CCullingManager::Instance();

  00051	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00057	66 0f d6 45 d4	 movq	 QWORD PTR _s$[ebp+12], xmm0
  0005c	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  00061	f3 0f 11 45 e4	 movss	 DWORD PTR _aVector3d$[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00066	f3 0f 10 46 54	 movss	 xmm0, DWORD PTR [esi+84]
  0006b	f3 0f 59 c5	 mulss	 xmm0, xmm5
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 133  : 	s.v3LastPosition = m_v3Eye;

  0006f	89 45 dc	 mov	 DWORD PTR _s$[ebp+20], eax
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 108  : 		y = b;

  00072	f3 0f 11 4d e8	 movss	 DWORD PTR _aVector3d$[ebp+4], xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00077	f3 0f 10 4e 58	 movss	 xmm1, DWORD PTR [esi+88]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 109  : 		z = c;

  0007c	f3 0f 11 55 ec	 movss	 DWORD PTR _aVector3d$[ebp+8], xmm2
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00081	f3 0f 5c e0	 subss	 xmm4, xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00085	f3 0f 10 56 5c	 movss	 xmm2, DWORD PTR [esi+92]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0008a	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0008f	f3 0f 59 cd	 mulss	 xmm1, xmm5
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00093	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$13[ebp], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0009a	f3 0f 59 d5	 mulss	 xmm2, xmm5
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  0009e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$13[ebp+4], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000a5	f3 0f 5c d9	 subss	 xmm3, xmm1
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 132  : 	s.fRadius = m_fObjectCollisionRadius;

  000a9	f3 0f 11 6d e0	 movss	 DWORD PTR _s$[ebp+24], xmm5
; File a:\vs\vc\include\vector

; 484  : 		_Myend = pointer();

  000ae	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$13[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000b5	f3 0f 5c c2	 subss	 xmm0, xmm2
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 144  : 		s.v3Position = v3CheckVector;

  000b9	0f 14 e3	 unpcklps xmm4, xmm3
  000bc	66 0f d6 65 c8	 movq	 QWORD PTR _s$[ebp], xmm4
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000c1	f3 0f 11 45 c4	 movss	 DWORD PTR $T25[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 144  : 		s.v3Position = v3CheckVector;

  000c6	8b 45 c4	 mov	 eax, DWORD PTR $T25[ebp+8]
  000c9	89 45 d0	 mov	 DWORD PTR _s$[ebp+8], eax

; 112  : 	{

  000cc	8d 45 b0	 lea	 eax, DWORD PTR _kVct_kPosition$13[ebp]

; 145  : 
; 146  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  000cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 112  : 	{

  000d6	89 45 a8	 mov	 DWORD PTR _kCameraCollisionChecker$7[ebp+4], eax
  000d9	8d 45 c8	 lea	 eax, DWORD PTR _s$[ebp]
  000dc	89 45 ac	 mov	 DWORD PTR _kCameraCollisionChecker$7[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  000df	8d 45 a4	 lea	 eax, DWORD PTR _kCameraCollisionChecker$7[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 112  : 	{

  000e2	c6 45 a4 00	 mov	 BYTE PTR _kCameraCollisionChecker$7[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  000e6	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _r$19[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  000ed	89 45 c0	 mov	 DWORD PTR _r$19[ebp+4], eax
  000f0	c7 45 c4 00 00
	80 bf		 mov	 DWORD PTR _r$19[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  000f7	8d 45 bc	 lea	 eax, DWORD PTR _r$19[ebp]
  000fa	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  00103	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  00106	f3 0f 11 2c 24	 movss	 DWORD PTR [esp], xmm5
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 151  : 		if (bCollide)

  00111	80 7d a4 00	 cmp	 BYTE PTR _kCameraCollisionChecker$7[ebp], 0
  00115	8b 7d b0	 mov	 edi, DWORD PTR _kVct_kPosition$13[ebp]
  00118	0f 84 26 01 00
	00		 je	 $LN16@ProcessBui

; 152  : 		{
; 153  : 			if (m_v3AngularVelocity.y > 0.0f)

  0011e	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  00126	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0012d	76 22		 jbe	 SHORT $LN22@ProcessBui

; 154  : 			{
; 155  : 				m_v3AngularVelocity.y = 0.0f;
; 156  : 				m_v3AngularVelocity.z += fMoveAmountLarge;

  0012f	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  00137	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  0013f	c7 86 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+808], 0
  00149	f3 0f 11 86 2c
	03 00 00	 movss	 DWORD PTR [esi+812], xmm0
$LN22@ProcessBui:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00151	8b 4d b4	 mov	 ecx, DWORD PTR _kVct_kPosition$13[ebp+4]
  00154	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00159	2b cf		 sub	 ecx, edi
  0015b	f7 e9		 imul	 ecx
  0015d	d1 fa		 sar	 edx, 1
  0015f	8b c2		 mov	 eax, edx
  00161	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00164	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 161  : 			if (kVct_kPosition.size() > 1)

  00166	83 f8 01	 cmp	 eax, 1
  00169	0f 87 bd 00 00
	00		 ja	 $LN17@ProcessBui
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0016f	f3 0f 10 6f 04	 movss	 xmm5, DWORD PTR [edi+4]
  00174	f3 0f 10 5f 08	 movss	 xmm3, DWORD PTR [edi+8]
  00179	f3 0f 5c 6e 34	 subss	 xmm5, DWORD PTR [esi+52]
  0017e	f3 0f 5c 5e 38	 subss	 xmm3, DWORD PTR [esi+56]

; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00183	f3 0f 10 56 5c	 movss	 xmm2, DWORD PTR [esi+92]
  00188	f3 0f 10 7e 58	 movss	 xmm7, DWORD PTR [esi+88]
  0018d	0f 28 e2	 movaps	 xmm4, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00190	f3 0f 10 37	 movss	 xmm6, DWORD PTR [edi]

; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00194	0f 28 c7	 movaps	 xmm0, xmm7

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00197	f3 0f 5c 76 30	 subss	 xmm6, DWORD PTR [esi+48]

; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0019c	f3 0f 59 c3	 mulss	 xmm0, xmm3
  001a0	f3 0f 59 e5	 mulss	 xmm4, xmm5

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  001a4	f3 0f 59 d6	 mulss	 xmm2, xmm6
  001a8	f3 0f 5c e0	 subss	 xmm4, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  001ac	f3 0f 59 fe	 mulss	 xmm7, xmm6
  001b0	f3 0f 10 46 54	 movss	 xmm0, DWORD PTR [esi+84]
  001b5	0f 28 c8	 movaps	 xmm1, xmm0
  001b8	f3 0f 59 c5	 mulss	 xmm0, xmm5
  001bc	f3 0f 59 cb	 mulss	 xmm1, xmm3
  001c0	f3 0f 5c f8	 subss	 xmm7, xmm0

; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001c4	f3 0f 10 46 48	 movss	 xmm0, DWORD PTR [esi+72]
  001c9	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  001cd	f3 0f 5c ca	 subss	 xmm1, xmm2

; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001d1	f3 0f 10 56 4c	 movss	 xmm2, DWORD PTR [esi+76]
  001d6	f3 0f 59 d1	 mulss	 xmm2, xmm1
  001da	f3 0f 58 d0	 addss	 xmm2, xmm0
  001de	f3 0f 10 46 50	 movss	 xmm0, DWORD PTR [esi+80]
  001e3	f3 0f 59 c7	 mulss	 xmm0, xmm7
  001e7	f3 0f 58 d0	 addss	 xmm2, xmm0
  001eb	0f 57 c0	 xorps	 xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 170  : 				if (fDot < 0)

  001ee	0f 2f c2	 comiss	 xmm0, xmm2
  001f1	76 1a		 jbe	 SHORT $LN19@ProcessBui

; 171  : 				{
; 172  : 	//				m_v3AngularVelocity.x = fMIN(-fMoveAmountSmall, m_v3AngularVelocity.x);
; 173  :  					m_v3AngularVelocity.x -= fMoveAmountSmall;

  001f3	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  001fb	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  00203	f3 0f 11 86 24
	03 00 00	 movss	 DWORD PTR [esi+804], xmm0
  0020b	eb 37		 jmp	 SHORT $LN16@ProcessBui
$LN19@ProcessBui:

; 174  : 				}
; 175  : 				else if(fDot > 0)

  0020d	0f 2f d0	 comiss	 xmm2, xmm0
  00210	76 1a		 jbe	 SHORT $LN17@ProcessBui

; 176  : 				{
; 177  : 	//				m_v3AngularVelocity.x = fMAX(fMoveAmountSmall, m_v3AngularVelocity.x);
; 178  :  					m_v3AngularVelocity.x += fMoveAmountSmall;

  00212	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  0021a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00222	f3 0f 11 86 24
	03 00 00	 movss	 DWORD PTR [esi+804], xmm0

; 179  : 				}
; 180  : 				else

  0022a	eb 18		 jmp	 SHORT $LN16@ProcessBui
$LN17@ProcessBui:

; 181  : 				{
; 182  : 	//				m_v3AngularVelocity.z = fMAX(fMoveAmountSmall, m_v3AngularVelocity.z);
; 183  :  					m_v3AngularVelocity.z += fMoveAmountSmall;

  0022c	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  00234	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0023c	f3 0f 11 86 2c
	03 00 00	 movss	 DWORD PTR [esi+812], xmm0
$LN16@ProcessBui:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00244	85 ff		 test	 edi, edi
  00246	74 09		 je	 SHORT $LN83@ProcessBui
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00248	57		 push	 edi
  00249	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0024e	83 c4 04	 add	 esp, 4
$LN83@ProcessBui:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 191  : 		v3CheckVector = m_v3Eye + 2.0f * m_fObjectCollisionRadius * m_v3Up;

  00251	f3 0f 10 ae f4
	02 00 00	 movss	 xmm5, DWORD PTR [esi+756]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00259	f3 0f 10 66 48	 movss	 xmm4, DWORD PTR [esi+72]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 191  : 		v3CheckVector = m_v3Eye + 2.0f * m_fObjectCollisionRadius * m_v3Up;

  0025e	0f 28 c5	 movaps	 xmm0, xmm5
  00261	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00269	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$12[ebp], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00270	f3 0f 10 4e 4c	 movss	 xmm1, DWORD PTR [esi+76]
  00275	f3 0f 10 56 50	 movss	 xmm2, DWORD PTR [esi+80]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0027a	f3 0f 10 5e 34	 movss	 xmm3, DWORD PTR [esi+52]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0027f	f3 0f 59 e0	 mulss	 xmm4, xmm0
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  00283	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$12[ebp+4], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0028a	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File a:\vs\vc\include\vector

; 484  : 		_Myend = pointer();

  0028e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$12[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00295	f3 0f 58 66 30	 addss	 xmm4, DWORD PTR [esi+48]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0029a	f3 0f 59 d0	 mulss	 xmm2, xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0029e	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  002a3	f3 0f 58 d9	 addss	 xmm3, xmm1
  002a7	f3 0f 58 c2	 addss	 xmm0, xmm2
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 192  : 		s.v3Position = v3CheckVector;

  002ab	0f 14 e3	 unpcklps xmm4, xmm3
  002ae	66 0f d6 65 c8	 movq	 QWORD PTR _s$[ebp], xmm4
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  002b3	f3 0f 11 45 c4	 movss	 DWORD PTR $T24[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 192  : 		s.v3Position = v3CheckVector;

  002b8	8b 45 c4	 mov	 eax, DWORD PTR $T24[ebp+8]
  002bb	89 45 d0	 mov	 DWORD PTR _s$[ebp+8], eax

; 112  : 	{

  002be	8d 45 b0	 lea	 eax, DWORD PTR _kVct_kPosition$12[ebp]

; 193  : 
; 194  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  002c1	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 112  : 	{

  002c8	89 45 a8	 mov	 DWORD PTR _kCameraCollisionChecker$6[ebp+4], eax
  002cb	8d 45 c8	 lea	 eax, DWORD PTR _s$[ebp]
  002ce	89 45 ac	 mov	 DWORD PTR _kCameraCollisionChecker$6[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  002d1	8d 45 a4	 lea	 eax, DWORD PTR _kCameraCollisionChecker$6[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 112  : 	{

  002d4	c6 45 a4 00	 mov	 BYTE PTR _kCameraCollisionChecker$6[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  002d8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _r$18[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  002df	89 45 c0	 mov	 DWORD PTR _r$18[ebp+4], eax
  002e2	c7 45 c4 00 00
	80 bf		 mov	 DWORD PTR _r$18[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  002e9	8d 45 bc	 lea	 eax, DWORD PTR _r$18[ebp]
  002ec	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  002f0	50		 push	 eax
  002f1	51		 push	 ecx
  002f2	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  002f5	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  002f8	f3 0f 11 2c 24	 movss	 DWORD PTR [esp], xmm5
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 199  : 		if (bCollide)

  00303	80 7d a4 00	 cmp	 BYTE PTR _kCameraCollisionChecker$6[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 115  : 	}

  00307	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 199  : 		if (bCollide)

  0030b	74 26		 je	 SHORT $LN15@ProcessBui

; 200  : 		{
; 201  : 			m_v3AngularVelocity.z = fMIN(-fMoveAmountSmall, m_v3AngularVelocity.y);

  0030d	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  00315	83 ec 08	 sub	 esp, 8
  00318	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0031e	c7 04 24 00 00
	00 c0		 mov	 DWORD PTR [esp], -1073741824 ; c0000000H
  00325	e8 00 00 00 00	 call	 ?fMIN@@YAMMM@Z		; fMIN
  0032a	d9 9e 2c 03 00
	00		 fstp	 DWORD PTR [esi+812]
  00330	83 c4 08	 add	 esp, 8
$LN15@ProcessBui:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00333	8b 45 b0	 mov	 eax, DWORD PTR _kVct_kPosition$12[ebp]
  00336	85 c0		 test	 eax, eax
  00338	74 09		 je	 SHORT $LN125@ProcessBui
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0033a	50		 push	 eax
  0033b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00340	83 c4 04	 add	 esp, 4
$LN125@ProcessBui:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 208  : 		v3CheckVector = m_v3Eye + 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  00343	f3 0f 10 ae f4
	02 00 00	 movss	 xmm5, DWORD PTR [esi+756]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0034b	f3 0f 10 4e 64	 movss	 xmm1, DWORD PTR [esi+100]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 208  : 		v3CheckVector = m_v3Eye + 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  00350	0f 28 c5	 movaps	 xmm0, xmm5
  00353	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0035b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$11[ebp], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00362	f3 0f 10 56 68	 movss	 xmm2, DWORD PTR [esi+104]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00367	f3 0f 10 5e 34	 movss	 xmm3, DWORD PTR [esi+52]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0036c	0f 28 e0	 movaps	 xmm4, xmm0
  0036f	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  00373	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$11[ebp+4], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0037a	f3 0f 59 66 60	 mulss	 xmm4, DWORD PTR [esi+96]
; File a:\vs\vc\include\vector

; 484  : 		_Myend = pointer();

  0037f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$11[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00386	f3 0f 59 d0	 mulss	 xmm2, xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0038a	f3 0f 58 d9	 addss	 xmm3, xmm1
  0038e	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  00393	f3 0f 58 66 30	 addss	 xmm4, DWORD PTR [esi+48]
  00398	f3 0f 58 c2	 addss	 xmm0, xmm2
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 209  : 		s.v3Position = v3CheckVector;

  0039c	0f 14 e3	 unpcklps xmm4, xmm3
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0039f	f3 0f 11 45 c4	 movss	 DWORD PTR $T23[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 209  : 		s.v3Position = v3CheckVector;

  003a4	8b 45 c4	 mov	 eax, DWORD PTR $T23[ebp+8]
  003a7	66 0f d6 65 c8	 movq	 QWORD PTR _s$[ebp], xmm4
  003ac	89 45 d0	 mov	 DWORD PTR _s$[ebp+8], eax

; 112  : 	{

  003af	8d 45 b0	 lea	 eax, DWORD PTR _kVct_kPosition$11[ebp]

; 210  : 
; 211  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  003b2	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 112  : 	{

  003b9	89 45 a8	 mov	 DWORD PTR _kCameraCollisionChecker$5[ebp+4], eax
  003bc	8d 45 c8	 lea	 eax, DWORD PTR _s$[ebp]
  003bf	89 45 ac	 mov	 DWORD PTR _kCameraCollisionChecker$5[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  003c2	8d 45 a4	 lea	 eax, DWORD PTR _kCameraCollisionChecker$5[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 112  : 	{

  003c5	c6 45 a4 00	 mov	 BYTE PTR _kCameraCollisionChecker$5[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  003c9	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _r$17[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  003d0	89 45 c0	 mov	 DWORD PTR _r$17[ebp+4], eax
  003d3	c7 45 c4 00 00
	80 bf		 mov	 DWORD PTR _r$17[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  003da	8d 45 bc	 lea	 eax, DWORD PTR _r$17[ebp]
  003dd	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  003e1	50		 push	 eax
  003e2	51		 push	 ecx
  003e3	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  003e6	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  003e9	f3 0f 11 2c 24	 movss	 DWORD PTR [esp], xmm5
  003ee	50		 push	 eax
  003ef	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 216  : 		if (bCollide)

  003f4	80 7d a4 00	 cmp	 BYTE PTR _kCameraCollisionChecker$5[ebp], 0
  003f8	74 33		 je	 SHORT $LN13@ProcessBui

; 217  : 		{
; 218  : 			if (m_v3AngularVelocity.x > 0.0f)

  003fa	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  00402	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00409	76 22		 jbe	 SHORT $LN13@ProcessBui

; 219  : 			{
; 220  : 				m_v3AngularVelocity.x = 0.0f;
; 221  : 				m_v3AngularVelocity.y += fMoveAmountLarge;

  0040b	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  00413	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  0041b	c7 86 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+804], 0
  00425	f3 0f 11 86 28
	03 00 00	 movss	 DWORD PTR [esi+808], xmm0
$LN13@ProcessBui:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0042d	8b 45 b0	 mov	 eax, DWORD PTR _kVct_kPosition$11[ebp]
  00430	85 c0		 test	 eax, eax
  00432	74 09		 je	 SHORT $LN167@ProcessBui
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0043a	83 c4 04	 add	 esp, 4
$LN167@ProcessBui:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 228  : 		v3CheckVector = m_v3Eye - 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  0043d	f3 0f 10 ae f4
	02 00 00	 movss	 xmm5, DWORD PTR [esi+756]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00445	f3 0f 10 4e 60	 movss	 xmm1, DWORD PTR [esi+96]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 228  : 		v3CheckVector = m_v3Eye - 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  0044a	0f 28 c5	 movaps	 xmm0, xmm5
  0044d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00455	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$10[ebp], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0045c	f3 0f 10 56 64	 movss	 xmm2, DWORD PTR [esi+100]
  00461	f3 0f 10 5e 68	 movss	 xmm3, DWORD PTR [esi+104]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00466	f3 0f 10 66 30	 movss	 xmm4, DWORD PTR [esi+48]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0046b	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  0046f	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$10[ebp+4], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00476	f3 0f 59 d0	 mulss	 xmm2, xmm0
; File a:\vs\vc\include\vector

; 484  : 		_Myend = pointer();

  0047a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$10[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00481	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00485	f3 0f 5c e1	 subss	 xmm4, xmm1
  00489	f3 0f 10 4e 34	 movss	 xmm1, DWORD PTR [esi+52]
  0048e	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  00493	f3 0f 5c ca	 subss	 xmm1, xmm2
  00497	f3 0f 5c c3	 subss	 xmm0, xmm3
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 229  : 		s.v3Position = v3CheckVector;

  0049b	0f 14 e1	 unpcklps xmm4, xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0049e	f3 0f 11 45 c4	 movss	 DWORD PTR $T22[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 229  : 		s.v3Position = v3CheckVector;

  004a3	8b 45 c4	 mov	 eax, DWORD PTR $T22[ebp+8]
  004a6	66 0f d6 65 c8	 movq	 QWORD PTR _s$[ebp], xmm4
  004ab	89 45 d0	 mov	 DWORD PTR _s$[ebp+8], eax

; 112  : 	{

  004ae	8d 45 b0	 lea	 eax, DWORD PTR _kVct_kPosition$10[ebp]

; 230  : 
; 231  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  004b1	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6

; 112  : 	{

  004b8	89 45 a8	 mov	 DWORD PTR _kCameraCollisionChecker$4[ebp+4], eax
  004bb	8d 45 c8	 lea	 eax, DWORD PTR _s$[ebp]
  004be	89 45 ac	 mov	 DWORD PTR _kCameraCollisionChecker$4[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  004c1	8d 45 a4	 lea	 eax, DWORD PTR _kCameraCollisionChecker$4[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 112  : 	{

  004c4	c6 45 a4 00	 mov	 BYTE PTR _kCameraCollisionChecker$4[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  004c8	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _r$16[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  004cf	89 45 c0	 mov	 DWORD PTR _r$16[ebp+4], eax
  004d2	c7 45 c4 00 00
	80 bf		 mov	 DWORD PTR _r$16[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  004d9	8d 45 bc	 lea	 eax, DWORD PTR _r$16[ebp]
  004dc	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  004e0	50		 push	 eax
  004e1	51		 push	 ecx
  004e2	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  004e5	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  004e8	f3 0f 11 2c 24	 movss	 DWORD PTR [esp], xmm5
  004ed	50		 push	 eax
  004ee	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 236  : 		if (bCollide)

  004f3	80 7d a4 00	 cmp	 BYTE PTR _kCameraCollisionChecker$4[ebp], 0
  004f7	74 2e		 je	 SHORT $LN11@ProcessBui

; 237  : 		{
; 238  : 			if (m_v3AngularVelocity.x < 0.0f)

  004f9	0f 57 c0	 xorps	 xmm0, xmm0
  004fc	0f 2f 86 24 03
	00 00		 comiss	 xmm0, DWORD PTR [esi+804]
  00503	76 22		 jbe	 SHORT $LN11@ProcessBui

; 239  : 			{
; 240  : 				m_v3AngularVelocity.x = 0.0f;
; 241  : 				m_v3AngularVelocity.y += fMoveAmountLarge;

  00505	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  0050d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  00515	c7 86 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+804], 0
  0051f	f3 0f 11 86 28
	03 00 00	 movss	 DWORD PTR [esi+808], xmm0
$LN11@ProcessBui:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00527	8b 45 b0	 mov	 eax, DWORD PTR _kVct_kPosition$10[ebp]
  0052a	85 c0		 test	 eax, eax
  0052c	74 09		 je	 SHORT $LN209@ProcessBui
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00534	83 c4 04	 add	 esp, 4
$LN209@ProcessBui:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 248  : 		v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  00537	f3 0f 10 86 f0
	02 00 00	 movss	 xmm0, DWORD PTR [esi+752]
  0053f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00547	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$9[ebp], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0054e	f3 0f 10 56 4c	 movss	 xmm2, DWORD PTR [esi+76]
  00553	f3 0f 10 5e 50	 movss	 xmm3, DWORD PTR [esi+80]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00558	f3 0f 10 66 30	 movss	 xmm4, DWORD PTR [esi+48]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0055d	0f 28 c8	 movaps	 xmm1, xmm0
  00560	f3 0f 59 4e 48	 mulss	 xmm1, DWORD PTR [esi+72]
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  00565	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$9[ebp+4], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0056c	f3 0f 59 d0	 mulss	 xmm2, xmm0
; File a:\vs\vc\include\vector

; 484  : 		_Myend = pointer();

  00570	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$9[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00577	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0057b	f3 0f 5c e1	 subss	 xmm4, xmm1
  0057f	f3 0f 10 4e 34	 movss	 xmm1, DWORD PTR [esi+52]
  00584	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  00589	f3 0f 5c ca	 subss	 xmm1, xmm2
  0058d	f3 0f 5c c3	 subss	 xmm0, xmm3
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 249  : 		s.v3Position = v3CheckVector;

  00591	0f 14 e1	 unpcklps xmm4, xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00594	f3 0f 11 45 c4	 movss	 DWORD PTR $T21[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 249  : 		s.v3Position = v3CheckVector;

  00599	8b 45 c4	 mov	 eax, DWORD PTR $T21[ebp+8]
  0059c	66 0f d6 65 c8	 movq	 QWORD PTR _s$[ebp], xmm4
  005a1	89 45 d0	 mov	 DWORD PTR _s$[ebp+8], eax

; 252  : 		CameraCollisionChecker kCameraCollisionChecker(&s, &kVct_kPosition);
; 253  : 		rkCullingMgr.ForInRange(aVector3d, m_fObjectCollisionRadius, &kCameraCollisionChecker);

  005a4	f3 0f 10 86 f4
	02 00 00	 movss	 xmm0, DWORD PTR [esi+756]

; 112  : 	{

  005ac	8d 45 b0	 lea	 eax, DWORD PTR _kVct_kPosition$9[ebp]
  005af	89 45 a8	 mov	 DWORD PTR _kCameraCollisionChecker$3[ebp+4], eax
  005b2	8d 45 c8	 lea	 eax, DWORD PTR _s$[ebp]
  005b5	89 45 ac	 mov	 DWORD PTR _kCameraCollisionChecker$3[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  005b8	8d 45 a4	 lea	 eax, DWORD PTR _kCameraCollisionChecker$3[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 251  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  005bb	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8

; 112  : 	{

  005c2	c6 45 a4 00	 mov	 BYTE PTR _kCameraCollisionChecker$3[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  005c6	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _r$15[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  005cd	89 45 c0	 mov	 DWORD PTR _r$15[ebp+4], eax
  005d0	c7 45 c4 00 00
	80 bf		 mov	 DWORD PTR _r$15[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  005d7	8d 45 bc	 lea	 eax, DWORD PTR _r$15[ebp]
  005da	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  005de	50		 push	 eax
  005df	51		 push	 ecx
  005e0	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  005e3	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  005e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005eb	50		 push	 eax
  005ec	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 256  : 		if (bCollide)

  005f1	80 7d a4 00	 cmp	 BYTE PTR _kCameraCollisionChecker$3[ebp], 0
  005f5	74 2e		 je	 SHORT $LN9@ProcessBui

; 257  : 		{
; 258  : 			if (m_v3AngularVelocity.z < 0.0f)

  005f7	0f 57 c0	 xorps	 xmm0, xmm0
  005fa	0f 2f 86 2c 03
	00 00		 comiss	 xmm0, DWORD PTR [esi+812]
  00601	76 22		 jbe	 SHORT $LN9@ProcessBui

; 259  : 			{
; 260  : 				m_v3AngularVelocity.z = 0.0f;
; 261  : 				m_v3AngularVelocity.y += fMoveAmountLarge;

  00603	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  0060b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40800000
  00613	c7 86 2c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+812], 0
  0061d	f3 0f 11 86 28
	03 00 00	 movss	 DWORD PTR [esi+808], xmm0
$LN9@ProcessBui:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00625	8b 45 b0	 mov	 eax, DWORD PTR _kVct_kPosition$9[ebp]
  00628	85 c0		 test	 eax, eax
  0062a	74 09		 je	 SHORT $LN251@ProcessBui
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0062c	50		 push	 eax
  0062d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00632	83 c4 04	 add	 esp, 4
$LN251@ProcessBui:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 268  : 		v3CheckVector = m_v3Eye + 4.0f * m_fObjectCollisionRadius * m_v3View;

  00635	f3 0f 10 ae f4
	02 00 00	 movss	 xmm5, DWORD PTR [esi+756]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0063d	f3 0f 10 4e 58	 movss	 xmm1, DWORD PTR [esi+88]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 268  : 		v3CheckVector = m_v3Eye + 4.0f * m_fObjectCollisionRadius * m_v3View;

  00642	0f 28 c5	 movaps	 xmm0, xmm5
  00645	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40800000
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0064d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$8[ebp], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00654	f3 0f 10 56 5c	 movss	 xmm2, DWORD PTR [esi+92]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00659	f3 0f 10 5e 34	 movss	 xmm3, DWORD PTR [esi+52]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0065e	0f 28 e0	 movaps	 xmm4, xmm0
  00661	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  00665	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$8[ebp+4], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0066c	f3 0f 59 66 54	 mulss	 xmm4, DWORD PTR [esi+84]
; File a:\vs\vc\include\vector

; 484  : 		_Myend = pointer();

  00671	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _kVct_kPosition$8[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00678	f3 0f 59 d0	 mulss	 xmm2, xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0067c	f3 0f 58 d9	 addss	 xmm3, xmm1
  00680	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  00685	f3 0f 58 66 30	 addss	 xmm4, DWORD PTR [esi+48]
  0068a	f3 0f 58 c2	 addss	 xmm0, xmm2
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 269  : 		s.v3Position = v3CheckVector;

  0068e	0f 14 e3	 unpcklps xmm4, xmm3
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00691	f3 0f 11 45 c4	 movss	 DWORD PTR $T20[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 269  : 		s.v3Position = v3CheckVector;

  00696	8b 45 c4	 mov	 eax, DWORD PTR $T20[ebp+8]
  00699	66 0f d6 65 c8	 movq	 QWORD PTR _s$[ebp], xmm4
  0069e	89 45 d0	 mov	 DWORD PTR _s$[ebp+8], eax

; 112  : 	{

  006a1	8d 45 b0	 lea	 eax, DWORD PTR _kVct_kPosition$8[ebp]

; 270  : 
; 271  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  006a4	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 10 ; 0000000aH

; 112  : 	{

  006ab	89 45 a8	 mov	 DWORD PTR _kCameraCollisionChecker$2[ebp+4], eax
  006ae	8d 45 c8	 lea	 eax, DWORD PTR _s$[ebp]
  006b1	89 45 ac	 mov	 DWORD PTR _kCameraCollisionChecker$2[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  006b4	8d 45 a4	 lea	 eax, DWORD PTR _kCameraCollisionChecker$2[ebp]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 112  : 	{

  006b7	c6 45 a4 00	 mov	 BYTE PTR _kCameraCollisionChecker$2[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\cullingmanager.h

; 16   : 	{}

  006bb	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _r$14[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
  006c2	89 45 c0	 mov	 DWORD PTR _r$14[ebp+4], eax
  006c5	c7 45 c4 00 00
	80 bf		 mov	 DWORD PTR _r$14[ebp+8], -1082130432 ; bf800000H

; 17   : 
; 18   : 	virtual ~RangeTester()
; 19   : 	{}
; 20   : 
; 21   : 
; 22   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 23   : 		const Vector3d &dir,          // dest pos of ray
; 24   : 		float distance,
; 25   : 		const Vector3d &sect,
; 26   : 		SpherePack *sphere)
; 27   : 	{
; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)
; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 34   : 	};
; 35   : 	
; 36   : 	
; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};
; 38   : 
; 39   : 	virtual void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state)
; 40   : 	{
; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)
; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 47   : 	}
; 48   : 
; 49   : 	virtual void PointTest2dCallback(const Vector3d &p, SpherePack *sphere,ViewState state)
; 50   : 	{
; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)
; 56   : 		{
; 57   : #ifdef SPHERELIB_STRICT
; 58   : 			puts("FIND!!");
; 59   : #endif
; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());
; 61   : 		}
; 62   : 	}
; 63   : };
; 64   : 
; 65   : class CCullingManager : public CSingleton<CCullingManager>, public SpherePackCallback, private CScreen
; 66   : {
; 67   : public:
; 68   : 	typedef SpherePack * CullingHandle;
; 69   : 	typedef std::vector<CGraphicObjectInstance *> TRangeList;
; 70   : 
; 71   : 	CCullingManager();
; 72   : 	virtual ~CCullingManager();
; 73   : 
; 74   : 	virtual void RayTraceCallback(const Vector3d &p1,          // source pos of ray
; 75   : 		const Vector3d &dir,          // dest pos of ray
; 76   : 		float distance,
; 77   : 		const Vector3d &sect,
; 78   : 		SpherePack *sphere);
; 79   : 	
; 80   : 	
; 81   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state);
; 82   : 	
; 83   : 	void RangeTestCallback(const Vector3d &p,float distance,SpherePack *sphere,ViewState state);	
; 84   : 
; 85   : 	void Reset();
; 86   : 	void Update();
; 87   : 	void Process();
; 88   : 	
; 89   : 	void FindRange(const Vector3d &p, float radius);
; 90   : 	void FindRay(const Vector3d &p1, const Vector3d &dir);
; 91   : 	void FindRayDistance(const Vector3d &p1, const Vector3d &dir, float distance);
; 92   : 
; 93   : 	void RangeTest(const Vector3d& p, float radius, SpherePackCallback* callback)
; 94   : 	{
; 95   : 		m_Factory->RangeTest(p, radius, callback);
; 96   : 	}
; 97   : 
; 98   : 	void PointTest2d(const Vector3d& p, SpherePackCallback* callback)
; 99   : 	{
; 100  : 		m_Factory->PointTest2d(p, callback);
; 101  : 	}
; 102  : 
; 103  : 	template <class T>
; 104  : 	void ForInRange2d(const Vector3d& p, T* pFunc)
; 105  : 	{
; 106  : 		RangeTester<T> r(pFunc);
; 107  : 		m_Factory->PointTest2d(p, &r);
; 108  : 	}
; 109  : 
; 110  : 	template <class T>
; 111  : 	void ForInRange(const Vector3d &p, float radius, T* pFunc)
; 112  : 	{
; 113  : 		RangeTester<T> r(pFunc);
; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  006cc	8d 45 bc	 lea	 eax, DWORD PTR _r$14[ebp]
  006cf	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  006d3	50		 push	 eax
  006d4	51		 push	 ecx
  006d5	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  006d8	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  006db	f3 0f 11 2c 24	 movss	 DWORD PTR [esp], xmm5
  006e0	50		 push	 eax
  006e1	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 276  : 		if (bCollide)

  006e6	80 7d a4 00	 cmp	 BYTE PTR _kCameraCollisionChecker$2[ebp], 0
  006ea	8b 7d b0	 mov	 edi, DWORD PTR _kVct_kPosition$8[ebp]
  006ed	0f 84 39 01 00
	00		 je	 $LN1@ProcessBui

; 277  : 		{
; 278  : 			if (m_v3AngularVelocity.y < 0.0f)
; 279  : 			{
; 280  : 				m_v3AngularVelocity.y = 0.0f;
; 281  : 				m_v3AngularVelocity.z += fMoveAmountLarge;

  006f3	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40800000
  006fb	0f 57 c0	 xorps	 xmm0, xmm0
  006fe	0f 2f 86 28 03
	00 00		 comiss	 xmm0, DWORD PTR [esi+808]
  00705	76 1e		 jbe	 SHORT $LN7@ProcessBui
  00707	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  0070f	f3 0f 58 c1	 addss	 xmm0, xmm1
  00713	c7 86 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+808], 0
  0071d	f3 0f 11 86 2c
	03 00 00	 movss	 DWORD PTR [esi+812], xmm0
$LN7@ProcessBui:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00725	8b 4d b4	 mov	 ecx, DWORD PTR _kVct_kPosition$8[ebp+4]
  00728	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0072d	2b cf		 sub	 ecx, edi
  0072f	f7 e9		 imul	 ecx
  00731	d1 fa		 sar	 edx, 1
  00733	8b c2		 mov	 eax, edx
  00735	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00738	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 284  : 			if (kVct_kPosition.size() > 1)

  0073a	83 f8 01	 cmp	 eax, 1
  0073d	76 11		 jbe	 SHORT $LN6@ProcessBui

; 285  : 			{
; 286  : 	//			m_v3AngularVelocity.z = fMAX(fMoveAmountLarge, m_v3AngularVelocity.z);
; 287  :  				m_v3AngularVelocity.z += fMoveAmountLarge;

  0073f	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  00747	f3 0f 58 c1	 addss	 xmm0, xmm1

; 288  : 			}
; 289  : 			else

  0074b	e9 d4 00 00 00	 jmp	 $LN320@ProcessBui
$LN6@ProcessBui:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00750	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00754	f3 0f 5c 46 30	 subss	 xmm0, DWORD PTR [esi+48]
  00759	f3 0f 10 67 08	 movss	 xmm4, DWORD PTR [edi+8]
  0075e	f3 0f 5c 66 38	 subss	 xmm4, DWORD PTR [esi+56]
  00763	f3 0f 10 7f 04	 movss	 xmm7, DWORD PTR [edi+4]
  00768	f3 0f 5c 7e 34	 subss	 xmm7, DWORD PTR [esi+52]

; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0076d	f3 0f 10 6e 58	 movss	 xmm5, DWORD PTR [esi+88]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00772	f3 0f 10 4e 54	 movss	 xmm1, DWORD PTR [esi+84]
  00777	f3 0f 10 76 5c	 movss	 xmm6, DWORD PTR [esi+92]
  0077c	0f 28 d1	 movaps	 xmm2, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0077f	f3 0f 11 45 a0	 movss	 DWORD PTR _v$3$[ebp], xmm0

; 1265 : }
; 1266 : 
; 1267 : D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
; 1268 :     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1269 : {
; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00784	0f 28 c5	 movaps	 xmm0, xmm5
  00787	f3 0f 59 c4	 mulss	 xmm0, xmm4
  0078b	f3 0f 59 f7	 mulss	 xmm6, xmm7

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0078f	f3 0f 59 d4	 mulss	 xmm2, xmm4
  00793	f3 0f 10 65 a0	 movss	 xmm4, DWORD PTR _v$3$[ebp]
  00798	f3 0f 5c f0	 subss	 xmm6, xmm0
  0079c	0f 28 c4	 movaps	 xmm0, xmm4

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0079f	f3 0f 59 cf	 mulss	 xmm1, xmm7
  007a3	f3 0f 59 46 5c	 mulss	 xmm0, DWORD PTR [esi+92]

; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  007a8	f3 0f 59 76 48	 mulss	 xmm6, DWORD PTR [esi+72]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  007ad	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  007b1	f3 0f 59 e5	 mulss	 xmm4, xmm5

; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  007b5	f3 0f 10 46 50	 movss	 xmm0, DWORD PTR [esi+80]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  007ba	f3 0f 5c e1	 subss	 xmm4, xmm1

; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  007be	f3 0f 10 4e 4c	 movss	 xmm1, DWORD PTR [esi+76]
  007c3	f3 0f 59 ca	 mulss	 xmm1, xmm2
  007c7	f3 0f 58 ce	 addss	 xmm1, xmm6
  007cb	f3 0f 59 c4	 mulss	 xmm0, xmm4
  007cf	f3 0f 58 c8	 addss	 xmm1, xmm0
  007d3	0f 57 c0	 xorps	 xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 293  : 				if (fDot < 0)

  007d6	0f 2f c1	 comiss	 xmm0, xmm1
  007d9	76 1a		 jbe	 SHORT $LN4@ProcessBui

; 294  : 				{
; 295  : 	// 				m_v3AngularVelocity.x = fMIN(-fMoveAmountSmall, m_v3AngularVelocity.x);
; 296  : 					m_v3AngularVelocity.x -= fMoveAmountSmall;

  007db	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  007e3	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@40000000
  007eb	f3 0f 11 86 24
	03 00 00	 movss	 DWORD PTR [esi+804], xmm0
  007f3	eb 37		 jmp	 SHORT $LN1@ProcessBui
$LN4@ProcessBui:

; 297  : 				}
; 298  : 				else if(fDot > 0)

  007f5	0f 2f c8	 comiss	 xmm1, xmm0
  007f8	76 1a		 jbe	 SHORT $LN2@ProcessBui

; 299  : 				{
; 300  : 	// 				m_v3AngularVelocity.x = fMAX(fMoveAmountSmall, m_v3AngularVelocity.x);
; 301  : 					m_v3AngularVelocity.x += fMoveAmountSmall;

  007fa	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  00802	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  0080a	f3 0f 11 86 24
	03 00 00	 movss	 DWORD PTR [esi+804], xmm0

; 302  : 				}
; 303  : 				else

  00812	eb 18		 jmp	 SHORT $LN1@ProcessBui
$LN2@ProcessBui:

; 304  : 				{
; 305  : 	//				m_v3AngularVelocity.z = fMAX(fMoveAmountSmall, m_v3AngularVelocity.z);
; 306  : 					m_v3AngularVelocity.z += fMoveAmountSmall;

  00814	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  0081c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
$LN320@ProcessBui:
  00824	f3 0f 11 86 2c
	03 00 00	 movss	 DWORD PTR [esi+812], xmm0
$LN1@ProcessBui:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0082c	85 ff		 test	 edi, edi
  0082e	74 09		 je	 SHORT $LN307@ProcessBui
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00830	57		 push	 edi
  00831	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00836	83 c4 04	 add	 esp, 4
$LN307@ProcessBui:
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 311  : }

  00839	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0083c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00843	59		 pop	 ecx
  00844	5f		 pop	 edi
  00845	5e		 pop	 esi
  00846	5b		 pop	 ebx
  00847	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0084a	33 cd		 xor	 ecx, ebp
  0084c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00851	8b e5		 mov	 esp, ebp
  00853	5d		 pop	 ebp
  00854	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _kVct_kPosition$13[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$6:
  00008	8d 4d bc	 lea	 ecx, DWORD PTR _r$19[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$1:
  00010	8d 4d b0	 lea	 ecx, DWORD PTR _kVct_kPosition$12[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$7:
  00018	8d 4d bc	 lea	 ecx, DWORD PTR _r$18[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$2:
  00020	8d 4d b0	 lea	 ecx, DWORD PTR _kVct_kPosition$11[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$8:
  00028	8d 4d bc	 lea	 ecx, DWORD PTR _r$17[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$3:
  00030	8d 4d b0	 lea	 ecx, DWORD PTR _kVct_kPosition$10[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$9:
  00038	8d 4d bc	 lea	 ecx, DWORD PTR _r$16[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$4:
  00040	8d 4d b0	 lea	 ecx, DWORD PTR _kVct_kPosition$9[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$10:
  00048	8d 4d bc	 lea	 ecx, DWORD PTR _r$15[ebp]
  0004b	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$5:
  00050	8d 4d b0	 lea	 ecx, DWORD PTR _kVct_kPosition$8[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$11:
  00058	8d 4d bc	 lea	 ecx, DWORD PTR _r$14[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__ehhandler$?ProcessBuildingCollision@CCamera@@AAEXXZ:
  00060	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00064	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00067	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0006a	33 c8		 xor	 ecx, eax
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00074	33 c8		 xor	 ecx, eax
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ProcessBuildingCollision@CCamera@@AAEXXZ
  00080	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ProcessBuildingCollision@CCamera@@AAEXXZ ENDP		; CCamera::ProcessBuildingCollision
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
;	COMDAT ?ProcessTerrainCollision@CCamera@@AAEXXZ
_TEXT	SEGMENT
_f$1$ = -52						; size = 4
_v3CheckVector$2$ = -52					; size = 4
tv714 = -48						; size = 8
tv708 = -48						; size = 4
tv706 = -48						; size = 8
tv700 = -48						; size = 4
_v3CheckVector$1 = -48					; size = 12
_v3CheckVector$1$ = -32					; size = 4
_v3CollisionPoint$ = -28				; size = 12
_v3NewEye$2 = -16					; size = 12
_v3NewEye$3 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?ProcessTerrainCollision@CCamera@@AAEXXZ PROC		; CCamera::ProcessTerrainCollision, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 38	 sub	 esp, 56			; 00000038H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 34	 mov	 DWORD PTR __$ArrayPad$[esp+56], eax
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx

; 15   : 	CPythonBackground & rPythonBackground = CPythonBackground::Instance();
; 16   : 	D3DXVECTOR3 v3CollisionPoint;
; 17   : 
; 18   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kTargetToCameraBottomRay, &v3CollisionPoint))

  00017	8d 44 24 20	 lea	 eax, DWORD PTR _v3CollisionPoint$[esp+60]
  0001b	57		 push	 edi
  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00022	8b cf		 mov	 ecx, edi
  00024	50		 push	 eax
  00025	8d 86 00 02 00
	00		 lea	 eax, DWORD PTR [esi+512]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain

; 19   : 	{
; 20   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  00031	8b ce		 mov	 ecx, esi
  00033	84 c0		 test	 al, al
  00035	0f 84 02 01 00
	00		 je	 $LN6@ProcessTer
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  00042	f3 0f 10 86 f0
	02 00 00	 movss	 xmm0, DWORD PTR [esi+752]
; File a:\vs\vc\include\math.h

; 701  :     return (float)floor(_X);

  0004a	83 ec 08	 sub	 esp, 8
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  0004d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00055	f3 0f 10 56 4c	 movss	 xmm2, DWORD PTR [esi+76]
  0005a	0f 28 c8	 movaps	 xmm1, xmm0
  0005d	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00061	f3 0f 59 4e 48	 mulss	 xmm1, DWORD PTR [esi+72]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00066	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  0006b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0006f	f3 0f 11 44 24
	28		 movss	 DWORD PTR _v3CheckVector$1$[esp+72], xmm0
  00075	f3 0f 10 46 34	 movss	 xmm0, DWORD PTR [esi+52]
  0007a	f3 0f 5c c2	 subss	 xmm0, xmm2
  0007e	f3 0f 11 44 24
	14		 movss	 DWORD PTR _v3CheckVector$2$[esp+72], xmm0
; File a:\vs\vc\include\math.h

; 701  :     return (float)floor(_X);

  00084	0f 5a c0	 cvtps2pd xmm0, xmm0
  00087	f2 0f 11 44 24
	18		 movsd	 QWORD PTR tv714[esp+72], xmm0
  0008d	dd 44 24 18	 fld	 QWORD PTR tv714[esp+72]
  00091	dd 1c 24	 fstp	 QWORD PTR [esp]
  00094	e8 00 00 00 00	 call	 _floor
  00099	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR _v3CheckVector$1$[esp+72]
  0009f	d9 5c 24 18	 fstp	 DWORD PTR tv708[esp+72]
  000a3	d9 44 24 18	 fld	 DWORD PTR tv708[esp+72]
  000a7	0f 5a c0	 cvtps2pd xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  000aa	51		 push	 ecx
  000ab	d9 5c 24 08	 fstp	 DWORD PTR [esp+8]
; File a:\vs\vc\include\math.h

; 701  :     return (float)floor(_X);

  000af	f2 0f 11 44 24
	1c		 movsd	 QWORD PTR tv706[esp+76], xmm0
  000b5	dd 44 24 1c	 fld	 QWORD PTR tv706[esp+76]
  000b9	dd 1c 24	 fstp	 QWORD PTR [esp]
  000bc	e8 00 00 00 00	 call	 _floor
  000c1	d9 5c 24 1c	 fstp	 DWORD PTR tv700[esp+76]
  000c5	d9 44 24 1c	 fld	 DWORD PTR tv700[esp+76]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  000c9	83 c4 04	 add	 esp, 4
  000cc	8b cf		 mov	 ecx, edi
  000ce	d9 1c 24	 fstp	 DWORD PTR [esp]
  000d1	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight

; 23   : 		D3DXVECTOR3 v3NewEye = v3CheckVector + 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  000d6	f3 0f 10 86 f0
	02 00 00	 movss	 xmm0, DWORD PTR [esi+752]
  000de	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  000e6	f3 0f 10 5e 50	 movss	 xmm3, DWORD PTR [esi+80]
  000eb	f3 0f 10 4e 48	 movss	 xmm1, DWORD PTR [esi+72]
  000f0	f3 0f 10 56 4c	 movss	 xmm2, DWORD PTR [esi+76]
  000f5	f3 0f 59 d8	 mulss	 xmm3, xmm0
  000f9	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000fd	f3 0f 59 d0	 mulss	 xmm2, xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00101	f3 0f 58 4c 24
	20		 addss	 xmm1, DWORD PTR _v3CheckVector$1$[esp+64]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  00107	d9 5c 24 18	 fstp	 DWORD PTR _v3CheckVector$1[esp+72]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0010b	f3 0f 58 5c 24
	18		 addss	 xmm3, DWORD PTR _v3CheckVector$1[esp+72]
  00111	f3 0f 58 54 24
	0c		 addss	 xmm2, DWORD PTR _v3CheckVector$2$[esp+64]

; 180  :     x = fx;

  00117	f3 0f 11 4c 24
	30		 movss	 DWORD PTR _v3NewEye$3[esp+64], xmm1
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 24   : 		if (v3NewEye.z > m_v3Eye.z)

  0011d	0f 2f 5e 38	 comiss	 xmm3, DWORD PTR [esi+56]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00121	f3 0f 11 54 24
	34		 movss	 DWORD PTR _v3NewEye$3[esp+68], xmm2

; 182  :     z = fz;

  00127	f3 0f 11 5c 24
	38		 movss	 DWORD PTR _v3NewEye$3[esp+72], xmm3
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 24   : 		if (v3NewEye.z > m_v3Eye.z)

  0012d	76 15		 jbe	 SHORT $LN4@ProcessTer

; 25   : 		{
; 26   : 			//printf("ToCameraBottom(%f, %f, %f) TCR %f, UP(%f, %f, %f), new %f > old %f", 
; 27   : 			//	v3CheckVector.x, v3CheckVector.y, v3CheckVector.z, 
; 28   : 			//	m_fTerrainCollisionRadius,
; 29   : 			//	m_v3Up.x, m_v3Up.y, m_v3Up.z,
; 30   : 			//	v3NewEye.z, m_v3Eye.z);
; 31   : 			SetEye(v3NewEye);

  0012f	8d 44 24 30	 lea	 eax, DWORD PTR _v3NewEye$3[esp+64]
  00133	8b ce		 mov	 ecx, esi
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye

; 32   : 		}
; 33   : 		/*
; 34   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 35   : 		D3DXVECTOR3 v3NewEye = v3CollisionPoint;
; 36   : 		SetEye(v3NewEye);
; 37   : 		*/
; 38   : 	}
; 39   : 	else

  0013b	eb 07		 jmp	 SHORT $LN4@ProcessTer
$LN6@ProcessTer:

; 40   : 		SetCameraState(CAMERA_STATE_NORMAL);

  0013d	6a 00		 push	 0
  0013f	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
$LN4@ProcessTer:

; 41   : 
; 42   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBottomToTerrainRay, &v3CollisionPoint))

  00144	8d 44 24 24	 lea	 eax, DWORD PTR _v3CollisionPoint$[esp+64]
  00148	8b cf		 mov	 ecx, edi
  0014a	50		 push	 eax
  0014b	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain

; 43   : 	{
; 44   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  00157	8b ce		 mov	 ecx, esi
  00159	84 c0		 test	 al, al
  0015b	0f 84 c5 00 00
	00		 je	 $LN3@ProcessTer
  00161	6a 01		 push	 1
  00163	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00168	f3 0f 10 4e 30	 movss	 xmm1, DWORD PTR [esi+48]
  0016d	f3 0f 10 56 34	 movss	 xmm2, DWORD PTR [esi+52]
  00172	f3 0f 5c 54 24
	28		 subss	 xmm2, DWORD PTR _v3CollisionPoint$[esp+68]
  00178	f3 0f 5c 4c 24
	24		 subss	 xmm1, DWORD PTR _v3CollisionPoint$[esp+64]
  0017e	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  00183	f3 0f 5c 44 24
	2c		 subss	 xmm0, DWORD PTR _v3CollisionPoint$[esp+72]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  00189	f3 0f 10 9e f0
	02 00 00	 movss	 xmm3, DWORD PTR [esi+752]
  00191	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@40000000
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00199	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0019d	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001a1	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001a5	f3 0f 58 d1	 addss	 xmm2, xmm1
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  001a9	f3 0f 11 5c 24
	0c		 movss	 DWORD PTR _f$1$[esp+64], xmm3
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  001af	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  001b3	0f 5a c2	 cvtps2pd xmm0, xmm2
  001b6	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  001bb	f3 0f 10 5c 24
	0c		 movss	 xmm3, DWORD PTR _f$1$[esp+64]
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  001c1	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  001c5	0f 2f d8	 comiss	 xmm3, xmm0
  001c8	76 63		 jbe	 SHORT $LN1@ProcessTer
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001ca	f3 0f 10 46 48	 movss	 xmm0, DWORD PTR [esi+72]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  001cf	8d 44 24 30	 lea	 eax, DWORD PTR _v3NewEye$2[esp+64]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001d3	f3 0f 10 4e 4c	 movss	 xmm1, DWORD PTR [esi+76]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  001d8	8b ce		 mov	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001da	f3 0f 10 56 50	 movss	 xmm2, DWORD PTR [esi+80]
  001df	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  001e3	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001e4	f3 0f 59 cb	 mulss	 xmm1, xmm3

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  001e8	f3 0f 58 44 24
	28		 addss	 xmm0, DWORD PTR _v3CollisionPoint$[esp+68]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001ee	f3 0f 59 d3	 mulss	 xmm2, xmm3

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  001f2	f3 0f 58 4c 24
	2c		 addss	 xmm1, DWORD PTR _v3CollisionPoint$[esp+72]
  001f8	f3 0f 58 54 24
	30		 addss	 xmm2, DWORD PTR _v3CollisionPoint$[esp+76]

; 180  :     x = fx;

  001fe	f3 0f 11 44 24
	34		 movss	 DWORD PTR _v3NewEye$2[esp+68], xmm0

; 181  :     y = fy;

  00204	f3 0f 11 4c 24
	38		 movss	 DWORD PTR _v3NewEye$2[esp+72], xmm1

; 182  :     z = fz;

  0020a	f3 0f 11 54 24
	3c		 movss	 DWORD PTR _v3NewEye$2[esp+76], xmm2
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 49   : 			SetEye(v3NewEye);

  00210	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye

; 54   : /*
; 55   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraFrontToTerrainRay, &v3CollisionPoint))
; 56   : 	{
; 57   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 4.0f * m_fTerrainCollisionRadius)
; 58   : 		{
; 59   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 4.0f * m_fTerrainCollisionRadius * m_v3View;
; 60   : 			//printf("CameraFrontToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 61   : 			SetEye(v3NewEye);
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBackToTerrainRay, &v3CollisionPoint))
; 66   : 	{
; 67   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < m_fTerrainCollisionRadius)
; 68   : 		{
; 69   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + m_fTerrainCollisionRadius * m_v3View;
; 70   : 			//printf("CameraBackToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 71   : 			SetEye(v3NewEye);
; 72   : 		}
; 73   : 	}
; 74   : 
; 75   : 	// Left
; 76   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraLeftToTerrainRay, &v3CollisionPoint))
; 77   : 	{
; 78   : 		SetCameraState(CAMERA_STATE_CANTGOLEFT);
; 79   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 80   : 		{
; 81   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 82   : 			//printf("CameraLeftToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 83   : 			SetEye(v3NewEye);
; 84   : 		}
; 85   : 	}
; 86   : 	else
; 87   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 88   : 
; 89   : 	// Right
; 90   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraRightToTerrainRay, &v3CollisionPoint))
; 91   : 	{
; 92   : 		SetCameraState(CAMERA_STATE_CANTGORIGHT);
; 93   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 94   : 		{
; 95   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 96   : 			//printf("CameraRightToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 97   : 			SetEye(v3NewEye);
; 98   : 		}
; 99   : 	}
; 100  : 	else
; 101  : 		SetCameraState(CAMERA_STATE_NORMAL);
; 102  : 	*/
; 103  : }

  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  0021b	33 cc		 xor	 ecx, esp
  0021d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	c3		 ret	 0
$LN3@ProcessTer:

; 50   : 		}
; 51   : 	}
; 52   : 	else
; 53   : 		SetCameraState(CAMERA_STATE_NORMAL);

  00226	6a 00		 push	 0
  00228	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
$LN1@ProcessTer:

; 54   : /*
; 55   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraFrontToTerrainRay, &v3CollisionPoint))
; 56   : 	{
; 57   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 4.0f * m_fTerrainCollisionRadius)
; 58   : 		{
; 59   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 4.0f * m_fTerrainCollisionRadius * m_v3View;
; 60   : 			//printf("CameraFrontToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 61   : 			SetEye(v3NewEye);
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBackToTerrainRay, &v3CollisionPoint))
; 66   : 	{
; 67   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < m_fTerrainCollisionRadius)
; 68   : 		{
; 69   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + m_fTerrainCollisionRadius * m_v3View;
; 70   : 			//printf("CameraBackToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 71   : 			SetEye(v3NewEye);
; 72   : 		}
; 73   : 	}
; 74   : 
; 75   : 	// Left
; 76   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraLeftToTerrainRay, &v3CollisionPoint))
; 77   : 	{
; 78   : 		SetCameraState(CAMERA_STATE_CANTGOLEFT);
; 79   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 80   : 		{
; 81   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 82   : 			//printf("CameraLeftToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 83   : 			SetEye(v3NewEye);
; 84   : 		}
; 85   : 	}
; 86   : 	else
; 87   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 88   : 
; 89   : 	// Right
; 90   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraRightToTerrainRay, &v3CollisionPoint))
; 91   : 	{
; 92   : 		SetCameraState(CAMERA_STATE_CANTGORIGHT);
; 93   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 94   : 		{
; 95   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 96   : 			//printf("CameraRightToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 97   : 			SetEye(v3NewEye);
; 98   : 		}
; 99   : 	}
; 100  : 	else
; 101  : 		SetCameraState(CAMERA_STATE_NORMAL);
; 102  : 	*/
; 103  : }

  0022d	8b 4c 24 3c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+64]
  00231	5f		 pop	 edi
  00232	5e		 pop	 esi
  00233	33 cc		 xor	 ecx, esp
  00235	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023a	8b e5		 mov	 esp, ebp
  0023c	5d		 pop	 ebp
  0023d	c3		 ret	 0
?ProcessTerrainCollision@CCamera@@AAEXXZ ENDP		; CCamera::ProcessTerrainCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetDistance@CCamera@@QBEMXZ
_TEXT	SEGMENT
?GetDistance@CCamera@@QBEMXZ PROC			; CCamera::GetDistance, COMDAT
; _this$ = ecx

; 186  : 		float GetDistance() const { return m_fDistance; }

  00000	d9 81 34 01 00
	00		 fld	 DWORD PTR [ecx+308]
  00006	c3		 ret	 0
?GetDistance@CCamera@@QBEMXZ ENDP			; CCamera::GetDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp
;	COMDAT ?Update@CCamera@@QAEXXZ
_TEXT	SEGMENT
_fNewDistance$ = -4					; size = 4
?Update@CCamera@@QAEXXZ PROC				; CCamera::Update, COMDAT
; _this$ = ecx

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 315  : // 	ProcessBuildingCollision();
; 316  : 
; 317  : 	RotateEyeAroundTarget(m_v3AngularVelocity.z, m_v3AngularVelocity.x);

  00007	83 ec 08	 sub	 esp, 8
  0000a	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  00012	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00018	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  00020	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00025	e8 00 00 00 00	 call	 ?RotateEyeAroundTarget@CCamera@@QAEXMM@Z ; CCamera::RotateEyeAroundTarget
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h

; 186  : 		float GetDistance() const { return m_fDistance; }

  0002a	f3 0f 10 86 34
	01 00 00	 movss	 xmm0, DWORD PTR [esi+308]
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 319  : 	float fNewDistance=fMAX(CAMERA_MIN_DISTANCE, fMIN( CAMERA_MAX_DISTANCE, GetDistance() - m_v3AngularVelocity.y ) );

  00032	83 ec 08	 sub	 esp, 8
  00035	f3 0f 5c 86 28
	03 00 00	 subss	 xmm0, DWORD PTR [esi+808]
  0003d	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00043	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  0004b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00050	e8 00 00 00 00	 call	 ?fMIN@@YAMMM@Z		; fMIN
  00055	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MIN_DISTANCE@CCamera@@0MA
  0005d	d9 5c 24 04	 fstp	 DWORD PTR [esp+4]
  00061	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00066	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX

; 320  : 	SetDistance(fNewDistance);

  0006b	83 c4 04	 add	 esp, 4
  0006e	8b ce		 mov	 ecx, esi
  00070	d9 5d fc	 fstp	 DWORD PTR _fNewDistance$[ebp]
  00073	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fNewDistance$[ebp]
  00078	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007d	e8 00 00 00 00	 call	 ?SetDistance@CCamera@@QAEXM@Z ; CCamera::SetDistance

; 321  : 	
; 322  : 	if (m_bProcessTerrainCollision)

  00082	80 be 34 03 00
	00 00		 cmp	 BYTE PTR [esi+820], 0
  00089	74 07		 je	 SHORT $LN4@Update

; 323  :  		ProcessTerrainCollision();

  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?ProcessTerrainCollision@CCamera@@AAEXXZ ; CCamera::ProcessTerrainCollision
$LN4@Update:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 222  :     x *= f;

  00092	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000
  0009a	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
  000a2	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 326  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  000a6	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 222  :     x *= f;

  000ae	f3 0f 11 86 24
	03 00 00	 movss	 DWORD PTR [esi+804], xmm0

; 223  :     y *= f;

  000b6	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
  000be	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000c2	f3 0f 11 86 28
	03 00 00	 movss	 DWORD PTR [esi+808], xmm0

; 224  :     z *= f;

  000ca	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
  000d2	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File a:\vs\vc\include\math.h

; 687  :     return (float)fabs(_X);

  000d6	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 224  :     z *= f;

  000de	f3 0f 11 86 2c
	03 00 00	 movss	 DWORD PTR [esi+812], xmm0
  000e6	f3 0f 10 86 24
	03 00 00	 movss	 xmm0, DWORD PTR [esi+804]
; File a:\vs\vc\include\math.h

; 687  :     return (float)fabs(_X);

  000ee	0f 5a c0	 cvtps2pd xmm0, xmm0
  000f1	66 0f 54 c1	 andpd	 xmm0, xmm1
  000f5	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 326  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  000f9	0f 2f d0	 comiss	 xmm2, xmm0
  000fc	76 0a		 jbe	 SHORT $LN3@Update

; 327  : 		m_v3AngularVelocity.x = 0.0f;

  000fe	c7 86 24 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+804], 0
$LN3@Update:
  00108	f3 0f 10 86 28
	03 00 00	 movss	 xmm0, DWORD PTR [esi+808]
; File a:\vs\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00110	0f 5a c0	 cvtps2pd xmm0, xmm0
  00113	66 0f 54 c1	 andpd	 xmm0, xmm1
  00117	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 328  : 	if (fabs(m_v3AngularVelocity.y) < 1.0f)

  0011b	0f 2f d0	 comiss	 xmm2, xmm0
  0011e	76 0a		 jbe	 SHORT $LN2@Update

; 329  : 		m_v3AngularVelocity.y = 0.0f;

  00120	c7 86 28 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+808], 0
$LN2@Update:
  0012a	f3 0f 10 86 2c
	03 00 00	 movss	 xmm0, DWORD PTR [esi+812]
; File a:\vs\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00132	0f 5a c0	 cvtps2pd xmm0, xmm0
  00135	66 0f 54 c1	 andpd	 xmm0, xmm1
  00139	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\userinterface\cameraprocedure.cpp

; 330  : 	if (fabs(m_v3AngularVelocity.z) < 1.0f)

  0013d	0f 2f d0	 comiss	 xmm2, xmm0
  00140	76 0a		 jbe	 SHORT $LN1@Update

; 331  : 		m_v3AngularVelocity.z = 0.0f;

  00142	c7 86 2c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+812], 0
$LN1@Update:

; 332  : 
; 333  : 	const float CAMERA_MOVABLE_DISTANCE = CAMERA_MAX_DISTANCE - CAMERA_MIN_DISTANCE;
; 334  : 	const float CAMERA_TARGET_DELTA = CAMERA_TARGET_FACE - CAMERA_TARGET_STANDARD;
; 335  : 	float fCameraCurMovableDistance=CAMERA_MAX_DISTANCE - GetDistance();

  0014c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  00154	0f 28 c8	 movaps	 xmm1, xmm0
  00157	f3 0f 5c 8e 34
	01 00 00	 subss	 xmm1, DWORD PTR [esi+308]
  0015f	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR ?CAMERA_MIN_DISTANCE@CCamera@@0MA

; 336  : 	float fNewTargetHeight = CAMERA_TARGET_STANDARD + CAMERA_TARGET_DELTA * fCameraCurMovableDistance / CAMERA_MOVABLE_DISTANCE;
; 337  : 
; 338  : 	SetTargetHeight(fNewTargetHeight);

  00167	51		 push	 ecx
  00168	8b ce		 mov	 ecx, esi
  0016a	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42480000
  00172	f3 0f 5e c8	 divss	 xmm1, xmm0
  00176	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@42c80000
  0017e	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00183	e8 00 00 00 00	 call	 ?SetTargetHeight@CCamera@@QAEXM@Z ; CCamera::SetTargetHeight
  00188	5e		 pop	 esi

; 339  : 
; 340  : 	// Cinematic
; 341  : #ifdef __20040725_CAMERA_WORK__
; 342  : 	m_MovementPosition += m_MovementSpeed;
; 343  : 	
; 344  : 	if (0.0f != m_MovementPosition.m_fViewDir)
; 345  : 		MoveFront(m_MovementPosition.m_fViewDir);
; 346  : 	if (0.0f != m_MovementPosition.m_fCrossDir)
; 347  : 		MoveAlongCross(m_MovementPosition.m_fCrossDir);
; 348  : 	if (0.0f != m_MovementPosition.m_fUpDir)
; 349  : 		MoveVertical(m_MovementPosition.m_fUpDir);
; 350  : #endif
; 351  : }

  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
?Update@CCamera@@QAEXXZ ENDP				; CCamera::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ PROC ; CSingleton<CPythonBackground>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCPythonBackground@@@@SAAAVCPythonBackground@@XZ ENDP ; CSingleton<CPythonBackground>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXPAUD3DXVECTOR3@@0@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00004	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00007	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000c	56		 push	 esi
  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00010	8b d3		 mov	 edx, ebx
  00012	2b d6		 sub	 edx, esi
  00014	f7 ea		 imul	 edx
  00016	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  00017	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  0001a	d1 fa		 sar	 edx, 1
  0001c	8b c2		 mov	 eax, edx
  0001e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00021	03 c2		 add	 eax, edx

; 1613 : 		if (_Unused_capacity() < _Count)

  00023	3b c7		 cmp	 eax, edi
  00025	73 66		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00027	2b 31		 sub	 esi, DWORD PTR [ecx]
  00029	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0002e	f7 ee		 imul	 esi

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00030	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00035	d1 fa		 sar	 edx, 1
  00037	8b f2		 mov	 esi, edx
  00039	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0003c	03 f2		 add	 esi, edx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0003e	2b c6		 sub	 eax, esi
  00040	3b c7		 cmp	 eax, edi
  00042	72 50		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00044	2b 19		 sub	 ebx, DWORD PTR [ecx]
  00046	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004b	f7 eb		 imul	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004d	03 f7		 add	 esi, edi

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0004f	bf 55 55 55 15	 mov	 edi, 357913941		; 15555555H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00054	d1 fa		 sar	 edx, 1
  00056	8b c2		 mov	 eax, edx
  00058	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005b	03 c2		 add	 eax, edx

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0005d	8b d0		 mov	 edx, eax
  0005f	d1 ea		 shr	 edx, 1
  00061	2b fa		 sub	 edi, edx
  00063	3b f8		 cmp	 edi, eax
  00065	73 13		 jae	 SHORT $LN27@Reserve
  00067	33 c0		 xor	 eax, eax

; 1576 : 		if (_Capacity < _Count)

  00069	3b c6		 cmp	 eax, esi
  0006b	5f		 pop	 edi
  0006c	0f 42 c6	 cmovb	 eax, esi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00071	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax

; 1618 : 			}
; 1619 : 		}

  00074	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00075	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0007a	03 c2		 add	 eax, edx

; 1576 : 		if (_Capacity < _Count)

  0007c	3b c6		 cmp	 eax, esi
  0007e	5f		 pop	 edi
  0007f	0f 42 c6	 cmovb	 eax, esi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00084	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax

; 1618 : 			}
; 1619 : 		}

  00087	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00088	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
$LN2@Reserve:
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx

; 1618 : 			}
; 1619 : 		}

  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00099	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  0009e	cc		 int	 3
?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Ptr$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$1$ = 8						; size = 4
__Cat$3 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$4 = 11						; size = 1
?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00030	33 f6		 xor	 esi, esi
  00032	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00035	85 ff		 test	 edi, edi
  00037	74 25		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00039	81 ff 55 55 55
	15		 cmp	 edi, 357913941		; 15555555H
  0003f	77 18		 ja	 SHORT $LN15@Reallocate
  00041	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00044	c1 e0 02	 shl	 eax, 2
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004d	8b f0		 mov	 esi, eax
  0004f	83 c4 04	 add	 esp, 4
  00052	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00055	85 f6		 test	 esi, esi
  00057	75 05		 jne	 SHORT $LN16@Reallocate
$LN15@Reallocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN60@Reallocate:
$LN16@Reallocate:
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0005e	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  00061	8d 45 0b	 lea	 eax, DWORD PTR __Alval$4[ebp]
; File a:\vs\vc\include\vector

; 1590 : 		_TRY_BEGIN

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0006b	6a 00		 push	 0
  0006d	50		 push	 eax
  0006e	56		 push	 esi
  0006f	ff 73 04	 push	 DWORD PTR [ebx+4]
  00072	ff 33		 push	 DWORD PTR [ebx]
  00074	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUD3DXVECTOR3@@PAU1@V?$allocator@UD3DXVECTOR3@@@std@@U1@@std@@YAPAUD3DXVECTOR3@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<D3DXVECTOR3 *,D3DXVECTOR3 *,std::allocator<D3DXVECTOR3>,D3DXVECTOR3>
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00079	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0007c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00081	2b 0b		 sub	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00083	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00086	f7 e9		 imul	 ecx

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00088	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0008a	d1 fa		 sar	 edx, 1
  0008c	8b ca		 mov	 ecx, edx
  0008e	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00091	03 ca		 add	 ecx, edx
  00093	89 4d 08	 mov	 DWORD PTR __Size$1$[ebp], ecx

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00096	85 c0		 test	 eax, eax
  00098	74 0c		 je	 SHORT $LN54@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  000a3	83 c4 04	 add	 esp, 4
$LN54@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  000a6	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  000a9	89 33		 mov	 DWORD PTR [ebx], esi
  000ab	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000ae	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000b1	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  000b4	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000b7	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1609 : 		}

  000ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c4	59		 pop	 ecx
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000ce	ff 75 ec	 push	 DWORD PTR __Ptr$2[ebp]
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1594 : 		_RERAISE;

  000d9	6a 00		 push	 0
  000db	6a 00		 push	 0
  000dd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN61@Reallocate:
$LN59@Reallocate:
  000e2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reallocate
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBE_NPBUD3DXVECTOR3@@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	f7 ea		 imul	 edx
  0000f	56		 push	 esi
  00010	d1 fa		 sar	 edx, 1

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00012	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00017	8b f2		 mov	 esi, edx
  00019	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001c	03 f2		 add	 esi, edx

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0001e	8b ce		 mov	 ecx, esi
  00020	d1 e9		 shr	 ecx, 1
  00022	2b c1		 sub	 eax, ecx
  00024	3b c6		 cmp	 eax, esi
  00026	73 10		 jae	 SHORT $LN4@Grow_to
  00028	33 f6		 xor	 esi, esi

; 1576 : 		if (_Capacity < _Count)

  0002a	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0002d	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00038	03 f1		 add	 esi, ecx

; 1576 : 		if (_Capacity < _Count)

  0003a	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0003d	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi

; 1579 : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?_Grow_to@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IBEII@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXPAUD3DXVECTOR3@@0@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4d		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 47		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	d1 fa		 sar	 edx, 1
  00022	8b fa		 mov	 edi, edx
  00024	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00027	03 fa		 add	 edi, edx

; 1247 : 			if (this->_Mylast == this->_Myend)

  00029	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002c	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  0002e	6a 01		 push	 1
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  0003c	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0003f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00042	85 c9		 test	 ecx, ecx
  00044	74 3b		 je	 SHORT $LN49@push_back
  00046	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0004a	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0004e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00051	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00054	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN4@push_back:

; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  0005e	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00061	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00063	6a 01		 push	 1
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@IAEXI@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0006c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006f	85 c9		 test	 ecx, ecx
  00071	74 0e		 je	 SHORT $LN49@push_back
  00073	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00077	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0007b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0007e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00081	83 46 04 0c	 add	 DWORD PTR [esi+4], 12	; 0000000cH
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?push_back@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEAAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEAAUD3DXVECTOR3@@I@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1210 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEAAUD3DXVECTOR3@@I@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1149 : 		}

  00015	c3		 ret	 0
?size@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	d1 fa		 sar	 edx, 1
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1016 : 		}

  00016	c3		 ret	 0
?_Unused_capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	d1 fa		 sar	 edx, 1
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 1011 : 		}

  00015	c3		 ret	 0
?capacity@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAE@ABV?$allocator@UD3DXVECTOR3@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAE@ABV?$allocator@UD3DXVECTOR3@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAE@ABV?$allocator@UD3DXVECTOR3@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::_Vector_alloc<0,std::_Vec_base_types<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 1b		 ja	 SHORT $LN14@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00028	8b c1		 mov	 eax, ecx

; 848  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00033	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::_Wrap_alloc<std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<D3DXVECTOR3> >::_Wrap_alloc<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z PROC ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UD3DXVECTOR3@@@std@@@std@@SAIABV?$allocator@UD3DXVECTOR3@@@2@@Z ENDP ; std::allocator_traits<std::allocator<D3DXVECTOR3> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ PROC	; std::allocator<D3DXVECTOR3>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UD3DXVECTOR3@@@std@@QBEIXZ ENDP	; std::allocator<D3DXVECTOR3>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z PROC ; std::allocator<D3DXVECTOR3>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 594  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?construct@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@ABU3@@Z ENDP ; std::allocator<D3DXVECTOR3>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00011	77 1b		 ja	 SHORT $LN11@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 02	 shl	 eax, 2
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00028	8b c1		 mov	 eax, ecx

; 579  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00033	cc		 int	 3
?allocate@?$allocator@UD3DXVECTOR3@@@std@@QAEPAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ PROC		; std::allocator<D3DXVECTOR3>::allocator<D3DXVECTOR3>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UD3DXVECTOR3@@@std@@QAE@XZ ENDP		; std::allocator<D3DXVECTOR3>::allocator<D3DXVECTOR3>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CDynamicSphereInstance@@QAE@XZ
_TEXT	SEGMENT
??0CDynamicSphereInstance@@QAE@XZ PROC			; CDynamicSphereInstance::CDynamicSphereInstance, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0CDynamicSphereInstance@@QAE@XZ ENDP			; CDynamicSphereInstance::CDynamicSphereInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ PROC ; CSingleton<CCullingManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCullingManager@@@@SAAAVCCullingManager@@XZ ENDP ; CSingleton<CCullingManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?GetUserData@SpherePack@@QBEPAXXZ
_TEXT	SEGMENT
?GetUserData@SpherePack@@QBEPAXXZ PROC			; SpherePack::GetUserData, COMDAT
; _this$ = ecx

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00000	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00003	c3		 ret	 0
?GetUserData@SpherePack@@QBEPAXXZ ENDP			; SpherePack::GetUserData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??_GSpherePackCallback@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSpherePackCallback@@UAEPAXI@Z PROC			; SpherePackCallback::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 56   : 	virtual ~SpherePackCallback() {}

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SpherePackCallback@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GSpherePackCallback@@UAEPAXI@Z ENDP			; SpherePackCallback::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::PointTest2dCallback, COMDAT
; _this$ = ecx

; 79   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_searchpos$ = 8						; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::RangeTestCallback, COMDAT
; _this$ = ecx

; 74   : 	{};

  00000	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; SpherePackCallback::RayTraceCallback, COMDAT
; _this$ = ecx

; 68   : 	{};

  00000	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; SpherePackCallback::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::VisibilityCallback, COMDAT
; _this$ = ecx

; 61   : 	{};

  00000	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??1SpherePackCallback@@UAE@XZ
_TEXT	SEGMENT
??1SpherePackCallback@@UAE@XZ PROC			; SpherePackCallback::~SpherePackCallback, COMDAT
; _this$ = ecx

; 56   : 	virtual ~SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	c3		 ret	 0
??1SpherePackCallback@@UAE@XZ ENDP			; SpherePackCallback::~SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\spherepack.h
;	COMDAT ??0SpherePackCallback@@QAE@XZ
_TEXT	SEGMENT
??0SpherePackCallback@@QAE@XZ PROC			; SpherePackCallback::SpherePackCallback, COMDAT
; _this$ = ecx

; 55   : 	SpherePackCallback() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SpherePackCallback@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0SpherePackCallback@@QAE@XZ ENDP			; SpherePackCallback::SpherePackCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?Set@Vector3d@@QAEXMMM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
?Set@Vector3d@@QAEXMMM@Z PROC				; Vector3d::Set, COMDAT
; _this$ = ecx

; 106  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 		x = a;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _a$[ebp]
  00008	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 108  : 		y = b;

  0000c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  00011	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 109  : 		z = c;

  00016	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _c$[ebp]
  0001b	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 110  : 	};

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
?Set@Vector3d@@QAEXMMM@Z ENDP				; Vector3d::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??0Vector3d@@QAE@XZ
_TEXT	SEGMENT
??0Vector3d@@QAE@XZ PROC				; Vector3d::Vector3d, COMDAT
; _this$ = ecx

; 26   : 	Vector3d(void) { };  // null constructor, does not inialize point.

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0Vector3d@@QAE@XZ ENDP				; Vector3d::Vector3d
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00006	8b 45 10	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _pV1$[ebp]
  0000c	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]
  00011	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00016	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  0001b	f3 0f 59 79 04	 mulss	 xmm7, DWORD PTR [ecx+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00020	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00024	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  00028	0f 28 cb	 movaps	 xmm1, xmm3
  0002b	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  00030	f3 0f 5c f8	 subss	 xmm7, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00034	f3 0f 59 59 04	 mulss	 xmm3, DWORD PTR [ecx+4]
  00039	0f 28 c2	 movaps	 xmm0, xmm2
  0003c	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00041	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]

; 1280 : 
; 1281 :     *pOut = v;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00049	f3 0f 5c c8	 subss	 xmm1, xmm0
  0004d	f3 0f 5c d3	 subss	 xmm2, xmm3
  00051	0f 14 f9	 unpcklps xmm7, xmm1
  00054	66 0f d6 38	 movq	 QWORD PTR [eax], xmm7
  00058	f3 0f 11 55 fc	 movss	 DWORD PTR _v$[ebp+8], xmm2
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _v$[ebp+8]
  00060	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1282 :     return pOut;
; 1283 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z PROC		; D3DXVec3Dot, COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	d9 01		 fld	 DWORD PTR [ecx]
  00011	d8 08		 fmul	 DWORD PTR [eax]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00018	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001b	de c1		 faddp	 ST(1), ST(0)

; 1265 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z ENDP		; D3DXVec3Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv161 = -4						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3Length, COMDAT

; 1232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  0000c	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00011	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00015	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001a	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0001e	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00022	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00026	f3 0f 58 d1	 addss	 xmm2, xmm1
  0002a	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0002e	0f 5a c2	 cvtps2pd xmm0, xmm2
  00031	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00036	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0003a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv161[esp+8], xmm0
  00040	d9 44 24 04	 fld	 DWORD PTR tv161[esp+8]

; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?D3DXVec3Length@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3Length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]

; 180  :     x = fx;

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00016	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0001a	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00023	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00028	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002d	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  00031	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 284  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]

; 180  :     x = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00015	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0001a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00024	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00029	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 258  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??XD3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??XD3DXVECTOR3@@QAEAAU0@M@Z PROC			; D3DXVECTOR3::operator*=, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 222  :     x *= f;

  00003	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;

  00007	8b c1		 mov	 eax, ecx
  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _f$[ebp]
  0000e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00012	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00016	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001b	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0001f	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0002d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 226  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??XD3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 1066 :         {return (fabsf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00013	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 1066 :         {return (fabsf(_X)); }

  00017	f3 0f 11 45 08	 movss	 DWORD PTR tv65[ebp], xmm0
  0001c	d9 45 08	 fld	 DWORD PTR tv65[ebp]
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 776  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv69 = -8						; size = 8
tv75 = 8						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 700  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 701  :     return (float)floor(_X);

  0000b	83 ec 08	 sub	 esp, 8
  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	f2 0f 11 45 f8	 movsd	 QWORD PTR tv69[ebp], xmm0
  00016	dd 45 f8	 fld	 QWORD PTR tv69[ebp]
  00019	dd 1c 24	 fstp	 QWORD PTR [esp]
  0001c	e8 00 00 00 00	 call	 _floor
  00021	d9 5d 08	 fstp	 DWORD PTR tv75[ebp]
  00024	d9 45 08	 fld	 DWORD PTR tv75[ebp]
  00027	83 c4 08	 add	 esp, 8

; 702  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_floorf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00013	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00017	f3 0f 11 45 08	 movss	 DWORD PTR tv68[ebp], xmm0
  0001c	d9 45 08	 fld	 DWORD PTR tv68[ebp]

; 688  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
END
