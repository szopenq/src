; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\GameLib\MapOutdoorRender.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?memchr@@YAPAXPAXHI@Z				; memchr
PUBLIC	_fabsf
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0D3DXVECTOR3@@QAE@ABU_D3DVECTOR@@@Z		; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	??0D3DXCOLOR@@QAE@MMMM@Z			; D3DXCOLOR::D3DXCOLOR
PUBLIC	??BD3DXCOLOR@@QBEKXZ				; D3DXCOLOR::operator unsigned long
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
PUBLIC	?D3DXPlaneDotCoord@@YAMPBUD3DXPLANE@@PBUD3DXVECTOR3@@@Z ; D3DXPlaneDotCoord
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?deallocate@?$allocator@E@std@@QAEXPAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
PUBLIC	?construct@?$allocator@E@std@@QAEXPAEABE@Z	; std::allocator<unsigned char>::construct
PUBLIC	?max_size@?$allocator@E@std@@QBEIXZ		; std::allocator<unsigned char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ; std::allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<unsigned char> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unused_capacity
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEXABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Grow_to
PUBLIC	?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Inside
PUBLIC	?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
PUBLIC	?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ ; CGraphicVertexBuffer::GetD3DVertexBuffer
PUBLIC	?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::begin
PUBLIC	?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::end
PUBLIC	?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::size
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Unchecked
PUBLIC	?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ ; CSingleton<CSpeedTreeForestDirectX8>::Instance
PUBLIC	??0?$allocator@PAVCGraphicThingInstance@@@std@@QAE@XZ ; std::allocator<CGraphicThingInstance *>::allocator<CGraphicThingInstance *>
PUBLIC	?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z ; std::allocator<CGraphicThingInstance *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicThingInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
PUBLIC	??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
PUBLIC	?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin
PUBLIC	?end@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::end
PUBLIC	?size@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::size
PUBLIC	?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXPAPAVCGraphicThingInstance@@0@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
PUBLIC	??0FFindIfCRC@CArea@@QAE@K@Z			; CArea::FFindIfCRC::FFindIfCRC
PUBLIC	??RFFindIfCRC@CArea@@QAE_NAAUSCRCWithNumber@1@@Z ; CArea::FFindIfCRC::operator()
PUBLIC	??RCRCNumComp@CArea@@QBE_NAAUSCRCWithNumber@1@0@Z ; CArea::CRCNumComp::operator()
PUBLIC	??0?$allocator@USCRCWithNumber@CArea@@@std@@QAE@XZ ; std::allocator<CArea::SCRCWithNumber>::allocator<CArea::SCRCWithNumber>
PUBLIC	?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z ; std::allocator<CArea::SCRCWithNumber>::deallocate
PUBLIC	?allocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z ; std::allocator<CArea::SCRCWithNumber>::allocate
PUBLIC	?construct@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU34@@Z ; std::allocator<CArea::SCRCWithNumber>::construct
PUBLIC	?max_size@?$allocator@USCRCWithNumber@CArea@@@std@@QBEIXZ ; std::allocator<CArea::SCRCWithNumber>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAIABV?$allocator@USCRCWithNumber@CArea@@@2@@Z ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> >::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@ABV?$allocator@USCRCWithNumber@CArea@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >::_Getal
PUBLIC	??0?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >
PUBLIC	??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::~vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >
PUBLIC	?capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::capacity
PUBLIC	?_Unused_capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Unused_capacity
PUBLIC	?begin@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::begin
PUBLIC	?end@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::end
PUBLIC	?size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::size
PUBLIC	?max_size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::max_size
PUBLIC	?push_back@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::push_back
PUBLIC	?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear
PUBLIC	?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXPAUSCRCWithNumber@CArea@@0@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy
PUBLIC	?_Grow_to@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEII@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Grow_to
PUBLIC	?_Inside@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBE_NPBUSCRCWithNumber@CArea@@@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Inside
PUBLIC	?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reallocate
PUBLIC	?_Reserve@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reserve
PUBLIC	?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy
PUBLIC	?_Xlen@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXPAUSCRCWithNumber@CArea@@0@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Orphan_range
PUBLIC	?isUsed@CTerrainPatchProxy@@QAE_NXZ		; CTerrainPatchProxy::isUsed
PUBLIC	?GetPatchNum@CTerrainPatchProxy@@QAEFXZ		; CTerrainPatchProxy::GetPatchNum
PUBLIC	?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ	; CTerrainPatchProxy::GetTerrainNum
PUBLIC	?IsMarked@CTerrain@@QAEHXZ			; CTerrain::IsMarked
PUBLIC	?GetMarkedSplatPatch@CTerrain@@QAEAAUTTerrainSplatPatch@@XZ ; CTerrain::GetMarkedSplatPatch
PUBLIC	?GetCoordinate@CTerrain@@QAEXPAG0@Z		; CTerrain::GetCoordinate
PUBLIC	?OnRender@CMapOutdoor@@MAEXXZ			; CMapOutdoor::OnRender
PUBLIC	?SetInverseViewAndDynamicShaodwMatrices@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetInverseViewAndDynamicShaodwMatrices
PUBLIC	?SetVisiblePart@CMapOutdoor@@QAEXH_N@Z		; CMapOutdoor::SetVisiblePart
PUBLIC	?SetSplatLimit@CMapOutdoor@@QAEXH@Z		; CMapOutdoor::SetSplatLimit
PUBLIC	?GetRenderedSplatNum@CMapOutdoor@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@PAH0PAM@Z ; CMapOutdoor::GetRenderedSplatNum
PUBLIC	?GetRenderedGraphicThingInstanceNum@CMapOutdoor@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@PAK0@Z ; CMapOutdoor::GetRenderedGraphicThingInstanceNum
PUBLIC	?ApplyLight@CMapOutdoor@@UAEXKABU_D3DLIGHT8@@@Z	; CMapOutdoor::ApplyLight
PUBLIC	?RenderMarkedArea@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderMarkedArea
PUBLIC	?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::RecurseRenderAttr
PUBLIC	?DrawPatchAttr@CMapOutdoor@@QAEXJ@Z		; CMapOutdoor::DrawPatchAttr
PUBLIC	?RenderCollision@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderCollision
PUBLIC	?RenderSky@CMapOutdoor@@QAEXXZ			; CMapOutdoor::RenderSky
PUBLIC	?RenderCloud@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderCloud
PUBLIC	?RenderBeforeLensFlare@CMapOutdoor@@QAEXXZ	; CMapOutdoor::RenderBeforeLensFlare
PUBLIC	?RenderAfterLensFlare@CMapOutdoor@@QAEXXZ	; CMapOutdoor::RenderAfterLensFlare
PUBLIC	?RenderScreenFiltering@CMapOutdoor@@QAEXXZ	; CMapOutdoor::RenderScreenFiltering
PUBLIC	?RenderTerrain@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderTerrain
PUBLIC	?RenderArea@CMapOutdoor@@QAEX_N@Z		; CMapOutdoor::RenderArea
PUBLIC	?RenderBlendArea@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderBlendArea
PUBLIC	?RenderDungeon@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderDungeon
PUBLIC	?RenderEffect@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderEffect
PUBLIC	?RenderPCBlocker@CMapOutdoor@@QAEXXZ		; CMapOutdoor::RenderPCBlocker
PUBLIC	?RenderTree@CMapOutdoor@@QAEXXZ			; CMapOutdoor::RenderTree
PUBLIC	??0FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE@XZ ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::FSortPatchDrawStructWithTerrainNum
PUBLIC	??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
PUBLIC	??0?$allocator@U?$pair@MJ@std@@@std@@QAE@XZ	; std::allocator<std::pair<float,long> >::allocator<std::pair<float,long> >
PUBLIC	?deallocate@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z ; std::allocator<std::pair<float,long> >::deallocate
PUBLIC	?allocate@?$allocator@U?$pair@MJ@std@@@std@@QAEPAU?$pair@MJ@2@I@Z ; std::allocator<std::pair<float,long> >::allocate
PUBLIC	?max_size@?$allocator@U?$pair@MJ@std@@@std@@QBEIXZ ; std::allocator<std::pair<float,long> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAIABV?$allocator@U?$pair@MJ@std@@@2@@Z ; std::allocator_traits<std::allocator<std::pair<float,long> > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::_Wrap_alloc<std::allocator<std::pair<float,long> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEPAU?$pair@MJ@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::max_size
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<float,long>,std::allocator<std::pair<float,long> > > >::_Getal
PUBLIC	?push_back@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEX$$QAU?$pair@MJ@2@@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::push_back
PUBLIC	?capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::capacity
PUBLIC	?_Unused_capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Unused_capacity
PUBLIC	?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin
PUBLIC	?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::end
PUBLIC	?size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::size
PUBLIC	?max_size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::max_size
PUBLIC	?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::clear
PUBLIC	?_Destroy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXPAU?$pair@MJ@2@0@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Destroy
PUBLIC	?_Grow_to@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEII@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Grow_to
PUBLIC	?_Inside@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBE_NPBU?$pair@MJ@2@@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Inside
PUBLIC	?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reallocate
PUBLIC	?_Reserve@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reserve
PUBLIC	?_Xlen@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Xlen
PUBLIC	?_Orphan_range@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXPAU?$pair@MJ@2@0@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Orphan_range
PUBLIC	??0?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ ; std::allocator<CMapOutdoor::TPatchDrawStruct>::allocator<CMapOutdoor::TPatchDrawStruct>
PUBLIC	?deallocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z ; std::allocator<CMapOutdoor::TPatchDrawStruct>::deallocate
PUBLIC	?allocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z ; std::allocator<CMapOutdoor::TPatchDrawStruct>::allocate
PUBLIC	?construct@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct
PUBLIC	?max_size@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEIXZ ; std::allocator<CMapOutdoor::TPatchDrawStruct>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAIABV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@2@@Z ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> > >::_Getal
PUBLIC	?capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::capacity
PUBLIC	?_Unused_capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Unused_capacity
PUBLIC	?begin@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::begin
PUBLIC	?end@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::end
PUBLIC	?size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::size
PUBLIC	?max_size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size
PUBLIC	?push_back@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXABUTPatchDrawStruct@CMapOutdoor@@@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::push_back
PUBLIC	?clear@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::clear
PUBLIC	?_Destroy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Destroy
PUBLIC	?_Grow_to@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEII@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Grow_to
PUBLIC	?_Inside@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBE_NPBUTPatchDrawStruct@CMapOutdoor@@@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Inside
PUBLIC	?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reserve
PUBLIC	?_Xlen@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Orphan_range
PUBLIC	?SetPatchDrawVector@CMapOutdoor@@IAEXXZ		; CMapOutdoor::SetPatchDrawVector
PUBLIC	?NEW_DrawWireFrame@CMapOutdoor@@IAEXPAVCTerrainPatchProxy@@GW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::NEW_DrawWireFrame
PUBLIC	?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::DrawWireFrame
PUBLIC	?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
PUBLIC	?InitializeVisibleParts@CMapOutdoor@@IAEXXZ	; CMapOutdoor::InitializeVisibleParts
PUBLIC	?IsVisiblePart@CMapOutdoor@@IAE_NH@Z		; CMapOutdoor::IsVisiblePart
PUBLIC	?__GetNoFogDistance@CMapOutdoor@@IAEMXZ		; CMapOutdoor::__GetNoFogDistance
PUBLIC	?__GetFogDistance@CMapOutdoor@@IAEMXZ		; CMapOutdoor::__GetFogDistance
PUBLIC	?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree
PUBLIC	?__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle@CMapOutdoor@@IAEHABUD3DXVECTOR3@@ABM@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle
PUBLIC	?__RenderTerrain_AppendPatch@CMapOutdoor@@IAEXABUD3DXVECTOR3@@MJ@Z ; CMapOutdoor::__RenderTerrain_AppendPatch
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator-
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV12@PAE@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unchecked
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator-
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@E@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@0ABE@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char>
PUBLIC	?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ		; CCamera::GetEye
PUBLIC	?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ	; CCamera::GetTarget
PUBLIC	?GetInverseViewMatrix@CCamera@@QBEABUD3DXMATRIX@@XZ ; CCamera::GetInverseViewMatrix
PUBLIC	?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ; CSingleton<CCameraManager>::Instance
PUBLIC	?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ; CSingleton<CStateManager>::Instance
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator-
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@2@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator-
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > > >
PUBLIC	??$make_pair@AAMAAJ@std@@YA?AU?$pair@MJ@0@AAMAAJ@Z ; std::make_pair<float &,long &>
PUBLIC	??4?$pair@MJ@std@@QAEAAU01@$$QAU01@@Z		; std::pair<float,long>::operator=
PUBLIC	?swap@?$pair@MJ@std@@QAEXAAU12@@Z		; std::pair<float,long>::swap
PUBLIC	??RFAreaRenderShadow@@QAEXPAVCGraphicObjectInstance@@@Z ; FAreaRenderShadow::operator()
PUBLIC	??RFPCBlockerHide@@QAEXPAVCGraphicObjectInstance@@@Z ; FPCBlockerHide::operator()
PUBLIC	??RFRenderPCBlocker@@QAEXPAVCGraphicObjectInstance@@@Z ; FRenderPCBlocker::operator()
PUBLIC	??RCMapOutdoor_LessThingInstancePtrRenderOrder@@QAE_NPAVCGraphicThingInstance@@0@Z ; CMapOutdoor_LessThingInstancePtrRenderOrder::operator()
PUBLIC	??RCMapOutdoor_FOpaqueThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z ; CMapOutdoor_FOpaqueThingInstanceRender::operator()
PUBLIC	??RCMapOutdoor_FBlendThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z ; CMapOutdoor_FBlendThingInstanceRender::operator()
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerHide@@@std@@YA?AUFPCBlockerHide@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FPCBlockerHide>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFAreaRenderShadow@@@std@@YA?AUFAreaRenderShadow@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FAreaRenderShadow>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEABUSCRCWithNumber@CArea@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator-
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV12@PAUSCRCWithNumber@CArea@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEPAUSCRCWithNumber@CArea@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEAAUSCRCWithNumber@CArea@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator-
PUBLIC	??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@0UFFindIfCRC@CArea@@@Z ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::FFindIfCRC>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UCRCNumComp@CArea@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@0UCRCNumComp@CArea@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::CRCNumComp>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::operator-
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicThingInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Unchecked
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::operator-
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA?AUCMapOutdoor_FOpaqueThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_FOpaqueThingInstanceRender>
PUBLIC	??$void_mem_fun@VCGraphicObjectInstance@@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@P8CGraphicObjectInstance@@AEXXZ@Z ; std::void_mem_fun<CGraphicObjectInstance>
PUBLIC	??0?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QAE@P8CGraphicObjectInstance@@AEXXZ@Z ; std::void_mem_fun_t<CGraphicObjectInstance>::void_mem_fun_t<CGraphicObjectInstance>
PUBLIC	??R?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QBEXPAVCGraphicObjectInstance@@@Z ; std::void_mem_fun_t<CGraphicObjectInstance>::operator()
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@2@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0V10@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,std::void_mem_fun_t<CGraphicObjectInstance> >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YA?AUCMapOutdoor_FBlendThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_FBlendThingInstanceRender>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFRenderPCBlocker@@@std@@YA?AUFRenderPCBlocker@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FRenderPCBlocker>
PUBLIC	??$?0MJX@?$pair@MJ@std@@QAE@$$QAU01@@Z		; std::pair<float,long>::pair<float,long><float,long,void>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Unchecked
PUBLIC	??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@0UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@Z ; std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$addressof@$$CBE@std@@YAPBEABE@Z		; std::addressof<unsigned char const >
PUBLIC	??$construct@EAAE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEAAE@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
PUBLIC	??$construct@EABE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEABE@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
PUBLIC	??$addressof@$$CBUSCRCWithNumber@CArea@@@std@@YAPBUSCRCWithNumber@CArea@@ABU12@@Z ; std::addressof<CArea::SCRCWithNumber const >
PUBLIC	??$construct@USCRCWithNumber@CArea@@AAU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>
PUBLIC	??$construct@USCRCWithNumber@CArea@@ABU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU23@@Z ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber const &>
PUBLIC	??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z ; std::addressof<std::pair<float,long> >
PUBLIC	??$forward@U?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z ; std::forward<std::pair<float,long> >
PUBLIC	??$construct@U?$pair@MJ@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::construct<std::pair<float,long>,std::pair<float,long> >
PUBLIC	??$addressof@$$CBUTPatchDrawStruct@CMapOutdoor@@@std@@YAPBUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z ; std::addressof<CMapOutdoor::TPatchDrawStruct const >
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU23@@Z ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct const &>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned char> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
PUBLIC	??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>
PUBLIC	??$_Umove@PAUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEPAUSCRCWithNumber@CArea@@PAU23@00@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Umove<CArea::SCRCWithNumber *>
PUBLIC	??$_Umove@PAU?$pair@MJ@std@@@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEPAU?$pair@MJ@1@PAU21@00@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Umove<std::pair<float,long> *>
PUBLIC	??$_Umove@PAUTPatchDrawStruct@CMapOutdoor@@@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEPAUTPatchDrawStruct@CMapOutdoor@@PAU23@00@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Umove<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Allocate@E@std@@YAPAEIPAE@Z			; std::_Allocate<unsigned char>
PUBLIC	??$_Allocate@USCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@IPAU12@@Z ; std::_Allocate<CArea::SCRCWithNumber>
PUBLIC	??$_Allocate@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@IPAU10@@Z ; std::_Allocate<std::pair<float,long> >
PUBLIC	??$_Allocate@UTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@IPAU12@@Z ; std::_Allocate<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAEV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??$_Find@PAEE@std@@YAPAEPAE0ABE@Z		; std::_Find<unsigned char *,unsigned char>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AAV10@PAE@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<unsigned char> > >
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0U?$less@X@0@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::less<void> >
PUBLIC	??$forward@AAM@std@@YAAAMAAM@Z			; std::forward<float &>
PUBLIC	??$forward@AAJ@std@@YAAAJAAJ@Z			; std::forward<long &>
PUBLIC	??$?0AAMAAJX@?$pair@MJ@std@@QAE@AAMAAJ@Z	; std::pair<float,long>::pair<float,long><float &,long &,void>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
PUBLIC	??$_For_each@PAPAVCGraphicObjectInstance@@UFPCBlockerHide@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFPCBlockerHide@@@Z ; std::_For_each<CGraphicObjectInstance * *,FPCBlockerHide>
PUBLIC	??$move@AAUFPCBlockerHide@@@std@@YA$$QAUFPCBlockerHide@@AAU1@@Z ; std::move<FPCBlockerHide &>
PUBLIC	??$_For_each@PAPAVCGraphicObjectInstance@@UFAreaRenderShadow@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFAreaRenderShadow@@@Z ; std::_For_each<CGraphicObjectInstance * *,FAreaRenderShadow>
PUBLIC	??$move@AAUFAreaRenderShadow@@@std@@YA$$QAUFAreaRenderShadow@@AAU1@@Z ; std::move<FAreaRenderShadow &>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
PUBLIC	??$_Find_if@PAUSCRCWithNumber@CArea@@UFFindIfCRC@2@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@0UFFindIfCRC@2@@Z ; std::_Find_if<CArea::SCRCWithNumber *,CArea::FFindIfCRC>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@AAV10@PAUSCRCWithNumber@CArea@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
PUBLIC	??$_Sort@PAUSCRCWithNumber@CArea@@HUCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort<CArea::SCRCWithNumber *,int,CArea::CRCNumComp>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAPAPAVCGraphicThingInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
PUBLIC	??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FOpaqueThingInstanceRender@@@Z ; std::_For_each<CGraphicThingInstance * *,CMapOutdoor_FOpaqueThingInstanceRender>
PUBLIC	??$move@AAUCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FOpaqueThingInstanceRender@@AAU1@@Z ; std::move<CMapOutdoor_FOpaqueThingInstanceRender &>
PUBLIC	??$_For_each@PAPAVCGraphicObjectInstance@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@@Z ; std::_For_each<CGraphicObjectInstance * *,std::void_mem_fun_t<CGraphicObjectInstance> >
PUBLIC	??$move@AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YA$$QAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@AAV10@@Z ; std::move<std::void_mem_fun_t<CGraphicObjectInstance> &>
PUBLIC	??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FBlendThingInstanceRender@@@Z ; std::_For_each<CGraphicThingInstance * *,CMapOutdoor_FBlendThingInstanceRender>
PUBLIC	??$move@AAUCMapOutdoor_FBlendThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FBlendThingInstanceRender@@AAU1@@Z ; std::move<CMapOutdoor_FBlendThingInstanceRender &>
PUBLIC	??$_For_each@PAPAVCGraphicObjectInstance@@UFRenderPCBlocker@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFRenderPCBlocker@@@Z ; std::_For_each<CGraphicObjectInstance * *,FRenderPCBlocker>
PUBLIC	??$move@AAUFRenderPCBlocker@@@std@@YA$$QAUFRenderPCBlocker@@AAU1@@Z ; std::move<FRenderPCBlocker &>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >
PUBLIC	??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > > >
PUBLIC	??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > > >
PUBLIC	??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$forward@AAE@std@@YAAAEAAE@Z			; std::forward<unsigned char &>
PUBLIC	??$construct@EAAE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEAAE@Z ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
PUBLIC	??$forward@ABE@std@@YAABEABE@Z			; std::forward<unsigned char const &>
PUBLIC	??$construct@EABE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEABE@Z ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
PUBLIC	??$forward@AAUSCRCWithNumber@CArea@@@std@@YAAAUSCRCWithNumber@CArea@@AAU12@@Z ; std::forward<CArea::SCRCWithNumber &>
PUBLIC	??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@AAU34@@Z ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>
PUBLIC	??$forward@ABUSCRCWithNumber@CArea@@@std@@YAABUSCRCWithNumber@CArea@@ABU12@@Z ; std::forward<CArea::SCRCWithNumber const &>
PUBLIC	??$construct@USCRCWithNumber@CArea@@ABU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@ABU34@@Z ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber const &>
PUBLIC	??$construct@U?$pair@MJ@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::pair<float,long> > >::construct<std::pair<float,long>,std::pair<float,long> >
PUBLIC	??$forward@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ; std::forward<CMapOutdoor::TPatchDrawStruct &>
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@AAU34@@Z ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>
PUBLIC	??$forward@ABUTPatchDrawStruct@CMapOutdoor@@@std@@YAABUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z ; std::forward<CMapOutdoor::TPatchDrawStruct const &>
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct const &>
PUBLIC	??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z ; std::_Ptr_cat<unsigned char,unsigned char>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned char> > >
PUBLIC	??$_Ptr_cat@PAVCGraphicThingInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicThingInstance@@0@Z ; std::_Ptr_cat<CGraphicThingInstance *,CGraphicThingInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> > >
PUBLIC	??$_Ptr_cat@USCRCWithNumber@CArea@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSCRCWithNumber@CArea@@0@Z ; std::_Ptr_cat<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
PUBLIC	??$_Ptr_cat@U?$pair@MJ@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@MJ@0@0@Z ; std::_Ptr_cat<std::pair<float,long>,std::pair<float,long> >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
PUBLIC	??$_Ptr_cat@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTPatchDrawStruct@CMapOutdoor@@0@Z ; std::_Ptr_cat<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
PUBLIC	??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char> > >
PUBLIC	??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z ; std::_Uninitialized_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
PUBLIC	??$_Uninitialized_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<float,long> *,std::pair<float,long> *,std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
PUBLIC	??$_Uninitialized_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z ; std::_Uninitialized_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
PUBLIC	??$_Find@PAEE@std@@YAPAEPAE0ABEU?$integral_constant@_N$00@0@@Z ; std::_Find<unsigned char *,unsigned char>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@YAPAU?$pair@MJ@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z ; std::_Sort<std::pair<float,long> *,int,std::less<void> >
PUBLIC	??$_Unguarded_partition@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z ; std::_Unguarded_partition<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$make_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::make_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Insertion_sort@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Insertion_sort<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Unguarded_partition@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@0@PAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Unguarded_partition<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$make_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::make_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Insertion_sort@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Insertion_sort<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Distance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAH@Z ; std::_Distance<CMapOutdoor::TPatchDrawStruct *,int>
PUBLIC	??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@H@Z ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??1?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::~_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator=
PUBLIC	??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@$$QAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator=
PUBLIC	??D?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator*
PUBLIC	??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator++
PUBLIC	??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@H@Z ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator++
PUBLIC	?_Init@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Init
PUBLIC	?_First@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_First
PUBLIC	?_Last@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Last
PUBLIC	?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Maxlen
PUBLIC	??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$construct@EAAE@?$allocator@E@std@@QAEXPAEAAE@Z ; std::allocator<unsigned char>::construct<unsigned char,unsigned char &>
PUBLIC	??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z ; std::allocator<CArea::SCRCWithNumber>::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>
PUBLIC	??$construct@U?$pair@MJ@std@@U12@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z ; std::allocator<std::pair<float,long> >::construct<std::pair<float,long>,std::pair<float,long> >
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>
PUBLIC	??$destroy@USCRCWithNumber@CArea@@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::destroy<CArea::SCRCWithNumber>
PUBLIC	??$destroy@U?$pair@MJ@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::destroy<std::pair<float,long> >
PUBLIC	??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::destroy<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Unchecked@PAE@std@@YAPAEPAE@Z		; std::_Unchecked<unsigned char *>
PUBLIC	??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninit_move<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char> > >
PUBLIC	??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z	; std::_Rechecked<unsigned char *,unsigned char *>
PUBLIC	??$_Unchecked@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z ; std::_Unchecked<CArea::SCRCWithNumber *>
PUBLIC	??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
PUBLIC	??$_Rechecked@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@PAU12@@Z ; std::_Rechecked<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
PUBLIC	??$_Unchecked@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Unchecked<std::pair<float,long> *>
PUBLIC	??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
PUBLIC	??$_Rechecked@PAU?$pair@MJ@std@@PAU12@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@PAU10@@Z ; std::_Rechecked<std::pair<float,long> *,std::pair<float,long> *>
PUBLIC	??$_Unchecked@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z ; std::_Unchecked<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
PUBLIC	??$_Rechecked@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@PAU12@@Z ; std::_Rechecked<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Destroy@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::_Destroy<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$return_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::return_temporary_buffer<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Within_limits@PAEE@std@@YA_NPAEABE@Z	; std::_Within_limits<unsigned char *,unsigned char>
PUBLIC	??$_Unguarded_partition@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MJ@std@@PAU12@@0@PAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::_Unguarded_partition<std::pair<float,long> *,std::less<void> >
PUBLIC	??$make_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::make_heap<std::pair<float,long> *,std::less<void> >
PUBLIC	??$sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::sort_heap<std::pair<float,long> *,std::less<void> >
PUBLIC	??$_Insertion_sort@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::_Insertion_sort<std::pair<float,long> *,std::less<void> >
PUBLIC	??$_Median@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Median<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$iter_swap@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAXPAUSCRCWithNumber@CArea@@0@Z ; std::iter_swap<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
PUBLIC	??$?0AAPAUSCRCWithNumber@CArea@@AAPAU01@X@?$pair@PAUSCRCWithNumber@CArea@@PAU12@@std@@QAE@AAPAUSCRCWithNumber@CArea@@0@Z ; std::pair<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>::pair<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *><CArea::SCRCWithNumber * &,CArea::SCRCWithNumber * &,void>
PUBLIC	??$_Dist_type@PAUSCRCWithNumber@CArea@@@std@@YAPAHPAUSCRCWithNumber@CArea@@@Z ; std::_Dist_type<CArea::SCRCWithNumber *>
PUBLIC	??$_Val_type@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z ; std::_Val_type<CArea::SCRCWithNumber *>
PUBLIC	??$_Make_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@PAH0@Z ; std::_Make_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
PUBLIC	??$_Sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Insertion_sort1@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@U12@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z ; std::_Insertion_sort1<CArea::SCRCWithNumber *,CArea::CRCNumComp,CArea::SCRCWithNumber>
PUBLIC	??$_Median@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Median<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$iter_swap@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAXPAPAVCGraphicThingInstance@@0@Z ; std::iter_swap<CGraphicThingInstance * *,CGraphicThingInstance * *>
PUBLIC	??$?0AAPAPAVCGraphicThingInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicThingInstance@@0@Z ; std::pair<CGraphicThingInstance * *,CGraphicThingInstance * *>::pair<CGraphicThingInstance * *,CGraphicThingInstance * *><CGraphicThingInstance * * &,CGraphicThingInstance * * &,void>
PUBLIC	??$_Unchecked@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z ; std::_Unchecked<CGraphicThingInstance * *>
PUBLIC	??$_Dist_type@PAPAVCGraphicThingInstance@@@std@@YAPAHPAPAVCGraphicThingInstance@@@Z ; std::_Dist_type<CGraphicThingInstance * *>
PUBLIC	??$_Val_type@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z ; std::_Val_type<CGraphicThingInstance * *>
PUBLIC	??$_Make_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH0@Z ; std::_Make_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Insertion_sort1@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAV1@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z ; std::_Insertion_sort1<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder,CGraphicThingInstance *>
PUBLIC	??$_Iter_cat@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::_Iter_cat<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Distance2@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CMapOutdoor::TPatchDrawStruct *,int>
PUBLIC	??$_Insertion_sort@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Insertion_sort<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@H@Z ; std::advance<CMapOutdoor::TPatchDrawStruct *,int>
PUBLIC	??$_Buffered_merge_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Buffered_merge_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$_Buffered_merge@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Buffered_merge<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$destroy@USCRCWithNumber@CArea@@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@@Z ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::destroy<CArea::SCRCWithNumber>
PUBLIC	??$destroy@U?$pair@MJ@std@@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@@Z ; std::allocator_traits<std::allocator<std::pair<float,long> > >::destroy<std::pair<float,long> >
PUBLIC	??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::destroy<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Val_type@PAE@std@@YAPAEPAE@Z		; std::_Val_type<unsigned char *>
PUBLIC	??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned char,unsigned char,unsigned char>
PUBLIC	??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber>,CArea::SCRCWithNumber>
PUBLIC	??$_Val_type@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Val_type<std::pair<float,long> *>
PUBLIC	??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::allocator<std::pair<float,long> >,std::pair<float,long> >
PUBLIC	??$_Val_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z ; std::_Val_type<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::allocator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$get_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YA?AU?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@0@H@Z ; std::get_temporary_buffer<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Within_limits@EU?$integral_constant@_N$0A@@std@@@std@@YA_NABEU?$integral_constant@_N$0A@@0@11@Z ; std::_Within_limits<unsigned char,std::integral_constant<bool,0> >
PUBLIC	??$_Median@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Median<std::pair<float,long> *,std::less<void> >
PUBLIC	??$?MMJ@std@@YA_NABU?$pair@MJ@0@0@Z		; std::operator<<float,long>
PUBLIC	??$?RAAU?$pair@MJ@std@@AAU01@@?$less@X@std@@QBE_NAAU?$pair@MJ@1@0@Z ; std::less<void>::operator()<std::pair<float,long> &,std::pair<float,long> &>
PUBLIC	??$iter_swap@PAU?$pair@MJ@std@@PAU12@@std@@YAXPAU?$pair@MJ@0@0@Z ; std::iter_swap<std::pair<float,long> *,std::pair<float,long> *>
PUBLIC	??$?0AAPAU?$pair@MJ@std@@AAPAU01@X@?$pair@PAU?$pair@MJ@std@@PAU12@@std@@QAE@AAPAU?$pair@MJ@1@0@Z ; std::pair<std::pair<float,long> *,std::pair<float,long> *>::pair<std::pair<float,long> *,std::pair<float,long> *><std::pair<float,long> * &,std::pair<float,long> * &,void>
PUBLIC	??$_Dist_type@PAU?$pair@MJ@std@@@std@@YAPAHPAU?$pair@MJ@0@@Z ; std::_Dist_type<std::pair<float,long> *>
PUBLIC	??$_Make_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@PAH0@Z ; std::_Make_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
PUBLIC	??$_Sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::_Sort_heap<std::pair<float,long> *,std::less<void> >
PUBLIC	??$_Insertion_sort1@PAU?$pair@MJ@std@@U?$less@X@2@U12@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z ; std::_Insertion_sort1<std::pair<float,long> *,std::less<void>,std::pair<float,long> >
PUBLIC	??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$swap@USCRCWithNumber@CArea@@@std@@YAXAAUSCRCWithNumber@CArea@@0@Z ; std::swap<CArea::SCRCWithNumber>
PUBLIC	??$forward@AAPAUSCRCWithNumber@CArea@@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@@Z ; std::forward<CArea::SCRCWithNumber * &>
PUBLIC	??$_Move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z ; std::_Move<CArea::SCRCWithNumber &>
PUBLIC	??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Adjust_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
PUBLIC	??$_Pop_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Pop_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ; std::_Move_backward<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
PUBLIC	??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$swap@PAVCGraphicThingInstance@@@std@@YAXAAPAVCGraphicThingInstance@@0@Z ; std::swap<CGraphicThingInstance *>
PUBLIC	??$forward@AAPAPAVCGraphicThingInstance@@@std@@YAAAPAPAVCGraphicThingInstance@@AAPAPAV1@@Z ; std::forward<CGraphicThingInstance * * &>
PUBLIC	??$_Move@AAPAVCGraphicThingInstance@@@std@@YA$$QAPAVCGraphicThingInstance@@AAPAV1@@Z ; std::_Move<CGraphicThingInstance * &>
PUBLIC	??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Adjust_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Pop_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Pop_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z ; std::_Move_backward<CGraphicThingInstance * *,CGraphicThingInstance * *>
PUBLIC	??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z ; std::_Insertion_sort1<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CMapOutdoor::TPatchDrawStruct *,int>
PUBLIC	??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHUFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$iter_swap@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0@Z ; std::iter_swap<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
PUBLIC	??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$_Merge_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Merge_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$_Buffered_rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ; std::_Buffered_rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??$forward@J@std@@YA$$QAJAAJ@Z			; std::forward<long>
PUBLIC	??$destroy@USCRCWithNumber@CArea@@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z ; std::allocator<CArea::SCRCWithNumber>::destroy<CArea::SCRCWithNumber>
PUBLIC	??$destroy@U?$pair@MJ@std@@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@@Z ; std::allocator<std::pair<float,long> >::destroy<std::pair<float,long> >
PUBLIC	??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::allocator<CMapOutdoor::TPatchDrawStruct>::destroy<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$construct@USCRCWithNumber@CArea@@U12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$?0AAPAUTPatchDrawStruct@CMapOutdoor@@AAHX@?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@QAE@AAPAUTPatchDrawStruct@CMapOutdoor@@AAH@Z ; std::pair<CMapOutdoor::TPatchDrawStruct *,int>::pair<CMapOutdoor::TPatchDrawStruct *,int><CMapOutdoor::TPatchDrawStruct * &,int &,void>
PUBLIC	??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Med3<std::pair<float,long> *,std::less<void> >
PUBLIC	??$swap@MJ@std@@YAXAAU?$pair@MJ@0@0@Z		; std::swap<float,long>
PUBLIC	??$forward@AAPAU?$pair@MJ@std@@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@@Z ; std::forward<std::pair<float,long> * &>
PUBLIC	??$_Move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z ; std::_Move<std::pair<float,long> &>
PUBLIC	??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Adjust_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
PUBLIC	??$_Pop_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::_Pop_heap<std::pair<float,long> *,std::less<void> >
PUBLIC	??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00@Z ; std::_Move_backward<std::pair<float,long> *,std::pair<float,long> *>
PUBLIC	??$_Push_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Push_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
PUBLIC	??$_Pop_heap_0@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z ; std::_Pop_heap_0<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>
PUBLIC	??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
PUBLIC	??$_Push_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Push_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Pop_heap_0@PAPAVCGraphicThingInstance@@PAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z ; std::_Pop_heap_0<CGraphicThingInstance * *,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<CGraphicThingInstance * *,CGraphicThingInstance * *>
PUBLIC	??$_Move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct &>
PUBLIC	??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$swap@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXAAUTPatchDrawStruct@CMapOutdoor@@0@Z ; std::swap<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Ptr_cat@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTPatchDrawStruct@CMapOutdoor@@AAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ; std::_Ptr_cat<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
PUBLIC	??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
PUBLIC	??$_Dist_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAHPAUTPatchDrawStruct@CMapOutdoor@@@Z ; std::_Dist_type<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ; std::_Lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$_Upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ; std::_Upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
PUBLIC	??$rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ; std::rotate<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$forward@USCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z ; std::forward<CArea::SCRCWithNumber>
PUBLIC	??$construct@USCRCWithNumber@CArea@@U12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@$$QAU34@@Z ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
PUBLIC	??$forward@UTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ; std::forward<CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@$$QAU34@@Z ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$forward@AAPAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@@Z ; std::forward<CMapOutdoor::TPatchDrawStruct * &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$_Push_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Push_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
PUBLIC	??$_Pop_heap_0@PAU?$pair@MJ@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z ; std::_Pop_heap_0<std::pair<float,long> *,std::pair<float,long>,std::less<void> >
PUBLIC	??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<std::pair<float,long> *,std::pair<float,long> *>
PUBLIC	??$_Pop_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00$$QAU12@UCRCNumComp@2@PAH@Z ; std::_Pop_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
PUBLIC	??$move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z ; std::move<CArea::SCRCWithNumber &>
PUBLIC	??$_Pop_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH@Z ; std::_Pop_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
PUBLIC	??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ; std::move<CMapOutdoor::TPatchDrawStruct &>
PUBLIC	??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$distance@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAHPAUTPatchDrawStruct@CMapOutdoor@@0@Z ; std::distance<CMapOutdoor::TPatchDrawStruct *>
PUBLIC	??$construct@USCRCWithNumber@CArea@@U12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z ; std::allocator<CArea::SCRCWithNumber>::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
PUBLIC	??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Swap_adl@M@std@@YAXAAM0@Z			; std::_Swap_adl<float>
PUBLIC	??$_Swap_adl@J@std@@YAXAAJ0@Z			; std::_Swap_adl<long>
PUBLIC	??$_Construct@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU12@@Z ; std::_Construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$_Pop_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00$$QAU10@U?$less@X@0@PAH@Z ; std::_Pop_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
PUBLIC	??$move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z ; std::move<std::pair<float,long> &>
PUBLIC	??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00PAH0@Z ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>
PUBLIC	??$swap@M@std@@YAXAAM0@Z			; std::swap<float>
PUBLIC	??$swap@J@std@@YAXAAJ0@Z			; std::swap<long>
PUBLIC	??$_Move@AAM@std@@YA$$QAMAAM@Z			; std::_Move<float &>
PUBLIC	??$_Move@AAJ@std@@YA$$QAJAAJ@Z			; std::_Move<long &>
PUBLIC	?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
PUBLIC	?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A ; m_dwRenderedCRCWithNumberVector
PUBLIC	??_C@_0DP@MKJEJLFD@CMapOutdoor?3?3RenderBeforeLensFla@ ; `string'
PUBLIC	??_R0?AVCGraphicObjectInstance@@@8		; CGraphicObjectInstance `RTTI Type Descriptor'
PUBLIC	??_R0?AVCGraphicThingInstance@@@8		; CGraphicThingInstance `RTTI Type Descriptor'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f400000
PUBLIC	__real@3f800000
PUBLIC	__real@42000000
PUBLIC	__real@437f0000
PUBLIC	__real@449c4000
PUBLIC	__real@45075000
PUBLIC	__real@453b8000
PUBLIC	__real@45875000
PUBLIC	__real@c2000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memchr:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixScaling@16:PROC
EXTRN	_D3DXMatrixLookAtRH@16:PROC
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?SetBlendOperation@CScreen@@QAEXXZ:PROC		; CScreen::SetBlendOperation
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	?GetD3DIndexBuffer@CGraphicIndexBuffer@@QBEPAUIDirect3DIndexBuffer8@@XZ:PROC ; CGraphicIndexBuffer::GetD3DIndexBuffer
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	?RenderCloud@CSkyBox@@QAEXXZ:PROC		; CSkyBox::RenderCloud
EXTRN	?Compute@CLensFlare@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CLensFlare::Compute
EXTRN	?DrawBeforeFlare@CLensFlare@@QAEXXZ:PROC	; CLensFlare::DrawBeforeFlare
EXTRN	?DrawFlare@CLensFlare@@QAEXXZ:PROC		; CLensFlare::DrawFlare
EXTRN	?AdjustBrightness@CLensFlare@@QAEXXZ:PROC	; CLensFlare::AdjustBrightness
EXTRN	?Render@CScreenFilter@@QAEXXZ:PROC		; CScreenFilter::Render
EXTRN	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ:PROC ; CGraphicObjectInstance::GetPosition
EXTRN	?Render@CGraphicObjectInstance@@QAE_NXZ:PROC	; CGraphicObjectInstance::Render
EXTRN	?BlendRender@CGraphicObjectInstance@@QAEXXZ:PROC ; CGraphicObjectInstance::BlendRender
EXTRN	?RenderShadow@CGraphicObjectInstance@@QAEXXZ:PROC ; CGraphicObjectInstance::RenderShadow
EXTRN	?RenderPCBlocker@CGraphicObjectInstance@@QAEXXZ:PROC ; CGraphicObjectInstance::RenderPCBlocker
EXTRN	?Show@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Show
EXTRN	?Hide@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Hide
EXTRN	?HaveBlendThing@CGraphicThingInstance@@QAE_NXZ:PROC ; CGraphicThingInstance::HaveBlendThing
EXTRN	?CollectRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z:PROC ; CArea::CollectRenderingObject
EXTRN	?CollectBlendRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z:PROC ; CArea::CollectBlendRenderingObject
EXTRN	?RenderEffect@CArea@@QAEXXZ:PROC		; CArea::RenderEffect
EXTRN	?RenderCollision@CArea@@QAEXXZ:PROC		; CArea::RenderCollision
EXTRN	?RenderDungeon@CArea@@QAEXXZ:PROC		; CArea::RenderDungeon
EXTRN	?SetCenterPosition@CTerrainPatchProxy@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CTerrainPatchProxy::SetCenterPosition
EXTRN	?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ:PROC ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z:PROC ; CMapOutdoor::GetAreaPointer
EXTRN	?BuildViewFrustum@CMapOutdoor@@IAEXAAUD3DXMATRIX@@@Z:PROC ; CMapOutdoor::BuildViewFrustum
EXTRN	?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ:PROC ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch
EXTRN	?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ:PROC ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	?SetLight@CStateManager@@QAEXKPBU_D3DLIGHT8@@@Z:PROC ; CStateManager::SetLight
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SaveTextureStageState
EXTRN	?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z:PROC ; CStateManager::RestoreTextureStageState
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SaveTransform
EXTRN	?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z:PROC ; CStateManager::RestoreTransform
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z:PROC ; CStateManager::SetIndices
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___RTDynamicCast:PROC
EXTRN	__ftoui3:PROC
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A:BYTE	; CGraphicBase::ms_matView
EXTRN	?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A:BYTE	; CGraphicBase::ms_matProj
EXTRN	?SOFTWARE_TRANSFORM_PATCH_ENABLE@CTerrainPatch@@2_NA:BYTE ; CTerrainPatch::SOFTWARE_TRANSFORM_PATCH_ENABLE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A DD 01H DUP (?) ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A DB 0cH DUP (?) ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A DB 0cH DUP (?) ; m_dwRenderedCRCWithNumberVector
_BSS	ENDS
;	COMDAT ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
_BSS	SEGMENT
?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A DB 0cH DUP (?) ; `CMapOutdoor::RenderArea'::`33'::s_kVct_pkOpaqueThingInstSort
_BSS	ENDS
;	COMDAT ?$S1@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4IA
_BSS	SEGMENT
?$S1@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4IA DD 01H DUP (?) ; S1<`template-parameter-33',CMapOutdoor::derArea,unsigned char * const,void,bool>
_BSS	ENDS
;	COMDAT ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
_BSS	SEGMENT
?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A DB 0cH DUP (?) ; `CMapOutdoor::RenderBlendArea'::`4'::s_kVct_pkBlendThingInstSort
_BSS	ENDS
;	COMDAT ?$S2@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4IA
_BSS	SEGMENT
?$S2@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4IA DD 01H DUP (?) ; `CMapOutdoor::RenderBlendArea'::`4'::$S2
_BSS	ENDS
;	COMDAT ?lStartTime@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4JA
_BSS	SEGMENT
?lStartTime@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4JA DD 01H DUP (?) ; `CMapOutdoor::RenderMarkedArea'::`4'::lStartTime
_BSS	ENDS
;	COMDAT ?$S3@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4IA
_BSS	SEGMENT
?$S3@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4IA DD 01H DUP (?) ; `CMapOutdoor::RenderMarkedArea'::`4'::$S3
_BSS	ENDS
CRT$XCU	SEGMENT
_m_dwRenderedCRCWithNumberVector$initializer$ DD FLAT:??__Em_dwRenderedCRCWithNumberVector@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c2000000
CONST	SEGMENT
__real@c2000000 DD 0c2000000r			; -32
CONST	ENDS
;	COMDAT __real@45875000
CONST	SEGMENT
__real@45875000 DD 045875000r			; 4330
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@45075000
CONST	SEGMENT
__real@45075000 DD 045075000r			; 2165
CONST	ENDS
;	COMDAT __real@449c4000
CONST	SEGMENT
__real@449c4000 DD 0449c4000r			; 1250
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_R0?AVCGraphicThingInstance@@@8
data$r	SEGMENT
??_R0?AVCGraphicThingInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicThingInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicThingInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVCGraphicObjectInstance@@@8
data$r	SEGMENT
??_R0?AVCGraphicObjectInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicObjectInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicObjectInstance@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0DP@MKJEJLFD@CMapOutdoor?3?3RenderBeforeLensFla@
CONST	SEGMENT
??_C@_0DP@MKJEJLFD@CMapOutdoor?3?3RenderBeforeLensFla@ DB 'CMapOutdoor::R'
	DB	'enderBeforeLensFlare mc_pEnvironmentData is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z$0
__ehfuncinfo$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z$0
__ehfuncinfo$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?m_TerrainNumVector$initializer$@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2P6AXXZA DD FLAT:??__E?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAJ@std@@YA$$QAJAAJ@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAJ@std@@YA$$QAJAAJ@Z PROC			; std::_Move<long &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAJ@std@@YA$$QAJAAJ@Z ENDP			; std::_Move<long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAM@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAM@std@@YA$$QAMAAM@Z PROC			; std::_Move<float &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAM@std@@YA$$QAMAAM@Z ENDP			; std::_Move<float &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@J@std@@YAXAAJ0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@J@std@@YAXAAJ0@Z PROC				; std::swap<long>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@J@std@@YAXAAJ0@Z ENDP				; std::swap<long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@M@std@@YAXAAM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@M@std@@YAXAAM0@Z PROC				; std::swap<float>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00011	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 55   : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$swap@M@std@@YAXAAM0@Z ENDP				; std::swap<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00PAH0@Z
_TEXT	SEGMENT
tv261 = -4						; size = 4
__First$ = 8						; size = 4
__Count$1$ = 12						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00PAH0@Z PROC ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>, COMDAT

; 3202 : 	{	// rotate [_First, _Last), random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3203 : 	_Diff _Shift = _Mid - _First;

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 3204 : 	_Diff _Count = _Last - _First;

  00007	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  0000f	2b c1		 sub	 eax, ecx
  00011	2b f1		 sub	 esi, ecx
  00013	c1 f8 04	 sar	 eax, 4
  00016	c1 fe 04	 sar	 esi, 4
  00019	8b d8		 mov	 ebx, eax
  0001b	89 45 fc	 mov	 DWORD PTR tv261[ebp], eax
  0001e	89 45 0c	 mov	 DWORD PTR __Count$1$[ebp], eax
  00021	57		 push	 edi

; 3205 : 
; 3206 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

  00022	8b fe		 mov	 edi, esi
  00024	85 f6		 test	 esi, esi
  00026	74 13		 je	 SHORT $LN8@Rotate
$LL9@Rotate:

; 3207 : 		{	// find subcycle count as GCD of shift count and length
; 3208 : 		_Diff _Tmp = _Count % _Factor;

  00028	8b c3		 mov	 eax, ebx

; 3209 : 		_Count = _Factor;

  0002a	8b df		 mov	 ebx, edi
  0002c	99		 cdq
  0002d	f7 ff		 idiv	 edi

; 3210 : 		_Factor = _Tmp;

  0002f	8b fa		 mov	 edi, edx
  00031	85 d2		 test	 edx, edx
  00033	75 f3		 jne	 SHORT $LL9@Rotate
  00035	8b 45 fc	 mov	 eax, DWORD PTR tv261[ebp]
  00038	89 5d 0c	 mov	 DWORD PTR __Count$1$[ebp], ebx
$LN8@Rotate:

; 3211 : 		}
; 3212 : 
; 3213 : 	if (_Count < _Last - _First)

  0003b	3b d8		 cmp	 ebx, eax
  0003d	7d 64		 jge	 SHORT $LN4@Rotate

; 3214 : 		for (; 0 < _Count; --_Count)

  0003f	85 db		 test	 ebx, ebx
  00041	7e 60		 jle	 SHORT $LN4@Rotate
  00043	8b d3		 mov	 edx, ebx
  00045	8b fe		 mov	 edi, esi
  00047	c1 e2 04	 shl	 edx, 4
  0004a	c1 e7 04	 shl	 edi, 4
  0004d	03 d1		 add	 edx, ecx
  0004f	90		 npad	 1
$LL6@Rotate:

; 3215 : 			{	// rotate each subcycle
; 3216 : 			_RanIt _Hole = _First + _Count;
; 3217 : 			_RanIt _Next = _Hole;
; 3218 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

  00050	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00053	8b da		 mov	 ebx, edx
  00055	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00058	0f 44 c1	 cmove	 eax, ecx
  0005b	eb 03 8d 49 00	 npad	 5
$LL3@Rotate:

; 3224 : 					: _First + (_Shift - (_Last - _Next1));

  00060	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00063	f3 0f 6f 0b	 movdqu	 xmm1, XMMWORD PTR [ebx]
; File a:\vs\vc\include\xutility

; 3224 : 					: _First + (_Shift - (_Last - _Next1));

  00067	2b c8		 sub	 ecx, eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00069	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
; File a:\vs\vc\include\xutility

; 3224 : 					: _First + (_Shift - (_Last - _Next1));

  0006d	c1 f9 04	 sar	 ecx, 4
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00070	f3 0f 7f 03	 movdqu	 XMMWORD PTR [ebx], xmm0
; File a:\vs\vc\include\xutility

; 3222 : 				_Next = _Next1;

  00074	8b d8		 mov	 ebx, eax
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  00076	f3 0f 7f 08	 movdqu	 XMMWORD PTR [eax], xmm1
; File a:\vs\vc\include\xutility

; 3224 : 					: _First + (_Shift - (_Last - _Next1));

  0007a	3b f1		 cmp	 esi, ecx
  0007c	7d 07		 jge	 SHORT $LN14@Rotate
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00081	03 c7		 add	 eax, edi
  00083	eb 0c		 jmp	 SHORT $LN15@Rotate
$LN14@Rotate:
  00085	8b c6		 mov	 eax, esi
  00087	2b c1		 sub	 eax, ecx
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0008c	c1 e0 04	 shl	 eax, 4
  0008f	03 c1		 add	 eax, ecx
$LN15@Rotate:

; 3225 : 				if (_Next1 == _Hole)

  00091	3b c2		 cmp	 eax, edx
  00093	75 cb		 jne	 SHORT $LL3@Rotate

; 3214 : 		for (; 0 < _Count; --_Count)

  00095	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$1$[ebp]
  00098	83 ea 10	 sub	 edx, 16			; 00000010H
  0009b	4b		 dec	 ebx
  0009c	89 5d 0c	 mov	 DWORD PTR __Count$1$[ebp], ebx
  0009f	85 db		 test	 ebx, ebx
  000a1	7f ad		 jg	 SHORT $LL6@Rotate
$LN4@Rotate:
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx

; 3226 : 					break;
; 3227 : 				}
; 3228 : 			}
; 3229 : 	}

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00PAH0@Z ENDP ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z PROC ; std::move<std::pair<float,long> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z ENDP ; std::move<std::pair<float,long> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00$$QAU10@U?$less@X@0@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Pop_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00$$QAU10@U?$less@X@0@PAH@Z PROC ; std::_Pop_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >, COMDAT

; 2394 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  00009	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  0000e	ff 75 14	 push	 DWORD PTR __Val$[ebp]
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00013	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00016	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001c	2b c2		 sub	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Adjust_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 2398 : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Pop_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00$$QAU10@U?$less@X@0@PAH@Z ENDP ; std::_Pop_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Construct@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU12@@Z PROC ; std::_Construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>, COMDAT

; 38   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN3@Construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN3@Construct:

; 41   : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$_Construct@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU12@@Z ENDP ; std::_Construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$_Swap_adl@J@std@@YAXAAJ0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@J@std@@YAXAAJ0@Z PROC			; std::_Swap_adl<long>, COMDAT

; 60   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 61   : 	swap(_Left, _Right);
; 62   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@J@std@@YAXAAJ0@Z ENDP			; std::_Swap_adl<long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$_Swap_adl@M@std@@YAXAAM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@M@std@@YAXAAM0@Z PROC			; std::_Swap_adl<float>, COMDAT

; 60   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00011	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 61   : 	swap(_Left, _Right);
; 62   : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$_Swap_adl@M@std@@YAXAAM0@Z ENDP			; std::_Swap_adl<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN3@construct:

; 601  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@U12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USCRCWithNumber@CArea@@U12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z PROC ; std::allocator<CArea::SCRCWithNumber>::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@USCRCWithNumber@CArea@@U12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z ENDP ; std::allocator<CArea::SCRCWithNumber>::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$distance@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAHPAUTPatchDrawStruct@CMapOutdoor@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAHPAUTPatchDrawStruct@CMapOutdoor@@0@Z PROC ; std::distance<CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 756  : 	{	// return distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 750  : 	_Off += _Last - _First;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	c1 f8 04	 sar	 eax, 4

; 757  : 	typename iterator_traits<_InIt>::difference_type _Off = 0;
; 758  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 759  : 	return (_Off);
; 760  : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??$distance@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAHPAUTPatchDrawStruct@CMapOutdoor@@0@Z ENDP ; std::distance<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 3234 : 	{	// rotate [_First, _Last), random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3235 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00PAH0@Z ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>
  00015	83 c4 14	 add	 esp, 20			; 00000014H

; 3236 : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z PROC ; std::move<CMapOutdoor::TPatchDrawStruct &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ENDP ; std::move<CMapOutdoor::TPatchDrawStruct &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 12		 je	 SHORT $LN1@Move
$LL3@Move:

; 2420 : 		*_Dest = _STD move(*_First);

  00010	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  00014	83 c1 10	 add	 ecx, 16			; 00000010H
  00017	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0001b	83 c0 10	 add	 eax, 16			; 00000010H
  0001e	3b ca		 cmp	 ecx, edx
  00020	75 ee		 jne	 SHORT $LL3@Move
$LN1@Move:

; 2421 : 	return (_Dest);
; 2422 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2526 : 	while (_First != _Last)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b d1		 cmp	 edx, ecx
  0000e	74 13		 je	 SHORT $LN1@Move_backw
$LL2@Move_backw:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00010	f3 0f 6f 41 f0	 movdqu	 xmm0, XMMWORD PTR [ecx-16]
  00015	83 e9 10	 sub	 ecx, 16			; 00000010H
  00018	83 e8 10	 sub	 eax, 16			; 00000010H
  0001b	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0001f	3b ca		 cmp	 ecx, edx
  00021	75 ed		 jne	 SHORT $LL2@Move_backw
$LN1@Move_backw:

; 2528 : 	return (_Dest);
; 2529 : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Pop_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH@Z PROC ; std::_Pop_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2394 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2395 : 	*_Dest = _Move(*_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00009	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0000c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000e	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00016	2b c2		 sub	 eax, edx
  00018	c1 f8 02	 sar	 eax, 2
  0001b	50		 push	 eax
  0001c	6a 00		 push	 0
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Adjust_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  00024	83 c4 14	 add	 esp, 20			; 00000014H

; 2398 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Pop_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH@Z ENDP ; std::_Pop_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z PROC ; std::move<CArea::SCRCWithNumber &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z ENDP ; std::move<CArea::SCRCWithNumber &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00$$QAU12@UCRCNumComp@2@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Pop_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00$$QAU12@UCRCNumComp@2@PAH@Z PROC ; std::_Pop_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>, COMDAT

; 2394 : 	{	// pop *_First to *_Dest and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2395 : 	*_Dest = _Move(*_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00009	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00016	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00019	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001c	2b c2		 sub	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Adjust_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
  0002a	83 c4 14	 add	 esp, 20			; 00000014H

; 2398 : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Pop_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00$$QAU12@UCRCNumComp@2@PAH@Z ENDP ; std::_Pop_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<std::pair<float,long> *,std::pair<float,long> *>, COMDAT

; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2526 : 	while (_First != _Last)

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	3b f2		 cmp	 esi, edx
  0000f	74 15		 je	 SHORT $LN1@Move_backw
$LL2@Move_backw:
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
; File a:\vs\vc\include\xutility

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00014	83 ea 08	 sub	 edx, 8
  00017	83 e8 08	 sub	 eax, 8
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0001a	89 08		 mov	 DWORD PTR [eax], ecx

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  0001c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\xutility

; 2526 : 	while (_First != _Last)

  00022	3b d6		 cmp	 edx, esi
  00024	75 eb		 jne	 SHORT $LL2@Move_backw
$LN1@Move_backw:
  00026	5e		 pop	 esi

; 2528 : 	return (_Dest);
; 2529 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<std::pair<float,long> *,std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAU?$pair@MJ@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z
_TEXT	SEGMENT
__Val$ = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAU?$pair@MJ@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z PROC ; std::_Pop_heap_0<std::pair<float,long> *,std::pair<float,long>,std::less<void> >, COMDAT

; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  0000c	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000f	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00012	f3 0f 10 42 f8	 movss	 xmm0, DWORD PTR [edx-8]
  00017	89 45 fc	 mov	 DWORD PTR __Val$[ebp+4], eax

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  0001f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00022	89 42 fc	 mov	 DWORD PTR [edx-4], eax
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  00025	8d 45 f8	 lea	 eax, DWORD PTR __Val$[ebp]
  00028	2b d1		 sub	 edx, ecx
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0002a	f3 0f 11 45 f8	 movss	 DWORD PTR __Val$[ebp], xmm0
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  0002f	50		 push	 eax
  00030	83 ea 08	 sub	 edx, 8
  00033	c1 fa 03	 sar	 edx, 3
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Adjust_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
  0003f	83 c4 14	 add	 esp, 20			; 00000014H

; 2406 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2407 : 		_Move(_Val), _Pred, _Dist_type(_First));
; 2408 : 	}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??$_Pop_heap_0@PAU?$pair@MJ@std@@U12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z ENDP ; std::_Pop_heap_0<std::pair<float,long> *,std::pair<float,long>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z PROC ; std::_Push_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >, COMDAT

; 2313 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Hole$[ebp]
  00007	56		 push	 esi

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 14	 mov	 edi, DWORD PTR __Val$[ebp]
  0000f	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00012	99		 cdq
  00013	2b c2		 sub	 eax, edx
  00015	8b c8		 mov	 ecx, eax
  00017	d1 f9		 sar	 ecx, 1
  00019	39 5d 10	 cmp	 DWORD PTR __Top$[ebp], ebx
  0001c	7d 3d		 jge	 SHORT $LN34@Push_heap
  0001e	8b ff		 npad	 2
$LL3@Push_heap:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00020	f3 0f 10 0c ce	 movss	 xmm1, DWORD PTR [esi+ecx*8]
  00025	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00029	0f 2f c1	 comiss	 xmm0, xmm1
  0002c	77 0e		 ja	 SHORT $LN11@Push_heap
  0002e	0f 2f c8	 comiss	 xmm1, xmm0
  00031	77 28		 ja	 SHORT $LN34@Push_heap
  00033	8b 44 ce 04	 mov	 eax, DWORD PTR [esi+ecx*8+4]
  00037	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  0003a	7d 1f		 jge	 SHORT $LN34@Push_heap
$LN11@Push_heap:

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0003c	8b 04 ce	 mov	 eax, DWORD PTR [esi+ecx*8]
  0003f	89 04 de	 mov	 DWORD PTR [esi+ebx*8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00042	8b 44 ce 04	 mov	 eax, DWORD PTR [esi+ecx*8+4]
  00046	89 44 de 04	 mov	 DWORD PTR [esi+ebx*8+4], eax
; File a:\vs\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

  0004a	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0004d	99		 cdq

; 2317 : 		{	// move _Hole up to parent
; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));
; 2319 : 		_Hole = _Idx;

  0004e	8b d9		 mov	 ebx, ecx
  00050	2b c2		 sub	 eax, edx
  00052	8b c8		 mov	 ecx, eax
  00054	d1 f9		 sar	 ecx, 1
  00056	39 5d 10	 cmp	 DWORD PTR __Top$[ebp], ebx
  00059	7c c5		 jl	 SHORT $LL3@Push_heap
$LN34@Push_heap:
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0005b	8b 07		 mov	 eax, DWORD PTR [edi]
  0005d	89 04 de	 mov	 DWORD PTR [esi+ebx*8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00060	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00063	5f		 pop	 edi
  00064	89 44 de 04	 mov	 DWORD PTR [esi+ebx*8+4], eax
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 2323 : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Push_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ENDP ; std::_Push_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@@Z PROC ; std::forward<CMapOutdoor::TPatchDrawStruct * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@@Z ENDP ; std::forward<CMapOutdoor::TPatchDrawStruct * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@$$QAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@UTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z PROC ; std::forward<CMapOutdoor::TPatchDrawStruct>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ENDP ; std::forward<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@U12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@$$QAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USCRCWithNumber@CArea@@U12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@USCRCWithNumber@CArea@@U12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@USCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z PROC ; std::forward<CArea::SCRCWithNumber>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@USCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z ENDP ; std::forward<CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z PROC ; std::rotate<CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 3240 : 	{	// rotate [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3241 : 	_DEBUG_RANGE(_First, _Mid);
; 3242 : 	_DEBUG_RANGE(_Mid, _Last);
; 3243 : 	if (_First != _Mid && _Mid != _Last)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR __Mid$[ebp]
  0000f	3b df		 cmp	 ebx, edi
  00011	74 13		 je	 SHORT $LN12@rotate
  00013	3b fe		 cmp	 edi, esi
  00015	74 0f		 je	 SHORT $LN12@rotate

; 751  : 	}
; 752  : 
; 753  : template<class _InIt> inline
; 754  : 	typename iterator_traits<_InIt>::difference_type
; 755  : 		distance(_InIt _First, _InIt _Last)
; 756  : 	{	// return distance between iterators
; 757  : 	typename iterator_traits<_InIt>::difference_type _Off = 0;
; 758  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 759  : 	return (_Off);
; 760  : 	}
; 761  : 
; 762  : template<class _InIt,
; 763  : 	class _Diff> inline
; 764  : 		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
; 765  : 	{	// add to _Off distance between iterators
; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}
; 768  : 
; 769  : 		// TEMPLATE FUNCTION next
; 770  : template<class _FwdIt> inline
; 771  : 	_FwdIt next(_FwdIt _First,
; 772  : 		typename iterator_traits<_FwdIt>::difference_type _Off = 1)
; 773  : 	{	// increment iterator
; 774  : 	static_assert((is_base_of<forward_iterator_tag,
; 775  : 		typename iterator_traits<_FwdIt>::iterator_category>::value),
; 776  : 		"next requires forward iterator");
; 777  : 
; 778  : 	_STD advance(_First, _Off);
; 779  : 	return (_First);
; 780  : 	}
; 781  : 
; 782  : 		// TEMPLATE FUNCTION prev
; 783  : template<class _BidIt> inline
; 784  : 	_BidIt prev(_BidIt _First,
; 785  : 		typename iterator_traits<_BidIt>::difference_type _Off = 1)
; 786  : 	{	// decrement iterator
; 787  : 	static_assert((is_base_of<bidirectional_iterator_tag,
; 788  : 		typename iterator_traits<_BidIt>::iterator_category>::value),
; 789  : 		"prev requires bidirectional iterator");
; 790  : 
; 791  : 	_STD advance(_First, -_Off);
; 792  : 	return (_First);
; 793  : 	}
; 794  : 
; 795  : 
; 796  : 		// TEMPLATE CLASS _Revranit
; 797  : template<class _Ty>
; 798  : 	struct pointer_traits;
; 799  : 
; 800  : template<class _RanIt,
; 801  : 	class _Base>
; 802  : 	class _Revranit
; 803  : 		: public _Base
; 804  : 	{	// wrap iterator to run it backwards
; 805  : public:
; 806  : 	typedef _Revranit<_RanIt, _Base> _Myt;
; 807  : 	typedef typename _Base::difference_type difference_type;
; 808  : 	typedef typename _Base::pointer pointer;
; 809  : 	typedef typename _Base::reference reference;
; 810  : 	typedef _RanIt iterator_type;
; 811  : 
; 812  : 	_Revranit()
; 813  : 		{	// construct with default wrapped iterator
; 814  : 		}
; 815  : 
; 816  : 	explicit _Revranit(_RanIt _Right)
; 817  : 		: current(_Right)
; 818  : 		{	// construct wrapped iterator from _Right
; 819  : 		}
; 820  : 
; 821  : 	template<class _RanIt2,
; 822  : 		class _Base2>
; 823  : 		_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
; 824  : 		: current(_Right.base())
; 825  : 		{	// initialize with compatible base
; 826  : 		}
; 827  : 
; 828  : 	_RanIt base() const
; 829  : 		{	// return wrapped iterator
; 830  : 		return (current);
; 831  : 		}
; 832  : 
; 833  : 	reference operator*() const
; 834  : 		{	// return designated value
; 835  : 		_RanIt _Tmp = current;
; 836  : 		return (*--_Tmp);
; 837  : 		}
; 838  : 
; 839  : 	pointer operator->() const
; 840  : 		{	// return pointer to class object
; 841  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 842  : 		}
; 843  : 
; 844  : 	_Myt& operator++()
; 845  : 		{	// preincrement
; 846  : 		--current;
; 847  : 		return (*this);
; 848  : 		}
; 849  : 
; 850  : 	_Myt operator++(int)
; 851  : 		{	// postincrement
; 852  : 		_Myt _Tmp = *this;
; 853  : 		--current;
; 854  : 		return (_Tmp);
; 855  : 		}
; 856  : 
; 857  : 	_Myt& operator--()
; 858  : 		{	// predecrement
; 859  : 		++current;
; 860  : 		return (*this);
; 861  : 		}
; 862  : 
; 863  : 	_Myt operator--(int)
; 864  : 		{	// postdecrement
; 865  : 		_Myt _Tmp = *this;
; 866  : 		++current;
; 867  : 		return (_Tmp);
; 868  : 		}
; 869  : 
; 870  : 	template<class _RanIt2,
; 871  : 		class _Base2>
; 872  : 		bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
; 873  : 		{	// test for iterator equality
; 874  : 		return (current == _Right.base());
; 875  : 		}
; 876  : 
; 877  : // N.B. functions valid for random-access iterators only beyond this point
; 878  : 
; 879  : 	_Myt& operator+=(difference_type _Off)
; 880  : 		{	// increment by integer
; 881  : 		current -= _Off;
; 882  : 		return (*this);
; 883  : 		}
; 884  : 
; 885  : 	_Myt operator+(difference_type _Off) const
; 886  : 		{	// return this + integer
; 887  : 		return (_Myt(current - _Off));
; 888  : 		}
; 889  : 
; 890  : 	_Myt& operator-=(difference_type _Off)
; 891  : 		{	// decrement by integer
; 892  : 		current += _Off;
; 893  : 		return (*this);
; 894  : 		}
; 895  : 
; 896  : 	_Myt operator-(difference_type _Off) const
; 897  : 		{	// return this - integer
; 898  : 		return (_Myt(current + _Off));
; 899  : 		}
; 900  : 
; 901  : 	reference operator[](difference_type _Off) const
; 902  : 		{	// subscript
; 903  : 		return (*(*this + _Off));
; 904  : 		}
; 905  : 
; 906  : 	template<class _RanIt2,
; 907  : 		class _Base2>
; 908  : 		bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
; 909  : 		{	// test if this < _Right
; 910  : 		return (_Right.base() < current);
; 911  : 		}
; 912  : 
; 913  : 	difference_type operator-(const _Myt& _Right) const
; 914  : 		{	// return difference of iterators
; 915  : 		return (_Right.base() - current);
; 916  : 		}
; 917  : 
; 918  : protected:
; 919  : 	_RanIt current;	// the wrapped iterator
; 920  : 	};
; 921  : 
; 922  : 		// _Revranit TEMPLATE OPERATORS
; 923  : template<class _RanIt,
; 924  : 	class _Base,
; 925  : 	class _Diff> inline
; 926  : 	_Revranit<_RanIt, _Base>
; 927  : 		operator+(_Diff _Off,
; 928  : 		const _Revranit<_RanIt, _Base>& _Right)
; 929  : 	{	// return reverse_iterator + integer
; 930  : 	return (_Right + _Off);
; 931  : 	}
; 932  : 
; 933  : template<class _RanIt1,
; 934  : 	class _Base1,
; 935  : 	class _RanIt2,
; 936  : 	class _Base2>
; 937  : 	auto inline operator-(
; 938  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 939  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 940  : 			-> decltype(_Right.base() - _Left.base())
; 941  : 	{	// return difference of reverse_iterators
; 942  : 	return (_Right.base() - _Left.base());
; 943  : 	}
; 944  : 
; 945  : template<class _RanIt1,
; 946  : 	class _Base1,
; 947  : 	class _RanIt2,
; 948  : 	class _Base2> inline
; 949  : 	bool operator==(
; 950  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 951  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 952  : 	{	// test for reverse_iterator equality
; 953  : 	return (_Left._Equal(_Right));
; 954  : 	}
; 955  : 
; 956  : template<class _RanIt1,
; 957  : 	class _Base1,
; 958  : 	class _RanIt2,
; 959  : 	class _Base2> inline
; 960  : 	bool operator!=(
; 961  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 962  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 963  : 	{	// test for reverse_iterator inequality
; 964  : 	return (!(_Left == _Right));
; 965  : 	}
; 966  : 
; 967  : template<class _RanIt1,
; 968  : 	class _Base1,
; 969  : 	class _RanIt2,
; 970  : 	class _Base2> inline
; 971  : 	bool operator<(
; 972  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 973  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 974  : 	{	// test for reverse_iterator < reverse_iterator
; 975  : 	return (_Left._Less(_Right));
; 976  : 	}
; 977  : 
; 978  : template<class _RanIt1,
; 979  : 	class _Base1,
; 980  : 	class _RanIt2,
; 981  : 	class _Base2> inline
; 982  : 	bool operator>(
; 983  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 984  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 985  : 	{	// test for reverse_iterator > reverse_iterator
; 986  : 	return (_Right < _Left);
; 987  : 	}
; 988  : 
; 989  : template<class _RanIt1,
; 990  : 	class _Base1,
; 991  : 	class _RanIt2,
; 992  : 	class _Base2> inline
; 993  : 	bool operator<=(
; 994  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 995  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 996  : 	{	// test for reverse_iterator <= reverse_iterator
; 997  : 	return (!(_Right < _Left));
; 998  : 	}
; 999  : 
; 1000 : template<class _RanIt1,
; 1001 : 	class _Base1,
; 1002 : 	class _RanIt2,
; 1003 : 	class _Base2> inline
; 1004 : 	bool operator>=(
; 1005 : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 1006 : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 1007 : 	{	// test for reverse_iterator >= reverse_iterator
; 1008 : 	return (!(_Left < _Right));
; 1009 : 	}
; 1010 : 
; 1011 : 		// TEMPLATE CLASS reverse_iterator
; 1012 : template<class _RanIt>
; 1013 : 	class reverse_iterator
; 1014 : 		: public _Revranit<_RanIt, iterator<
; 1015 : 			typename iterator_traits<_RanIt>::iterator_category,
; 1016 : 			typename iterator_traits<_RanIt>::value_type,
; 1017 : 			typename iterator_traits<_RanIt>::difference_type,
; 1018 : 			typename iterator_traits<_RanIt>::pointer,
; 1019 : 			typename iterator_traits<_RanIt>::reference> >
; 1020 : 	{	// wrap iterator to run it backwards
; 1021 : 	typedef reverse_iterator<_RanIt> _Myt;
; 1022 : 	typedef _Revranit<_RanIt, iterator<
; 1023 : 		typename iterator_traits<_RanIt>::iterator_category,
; 1024 : 		typename iterator_traits<_RanIt>::value_type,
; 1025 : 		typename iterator_traits<_RanIt>::difference_type,
; 1026 : 		typename iterator_traits<_RanIt>::pointer,
; 1027 : 		typename iterator_traits<_RanIt>::reference> > _Mybase;
; 1028 : 
; 1029 : public:
; 1030 : 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
; 1031 : 	typedef typename iterator_traits<_RanIt>::pointer pointer;
; 1032 : 	typedef typename iterator_traits<_RanIt>::reference reference;
; 1033 : 	typedef _RanIt iterator_type;
; 1034 : 
; 1035 : 	reverse_iterator()
; 1036 : 		{	// construct with default wrapped iterator
; 1037 : 		}
; 1038 : 
; 1039 : 	explicit reverse_iterator(_RanIt _Right)
; 1040 : 		: _Mybase(_Right)
; 1041 : 		{	// construct wrapped iterator from _Right
; 1042 : 		}
; 1043 : 
; 1044 : 	template<class _Other>
; 1045 : 		reverse_iterator(const reverse_iterator<_Other>& _Right)
; 1046 : 		: _Mybase(_Right.base())
; 1047 : 		{	// initialize with compatible base
; 1048 : 		}
; 1049 : 
; 1050 : 	reverse_iterator(_Mybase _Right)
; 1051 : 		: _Mybase(_Right)
; 1052 : 		{	// construct wrapped iterator from base object
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class _Other>
; 1056 : 		_Myt& operator=(const reverse_iterator<_Other>& _Right)
; 1057 : 		{	// assign from compatible base
; 1058 : 		this->current = _Right.base();
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& operator++()
; 1063 : 		{	// preincrement
; 1064 : 		++*((_Mybase *)this);
; 1065 : 		return (*this);
; 1066 : 		}
; 1067 : 
; 1068 : 	_Myt operator++(int)
; 1069 : 		{	// postincrement
; 1070 : 		_Myt _Tmp = *this;
; 1071 : 		++*this;
; 1072 : 		return (_Tmp);
; 1073 : 		}
; 1074 : 
; 1075 : 	_Myt& operator--()
; 1076 : 		{	// predecrement
; 1077 : 		--*((_Mybase *)this);
; 1078 : 		return (*this);
; 1079 : 		}
; 1080 : 
; 1081 : 	_Myt operator--(int)
; 1082 : 		{	// postdecrement
; 1083 : 		_Myt _Tmp = *this;
; 1084 : 		--*this;
; 1085 : 		return (_Tmp);
; 1086 : 		}
; 1087 : 
; 1088 : 	_Myt& operator+=(difference_type _Off)
; 1089 : 		{	// increment by integer
; 1090 : 		*((_Mybase *)this) += _Off;
; 1091 : 		return (*this);
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt operator+(difference_type _Off) const
; 1095 : 		{	// return this + integer
; 1096 : 		_Myt _Tmp = *this;
; 1097 : 		return (_Tmp += _Off);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Myt& operator-=(difference_type _Off)
; 1101 : 		{	// decrement by integer
; 1102 : 		*((_Mybase *)this) -= _Off;
; 1103 : 		return (*this);
; 1104 : 		}
; 1105 : 
; 1106 : 	_Myt operator-(difference_type _Off) const
; 1107 : 		{	// return this - integer
; 1108 : 		_Myt _Tmp = *this;
; 1109 : 		return (_Tmp -= _Off);
; 1110 : 		}
; 1111 : 	};
; 1112 : 
; 1113 : template<class _RanIt>
; 1114 : 	struct _Is_checked_helper<reverse_iterator<_RanIt> >
; 1115 : 		: public _Is_checked_helper<_RanIt>
; 1116 : 	{	// mark reverse_iterator as checked if its wrapped iterator is checked
; 1117 : 	};
; 1118 : 
; 1119 : 		// reverse_iterator TEMPLATE OPERATORS
; 1120 : template<class _RanIt,
; 1121 : 	class _Diff> inline
; 1122 : 	reverse_iterator<_RanIt> operator+(_Diff _Off,
; 1123 : 		const reverse_iterator<_RanIt>& _Right)
; 1124 : 	{	// return reverse_iterator + integer
; 1125 : 	return (_Right + _Off);
; 1126 : 	}
; 1127 : 
; 1128 : template<class _RanIt1,
; 1129 : 	class _RanIt2>
; 1130 : 	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
; 1131 : 		const reverse_iterator<_RanIt2>& _Right)
; 1132 : 			-> decltype(_Right.base() - _Left.base())
; 1133 : 	{	// return difference of reverse_iterators
; 1134 : 	return (_Right.base() - _Left.base());
; 1135 : 	}
; 1136 : 
; 1137 : template<class _RanIt1,
; 1138 : 	class _RanIt2> inline
; 1139 : 	bool operator==(const reverse_iterator<_RanIt1>& _Left,
; 1140 : 		const reverse_iterator<_RanIt2>& _Right)
; 1141 : 	{	// test for reverse_iterator equality
; 1142 : 	return (_Left._Equal(_Right));
; 1143 : 	}
; 1144 : 
; 1145 : template<class _RanIt1,
; 1146 : 	class _RanIt2> inline
; 1147 : 	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
; 1148 : 		const reverse_iterator<_RanIt2>& _Right)
; 1149 : 	{	// test for reverse_iterator inequality
; 1150 : 	return (!(_Left == _Right));
; 1151 : 	}
; 1152 : 
; 1153 : template<class _RanIt1,
; 1154 : 	class _RanIt2> inline
; 1155 : 	bool operator<(const reverse_iterator<_RanIt1>& _Left,
; 1156 : 		const reverse_iterator<_RanIt2>& _Right)
; 1157 : 	{	// test for reverse_iterator < reverse_iterator
; 1158 : 	return (_Left._Less(_Right));
; 1159 : 	}
; 1160 : 
; 1161 : template<class _RanIt1,
; 1162 : 	class _RanIt2> inline
; 1163 : 	bool operator>(const reverse_iterator<_RanIt1>& _Left,
; 1164 : 		const reverse_iterator<_RanIt2>& _Right)
; 1165 : 	{	// test for reverse_iterator > reverse_iterator
; 1166 : 	return (_Right < _Left);
; 1167 : 	}
; 1168 : 
; 1169 : template<class _RanIt1,
; 1170 : 	class _RanIt2> inline
; 1171 : 	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
; 1172 : 		const reverse_iterator<_RanIt2>& _Right)
; 1173 : 	{	// test for reverse_iterator <= reverse_iterator
; 1174 : 	return (!(_Right < _Left));
; 1175 : 	}
; 1176 : 
; 1177 : template<class _RanIt1,
; 1178 : 	class _RanIt2> inline
; 1179 : 	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
; 1180 : 		const reverse_iterator<_RanIt2>& _Right)
; 1181 : 	{	// test for reverse_iterator >= reverse_iterator
; 1182 : 	return (!(_Left < _Right));
; 1183 : 	}
; 1184 : 
; 1185 : 
; 1186 : 		// TEMPLATE FUNCTIONS begin AND end
; 1187 : template<class _Container>
; 1188 : 	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
; 1189 : 	{	// get beginning of sequence
; 1190 : 	return (_Cont.begin());
; 1191 : 	}
; 1192 : 
; 1193 : template<class _Container>
; 1194 : 	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
; 1195 : 	{	// get beginning of sequence
; 1196 : 	return (_Cont.begin());
; 1197 : 	}
; 1198 : 
; 1199 : template<class _Container>
; 1200 : 	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
; 1201 : 	{	// get end of sequence
; 1202 : 	return (_Cont.end());
; 1203 : 	}
; 1204 : 
; 1205 : template<class _Container>
; 1206 : 	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
; 1207 : 	{	// get end of sequence
; 1208 : 	return (_Cont.end());
; 1209 : 	}
; 1210 : 
; 1211 : template<class _Ty,
; 1212 : 	size_t _Size> inline
; 1213 : 	_Ty *begin(_Ty (&_Array)[_Size])
; 1214 : 	{	// get beginning of array
; 1215 : 	return (_Array);
; 1216 : 	}
; 1217 : 
; 1218 : template<class _Ty,
; 1219 : 	size_t _Size> inline
; 1220 : 	_Ty *end(_Ty (&_Array)[_Size])
; 1221 : 	{	// get end of array
; 1222 : 	return (_Array + _Size);
; 1223 : 	}
; 1224 : 
; 1225 : 		// TEMPLATE FUNCTIONS cbegin AND cend
; 1226 : template<class _Container>
; 1227 : 	auto inline cbegin(const _Container& _Cont) -> decltype(_STD begin(_Cont))
; 1228 : 	{	// get beginning of sequence
; 1229 : 	return (_STD begin(_Cont));
; 1230 : 	}
; 1231 : 
; 1232 : template<class _Container>
; 1233 : 	auto inline cend(const _Container& _Cont) -> decltype(_STD end(_Cont))
; 1234 : 	{	// get end of sequence
; 1235 : 	return (_STD end(_Cont));
; 1236 : 	}
; 1237 : 
; 1238 : 		// TEMPLATE FUNCTIONS rbegin AND rend
; 1239 : template<class _Container>
; 1240 : 	auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
; 1241 : 	{	// get beginning of reversed sequence
; 1242 : 	return (_Cont.rbegin());
; 1243 : 	}
; 1244 : 
; 1245 : template<class _Container>
; 1246 : 	auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
; 1247 : 	{	// get beginning of reversed sequence
; 1248 : 	return (_Cont.rbegin());
; 1249 : 	}
; 1250 : 
; 1251 : template<class _Container>
; 1252 : 	auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
; 1253 : 	{	// get end of reversed sequence
; 1254 : 	return (_Cont.rend());
; 1255 : 	}
; 1256 : 
; 1257 : template<class _Container>
; 1258 : 	auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
; 1259 : 	{	// get end of reversed sequence
; 1260 : 	return (_Cont.rend());
; 1261 : 	}
; 1262 : 
; 1263 : template<class _Ty,
; 1264 : 	size_t _Size> inline
; 1265 : 	reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
; 1266 : 	{	// get beginning of reversed array
; 1267 : 	return (reverse_iterator<_Ty *>(_Array + _Size));
; 1268 : 	}
; 1269 : 
; 1270 : template<class _Ty,
; 1271 : 	size_t _Size> inline
; 1272 : 	reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
; 1273 : 	{	// get end of reversed array
; 1274 : 	return (reverse_iterator<_Ty *>(_Array));
; 1275 : 	}
; 1276 : 
; 1277 : template<class _Elem> inline
; 1278 : 	reverse_iterator<const _Elem *> rbegin(initializer_list<_Elem> _Ilist)
; 1279 : 	{	// get beginning of reversed sequence
; 1280 : 	return (reverse_iterator<const _Elem *>(_Ilist.end()));
; 1281 : 	}
; 1282 : 
; 1283 : template<class _Elem> inline
; 1284 : 	reverse_iterator<const _Elem *> rend(initializer_list<_Elem> _Ilist)
; 1285 : 	{	// get end of reversed sequence
; 1286 : 	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
; 1287 : 	}
; 1288 : 
; 1289 : 		// TEMPLATE FUNCTIONS crbegin AND crend
; 1290 : template<class _Container>
; 1291 : 	auto inline crbegin(const _Container& _Cont) -> decltype(_STD rbegin(_Cont))
; 1292 : 	{	// get beginning of reversed sequence
; 1293 : 	return (_STD rbegin(_Cont));
; 1294 : 	}
; 1295 : 
; 1296 : template<class _Container>
; 1297 : 	auto inline crend(const _Container& _Cont) -> decltype(_STD rend(_Cont))
; 1298 : 	{	// get end of reversed sequence
; 1299 : 	return (_STD rend(_Cont));
; 1300 : 	}
; 1301 : 
; 1302 : 
; 1303 : 		// TEMPLATE CLASS _Array_const_iterator
; 1304 : template<class _Ty,
; 1305 : 	size_t _Size>
; 1306 : 	class _Array_const_iterator
; 1307 : 		: public _Iterator012<random_access_iterator_tag,
; 1308 : 			_Ty,
; 1309 : 			ptrdiff_t,
; 1310 : 			const _Ty *,
; 1311 : 			const _Ty&,
; 1312 : 			_Iterator_base>
; 1313 : 	{	// iterator for nonmutable array
; 1314 : public:
; 1315 : 	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
; 1316 : 	typedef random_access_iterator_tag iterator_category;
; 1317 : 
; 1318 : 	typedef _Ty value_type;
; 1319 : 	typedef size_t size_type;
; 1320 : 	typedef ptrdiff_t difference_type;
; 1321 : 	typedef const _Ty *pointer;
; 1322 : 	typedef const _Ty& reference;
; 1323 : 	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
; 1324 : 	enum {_EEN_IDL =
; 1325 : 		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator
; 1326 : 
; 1327 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 1328 : 	_Array_const_iterator()
; 1329 : 		{	// construct with null pointer
; 1330 : 		_Ptr = 0;
; 1331 : 		}
; 1332 : 
; 1333 : 	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
; 1334 : 		{	// construct with pointer and offset
; 1335 : 		_Ptr = _Parg + _Off;
; 1336 : 		}
; 1337 : 
; 1338 : 	typedef pointer _Unchecked_type;
; 1339 : 
; 1340 : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 1341 : 		{	// reset from unchecked iterator
; 1342 : 		_Ptr = _Right;
; 1343 : 		return (*this);
; 1344 : 		}
; 1345 : 
; 1346 : 	_Unchecked_type _Unchecked() const
; 1347 : 		{	// make an unchecked iterator
; 1348 : 		return (_Ptr);
; 1349 : 		}
; 1350 : 
; 1351 : 	reference operator*() const
; 1352 : 		{	// return designated object
; 1353 : 		return (*_Ptr);
; 1354 : 		}
; 1355 : 
; 1356 : 	pointer operator->() const
; 1357 : 		{	// return pointer to class object
; 1358 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 1359 : 		}
; 1360 : 
; 1361 : 	_Myiter& operator++()
; 1362 : 		{	// preincrement
; 1363 : 		++_Ptr;
; 1364 : 		return (*this);
; 1365 : 		}
; 1366 : 
; 1367 : 	_Myiter operator++(int)
; 1368 : 		{	// postincrement
; 1369 : 		_Myiter _Tmp = *this;
; 1370 : 		++*this;
; 1371 : 		return (_Tmp);
; 1372 : 		}
; 1373 : 
; 1374 : 	_Myiter& operator--()
; 1375 : 		{	// predecrement
; 1376 : 		--_Ptr;
; 1377 : 		return (*this);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myiter operator--(int)
; 1381 : 		{	// postdecrement
; 1382 : 		_Myiter _Tmp = *this;
; 1383 : 		--*this;
; 1384 : 		return (_Tmp);
; 1385 : 		}
; 1386 : 
; 1387 : 	_Myiter& operator+=(difference_type _Off)
; 1388 : 		{	// increment by integer
; 1389 : 		_Ptr += _Off;
; 1390 : 		return (*this);
; 1391 : 		}
; 1392 : 
; 1393 : 	_Myiter operator+(difference_type _Off) const
; 1394 : 		{	// return this + integer
; 1395 : 		_Myiter _Tmp = *this;
; 1396 : 		return (_Tmp += _Off);
; 1397 : 		}
; 1398 : 
; 1399 : 	_Myiter& operator-=(difference_type _Off)
; 1400 : 		{	// decrement by integer
; 1401 : 		return (*this += -_Off);
; 1402 : 		}
; 1403 : 
; 1404 : 	_Myiter operator-(difference_type _Off) const
; 1405 : 		{	// return this - integer
; 1406 : 		_Myiter _Tmp = *this;
; 1407 : 		return (_Tmp -= _Off);
; 1408 : 		}
; 1409 : 
; 1410 : 	difference_type operator-(const _Myiter& _Right) const
; 1411 : 		{	// return difference of iterators
; 1412 : 		return (_Ptr - _Right._Ptr);
; 1413 : 		}
; 1414 : 
; 1415 : 	reference operator[](difference_type _Off) const
; 1416 : 		{	// subscript
; 1417 : 		return (*(*this + _Off));
; 1418 : 		}
; 1419 : 
; 1420 : 	bool operator==(const _Myiter& _Right) const
; 1421 : 		{	// test for iterator equality
; 1422 : 		return (_Ptr == _Right._Ptr);
; 1423 : 		}
; 1424 : 
; 1425 : 	bool operator!=(const _Myiter& _Right) const
; 1426 : 		{	// test for iterator inequality
; 1427 : 		return (!(*this == _Right));
; 1428 : 		}
; 1429 : 
; 1430 : 	bool operator<(const _Myiter& _Right) const
; 1431 : 		{	// test if this < _Right
; 1432 : 		return (_Ptr < _Right._Ptr);
; 1433 : 		}
; 1434 : 
; 1435 : 	bool operator>(const _Myiter& _Right) const
; 1436 : 		{	// test if this > _Right
; 1437 : 		return (_Right < *this);
; 1438 : 		}
; 1439 : 
; 1440 : 	bool operator<=(const _Myiter& _Right) const
; 1441 : 		{	// test if this <= _Right
; 1442 : 		return (!(_Right < *this));
; 1443 : 		}
; 1444 : 
; 1445 : 	bool operator>=(const _Myiter& _Right) const
; 1446 : 		{	// test if this >= _Right
; 1447 : 		return (!(*this < _Right));
; 1448 : 		}
; 1449 : 
; 1450 : 	pointer _Ptr;	// beginning of array
; 1451 : 
; 1452 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 1453 : 	_Array_const_iterator()
; 1454 : 		{	// construct with null pointer
; 1455 : 		_Ptr = 0;
; 1456 : 		_Idx = 0;
; 1457 : 		}
; 1458 : 
; 1459 : 	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
; 1460 : 		{	// construct with pointer and offset
; 1461 : 		_Ptr = _Parg;
; 1462 : 		_Idx = _Off;
; 1463 : 		}
; 1464 : 
; 1465 : 	typedef pointer _Unchecked_type;
; 1466 : 
; 1467 : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 1468 : 		{	// reset from unchecked iterator
; 1469 : 		_Idx = _Right - _Ptr;
; 1470 : 		return (*this);
; 1471 : 		}
; 1472 : 
; 1473 : 	_Unchecked_type _Unchecked() const
; 1474 : 		{	// make an unchecked iterator
; 1475 : 		return (_Ptr + _Idx);
; 1476 : 		}
; 1477 : 
; 1478 : 	reference operator*() const
; 1479 : 		{	// return designated object
; 1480 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1481 : 		if (_Ptr == 0
; 1482 : 			|| _Size <= _Idx)
; 1483 : 			{	// report error
; 1484 : 			_DEBUG_ERROR("array iterator not dereferencable");
; 1485 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1486 : 			}
; 1487 : 
; 1488 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1489 : 		_SCL_SECURE_VALIDATE(_Ptr != 0);
; 1490 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1492 : 
; 1493 : 		_Analysis_assume_(_Ptr != 0);
; 1494 : 
; 1495 : 		return (_Ptr[_Idx]);
; 1496 : 		}
; 1497 : 
; 1498 : 	pointer operator->() const
; 1499 : 		{	// return pointer to class object
; 1500 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 1501 : 		}
; 1502 : 
; 1503 : 	_Myiter& operator++()
; 1504 : 		{	// preincrement
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 		if (_Ptr == 0
; 1507 : 			|| _Size <= _Idx)
; 1508 : 			{	// report error
; 1509 : 			_DEBUG_ERROR("array iterator not incrementable");
; 1510 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1511 : 			}
; 1512 : 
; 1513 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1514 : 		_SCL_SECURE_VALIDATE(_Ptr != 0);
; 1515 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
; 1516 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1517 : 
; 1518 : 		++_Idx;
; 1519 : 		return (*this);
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myiter operator++(int)
; 1523 : 		{	// postincrement
; 1524 : 		_Myiter _Tmp = *this;
; 1525 : 		++*this;
; 1526 : 		return (_Tmp);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myiter& operator--()
; 1530 : 		{	// predecrement
; 1531 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1532 : 		if (_Ptr == 0
; 1533 : 			|| _Idx <= 0)
; 1534 : 			{	// report error
; 1535 : 			_DEBUG_ERROR("array iterator not decrementable");
; 1536 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1537 : 			}
; 1538 : 
; 1539 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1540 : 		_SCL_SECURE_VALIDATE(_Ptr != 0);
; 1541 : 		_SCL_SECURE_VALIDATE_RANGE(0 < _Idx);
; 1542 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1543 : 
; 1544 : 		--_Idx;
; 1545 : 		return (*this);
; 1546 : 		}
; 1547 : 
; 1548 : 	_Myiter operator--(int)
; 1549 : 		{	// postdecrement
; 1550 : 		_Myiter _Tmp = *this;
; 1551 : 		--*this;
; 1552 : 		return (_Tmp);
; 1553 : 		}
; 1554 : 
; 1555 : 	_Myiter& operator+=(difference_type _Off)
; 1556 : 		{	// increment by integer
; 1557 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1558 : 		if (_Size < _Idx + _Off)
; 1559 : 			{	// report error
; 1560 : 			_DEBUG_ERROR("array iterator + offset out of range");
; 1561 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1562 : 			}
; 1563 : 
; 1564 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1565 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx + _Off <= _Size);
; 1566 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1567 : 
; 1568 : 		_Idx += _Off;
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myiter operator+(difference_type _Off) const
; 1573 : 		{	// return this + integer
; 1574 : 		_Myiter _Tmp = *this;
; 1575 : 		return (_Tmp += _Off);
; 1576 : 		}
; 1577 : 
; 1578 : 	_Myiter& operator-=(difference_type _Off)
; 1579 : 		{	// decrement by integer
; 1580 : 		return (*this += -_Off);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myiter operator-(difference_type _Off) const
; 1584 : 		{	// return this - integer
; 1585 : 		_Myiter _Tmp = *this;
; 1586 : 		return (_Tmp -= _Off);
; 1587 : 		}
; 1588 : 
; 1589 : 	difference_type operator-(const _Myiter& _Right) const
; 1590 : 		{	// return difference of iterators
; 1591 : 		_Compat(_Right);
; 1592 : 		return (_Idx < _Right._Idx
; 1593 : 			? -(difference_type)(_Right._Idx - _Idx)
; 1594 : 			: (difference_type)_Idx - _Right._Idx);
; 1595 : 		}
; 1596 : 
; 1597 : 	reference operator[](difference_type _Off) const
; 1598 : 		{	// subscript
; 1599 : 		return (*(*this + _Off));
; 1600 : 		}
; 1601 : 
; 1602 : 	bool operator==(const _Myiter& _Right) const
; 1603 : 		{	// test for iterator equality
; 1604 : 		_Compat(_Right);
; 1605 : 		return (_Idx == _Right._Idx);
; 1606 : 		}
; 1607 : 
; 1608 : 	bool operator!=(const _Myiter& _Right) const
; 1609 : 		{	// test for iterator inequality
; 1610 : 		return (!(*this == _Right));
; 1611 : 		}
; 1612 : 
; 1613 : 	bool operator<(const _Myiter& _Right) const
; 1614 : 		{	// test if this < _Right
; 1615 : 		_Compat(_Right);
; 1616 : 		return (_Idx < _Right._Idx);
; 1617 : 		}
; 1618 : 
; 1619 : 	bool operator>(const _Myiter& _Right) const
; 1620 : 		{	// test if this > _Right
; 1621 : 		return (_Right < *this);
; 1622 : 		}
; 1623 : 
; 1624 : 	bool operator<=(const _Myiter& _Right) const
; 1625 : 		{	// test if this <= _Right
; 1626 : 		return (!(_Right < *this));
; 1627 : 		}
; 1628 : 
; 1629 : 	bool operator>=(const _Myiter& _Right) const
; 1630 : 		{	// test if this >= _Right
; 1631 : 		return (!(*this < _Right));
; 1632 : 		}
; 1633 : 
; 1634 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1635 : 	void _Compat(const _Myiter& _Right) const
; 1636 : 		{	// test for compatible iterator pair
; 1637 : 		if (_Ptr != _Right._Ptr)
; 1638 : 			{	// report error
; 1639 : 			_DEBUG_ERROR("array iterators incompatible");
; 1640 : 			_SCL_SECURE_INVALID_ARGUMENT;
; 1641 : 			}
; 1642 : 		}
; 1643 : 
; 1644 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1645 : 	void _Compat(const _Myiter& _Right) const
; 1646 : 		{	// test for compatible iterator pair
; 1647 : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr == _Right._Ptr);
; 1648 : 		}
; 1649 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1650 : 
; 1651 : 	pointer _Ptr;	// beginning of array
; 1652 : 	size_t _Idx;	// offset into array
; 1653 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 1654 : 	};
; 1655 : 
; 1656 : template<class _Ty,
; 1657 : 	size_t _Size> inline
; 1658 : 	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
; 1659 : 		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
; 1660 : 	{	// convert to unchecked
; 1661 : 	return (_Iter._Unchecked());
; 1662 : 	}
; 1663 : 
; 1664 : template<class _Ty,
; 1665 : 	size_t _Size> inline
; 1666 : 	_Array_const_iterator<_Ty, _Size>&
; 1667 : 		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
; 1668 : 			typename _Array_const_iterator<_Ty, _Size>
; 1669 : 				::_Unchecked_type _Right)
; 1670 : 	{	// convert to checked
; 1671 : 	return (_Iter._Rechecked(_Right));
; 1672 : 	}
; 1673 : 
; 1674 : template<class _Ty,
; 1675 : 	size_t _Size> inline
; 1676 : 	_Array_const_iterator<_Ty, _Size> operator+(
; 1677 : 		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
; 1678 : 		_Array_const_iterator<_Ty, _Size> _Next)
; 1679 : 	{	// add offset to iterator
; 1680 : 	return (_Next += _Off);
; 1681 : 	}
; 1682 : 
; 1683 : 		// TEMPLATE CLASS _Array_iterator
; 1684 : template<class _Ty,
; 1685 : 	size_t _Size>
; 1686 : 	class _Array_iterator
; 1687 : 		: public _Array_const_iterator<_Ty, _Size>
; 1688 : 	{	// iterator for mutable array
; 1689 : public:
; 1690 : 	typedef _Array_iterator<_Ty, _Size> _Myiter;
; 1691 : 	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
; 1692 : 	typedef random_access_iterator_tag iterator_category;
; 1693 : 
; 1694 : 	typedef _Ty value_type;
; 1695 : 	typedef size_t size_type;
; 1696 : 	typedef ptrdiff_t difference_type;
; 1697 : 	typedef _Ty *pointer;
; 1698 : 	typedef _Ty& reference;
; 1699 : 
; 1700 : 	_Array_iterator()
; 1701 : 		{	// construct with null pointer
; 1702 : 		}
; 1703 : 
; 1704 : 	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
; 1705 : 		: _Mybase(_Parg, _Off)
; 1706 : 		{	// construct with pointer and offset
; 1707 : 		}
; 1708 : 	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
; 1709 : 	enum {_EEN_IDL =
; 1710 : 		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator
; 1711 : 
; 1712 : 	typedef pointer _Unchecked_type;
; 1713 : 
; 1714 : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 1715 : 		{	// reset from unchecked iterator
; 1716 : 		((_Mybase *)this)->_Rechecked(_Right);
; 1717 : 		return (*this);
; 1718 : 		}
; 1719 : 
; 1720 : 	_Unchecked_type _Unchecked() const
; 1721 : 		{	// make an unchecked iterator
; 1722 : 		return ((pointer)((_Mybase *)this)->_Unchecked());
; 1723 : 		}
; 1724 : 
; 1725 : 	reference operator*() const
; 1726 : 		{	// return designated object
; 1727 : 		return ((reference)**(_Mybase *)this);
; 1728 : 		}
; 1729 : 
; 1730 : 	pointer operator->() const
; 1731 : 		{	// return pointer to class object
; 1732 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 1733 : 		}
; 1734 : 
; 1735 : 	_Myiter& operator++()
; 1736 : 		{	// preincrement
; 1737 : 		++*(_Mybase *)this;
; 1738 : 		return (*this);
; 1739 : 		}
; 1740 : 
; 1741 : 	_Myiter operator++(int)
; 1742 : 		{	// postincrement
; 1743 : 		_Myiter _Tmp = *this;
; 1744 : 		++*this;
; 1745 : 		return (_Tmp);
; 1746 : 		}
; 1747 : 
; 1748 : 	_Myiter& operator--()
; 1749 : 		{	// predecrement
; 1750 : 		--*(_Mybase *)this;
; 1751 : 		return (*this);
; 1752 : 		}
; 1753 : 
; 1754 : 	_Myiter operator--(int)
; 1755 : 		{	// postdecrement
; 1756 : 		_Myiter _Tmp = *this;
; 1757 : 		--*this;
; 1758 : 		return (_Tmp);
; 1759 : 		}
; 1760 : 
; 1761 : 	_Myiter& operator+=(difference_type _Off)
; 1762 : 		{	// increment by integer
; 1763 : 		*(_Mybase *)this += _Off;
; 1764 : 		return (*this);
; 1765 : 		}
; 1766 : 
; 1767 : 	_Myiter operator+(difference_type _Off) const
; 1768 : 		{	// return this + integer
; 1769 : 		_Myiter _Tmp = *this;
; 1770 : 		return (_Tmp += _Off);
; 1771 : 		}
; 1772 : 
; 1773 : 	_Myiter& operator-=(difference_type _Off)
; 1774 : 		{	// decrement by integer
; 1775 : 		return (*this += -_Off);
; 1776 : 		}
; 1777 : 
; 1778 : 	_Myiter operator-(difference_type _Off) const
; 1779 : 		{	// return this - integer
; 1780 : 		_Myiter _Tmp = *this;
; 1781 : 		return (_Tmp -= _Off);
; 1782 : 		}
; 1783 : 
; 1784 : 	difference_type operator-(const _Mybase& _Right) const
; 1785 : 		{	// return difference of iterators
; 1786 : 		return (*(_Mybase *)this - _Right);
; 1787 : 		}
; 1788 : 
; 1789 : 	reference operator[](difference_type _Off) const
; 1790 : 		{	// subscript
; 1791 : 		return (*(*this + _Off));
; 1792 : 		}
; 1793 : 	};
; 1794 : 
; 1795 : template<class _Ty,
; 1796 : 	size_t _Size> inline
; 1797 : 	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
; 1798 : 		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
; 1799 : 	{	// convert to unchecked
; 1800 : 	return (_Iter._Unchecked());
; 1801 : 	}
; 1802 : 
; 1803 : template<class _Ty,
; 1804 : 	size_t _Size> inline
; 1805 : 	_Array_iterator<_Ty, _Size>&
; 1806 : 		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
; 1807 : 			typename _Array_iterator<_Ty, _Size>
; 1808 : 				::_Unchecked_type _Right)
; 1809 : 	{	// convert to checked
; 1810 : 	return (_Iter._Rechecked(_Right));
; 1811 : 	}
; 1812 : 
; 1813 : template<class _Ty,
; 1814 : 	size_t _Size> inline
; 1815 : 	_Array_iterator<_Ty, _Size> operator+(
; 1816 : 		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
; 1817 : 		_Array_iterator<_Ty, _Size> _Next)
; 1818 : 	{	// add offset to iterator
; 1819 : 	return (_Next += _Off);
; 1820 : 	}
; 1821 : 
; 1822 : 		// TEMPLATE CLASS move_iterator
; 1823 : template<class _RanIt>
; 1824 : 	class move_iterator
; 1825 : 	{	// wrap iterator to move rvalues
; 1826 : public:
; 1827 : 	typedef move_iterator<_RanIt> _Myt;
; 1828 : 	typedef typename iterator_traits<_RanIt>::iterator_category
; 1829 : 		iterator_category;
; 1830 : 	typedef typename iterator_traits<_RanIt>::value_type
; 1831 : 		value_type;
; 1832 : 	typedef typename iterator_traits<_RanIt>::difference_type
; 1833 : 		difference_type;
; 1834 : 	typedef _RanIt pointer;
; 1835 : 	typedef value_type&& reference;
; 1836 : 	typedef _RanIt iterator_type;
; 1837 : 
; 1838 : 	move_iterator()
; 1839 : 		{	// construct with default wrapped iterator
; 1840 : 		}
; 1841 : 
; 1842 : 	explicit move_iterator(iterator_type _Right)
; 1843 : 		: current(_Right)
; 1844 : 		{	// construct wrapped iterator from _Right
; 1845 : 		}
; 1846 : 
; 1847 : 	template<class _RanIt2>
; 1848 : 		move_iterator(const move_iterator<_RanIt2>& _Right)
; 1849 : 		: current(_Right.base())
; 1850 : 		{	// initialize with compatible base
; 1851 : 		}
; 1852 : 
; 1853 : 	template<class _RanIt2>
; 1854 : 		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
; 1855 : 		{	// assign with compatible base
; 1856 : 		current = _Right.base();
; 1857 : 		return (*this);
; 1858 : 		}
; 1859 : 
; 1860 : 	_RanIt base() const
; 1861 : 		{	// return wrapped iterator
; 1862 : 		return (current);
; 1863 : 		}
; 1864 : 
; 1865 : 	reference operator*() const
; 1866 : 		{	// return designated value
; 1867 : 		return (_STD move(*current));
; 1868 : 		}
; 1869 : 
; 1870 : 	pointer operator->() const
; 1871 : 		{	// return pointer to class object
; 1872 : 		return (current);
; 1873 : 		}
; 1874 : 
; 1875 : 	_Myt& operator++()
; 1876 : 		{	// preincrement
; 1877 : 		++current;
; 1878 : 		return (*this);
; 1879 : 		}
; 1880 : 
; 1881 : 	_Myt operator++(int)
; 1882 : 		{	// postincrement
; 1883 : 		_Myt _Tmp = *this;
; 1884 : 		++current;
; 1885 : 		return (_Tmp);
; 1886 : 		}
; 1887 : 
; 1888 : 	_Myt& operator--()
; 1889 : 		{	// predecrement
; 1890 : 		--current;
; 1891 : 		return (*this);
; 1892 : 		}
; 1893 : 
; 1894 : 	_Myt operator--(int)
; 1895 : 		{	// postdecrement
; 1896 : 		_Myt _Tmp = *this;
; 1897 : 		--current;
; 1898 : 		return (_Tmp);
; 1899 : 		}
; 1900 : 
; 1901 : 	template<class _RanIt2>
; 1902 : 		bool _Equal(const move_iterator<_RanIt2>& _Right) const
; 1903 : 		{	// test for iterator equality
; 1904 : 		return (current == _Right.base());
; 1905 : 		}
; 1906 : 
; 1907 : // N.B. functions valid for random-access iterators only beyond this point
; 1908 : 
; 1909 : 	_Myt& operator+=(difference_type _Off)
; 1910 : 		{	// increment by integer
; 1911 : 		current += _Off;
; 1912 : 		return (*this);
; 1913 : 		}
; 1914 : 
; 1915 : 	_Myt operator+(difference_type _Off) const
; 1916 : 		{	// return this + integer
; 1917 : 		return (_Myt(current + _Off));
; 1918 : 		}
; 1919 : 
; 1920 : 	_Myt& operator-=(difference_type _Off)
; 1921 : 		{	// decrement by integer
; 1922 : 		current -= _Off;
; 1923 : 		return (*this);
; 1924 : 		}
; 1925 : 
; 1926 : 	_Myt operator-(difference_type _Off) const
; 1927 : 		{	// return this - integer
; 1928 : 		return (_Myt(current - _Off));
; 1929 : 		}
; 1930 : 
; 1931 : 	reference operator[](difference_type _Off) const
; 1932 : 		{	// subscript
; 1933 : 		return (_STD move(current[_Off]));
; 1934 : 		}
; 1935 : 
; 1936 : 	template<class _RanIt2>
; 1937 : 		bool _Less(const move_iterator<_RanIt2>& _Right) const
; 1938 : 		{	// test if this < _Right
; 1939 : 		return (current < _Right.base());
; 1940 : 		}
; 1941 : 
; 1942 : 	difference_type operator-(const _Myt& _Right) const
; 1943 : 		{	// return difference of iterators
; 1944 : 		return (current - _Right.base());
; 1945 : 		}
; 1946 : 
; 1947 : protected:
; 1948 : 	iterator_type current;	// the wrapped iterator
; 1949 : 	};
; 1950 : 
; 1951 : template<class _RanIt>
; 1952 : 	struct _Is_checked_helper<move_iterator<_RanIt> >
; 1953 : 		: public _Is_checked_helper<_RanIt>
; 1954 : 	{	// mark move_iterator as checked if its wrapped iterator is checked
; 1955 : 	};
; 1956 : 
; 1957 : 		// move_iterator TEMPLATE OPERATORS
; 1958 : template<class _RanIt,
; 1959 : 	class _Diff> inline
; 1960 : 	move_iterator<_RanIt>
; 1961 : 		operator+(_Diff _Off,
; 1962 : 		const move_iterator<_RanIt>& _Right)
; 1963 : 	{	// return move_iterator + integer
; 1964 : 	return (_Right + _Off);
; 1965 : 	}
; 1966 : 
; 1967 : template<class _RanIt1,
; 1968 : 	class _RanIt2>
; 1969 : 	auto inline operator-(
; 1970 : 		move_iterator<_RanIt1>& _Left,
; 1971 : 		const move_iterator<_RanIt2>& _Right)
; 1972 : 			-> decltype(_Left.base() - _Right.base())
; 1973 : 	{	// test for move_iterator equality
; 1974 : 	return (_Left.base() - _Right.base());
; 1975 : 	}
; 1976 : 
; 1977 : template<class _RanIt1,
; 1978 : 	class _RanIt2> inline
; 1979 : 	bool operator==(
; 1980 : 		const move_iterator<_RanIt1>& _Left,
; 1981 : 		const move_iterator<_RanIt2>& _Right)
; 1982 : 	{	// test for move_iterator equality
; 1983 : 	return (_Left._Equal(_Right));
; 1984 : 	}
; 1985 : 
; 1986 : template<class _RanIt1,
; 1987 : 	class _RanIt2> inline
; 1988 : 	bool operator!=(
; 1989 : 		const move_iterator<_RanIt1>& _Left,
; 1990 : 		const move_iterator<_RanIt2>& _Right)
; 1991 : 	{	// test for move_iterator inequality
; 1992 : 	return (!(_Left == _Right));
; 1993 : 	}
; 1994 : 
; 1995 : template<class _RanIt1,
; 1996 : 	class _RanIt2> inline
; 1997 : 	bool operator<(
; 1998 : 		const move_iterator<_RanIt1>& _Left,
; 1999 : 		const move_iterator<_RanIt2>& _Right)
; 2000 : 	{	// test for move_iterator < move_iterator
; 2001 : 	return (_Left._Less(_Right));
; 2002 : 	}
; 2003 : 
; 2004 : template<class _RanIt1,
; 2005 : 	class _RanIt2> inline
; 2006 : 	bool operator>(
; 2007 : 		const move_iterator<_RanIt1>& _Left,
; 2008 : 		const move_iterator<_RanIt2>& _Right)
; 2009 : 	{	// test for move_iterator > move_iterator
; 2010 : 	return (_Right < _Left);
; 2011 : 	}
; 2012 : 
; 2013 : template<class _RanIt1,
; 2014 : 	class _RanIt2> inline
; 2015 : 	bool operator<=(
; 2016 : 		const move_iterator<_RanIt1>& _Left,
; 2017 : 		const move_iterator<_RanIt2>& _Right)
; 2018 : 	{	// test for move_iterator <= move_iterator
; 2019 : 	return (!(_Right < _Left));
; 2020 : 	}
; 2021 : 
; 2022 : template<class _RanIt1,
; 2023 : 	class _RanIt2> inline
; 2024 : 	bool operator>=(
; 2025 : 		const move_iterator<_RanIt1>& _Left,
; 2026 : 		const move_iterator<_RanIt2>& _Right)
; 2027 : 	{	// test for move_iterator >= move_iterator
; 2028 : 	return (!(_Left < _Right));
; 2029 : 	}
; 2030 : 
; 2031 : 		// TEMPLATE FUNCTION make_move_iterator
; 2032 : template<class _RanIt> inline
; 2033 : 	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
; 2034 : 	{	// make move_iterator from iterator
; 2035 : 	return (move_iterator<_RanIt>(_Iter));
; 2036 : 	}
; 2037 : 
; 2038 : 		// TEMPLATE FUNCTION copy
; 2039 : template<class _InIt,
; 2040 : 	class _OutIt> inline
; 2041 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2042 : 		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
; 2043 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)
; 2045 : 		*_Dest = *_First;
; 2046 : 	return (_Dest);
; 2047 : 	}
; 2048 : 
; 2049 : template<class _InIt,
; 2050 : 	class _OutIt> inline
; 2051 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2052 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2053 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars
; 2054 : 	ptrdiff_t _Count = _Last - _First;
; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));
; 2057 : 	return (_Dest + _Count);
; 2058 : 	}
; 2059 : 
; 2060 : template<class _InIt,
; 2061 : 	class _OutIt> inline
; 2062 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2063 : 		_OutIt _Dest)
; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2067 : 	}
; 2068 : 
; 2069 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2070 : template<class _InIt,
; 2071 : 	class _OutIt> inline
; 2072 : 	_OutIt copy(_InIt _First, _InIt _Last,
; 2073 : 		_OutIt _Dest)
; 2074 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2075 : 	return (_Rechecked(_Dest,
; 2076 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2077 : 			_Unchecked(_Dest))));
; 2078 : 	}
; 2079 : 
; 2080 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2081 : template<class _InIt,
; 2082 : 	class _OutIt> inline
; 2083 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2084 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2085 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2086 : 	return (_Copy_impl(_First, _Last,
; 2087 : 		_Dest));
; 2088 : 	}
; 2089 : 
; 2090 : template<class _InIt,
; 2091 : 	class _OutIt> inline
; 2092 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2093 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2094 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators
; 2095 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2096 : 	_Copy_impl(_First, _Last,
; 2097 : 		_Unchecked(_Dest));
; 2098 : 	return (_Ans);
; 2099 : 	}
; 2100 : 
; 2101 : template<class _InIt,
; 2102 : 	class _OutIt> inline
; 2103 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2104 : 		_OutIt _Dest, true_type)
; 2105 : 	{	// copy [_First, _Last) to [_Dest, ...), checked dest
; 2106 : 	return (_Copy_impl(_First, _Last,
; 2107 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2108 : 	}
; 2109 : 
; 2110 : template<class _InIt,
; 2111 : 	class _OutIt> inline
; 2112 : _SCL_INSECURE_DEPRECATE
; 2113 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2114 : 		_OutIt _Dest, false_type)
; 2115 : 	{	// copy [_First, _Last) to [_Dest, ...), unchecked dest
; 2116 : 	return (_Copy_impl(_First, _Last,
; 2117 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2118 : 	}
; 2119 : 
; 2120 : template<class _InIt,
; 2121 : 	class _OutIt> inline
; 2122 : 	_OutIt copy(_InIt _First, _InIt _Last,
; 2123 : 		_OutIt _Dest)
; 2124 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2125 : 	if (_First == _Last)
; 2126 : 		return (_Dest);
; 2127 : 	else
; 2128 : 		{	// worth copying, check then copy
; 2129 : 		_DEBUG_RANGE(_First, _Last);
; 2130 : 		_DEBUG_POINTER(_Dest);
; 2131 : 		return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2132 : 			_Dest, _Is_checked(_Dest)));
; 2133 : 		}
; 2134 : 	}
; 2135 : 
; 2136 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2137 : template<class _InIt,
; 2138 : 	class _OutTy,
; 2139 : 	size_t _OutSize> inline
; 2140 : 	_OutTy *copy(_InIt _First, _InIt _Last,
; 2141 : 		_OutTy (&_Dest)[_OutSize])
; 2142 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2143 : 	return (_Unchecked(
; 2144 : 		_STD copy(_First, _Last,
; 2145 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2146 : 	}
; 2147 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2148 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2149 : 
; 2150 : 		// TEMPLATE FUNCTION copy_n
; 2151 : template<class _InIt,
; 2152 : 	class _Diff,
; 2153 : 	class _OutIt> inline
; 2154 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2155 : 		_OutIt _Dest, input_iterator_tag)
; 2156 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), input iterators
; 2157 : 	*_Dest = *_First;	// 0 < _Count has been guaranteed
; 2158 : 	while (0 < --_Count)
; 2159 : 		*++_Dest = *++_First;
; 2160 : 	return (++_Dest);
; 2161 : 	}
; 2162 : 
; 2163 : template<class _InIt,
; 2164 : 	class _Diff,
; 2165 : 	class _OutIt> inline
; 2166 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2167 : 		_OutIt _Dest, forward_iterator_tag)
; 2168 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), forward iterators
; 2169 : 	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
; 2170 : 		*_Dest = *_First;
; 2171 : 	return (_Dest);
; 2172 : 	}
; 2173 : 
; 2174 : template<class _InIt,
; 2175 : 	class _Diff,
; 2176 : 	class _OutIt> inline
; 2177 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2178 : 		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
; 2179 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary iterators
; 2180 : 	return (_Copy_n(_First, _Count,
; 2181 : 		_Dest, _Iter_cat(_First)));
; 2182 : 	}
; 2183 : template<class _InIt,
; 2184 : 	class _Diff,
; 2185 : 	class _OutIt> inline
; 2186 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2187 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2188 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), pointers to scalars
; 2189 : 	_CSTD memmove(&*_Dest, &*_First,
; 2190 : 		_Count * sizeof (*_First));
; 2191 : 	return (_Dest + _Count);
; 2192 : 	}
; 2193 : 
; 2194 : template<class _InIt,
; 2195 : 	class _Diff,
; 2196 : 	class _OutIt> inline
; 2197 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2198 : 		_OutIt _Dest)
; 2199 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked
; 2200 : 	return (_Copy_n(_First, _Count,
; 2201 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2202 : 	}
; 2203 : 
; 2204 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2205 : template<class _InIt,
; 2206 : 	class _Diff,
; 2207 : 	class _OutIt> inline
; 2208 : 	_OutIt copy_n(_InIt _First, _Diff _Count,
; 2209 : 		_OutIt _Dest)
; 2210 : 	{	// copy [_First, _First + _Count) to [_Dest, ...)
; 2211 : 	if (_Count <= 0)
; 2212 : 		return (_Dest);
; 2213 : 	else
; 2214 : 		return (_Rechecked(_Dest,
; 2215 : 			_Copy_n(_Unchecked(_First), _Count,
; 2216 : 				_Unchecked(_Dest))));
; 2217 : 	}
; 2218 : 
; 2219 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2220 : template<class _InIt,
; 2221 : 	class _Diff,
; 2222 : 	class _OutIt> inline
; 2223 : 	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
; 2224 : 		_OutIt _Dest, _Mutable_iterator_tag)
; 2225 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary dest
; 2226 : 	return (_Copy_n(_First, _Count,
; 2227 : 		_Dest));
; 2228 : 	}
; 2229 : 
; 2230 : template<class _InIt,
; 2231 : 	class _Diff,
; 2232 : 	class _OutIt> inline
; 2233 : 	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
; 2234 : 		_OutIt _Dest, random_access_iterator_tag)
; 2235 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access dest
; 2236 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2237 : 	_Copy_n(_First, _Count,
; 2238 : 		_Unchecked(_Dest));
; 2239 : 	return (_Ans);
; 2240 : 	}
; 2241 : 
; 2242 : template<class _InIt,
; 2243 : 	class _Diff,
; 2244 : 	class _OutIt> inline
; 2245 : 	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
; 2246 : 		_OutIt _Dest, input_iterator_tag)
; 2247 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input
; 2248 : 	return (_Copy_n2(_First, _Count,
; 2249 : 		_Dest, _Iter_cat(_Dest)));
; 2250 : 	}
; 2251 : 
; 2252 : template<class _InIt,
; 2253 : 	class _Diff,
; 2254 : 	class _OutIt> inline
; 2255 : 	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
; 2256 : 		_OutIt _Dest, random_access_iterator_tag)
; 2257 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access input
; 2258 : 	_InIt _Last = _First + _Count;	// also checks range
; 2259 : 	_Last = _Last;	// to quiet diagnostics
; 2260 : 	return (_Copy_n2(_Unchecked(_First), _Count,
; 2261 : 		_Dest, _Iter_cat(_Dest)));
; 2262 : 	}
; 2263 : 
; 2264 : template<class _InIt,
; 2265 : 	class _Diff,
; 2266 : 	class _OutIt> inline
; 2267 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2268 : 		_OutIt _Dest, true_type)
; 2269 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), checked dest
; 2270 : 	return (_Copy_n1(_First, _Count,
; 2271 : 		_Dest, _Iter_cat(_First)));
; 2272 : 	}
; 2273 : 
; 2274 : template<class _InIt,
; 2275 : 	class _Diff,
; 2276 : 	class _OutIt> inline
; 2277 : _SCL_INSECURE_DEPRECATE
; 2278 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2279 : 		_OutIt _Dest, false_type)
; 2280 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked dest
; 2281 : 	return (_Copy_n1(_First, _Count,
; 2282 : 		_Dest, _Iter_cat(_First)));
; 2283 : 	}
; 2284 : 
; 2285 : template<class _InIt,
; 2286 : 	class _Diff,
; 2287 : 	class _OutIt> inline
; 2288 : 	_OutIt copy_n(_InIt _First, _Diff _Count,
; 2289 : 		_OutIt _Dest)
; 2290 : 	{	// copy [_First, _First + _Count) to [_Dest, ...)
; 2291 : 	_DEBUG_POINTER(_First);
; 2292 : 	_DEBUG_POINTER(_Dest);
; 2293 : 	if (_Count <= 0)
; 2294 : 		return (_Dest);
; 2295 : 	else
; 2296 : 		return (_Copy_n(_First, _Count,
; 2297 : 			_Dest, _Is_checked(_Dest)));
; 2298 : 	}
; 2299 : 
; 2300 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2301 : template<class _InTy,
; 2302 : 	size_t _InSize,
; 2303 : 	class _Diff,
; 2304 : 	class _OutIt> inline
; 2305 : 	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,
; 2306 : 		_OutIt _Dest)
; 2307 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), array input
; 2308 : 	return (_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
; 2309 : 		_Dest));
; 2310 : 	}
; 2311 : 
; 2312 : template<class _InIt,
; 2313 : 	class _Diff,
; 2314 : 	class _OutTy,
; 2315 : 	size_t _OutSize> inline
; 2316 : 	_OutTy *copy_n(_InIt _First, _Diff _Count,
; 2317 : 		_OutTy (&_Dest)[_OutSize])
; 2318 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
; 2319 : 	return (_Unchecked(
; 2320 : 		_STD copy_n(_First, _Count,
; 2321 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2322 : 	}
; 2323 : 
; 2324 : template<class _InTy,
; 2325 : 	size_t _InSize,
; 2326 : 	class _Diff,
; 2327 : 	class _OutTy,
; 2328 : 	size_t _OutSize> inline
; 2329 : 	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,
; 2330 : 		_OutTy (&_Dest)[_OutSize])
; 2331 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest
; 2332 : 	return (_Unchecked(
; 2333 : 		_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
; 2334 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2335 : 	}
; 2336 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2337 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2338 : 
; 2339 : 		// TEMPLATE FUNCTION copy_backward
; 2340 : template<class _BidIt1,
; 2341 : 	class _BidIt2> inline
; 2342 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2343 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2344 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2345 : 	while (_First != _Last)
; 2346 : 		*--_Dest = *--_Last;
; 2347 : 	return (_Dest);
; 2348 : 	}
; 2349 : 
; 2350 : template<class _InIt,
; 2351 : 	class _OutIt> inline
; 2352 : 	_OutIt _Copy_backward(_InIt _First, _InIt _Last,
; 2353 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2354 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2355 : 	ptrdiff_t _Count = _Last - _First;
; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));
; 2358 : 	return (_Dest - _Count);
; 2359 : 	}
; 2360 : 
; 2361 : template<class _BidIt1,
; 2362 : 	class _BidIt2> inline
; 2363 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2364 : 		_BidIt2 _Dest)
; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked
; 2366 : 	return (_Copy_backward(_First, _Last,
; 2367 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2368 : 	}
; 2369 : 
; 2370 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2371 : template<class _BidIt1,
; 2372 : 	class _BidIt2> inline
; 2373 : 	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2374 : 		_BidIt2 _Dest)
; 2375 : 	{	// copy [_First, _Last) backwards to [..., _Dest)
; 2376 : 	return (_Rechecked(_Dest,
; 2377 : 		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2378 : 			_Unchecked(_Dest))));
; 2379 : 	}
; 2380 : 
; 2381 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2382 : template<class _BidIt1,
; 2383 : 	class _BidIt2> inline
; 2384 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2385 : 		_BidIt2 _Dest, true_type)
; 2386 : 	{	// copy [_First, _Last) backwards to [..., _Dest), checked dest
; 2387 : 	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2388 : 		_Dest));
; 2389 : 	}
; 2390 : 
; 2391 : template<class _BidIt1,
; 2392 : 	class _BidIt2> inline
; 2393 : _SCL_INSECURE_DEPRECATE
; 2394 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2395 : 		_BidIt2 _Dest, false_type)
; 2396 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2397 : 	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2398 : 		_Dest));
; 2399 : 	}
; 2400 : 
; 2401 : template<class _BidIt1,
; 2402 : 	class _BidIt2> inline
; 2403 : 	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2404 : 		_BidIt2 _Dest)
; 2405 : 	{	// copy [_First, _Last) backwards to [..., _Dest)
; 2406 : 	_DEBUG_RANGE(_First, _Last);
; 2407 : 	_DEBUG_POINTER(_Dest);
; 2408 : 	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2409 : 		_Dest, _Is_checked(_Dest)));
; 2410 : 	}
; 2411 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2412 : 
; 2413 : 		// TEMPLATE FUNCTION move
; 2414 : template<class _InIt,
; 2415 : 	class _OutIt> inline
; 2416 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2417 : 		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)
; 2420 : 		*_Dest = _STD move(*_First);
; 2421 : 	return (_Dest);
; 2422 : 	}
; 2423 : 
; 2424 : template<class _InIt,
; 2425 : 	class _OutIt> inline
; 2426 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2427 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2428 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars
; 2429 : 	ptrdiff_t _Count = _Last - _First;
; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));
; 2432 : 	return (_Dest + _Count);
; 2433 : 	}
; 2434 : 
; 2435 : template<class _InIt,
; 2436 : 	class _OutIt> inline
; 2437 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2438 : 		_OutIt _Dest)
; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked
; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}
; 2443 : 
; 2444 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2445 : template<class _InIt,
; 2446 : 	class _OutIt> inline
; 2447 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2448 : 		_OutIt _Dest)
; 2449 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2450 : 	return (_Rechecked(_Dest,
; 2451 : 		_Move(_Unchecked(_First), _Unchecked(_Last),
; 2452 : 			_Unchecked(_Dest))));
; 2453 : 	}
; 2454 : 
; 2455 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2456 : template<class _InIt,
; 2457 : 	class _OutIt> inline
; 2458 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2459 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2460 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2461 : 	return (_Move(_First, _Last,
; 2462 : 		_Dest));
; 2463 : 	}
; 2464 : 
; 2465 : template<class _InIt,
; 2466 : 	class _OutIt> inline
; 2467 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2468 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2469 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators
; 2470 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2471 : 	_Move(_First, _Last,
; 2472 : 		_Unchecked(_Dest));
; 2473 : 	return (_Ans);
; 2474 : 	}
; 2475 : 
; 2476 : template<class _InIt,
; 2477 : 	class _OutIt> inline
; 2478 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2479 : 		_OutIt _Dest, true_type)
; 2480 : 	{	// move [_First, _Last) to [_Dest, ...), checked dest
; 2481 : 	return (_Move(_First, _Last,
; 2482 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2483 : 	}
; 2484 : 
; 2485 : template<class _InIt,
; 2486 : 	class _OutIt> inline
; 2487 : _SCL_INSECURE_DEPRECATE
; 2488 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2489 : 		_OutIt _Dest, false_type)
; 2490 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked dest
; 2491 : 	return (_Move(_First, _Last,
; 2492 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2493 : 	}
; 2494 : 
; 2495 : template<class _InIt,
; 2496 : 	class _OutIt> inline
; 2497 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2498 : 		_OutIt _Dest)
; 2499 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2500 : 	_DEBUG_RANGE(_First, _Last);
; 2501 : 	_DEBUG_POINTER(_Dest);
; 2502 : 	return (_Move(_Unchecked(_First), _Unchecked(_Last),
; 2503 : 		_Dest, _Is_checked(_Dest)));
; 2504 : 	}
; 2505 : 
; 2506 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2507 : template<class _InIt,
; 2508 : 	class _OutTy,
; 2509 : 	size_t _OutSize> inline
; 2510 : 	_OutTy *move(_InIt _First, _InIt _Last,
; 2511 : 		_OutTy (&_Dest)[_OutSize])
; 2512 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2513 : 	return (_Unchecked(
; 2514 : 		_STD move(_First, _Last,
; 2515 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2516 : 	}
; 2517 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2518 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2519 : 
; 2520 : 		// TEMPLATE FUNCTION move_backward
; 2521 : template<class _BidIt1,
; 2522 : 	class _BidIt2> inline
; 2523 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2524 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2526 : 	while (_First != _Last)
; 2527 : 		*--_Dest = _STD move(*--_Last);
; 2528 : 	return (_Dest);
; 2529 : 	}
; 2530 : 
; 2531 : template<class _InIt,
; 2532 : 	class _OutIt> inline
; 2533 : 	_OutIt _Move_backward(_InIt _First, _InIt _Last,
; 2534 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2536 : 	ptrdiff_t _Count = _Last - _First;
; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));
; 2539 : 	return (_Dest - _Count);
; 2540 : 	}
; 2541 : 
; 2542 : template<class _BidIt1,
; 2543 : 	class _BidIt2> inline
; 2544 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2545 : 		_BidIt2 _Dest)
; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked
; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2549 : 	}
; 2550 : 
; 2551 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2552 : template<class _BidIt1,
; 2553 : 	class _BidIt2> inline
; 2554 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2555 : 		_BidIt2 _Dest)
; 2556 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2557 : 	return (_Rechecked(_Dest,
; 2558 : 		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2559 : 			_Unchecked(_Dest))));
; 2560 : 	}
; 2561 : 
; 2562 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2563 : template<class _BidIt1,
; 2564 : 	class _BidIt2> inline
; 2565 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2566 : 		_BidIt2 _Dest, true_type)
; 2567 : 	{	// move [_First, _Last) backwards to [..., _Dest), checked dest
; 2568 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2569 : 		_Dest));
; 2570 : 	}
; 2571 : 
; 2572 : template<class _BidIt1,
; 2573 : 	class _BidIt2> inline
; 2574 : _SCL_INSECURE_DEPRECATE
; 2575 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2576 : 		_BidIt2 _Dest, false_type)
; 2577 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2578 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2579 : 		_Dest));
; 2580 : 	}
; 2581 : 
; 2582 : template<class _BidIt1,
; 2583 : 	class _BidIt2> inline
; 2584 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2585 : 		_BidIt2 _Dest)
; 2586 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2587 : 	_DEBUG_RANGE(_First, _Last);
; 2588 : 	_DEBUG_POINTER(_Dest);
; 2589 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2590 : 		_Dest, _Is_checked(_Dest)));
; 2591 : 	}
; 2592 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2593 : 
; 2594 : 		// TEMPLATE FUNCTION fill
; 2595 : template<class _FwdIt,
; 2596 : 	class _Ty> inline
; 2597 : 	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2598 : 	{	// copy _Val through [_First, _Last)
; 2599 : 	for (; _First != _Last; ++_First)
; 2600 : 		*_First = _Val;
; 2601 : 	}
; 2602 : 
; 2603 : inline void _Fill(char *_First, char *_Last, char _Val)
; 2604 : 	{	// copy char _Val through [_First, _Last)
; 2605 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2606 : 	}
; 2607 : 
; 2608 : inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
; 2609 : 	{	// copy signed char _Val through [_First, _Last)
; 2610 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2611 : 	}
; 2612 : 
; 2613 : inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
; 2614 : 	{	// copy unsigned char _Val through [_First, _Last)
; 2615 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2616 : 	}
; 2617 : 
; 2618 : template<class _FwdIt,
; 2619 : 	class _Ty> inline
; 2620 : 	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2621 : 	{	// copy _Val through [_First, _Last)
; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}
; 2625 : 
; 2626 : 		// TEMPLATE FUNCTION fill_n
; 2627 : template<class _OutIt,
; 2628 : 	class _Diff,
; 2629 : 	class _Ty> inline
; 2630 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)
; 2633 : 		*_Dest = _Val;
; 2634 : 	return (_Dest);
; 2635 : 	}
; 2636 : 
; 2637 : inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)
; 2639 : 	_CSTD memset(_Dest, _Val, _Count);
; 2640 : 	return (_Dest + _Count);
; 2641 : 	}
; 2642 : 
; 2643 : inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
; 2644 : 	signed char _Val)
; 2645 : 	{	// copy signed char _Val _Count times through [_Dest, ...)
; 2646 : 	_CSTD memset(_Dest, _Val, _Count);
; 2647 : 	return (_Dest + _Count);
; 2648 : 	}
; 2649 : 
; 2650 : inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
; 2651 : 	unsigned char _Val)
; 2652 : 	{	// copy unsigned char _Val _Count times through [_Dest, ...)
; 2653 : 	_CSTD memset(_Dest, _Val, _Count);
; 2654 : 	return (_Dest + _Count);
; 2655 : 	}
; 2656 : 
; 2657 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2658 : template<class _OutIt,
; 2659 : 	class _Diff,
; 2660 : 	class _Ty> inline
; 2661 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2662 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2663 : 	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
; 2664 : 	}
; 2665 : 
; 2666 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2667 : template<class _OutIt,
; 2668 : 	class _Diff,
; 2669 : 	class _Ty> inline
; 2670 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2671 : 		_Mutable_iterator_tag)
; 2672 : 	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator
; 2673 : 	return (_Fill_n(_Dest, _Count, _Val));
; 2674 : 	}
; 2675 : 
; 2676 : template<class _OutIt,
; 2677 : 	class _Diff,
; 2678 : 	class _Ty> inline
; 2679 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2680 : 		random_access_iterator_tag)
; 2681 : 	{	// copy _Val _Count times through [_Dest, ...), random-access iterator
; 2682 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2683 : 	_Fill_n(_Unchecked(_Dest), _Count, _Val);
; 2684 : 	return (_Ans);
; 2685 : 	}
; 2686 : 
; 2687 : template<class _OutIt,
; 2688 : 	class _Diff,
; 2689 : 	class _Ty> inline
; 2690 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2691 : 		true_type)
; 2692 : 	{	// copy _Val _Count times through [_Dest, ...), checked dest
; 2693 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2694 : 		_Iter_cat(_Dest)));
; 2695 : 	}
; 2696 : 
; 2697 : template<class _OutIt,
; 2698 : 	class _Diff,
; 2699 : 	class _Ty> inline
; 2700 : _SCL_INSECURE_DEPRECATE
; 2701 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2702 : 		false_type)
; 2703 : 	{	// copy _Val _Count times through [_Dest, ...), unchecked dest
; 2704 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2705 : 		_Iter_cat(_Dest)));
; 2706 : 	}
; 2707 : 
; 2708 : template<class _OutIt,
; 2709 : 	class _Diff,
; 2710 : 	class _Ty> inline
; 2711 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2712 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2713 : 	_DEBUG_POINTER(_Dest);
; 2714 : 	return (_Fill_n(_Dest, _Count, _Val,
; 2715 : 		_Is_checked(_Dest)));
; 2716 : 	}
; 2717 : 
; 2718 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2719 : template<class _OutTy,
; 2720 : 	size_t _OutSize,
; 2721 : 	class _Diff,
; 2722 : 	class _Ty> inline
; 2723 : 	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
; 2724 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2725 : 	return (_Unchecked(_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
; 2726 : 		_Count, _Val)));
; 2727 : 	}
; 2728 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2729 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2730 : 
; 2731 : 		// TEMPLATE FUNCTION equal
; 2732 : template<class _InIt1,
; 2733 : 	class _InIt2> inline
; 2734 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
; 2735 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2736 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2737 : 		if (!(*_First1 == *_First2))
; 2738 : 			return (false);
; 2739 : 	return (true);
; 2740 : 	}
; 2741 : 
; 2742 : inline bool _Equal(const char *_First1, const char *_Last1,
; 2743 : 	const char *_First2)
; 2744 : 	{	// compare [_First1, _Last1) to [_First2, ...), for chars
; 2745 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2746 : 	}
; 2747 : 
; 2748 : inline bool _Equal(const signed char *_First1, const signed char *_Last1,
; 2749 : 	const signed char *_First2)
; 2750 : 	{	// compare [_First1, _Last1) to [_First2, ...), for signed chars
; 2751 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2752 : 	}
; 2753 : 
; 2754 : inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
; 2755 : 	const unsigned char *_First2)
; 2756 : 	{	// compare [_First1, _Last1) to [_First2, ...), for unsigned chars
; 2757 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2758 : 	}
; 2759 : 
; 2760 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2761 : template<class _InIt1,
; 2762 : 	class _InIt2> inline
; 2763 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2764 : 		_InIt2 _First2)
; 2765 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2766 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2767 : 		_Unchecked(_First2)));
; 2768 : 	}
; 2769 : 
; 2770 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2771 : template<class _InIt1,
; 2772 : 	class _InIt2> inline
; 2773 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2774 : 		_InIt2 _First2, true_type)
; 2775 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked dest
; 2776 : 	return (_Equal(_First1, _Last1,
; 2777 : 		_First2));
; 2778 : 	}
; 2779 : 
; 2780 : template<class _InIt1,
; 2781 : 	class _InIt2> inline
; 2782 : _SCL_INSECURE_DEPRECATE
; 2783 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2784 : 		_InIt2 _First2, false_type)
; 2785 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked dest
; 2786 : 	return (_Equal(_First1, _Last1,
; 2787 : 		_First2));
; 2788 : 	}
; 2789 : 
; 2790 : template<class _InIt1,
; 2791 : 	class _InIt2> inline
; 2792 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2793 : 		_InIt2 _First2)
; 2794 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2795 : 	_DEBUG_RANGE(_First1, _Last1);
; 2796 : 	_DEBUG_POINTER(_First2);
; 2797 : 	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
; 2798 : 		_First2, _Is_checked(_First2)));
; 2799 : 	}
; 2800 : 
; 2801 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2802 : template<class _InIt1,
; 2803 : 	class _InTy,
; 2804 : 	size_t _InSize> inline
; 2805 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InTy (&_First2)[_InSize])
; 2807 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2808 : 	return (_STD equal(_First1, _Last1,
; 2809 : 		_Array_iterator<_InTy, _InSize>(_First2)));
; 2810 : 	}
; 2811 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2812 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2813 : 
; 2814 : 		// TEMPLATE FUNCTION equal WITH PRED
; 2815 : template<class _InIt1,
; 2816 : 	class _InIt2,
; 2817 : 	class _Pr> inline
; 2818 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
; 2819 : 		_InIt2 _First2, _Pr _Pred)
; 2820 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
; 2821 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2822 : 		if (!_Pred(*_First1, *_First2))
; 2823 : 			return (false);
; 2824 : 	return (true);
; 2825 : 	}
; 2826 : 
; 2827 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2828 : template<class _InIt1,
; 2829 : 	class _InIt2,
; 2830 : 	class _Pr> inline
; 2831 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2832 : 		_InIt2 _First2, _Pr _Pred)
; 2833 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2834 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2835 : 		_Unchecked(_First2), _Pred));
; 2836 : 	}
; 2837 : 
; 2838 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2839 : template<class _InIt1,
; 2840 : 	class _InIt2,
; 2841 : 	class _Pr> inline
; 2842 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2843 : 		_InIt2 _First2, _Pr _Pred, true_type)
; 2844 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked input
; 2845 : 	return (_Equal(_First1, _Last1,
; 2846 : 		_First2, _Pred));
; 2847 : 	}
; 2848 : 
; 2849 : template<class _InIt1,
; 2850 : 	class _InIt2,
; 2851 : 	class _Pr> inline
; 2852 : _SCL_INSECURE_DEPRECATE
; 2853 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2854 : 		_InIt2 _First2, _Pr _Pred, false_type)
; 2855 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked input
; 2856 : 	return (_Equal(_First1, _Last1,
; 2857 : 		_First2, _Pred));
; 2858 : 	}
; 2859 : 
; 2860 : template<class _InIt1,
; 2861 : 	class _InIt2,
; 2862 : 	class _Pr> inline
; 2863 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2864 : 		_InIt2 _First2, _Pr _Pred)
; 2865 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2866 : 	_DEBUG_RANGE(_First1, _Last1);
; 2867 : 	_DEBUG_POINTER(_First2);
; 2868 : 	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
; 2869 : 		_First2, _Pred, _Is_checked(_First2)));
; 2870 : 	}
; 2871 : 
; 2872 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2873 : template<class _InIt1,
; 2874 : 	class _InTy,
; 2875 : 	size_t _InSize,
; 2876 : 	class _Pr> inline
; 2877 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2878 : 		_InTy (&_First2)[_InSize], _Pr _Pred)
; 2879 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2880 : 	return (_STD equal(_First1, _Last1,
; 2881 : 		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
; 2882 : 	}
; 2883 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2884 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2885 : 
; 2886 : 		// TEMPLATE FUNCTION lexicographical_compare
; 2887 : template<class _InIt1,
; 2888 : 	class _InIt2> inline
; 2889 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2890 : 		_InIt2 _First2, _InIt2 _Last2)
; 2891 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2892 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2893 : 		if (_DEBUG_LT(*_First1, *_First2))
; 2894 : 			return (true);
; 2895 : 		else if (*_First2 < *_First1)
; 2896 : 			return (false);
; 2897 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2898 : 	}
; 2899 : 
; 2900 : inline bool _Lexicographical_compare(
; 2901 : 	const unsigned char *_First1, const unsigned char *_Last1,
; 2902 : 	const unsigned char *_First2, const unsigned char *_Last2)
; 2903 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for unsigned char
; 2904 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2905 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2906 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2907 : 	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
; 2908 : 	}
; 2909 : 
; 2910 :  #if CHAR_MAX == UCHAR_MAX
; 2911 : inline bool _Lexicographical_compare(
; 2912 : 	const char *_First1, const char *_Last1,
; 2913 : 	const char *_First2, const char *_Last2)
; 2914 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for nonnegative char
; 2915 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2916 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2917 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2918 : 	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
; 2919 : 	}
; 2920 :  #endif /* CHAR_MAX == UCHAR_MAX */
; 2921 : 
; 2922 : template<class _InIt1,
; 2923 : 	class _InIt2> inline
; 2924 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2925 : 		_InIt2 _First2, _InIt2 _Last2)
; 2926 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2927 : 	_DEBUG_RANGE(_First1, _Last1);
; 2928 : 	_DEBUG_RANGE(_First2, _Last2);
; 2929 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2930 : 		_Unchecked(_First2), _Unchecked(_Last2)));
; 2931 : 	}
; 2932 : 
; 2933 : 		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
; 2934 : template<class _InIt1,
; 2935 : 	class _InIt2,
; 2936 : 	class _Pr> inline
; 2937 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2938 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2939 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2940 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2941 : 		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
; 2942 : 			return (true);
; 2943 : 		else if (_Pred(*_First2, *_First1))
; 2944 : 			return (false);
; 2945 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2946 : 	}
; 2947 : 
; 2948 : template<class _InIt1,
; 2949 : 	class _InIt2,
; 2950 : 	class _Pr> inline
; 2951 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2952 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2953 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2954 : 	_DEBUG_RANGE(_First1, _Last1);
; 2955 : 	_DEBUG_RANGE(_First2, _Last2);
; 2956 : 	_DEBUG_POINTER(_Pred);
; 2957 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2958 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
; 2959 : 	}
; 2960 : 
; 2961 : 		// TEMPLATE FUNCTION find
; 2962 : template<class _Ty,
; 2963 : 	class _Ignored> inline
; 2964 : 	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
; 2965 : 	{	// signed _Elem, signed _Ty
; 2966 : 	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);
; 2967 : 	}
; 2968 : 
; 2969 : template<class _Ty> inline
; 2970 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
; 2971 : 	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
; 2972 : 	return (_Val <= SCHAR_MAX || static_cast<_Ty>(SCHAR_MIN) <= _Val);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _Ty> inline
; 2976 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
; 2977 : 	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
; 2978 : 	return (_Val <= SCHAR_MAX);
; 2979 : 	}
; 2980 : 
; 2981 : template<class _Ty,
; 2982 : 	class _Ignored> inline
; 2983 : 	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
; 2984 : 	{	// unsigned _Elem, signed _Ty
; 2985 : 	return (0 <= _Val && _Val <= UCHAR_MAX);
; 2986 : 	}
; 2987 : 
; 2988 : template<class _Ty,
; 2989 : 	class _Ignored> inline
; 2990 : 	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
; 2991 : 	{	// unsigned _Elem, unsigned _Ty
; 2992 : 	return (_Val <= UCHAR_MAX);
; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))
; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));
; 3018 : 	return (_First ? _First : _Last);
; 3019 : 	}
; 3020 : 
; 3021 : template<class _InIt,
; 3022 : 	class _Ty> inline
; 3023 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
; 3024 : 	{	// find first matching _Val
; 3025 : 	for (; _First != _Last; ++_First)
; 3026 : 		if (*_First == _Val)
; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}
; 3030 : 
; 3031 : template<class _InIt,
; 3032 : 	class _Ty> inline
; 3033 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3034 : 	{	// find first matching _Val
; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));
; 3046 : 	}
; 3047 : 
; 3048 : template<class _InIt,
; 3049 : 	class _Ty> inline
; 3050 : 	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3051 : 	{	// find first matching _Val
; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 3055 : 	}
; 3056 : 
; 3057 : 		// TEMPLATE FUNCTION _Find_pr WITH PREDICATE
; 3058 : template<class _InIt,
; 3059 : 	class _Ty,
; 3060 : 	class _Pr> inline
; 3061 : 	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
; 3062 : 	{	// find first matching _Val, using _Pred
; 3063 : 	for (; _First != _Last; ++_First)
; 3064 : 		if (_Pred(*_First, _Val))
; 3065 : 			break;
; 3066 : 	return (_First);
; 3067 : 	}
; 3068 : 
; 3069 : 		// TEMPLATE FUNCTION count
; 3070 : template<class _InIt,
; 3071 : 	class _Ty> inline
; 3072 : 	typename iterator_traits<_InIt>::difference_type
; 3073 : 		_Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3074 : 	{	// count elements that match _Val
; 3075 : 	typename iterator_traits<_InIt>::difference_type _Count = 0;
; 3076 : 
; 3077 : 	for (; _First != _Last; ++_First)
; 3078 : 		if (*_First == _Val)
; 3079 : 			++_Count;
; 3080 : 	return (_Count);
; 3081 : 	}
; 3082 : 
; 3083 : template<class _InIt,
; 3084 : 	class _Ty> inline
; 3085 : 	typename iterator_traits<_InIt>::difference_type
; 3086 : 		count(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3087 : 	{	// count elements that match _Val
; 3088 : 	_DEBUG_RANGE(_First, _Last);
; 3089 : 	return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
; 3090 : 	}
; 3091 : 
; 3092 : 		// TEMPLATE FUNCTION _Count_pr WITH PREDICATE
; 3093 : template<class _InIt,
; 3094 : 	class _Ty,
; 3095 : 	class _Pr> inline
; 3096 : 	typename iterator_traits<_InIt>::difference_type
; 3097 : 		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
; 3098 : 	{	// count elements that match _Val, using _Pred
; 3099 : 	typename iterator_traits<_InIt>::difference_type _Count = 0;
; 3100 : 
; 3101 : 	for (; _First != _Last; ++_First)
; 3102 : 		if (_Pred(*_First, _Val))
; 3103 : 			++_Count;
; 3104 : 	return (_Count);
; 3105 : 	}
; 3106 : 
; 3107 : 		// TEMPLATE FUNCTION is_permutation WITH PREDICATE
; 3108 : template<class _FwdIt1,
; 3109 : 	class _FwdIt2,
; 3110 : 	class _Pr> inline
; 3111 : 	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
; 3112 : 		_FwdIt2 _First2, _Pr _Pred)
; 3113 : 	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
; 3114 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 3115 : 		if (!_Pred(*_First1, *_First2))
; 3116 : 			break;	// find first inequality
; 3117 : 	if (_First1 != _Last1)
; 3118 : 		{	// check match counts in suffix
; 3119 : 		_FwdIt2 _Last2 = _First2;
; 3120 : 		advance(_Last2, distance(_First1, _Last1));
; 3121 : 		for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
; 3122 : 			if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
; 3123 : 				{	// new value, compare match counts
; 3124 : 				typename iterator_traits<_FwdIt2>::difference_type _Count =
; 3125 : 					_Count_pr(_First2, _Last2, *_Next1, _Pred);
; 3126 : 				if (_Count == 0
; 3127 : 					|| _Count != _Count_pr(_Next1, _Last1, *_Next1, _Pred))
; 3128 : 					return (false);	// match counts differ, fail
; 3129 : 				}
; 3130 : 		}
; 3131 : 	return (true);
; 3132 : 	}
; 3133 : 
; 3134 : template<class _FwdIt1,
; 3135 : 	class _FwdIt2,
; 3136 : 	class _Pr> inline
; 3137 : 	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
; 3138 : 		_FwdIt2 _First2, _Pr _Pred)
; 3139 : 	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
; 3140 : 	_DEBUG_RANGE(_First1, _Last1);
; 3141 : 	_DEBUG_POINTER(_Pred);
; 3142 : 	return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
; 3143 : 		_Unchecked(_First2), _Pred);
; 3144 : 	}
; 3145 : 
; 3146 : 		// TEMPLATE FUNCTION is_permutation
; 3147 : template<class _FwdIt1,
; 3148 : 	class _FwdIt2> inline
; 3149 : 	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
; 3150 : 		_FwdIt2 _First2)
; 3151 : 	{	// test if [_First1, _Last1) == permuted [_First2, ...)
; 3152 : 	return (_STD is_permutation(_First1, _Last1,
; 3153 : 		_First2, equal_to<>()));
; 3154 : 	}
; 3155 : 
; 3156 : 		// TEMPLATE FUNCTION reverse
; 3157 : template<class _BidIt> inline
; 3158 : 	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
; 3159 : 	{	// reverse elements in [_First, _Last), bidirectional iterators
; 3160 : 	for (; _First != _Last && _First != --_Last; ++_First)
; 3161 : 		_STD iter_swap(_First, _Last);
; 3162 : 	}
; 3163 : 
; 3164 : template<class _BidIt> inline
; 3165 : 	void reverse(_BidIt _First, _BidIt _Last)
; 3166 : 	{	// reverse elements in [_First, _Last)
; 3167 : 	_DEBUG_RANGE(_First, _Last);
; 3168 : 	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 3169 : 	}
; 3170 : 
; 3171 : 		// TEMPLATE FUNCTION rotate
; 3172 : template<class _FwdIt> inline
; 3173 : 	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
; 3174 : 		forward_iterator_tag)
; 3175 : 	{	// rotate [_First, _Last), forward iterators
; 3176 : 	for (_FwdIt _Next = _Mid; ; )
; 3177 : 		{	// swap [_First, ...) into place
; 3178 : 		_STD iter_swap(_First, _Next);
; 3179 : 		if (++_First == _Mid)
; 3180 : 			if (++_Next == _Last)
; 3181 : 				break;	// done, quit
; 3182 : 			else
; 3183 : 				_Mid = _Next;	// mark end of next interval
; 3184 : 		else if (++_Next == _Last)
; 3185 : 			_Next = _Mid;	// wrap to last end
; 3186 : 		}
; 3187 : 	}
; 3188 : 
; 3189 : template<class _BidIt> inline
; 3190 : 	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
; 3191 : 		bidirectional_iterator_tag)
; 3192 : 	{	// rotate [_First, _Last), bidirectional iterators
; 3193 : 	_STD reverse(_First, _Mid);
; 3194 : 	_STD reverse(_Mid, _Last);
; 3195 : 	_STD reverse(_First, _Last);
; 3196 : 	}
; 3197 : 
; 3198 : template<class _RanIt,
; 3199 : 	class _Diff,
; 3200 : 	class _Ty> inline
; 3201 : 	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
; 3202 : 	{	// rotate [_First, _Last), random-access iterators
; 3203 : 	_Diff _Shift = _Mid - _First;
; 3204 : 	_Diff _Count = _Last - _First;
; 3205 : 
; 3206 : 	for (_Diff _Factor = _Shift; _Factor != 0; )
; 3207 : 		{	// find subcycle count as GCD of shift count and length
; 3208 : 		_Diff _Tmp = _Count % _Factor;
; 3209 : 		_Count = _Factor;
; 3210 : 		_Factor = _Tmp;
; 3211 : 		}
; 3212 : 
; 3213 : 	if (_Count < _Last - _First)
; 3214 : 		for (; 0 < _Count; --_Count)
; 3215 : 			{	// rotate each subcycle
; 3216 : 			_RanIt _Hole = _First + _Count;
; 3217 : 			_RanIt _Next = _Hole;
; 3218 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
; 3219 : 			for (; ; )
; 3220 : 				{	// percolate elements back around subcycle
; 3221 : 				iter_swap(_Next, _Next1);
; 3222 : 				_Next = _Next1;
; 3223 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 3224 : 					: _First + (_Shift - (_Last - _Next1));
; 3225 : 				if (_Next1 == _Hole)
; 3226 : 					break;
; 3227 : 				}
; 3228 : 			}
; 3229 : 	}
; 3230 : 
; 3231 : template<class _RanIt> inline
; 3232 : 	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
; 3233 : 		random_access_iterator_tag)
; 3234 : 	{	// rotate [_First, _Last), random-access iterators
; 3235 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00PAH0@Z ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>
  00023	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@rotate:

; 691  : 	}
; 692  : 
; 693  : template<class _InIt,
; 694  : 	class _Diff> inline
; 695  : 	void advance(_InIt& _Where, _Diff _Off)
; 696  : 	{	// increment iterator by offset, arbitrary iterators
; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}
; 699  : 
; 700  : 		// TEMPLATE FUNCTION _Dist_type
; 701  : 
; 702  : template<class _Iter> inline
; 703  : 	typename iterator_traits<_Iter>::difference_type
; 704  : 		*_Dist_type(_Iter)
; 705  : 	{	// return distance type from arbitrary argument
; 706  : 	return (0);
; 707  : 	}
; 708  : 
; 709  : 		// TEMPLATE FUNCTIONS distance and _Distance
; 710  : template<class _InIt,
; 711  : 	class _Diff> inline
; 712  : 		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
; 713  : 			input_iterator_tag)
; 714  : 	{	// add to _Off distance between input iterators
; 715  : 	for (; _First != _Last; ++_First)
; 716  : 		++_Off;
; 717  : 	}
; 718  : 
; 719  : template<class _FwdIt,
; 720  : 	class _Diff> inline
; 721  : 		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
; 722  : 			forward_iterator_tag)
; 723  : 	{	// add to _Off distance between forward iterators (redundant)
; 724  : 	for (; _First != _Last; ++_First)
; 725  : 		++_Off;
; 726  : 	}
; 727  : 
; 728  : template<class _BidIt,
; 729  : 	class _Diff> inline
; 730  : 		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
; 731  : 			bidirectional_iterator_tag)
; 732  : 	{	// add to _Off distance between bidirectional iterators (redundant)
; 733  : 	for (; _First != _Last; ++_First)
; 734  : 		++_Off;
; 735  : 	}
; 736  : 
; 737  : template<class _RanIt,
; 738  : 	class _Diff> inline
; 739  : 		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
; 740  : 			random_access_iterator_tag)
; 741  : 	{	// add to _Off distance between random-access iterators
; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

  00026	2b f7		 sub	 esi, edi

; 690  : 	_Where += _Off;

  00028	83 e6 f0	 and	 esi, -16		; fffffff0H
  0002b	5f		 pop	 edi
  0002c	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx

; 3244 : 		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
; 3245 : 			_Iter_cat(_First));
; 3246 : 	_STD advance(_First, _STD distance(_Mid, _Last));
; 3247 : 	return (_First);
; 3248 : 	}

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$rotate@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ENDP ; std::rotate<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z
_TEXT	SEGMENT
__Count2$1$ = -24					; size = 4
__Mid$1$ = -20						; size = 4
$T1 = -16						; size = 4
_rhsTerrainNumOrder$1$ = -16				; size = 4
__Val$1$ = -12						; size = 4
__Idx$1$ = -8						; size = 4
_blhsOrderFound$1$ = -1					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z PROC ; std::_Upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2553 : 	{	// find first element that _Val is before, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\algorithm

; 2553 : 	{	// find first element that _Val is before, using _Pred

  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	53		 push	 ebx
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	2b cb		 sub	 ecx, ebx
  0000f	c1 f9 04	 sar	 ecx, 4
  00012	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
; File a:\vs\vc\include\algorithm

; 2557 : 	while (0 < _Count)

  00015	85 c9		 test	 ecx, ecx
  00017	0f 8e 8a 02 00
	00		 jle	 $LN434@Upper_boun
  0001d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00020	56		 push	 esi
  00021	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00027	83 c0 04	 add	 eax, 4
  0002a	57		 push	 edi
  0002b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00031	89 45 f4	 mov	 DWORD PTR __Val$1$[ebp], eax
$LL4@Upper_boun:

; 2558 : 		{	// divide and conquer, find half that contains answer
; 2559 : 		_Diff _Count2 = _Count / 2;

  00034	8b c1		 mov	 eax, ecx
  00036	99		 cdq
  00037	2b c2		 sub	 eax, edx
  00039	d1 f8		 sar	 eax, 1
  0003b	89 45 e8	 mov	 DWORD PTR __Count2$1$[ebp], eax
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0003e	c1 e0 04	 shl	 eax, 4
  00041	03 c3		 add	 eax, ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 360  : 				DWORD lhsTerrainNumOrder = 0, rhsTerrainNumOrder = 0;

  00043	33 db		 xor	 ebx, ebx
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00045	89 45 ec	 mov	 DWORD PTR __Mid$1$[ebp], eax

; 2992 : 	return (_Val <= UCHAR_MAX);

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Val$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 361  : 				bool blhsOrderFound = false;

  0004b	88 5d ff	 mov	 BYTE PTR _blhsOrderFound$1$[ebp], bl
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  0004e	8a 00		 mov	 al, BYTE PTR [eax]
  00050	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  00052	76 05		 jbe	 SHORT $LN55@Upper_boun

; 3015 : 		return (_Last);

  00054	89 75 f0	 mov	 DWORD PTR $T1[ebp], esi
  00057	eb 28		 jmp	 SHORT $LN56@Upper_boun
$LN55@Upper_boun:

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  00059	0f b6 c8	 movzx	 ecx, al
  0005c	8b c6		 mov	 eax, esi
  0005e	2b c7		 sub	 eax, edi
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00060	50		 push	 eax
  00061	51		 push	 ecx
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  00068	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  00071	8b ce		 mov	 ecx, esi
  00073	85 c0		 test	 eax, eax
  00075	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  0007b	0f 45 c8	 cmovne	 ecx, eax
  0007e	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
$LN56@Upper_boun:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 365  : 				TTerrainNumVector::iterator rhsIterator = std::find(m_TerrainNumVector.begin(), m_TerrainNumVector.end(), rhs.byTerrainNum);

  00081	8b 45 ec	 mov	 eax, DWORD PTR __Mid$1$[ebp]
  00084	83 c0 04	 add	 eax, 4
  00087	89 45 f8	 mov	 DWORD PTR __Idx$1$[ebp], eax
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  0008a	8a 08		 mov	 cl, BYTE PTR [eax]
  0008c	80 f9 ff	 cmp	 cl, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  0008f	76 04		 jbe	 SHORT $LN96@Upper_boun

; 3015 : 		return (_Last);

  00091	8b ce		 mov	 ecx, esi
  00093	eb 28		 jmp	 SHORT $LN97@Upper_boun
$LN96@Upper_boun:

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  00095	8b c6		 mov	 eax, esi
  00097	0f b6 c9	 movzx	 ecx, cl
  0009a	2b c7		 sub	 eax, edi
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  0009c	50		 push	 eax
  0009d	51		 push	 ecx
  0009e	57		 push	 edi
  0009f	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  000a4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  000ad	85 c0		 test	 eax, eax
  000af	8b ce		 mov	 ecx, esi
  000b1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  000b7	0f 45 c8	 cmovne	 ecx, eax
  000ba	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1$[ebp]
$LN97@Upper_boun:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000bd	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
  000c0	3b d6		 cmp	 edx, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 367  : 				if (lhsIterator != m_TerrainNumVector.end())

  000c2	74 08		 je	 SHORT $LN24@Upper_boun
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000c4	8b da		 mov	 ebx, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 369  : 					blhsOrderFound = true;

  000c6	c6 45 ff 01	 mov	 BYTE PTR _blhsOrderFound$1$[ebp], 1
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000ca	2b df		 sub	 ebx, edi
$LN24@Upper_boun:

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000cc	3b ce		 cmp	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 372  : 				if (rhsIterator != m_TerrainNumVector.end())

  000ce	74 07		 je	 SHORT $LN430@Upper_boun
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000d0	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 377  : 				if (!brhsOrderFound)

  000d2	e9 e6 00 00 00	 jmp	 $LN441@Upper_boun
$LN430@Upper_boun:
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  000d7	3b c6		 cmp	 eax, esi
  000d9	73 6a		 jae	 SHORT $LN168@Upper_boun
  000db	3b f8		 cmp	 edi, eax
  000dd	77 66		 ja	 SHORT $LN168@Upper_boun

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  000df	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  000e5	2b c7		 sub	 eax, edi
  000e7	89 45 f8	 mov	 DWORD PTR __Idx$1$[ebp], eax

; 1247 : 			if (this->_Mylast == this->_Myend)

  000ea	3b f1		 cmp	 esi, ecx
  000ec	75 4e		 jne	 SHORT $LN180@Upper_boun

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  000ee	8b c1		 mov	 eax, ecx
  000f0	2b c6		 sub	 eax, esi

; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)

  000f2	83 f8 01	 cmp	 eax, 1
  000f5	73 42		 jae	 SHORT $LN437@Upper_boun

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  000f7	8b c7		 mov	 eax, edi
  000f9	2b c6		 sub	 eax, esi
  000fb	48		 dec	 eax
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	0f 82 a9 01 00
	00		 jb	 $LN445@Upper_boun

; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00105	2b cf		 sub	 ecx, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00107	83 c8 ff	 or	 eax, -1
  0010a	8b d1		 mov	 edx, ecx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0010c	2b f7		 sub	 esi, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0010e	d1 ea		 shr	 edx, 1

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00110	46		 inc	 esi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00111	2b c2		 sub	 eax, edx
  00113	3b c1		 cmp	 eax, ecx
  00115	73 04		 jae	 SHORT $LN205@Upper_boun
  00117	33 c9		 xor	 ecx, ecx
  00119	eb 02		 jmp	 SHORT $LN206@Upper_boun
$LN205@Upper_boun:
  0011b	03 ca		 add	 ecx, edx
$LN206@Upper_boun:

; 1576 : 		if (_Capacity < _Count)

  0011d	3b ce		 cmp	 ecx, esi
  0011f	0f 42 ce	 cmovb	 ecx, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00122	51		 push	 ecx
  00123	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00128	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
  0012d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00133	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN437@Upper_boun:
  00139	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1$[ebp]
$LN180@Upper_boun:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0013c	85 f6		 test	 esi, esi
  0013e	74 71		 je	 SHORT $LN294@Upper_boun
  00140	8a 04 38	 mov	 al, BYTE PTR [eax+edi]
; File a:\vs\vc\include\vector

; 1254 : 		else

  00143	eb 5e		 jmp	 SHORT $LN442@Upper_boun
$LN168@Upper_boun:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00145	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  0014b	3b f1		 cmp	 esi, ecx
  0014d	75 4e		 jne	 SHORT $LN241@Upper_boun

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  0014f	8b c1		 mov	 eax, ecx
  00151	2b c6		 sub	 eax, esi

; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)

  00153	83 f8 01	 cmp	 eax, 1
  00156	73 42		 jae	 SHORT $LN436@Upper_boun

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00158	8b c7		 mov	 eax, edi
  0015a	2b c6		 sub	 eax, esi
  0015c	48		 dec	 eax
  0015d	83 f8 01	 cmp	 eax, 1
  00160	0f 82 48 01 00
	00		 jb	 $LN445@Upper_boun

; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00166	2b cf		 sub	 ecx, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00168	83 c8 ff	 or	 eax, -1
  0016b	8b d1		 mov	 edx, ecx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0016d	2b f7		 sub	 esi, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0016f	d1 ea		 shr	 edx, 1

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00171	46		 inc	 esi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00172	2b c2		 sub	 eax, edx
  00174	3b c1		 cmp	 eax, ecx
  00176	73 04		 jae	 SHORT $LN266@Upper_boun
  00178	33 c9		 xor	 ecx, ecx
  0017a	eb 02		 jmp	 SHORT $LN267@Upper_boun
$LN266@Upper_boun:
  0017c	03 ca		 add	 ecx, edx
$LN267@Upper_boun:

; 1576 : 		if (_Capacity < _Count)

  0017e	3b ce		 cmp	 ecx, esi
  00180	0f 42 ce	 cmovb	 ecx, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00183	51		 push	 ecx
  00184	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00189	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
  0018e	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00194	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN436@Upper_boun:
  0019a	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1$[ebp]
$LN241@Upper_boun:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0019d	85 f6		 test	 esi, esi
  0019f	74 10		 je	 SHORT $LN294@Upper_boun
  001a1	8a 00		 mov	 al, BYTE PTR [eax]
$LN442@Upper_boun:
  001a3	88 06		 mov	 BYTE PTR [esi], al
  001a5	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  001ab	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN294@Upper_boun:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  001b1	46		 inc	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 380  : 					rhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  001b2	8b ce		 mov	 ecx, esi
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  001b4	89 35 04 00 00
	00		 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 380  : 					rhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  001ba	2b cf		 sub	 ecx, edi
  001bc	49		 dec	 ecx
$LN441@Upper_boun:

; 381  : 				}
; 382  : 				if (!blhsOrderFound)

  001bd	80 7d ff 00	 cmp	 BYTE PTR _blhsOrderFound$1$[ebp], 0
  001c1	89 4d f0	 mov	 DWORD PTR _rhsTerrainNumOrder$1$[ebp], ecx
  001c4	0f 85 af 00 00
	00		 jne	 $LN19@Upper_boun
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  001ca	8b 45 f4	 mov	 eax, DWORD PTR __Val$1$[ebp]
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  001cd	8b de		 mov	 ebx, esi
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  001cf	8a 00		 mov	 al, BYTE PTR [eax]
  001d1	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  001d3	77 29		 ja	 SHORT $LN432@Upper_boun

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  001d5	2b f7		 sub	 esi, edi
  001d7	0f b6 c0	 movzx	 eax, al
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  001da	56		 push	 esi
  001db	50		 push	 eax
  001dc	57		 push	 edi
  001dd	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  001e2	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  001eb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  001f1	85 c0		 test	 eax, eax
  001f3	0f 45 d8	 cmovne	 ebx, eax
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  001f6	3b de		 cmp	 ebx, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 385  : 					if (lhsIterator != m_TerrainNumVector.end())

  001f8	74 04		 je	 SHORT $LN432@Upper_boun
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  001fa	2b df		 sub	 ebx, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 390  : 					if (!blhsOrderFound)

  001fc	eb 7b		 jmp	 SHORT $LN19@Upper_boun
$LN432@Upper_boun:
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  001fe	8b 45 f4	 mov	 eax, DWORD PTR __Val$1$[ebp]
  00201	3b c6		 cmp	 eax, esi
  00203	73 31		 jae	 SHORT $LN373@Upper_boun
  00205	3b f8		 cmp	 edi, eax
  00207	77 2d		 ja	 SHORT $LN373@Upper_boun

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00209	8b d8		 mov	 ebx, eax
  0020b	2b df		 sub	 ebx, edi

; 1247 : 			if (this->_Mylast == this->_Myend)

  0020d	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  00213	75 18		 jne	 SHORT $LN372@Upper_boun

; 1248 : 				_Reserve(1);

  00215	6a 01		 push	 1
  00217	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  0021c	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
  00221	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00227	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN372@Upper_boun:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0022d	85 f6		 test	 esi, esi
  0022f	74 3c		 je	 SHORT $LN418@Upper_boun
  00231	8a 04 3b	 mov	 al, BYTE PTR [ebx+edi]
; File a:\vs\vc\include\vector

; 1254 : 		else

  00234	eb 29		 jmp	 SHORT $LN443@Upper_boun
$LN373@Upper_boun:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00236	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  0023c	75 1b		 jne	 SHORT $LN370@Upper_boun

; 1257 : 				_Reserve(1);

  0023e	6a 01		 push	 1
  00240	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00245	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
  0024a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00250	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00256	8b 45 f4	 mov	 eax, DWORD PTR __Val$1$[ebp]
$LN370@Upper_boun:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00259	85 f6		 test	 esi, esi
  0025b	74 10		 je	 SHORT $LN418@Upper_boun
  0025d	8a 00		 mov	 al, BYTE PTR [eax]
$LN443@Upper_boun:
  0025f	88 06		 mov	 BYTE PTR [esi], al
  00261	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00267	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN418@Upper_boun:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0026d	46		 inc	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 393  : 						lhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  0026e	8b de		 mov	 ebx, esi
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00270	89 35 04 00 00
	00		 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 393  : 						lhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  00276	2b df		 sub	 ebx, edi
  00278	4b		 dec	 ebx
$LN19@Upper_boun:

; 394  : 					}
; 395  : 				}
; 396  : 
; 397  : 				return lhsTerrainNumOrder < rhsTerrainNumOrder;

  00279	3b 5d f0	 cmp	 ebx, DWORD PTR _rhsTerrainNumOrder$1$[ebp]
; File a:\vs\vc\include\algorithm

; 2563 : 		if (!_Pred(_Val, *_Mid))

  0027c	72 16		 jb	 SHORT $LN2@Upper_boun

; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;

  0027e	8b 5d ec	 mov	 ebx, DWORD PTR __Mid$1$[ebp]

; 2567 : 			_Count -= _Count2 + 1;

  00281	83 c8 ff	 or	 eax, -1
  00284	2b 45 e8	 sub	 eax, DWORD PTR __Count2$1$[ebp]
  00287	83 c3 10	 add	 ebx, 16			; 00000010H
  0028a	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0028d	89 5d 08	 mov	 DWORD PTR __First$[ebp], ebx
  00290	03 c8		 add	 ecx, eax

; 2568 : 			}
; 2569 : 		else

  00292	eb 06		 jmp	 SHORT $LN444@Upper_boun
$LN2@Upper_boun:

; 2570 : 			_Count = _Count2;

  00294	8b 4d e8	 mov	 ecx, DWORD PTR __Count2$1$[ebp]
  00297	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
$LN444@Upper_boun:
  0029a	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  0029d	85 c9		 test	 ecx, ecx
  0029f	0f 8f 8f fd ff
	ff		 jg	 $LL4@Upper_boun
  002a5	5f		 pop	 edi
  002a6	5e		 pop	 esi
$LN434@Upper_boun:

; 2571 : 		}
; 2572 : 	return (_First);

  002a7	8b c3		 mov	 eax, ebx
  002a9	5b		 pop	 ebx

; 2573 : 	}

  002aa	8b e5		 mov	 esp, ebp
  002ac	5d		 pop	 ebp
  002ad	c3		 ret	 0
$LN445@Upper_boun:
; File a:\vs\vc\include\vector

; 1754 : 		_Xlength_error("vector<T> too long");

  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  002b3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN446@Upper_boun:
$LN440@Upper_boun:
  002b8	cc		 int	 3
??$_Upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ENDP ; std::_Upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z
_TEXT	SEGMENT
__Mid$1$ = -24						; size = 4
__Count2$1$ = -20					; size = 4
__Idx$1$ = -16						; size = 4
$T1 = -16						; size = 4
_rhsTerrainNumOrder$1$ = -16				; size = 4
__Val$1$ = -12						; size = 4
__Idx$1$ = -8						; size = 4
_blhsOrderFound$1$ = -1					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z PROC ; std::_Lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2504 : 	{	// find first element not before _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\algorithm

; 2504 : 	{	// find first element not before _Val, using _Pred

  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	53		 push	 ebx
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	2b cb		 sub	 ecx, ebx
  0000f	c1 f9 04	 sar	 ecx, 4
  00012	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
; File a:\vs\vc\include\algorithm

; 2508 : 	while (0 < _Count)

  00015	85 c9		 test	 ecx, ecx
  00017	0f 8e 8d 02 00
	00		 jle	 $LN434@Lower_boun
  0001d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00020	56		 push	 esi
  00021	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00027	83 c0 04	 add	 eax, 4
  0002a	57		 push	 edi
  0002b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00031	89 45 f4	 mov	 DWORD PTR __Val$1$[ebp], eax
$LL4@Lower_boun:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

  00034	8b c1		 mov	 eax, ecx
  00036	99		 cdq
  00037	2b c2		 sub	 eax, edx
  00039	d1 f8		 sar	 eax, 1
  0003b	89 45 ec	 mov	 DWORD PTR __Count2$1$[ebp], eax
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0003e	c1 e0 04	 shl	 eax, 4
  00041	03 c3		 add	 eax, ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 360  : 				DWORD lhsTerrainNumOrder = 0, rhsTerrainNumOrder = 0;

  00043	33 db		 xor	 ebx, ebx
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00045	89 45 e8	 mov	 DWORD PTR __Mid$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 364  : 				TTerrainNumVector::iterator lhsIterator = std::find(m_TerrainNumVector.begin(), m_TerrainNumVector.end(), lhs.byTerrainNum);

  00048	83 c0 04	 add	 eax, 4
  0004b	89 45 f8	 mov	 DWORD PTR __Idx$1$[ebp], eax
  0004e	88 5d ff	 mov	 BYTE PTR _blhsOrderFound$1$[ebp], bl
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  00051	8a 00		 mov	 al, BYTE PTR [eax]
  00053	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  00055	76 05		 jbe	 SHORT $LN55@Lower_boun

; 3015 : 		return (_Last);

  00057	89 75 f0	 mov	 DWORD PTR $T1[ebp], esi
  0005a	eb 28		 jmp	 SHORT $LN56@Lower_boun
$LN55@Lower_boun:

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  0005c	0f b6 c8	 movzx	 ecx, al
  0005f	8b c6		 mov	 eax, esi
  00061	2b c7		 sub	 eax, edi
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00063	50		 push	 eax
  00064	51		 push	 ecx
  00065	57		 push	 edi
  00066	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  0006b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  00074	8b ce		 mov	 ecx, esi
  00076	85 c0		 test	 eax, eax
  00078	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  0007e	0f 45 c8	 cmovne	 ecx, eax
  00081	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
$LN56@Lower_boun:

; 2992 : 	return (_Val <= UCHAR_MAX);

  00084	8b 55 f4	 mov	 edx, DWORD PTR __Val$1$[ebp]
  00087	8a 02		 mov	 al, BYTE PTR [edx]
  00089	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  0008b	76 04		 jbe	 SHORT $LN96@Lower_boun

; 3015 : 		return (_Last);

  0008d	8b ce		 mov	 ecx, esi
  0008f	eb 28		 jmp	 SHORT $LN97@Lower_boun
$LN96@Lower_boun:

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  00091	0f b6 c8	 movzx	 ecx, al
  00094	8b c6		 mov	 eax, esi
  00096	2b c7		 sub	 eax, edi
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00098	50		 push	 eax
  00099	51		 push	 ecx
  0009a	57		 push	 edi
  0009b	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  000a0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	8b 55 f4	 mov	 edx, DWORD PTR __Val$1$[ebp]
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  000ac	8b ce		 mov	 ecx, esi
  000ae	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  000b4	85 c0		 test	 eax, eax
  000b6	0f 45 c8	 cmovne	 ecx, eax
$LN97@Lower_boun:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000b9	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  000bc	3b c6		 cmp	 eax, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 367  : 				if (lhsIterator != m_TerrainNumVector.end())

  000be	74 08		 je	 SHORT $LN24@Lower_boun
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000c0	8b d8		 mov	 ebx, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 369  : 					blhsOrderFound = true;

  000c2	c6 45 ff 01	 mov	 BYTE PTR _blhsOrderFound$1$[ebp], 1
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000c6	2b df		 sub	 ebx, edi
$LN24@Lower_boun:

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000c8	3b ce		 cmp	 ecx, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 372  : 				if (rhsIterator != m_TerrainNumVector.end())

  000ca	74 07		 je	 SHORT $LN430@Lower_boun
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000cc	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 377  : 				if (!brhsOrderFound)

  000ce	e9 e8 00 00 00	 jmp	 $LN440@Lower_boun
$LN430@Lower_boun:
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  000d3	3b d6		 cmp	 edx, esi
  000d5	73 6c		 jae	 SHORT $LN168@Lower_boun
  000d7	3b fa		 cmp	 edi, edx
  000d9	77 68		 ja	 SHORT $LN168@Lower_boun

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  000db	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  000e1	8b c2		 mov	 eax, edx
  000e3	2b c7		 sub	 eax, edi
  000e5	89 45 f0	 mov	 DWORD PTR __Idx$1$[ebp], eax

; 1247 : 			if (this->_Mylast == this->_Myend)

  000e8	3b f1		 cmp	 esi, ecx
  000ea	75 4e		 jne	 SHORT $LN180@Lower_boun

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  000ec	8b c1		 mov	 eax, ecx
  000ee	2b c6		 sub	 eax, esi

; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)

  000f0	83 f8 01	 cmp	 eax, 1
  000f3	73 42		 jae	 SHORT $LN436@Lower_boun

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  000f5	8b c7		 mov	 eax, edi
  000f7	2b c6		 sub	 eax, esi
  000f9	48		 dec	 eax
  000fa	83 f8 01	 cmp	 eax, 1
  000fd	0f 82 ae 01 00
	00		 jb	 $LN444@Lower_boun

; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00103	2b cf		 sub	 ecx, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00105	83 c8 ff	 or	 eax, -1
  00108	8b d1		 mov	 edx, ecx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0010a	2b f7		 sub	 esi, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0010c	d1 ea		 shr	 edx, 1

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0010e	46		 inc	 esi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0010f	2b c2		 sub	 eax, edx
  00111	3b c1		 cmp	 eax, ecx
  00113	73 04		 jae	 SHORT $LN205@Lower_boun
  00115	33 c9		 xor	 ecx, ecx
  00117	eb 02		 jmp	 SHORT $LN206@Lower_boun
$LN205@Lower_boun:
  00119	03 ca		 add	 ecx, edx
$LN206@Lower_boun:

; 1576 : 		if (_Capacity < _Count)

  0011b	3b ce		 cmp	 ecx, esi
  0011d	0f 42 ce	 cmovb	 ecx, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00120	51		 push	 ecx
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00126	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
  0012b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00131	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN436@Lower_boun:
  00137	8b 45 f0	 mov	 eax, DWORD PTR __Idx$1$[ebp]
$LN180@Lower_boun:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0013a	85 f6		 test	 esi, esi
  0013c	74 71		 je	 SHORT $LN294@Lower_boun
  0013e	8a 04 38	 mov	 al, BYTE PTR [eax+edi]
; File a:\vs\vc\include\vector

; 1254 : 		else

  00141	eb 5e		 jmp	 SHORT $LN441@Lower_boun
$LN168@Lower_boun:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00143	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  00149	3b f1		 cmp	 esi, ecx
  0014b	75 4e		 jne	 SHORT $LN241@Lower_boun

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  0014d	8b c1		 mov	 eax, ecx
  0014f	2b c6		 sub	 eax, esi

; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)

  00151	83 f8 01	 cmp	 eax, 1
  00154	73 45		 jae	 SHORT $LN241@Lower_boun

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00156	8b c7		 mov	 eax, edi
  00158	2b c6		 sub	 eax, esi
  0015a	48		 dec	 eax
  0015b	83 f8 01	 cmp	 eax, 1
  0015e	0f 82 4d 01 00
	00		 jb	 $LN444@Lower_boun

; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00164	2b cf		 sub	 ecx, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00166	83 c8 ff	 or	 eax, -1
  00169	8b d1		 mov	 edx, ecx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0016b	2b f7		 sub	 esi, edi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0016d	d1 ea		 shr	 edx, 1

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0016f	46		 inc	 esi

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00170	2b c2		 sub	 eax, edx
  00172	3b c1		 cmp	 eax, ecx
  00174	73 04		 jae	 SHORT $LN266@Lower_boun
  00176	33 c9		 xor	 ecx, ecx
  00178	eb 02		 jmp	 SHORT $LN267@Lower_boun
$LN266@Lower_boun:
  0017a	03 ca		 add	 ecx, edx
$LN267@Lower_boun:

; 1576 : 		if (_Capacity < _Count)

  0017c	3b ce		 cmp	 ecx, esi
  0017e	0f 42 ce	 cmovb	 ecx, esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00181	51		 push	 ecx
  00182	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00187	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
  0018c	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00192	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00198	8b 55 f4	 mov	 edx, DWORD PTR __Val$1$[ebp]
$LN241@Lower_boun:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0019b	85 f6		 test	 esi, esi
  0019d	74 10		 je	 SHORT $LN294@Lower_boun
  0019f	8a 02		 mov	 al, BYTE PTR [edx]
$LN441@Lower_boun:
  001a1	88 06		 mov	 BYTE PTR [esi], al
  001a3	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  001a9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN294@Lower_boun:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  001af	46		 inc	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 380  : 					rhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  001b0	8b ce		 mov	 ecx, esi
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  001b2	89 35 04 00 00
	00		 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 380  : 					rhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  001b8	2b cf		 sub	 ecx, edi
  001ba	49		 dec	 ecx
$LN440@Lower_boun:

; 381  : 				}
; 382  : 				if (!blhsOrderFound)

  001bb	80 7d ff 00	 cmp	 BYTE PTR _blhsOrderFound$1$[ebp], 0
  001bf	89 4d f0	 mov	 DWORD PTR _rhsTerrainNumOrder$1$[ebp], ecx
  001c2	0f 85 b4 00 00
	00		 jne	 $LN19@Lower_boun
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  001c8	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1$[ebp]
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  001cb	8b de		 mov	 ebx, esi
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  001cd	8a 08		 mov	 cl, BYTE PTR [eax]
  001cf	80 f9 ff	 cmp	 cl, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  001d2	77 2c		 ja	 SHORT $LN432@Lower_boun

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  001d4	2b f7		 sub	 esi, edi
  001d6	0f b6 c1	 movzx	 eax, cl
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  001d9	56		 push	 esi
  001da	50		 push	 eax
  001db	57		 push	 edi
  001dc	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  001e1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  001ea	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  001f0	85 c0		 test	 eax, eax
  001f2	0f 45 d8	 cmovne	 ebx, eax
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  001f5	3b de		 cmp	 ebx, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 385  : 					if (lhsIterator != m_TerrainNumVector.end())

  001f7	74 04		 je	 SHORT $LN435@Lower_boun
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  001f9	2b df		 sub	 ebx, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 390  : 					if (!blhsOrderFound)

  001fb	eb 7f		 jmp	 SHORT $LN19@Lower_boun
$LN435@Lower_boun:
  001fd	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1$[ebp]
$LN432@Lower_boun:
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00200	3b c6		 cmp	 eax, esi
  00202	73 35		 jae	 SHORT $LN373@Lower_boun
  00204	3b f8		 cmp	 edi, eax
  00206	77 31		 ja	 SHORT $LN373@Lower_boun

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00208	2b c7		 sub	 eax, edi
  0020a	89 45 f8	 mov	 DWORD PTR __Idx$1$[ebp], eax

; 1247 : 			if (this->_Mylast == this->_Myend)

  0020d	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  00213	75 1b		 jne	 SHORT $LN372@Lower_boun

; 1248 : 				_Reserve(1);

  00215	6a 01		 push	 1
  00217	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  0021c	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
  00221	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00227	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  0022d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1$[ebp]
$LN372@Lower_boun:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00230	85 f6		 test	 esi, esi
  00232	74 3c		 je	 SHORT $LN418@Lower_boun
  00234	8a 04 38	 mov	 al, BYTE PTR [eax+edi]
; File a:\vs\vc\include\vector

; 1254 : 		else

  00237	eb 29		 jmp	 SHORT $LN442@Lower_boun
$LN373@Lower_boun:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00239	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8
  0023f	75 1b		 jne	 SHORT $LN370@Lower_boun

; 1257 : 				_Reserve(1);

  00241	6a 01		 push	 1
  00243	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00248	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
  0024d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00253	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00259	8b 45 f8	 mov	 eax, DWORD PTR __Idx$1$[ebp]
$LN370@Lower_boun:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0025c	85 f6		 test	 esi, esi
  0025e	74 10		 je	 SHORT $LN418@Lower_boun
  00260	8a 00		 mov	 al, BYTE PTR [eax]
$LN442@Lower_boun:
  00262	88 06		 mov	 BYTE PTR [esi], al
  00264	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  0026a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
$LN418@Lower_boun:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00270	46		 inc	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 393  : 						lhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  00271	8b de		 mov	 ebx, esi
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00273	89 35 04 00 00
	00		 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 393  : 						lhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  00279	2b df		 sub	 ebx, edi
  0027b	4b		 dec	 ebx
$LN19@Lower_boun:

; 394  : 					}
; 395  : 				}
; 396  : 
; 397  : 				return lhsTerrainNumOrder < rhsTerrainNumOrder;

  0027c	3b 5d f0	 cmp	 ebx, DWORD PTR _rhsTerrainNumOrder$1$[ebp]
; File a:\vs\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

  0027f	73 16		 jae	 SHORT $LN2@Lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;

  00281	8b 5d e8	 mov	 ebx, DWORD PTR __Mid$1$[ebp]

; 2518 : 			_Count -= _Count2 + 1;

  00284	83 c8 ff	 or	 eax, -1
  00287	2b 45 ec	 sub	 eax, DWORD PTR __Count2$1$[ebp]
  0028a	83 c3 10	 add	 ebx, 16			; 00000010H
  0028d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00290	89 5d 08	 mov	 DWORD PTR __First$[ebp], ebx
  00293	03 c8		 add	 ecx, eax

; 2519 : 			}
; 2520 : 		else

  00295	eb 06		 jmp	 SHORT $LN443@Lower_boun
$LN2@Lower_boun:

; 2521 : 			_Count = _Count2;

  00297	8b 4d ec	 mov	 ecx, DWORD PTR __Count2$1$[ebp]
  0029a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
$LN443@Lower_boun:
  0029d	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  002a0	85 c9		 test	 ecx, ecx
  002a2	0f 8f 8c fd ff
	ff		 jg	 $LL4@Lower_boun
  002a8	5f		 pop	 edi
  002a9	5e		 pop	 esi
$LN434@Lower_boun:

; 2522 : 		}
; 2523 : 	return (_First);

  002aa	8b c3		 mov	 eax, ebx
  002ac	5b		 pop	 ebx

; 2524 : 	}

  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c3		 ret	 0
$LN444@Lower_boun:
; File a:\vs\vc\include\vector

; 1754 : 		_Xlength_error("vector<T> too long");

  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  002b6	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN445@Lower_boun:
$LN439@Lower_boun:
  002bb	cc		 int	 3
??$_Lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ENDP ; std::_Lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAHPAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAHPAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::_Dist_type<CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAHPAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::_Dist_type<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >, COMDAT

; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	3b d6		 cmp	 edx, esi
  00014	74 3f		 je	 SHORT $LN1@Move
$LL3@Move:
; File a:\vs\vc\include\xmemory

; 797  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

  00016	8b 4d 24	 mov	 ecx, DWORD PTR __Dest$[ebp+16]
  00019	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0001c	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0001f	73 11		 jae	 SHORT $LN16@Move

; 798  : 			*_Pbuf->_Current++ =
; 799  : 				_STD forward<_Ty>(_Val);	// below high water mark, move

  00021	f3 0f 6f 02	 movdqu	 xmm0, XMMWORD PTR [edx]
  00025	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00029	8b 45 24	 mov	 eax, DWORD PTR __Dest$[ebp+16]
  0002c	83 40 04 10	 add	 DWORD PTR [eax+4], 16	; 00000010H

; 800  : 		else

  00030	eb 1c		 jmp	 SHORT $LN2@Move
$LN16@Move:
; File a:\vs\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00032	85 c0		 test	 eax, eax
  00034	74 0b		 je	 SHORT $LN25@Move
  00036	f3 0f 6f 02	 movdqu	 xmm0, XMMWORD PTR [edx]
  0003a	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0003e	8b 4d 24	 mov	 ecx, DWORD PTR __Dest$[ebp+16]
$LN25@Move:
; File a:\vs\vc\include\xmemory

; 804  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

  00041	83 41 04 10	 add	 DWORD PTR [ecx+4], 16	; 00000010H
  00045	8b 45 24	 mov	 eax, DWORD PTR __Dest$[ebp+16]
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN2@Move:
; File a:\vs\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  0004e	83 c2 10	 add	 edx, 16			; 00000010H
  00051	3b d6		 cmp	 edx, esi
  00053	75 c1		 jne	 SHORT $LL3@Move
$LN1@Move:
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  00055	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 762  : 		*this = _Right;
; 763  : 		}
; 764  : 
; 765  : 	~_Temp_iterator() _NOEXCEPT
; 766  : 		{	// destroy the object
; 767  : 		if (_Buf._Begin != 0)

  00058	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]

; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
; 777  : 		{	// assign _Right (share active buffer)
; 778  : 		_Pbuf = _Right._Pbuf;

  0005b	8b 4d 24	 mov	 ecx, DWORD PTR __Dest$[ebp+16]

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  0005e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 759  : 		_Buf._Current = 0;

  00064	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 760  : 		_Buf._Hiwater = 0;

  0006b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 761  : 		_Buf._Size = 0;

  00072	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
; 777  : 		{	// assign _Right (share active buffer)
; 778  : 		_Pbuf = _Right._Pbuf;

  00079	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 762  : 		*this = _Right;
; 763  : 		}
; 764  : 
; 765  : 	~_Temp_iterator() _NOEXCEPT
; 766  : 		{	// destroy the object
; 767  : 		if (_Buf._Begin != 0)

  0007c	85 c0		 test	 eax, eax
  0007e	74 09		 je	 SHORT $LN53@Move

; 41   : 	operator delete(_Pbuf);

  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00086	83 c4 04	 add	 esp, 4
$LN53@Move:
; File a:\vs\vc\include\xutility

; 2421 : 	return (_Dest);

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi

; 2422 : 	}

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTPatchDrawStruct@CMapOutdoor@@AAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTPatchDrawStruct@CMapOutdoor@@AAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z PROC ; std::_Ptr_cat<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >, COMDAT

; 414  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 415  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 416  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 417  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTPatchDrawStruct@CMapOutdoor@@AAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ENDP ; std::_Ptr_cat<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXAAUTPatchDrawStruct@CMapOutdoor@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXAAUTPatchDrawStruct@CMapOutdoor@@0@Z PROC ; std::swap<CMapOutdoor::TPatchDrawStruct>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);
; 53   : 	_Left = _Move(_Right);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  0000d	f3 0f 6f 09	 movdqu	 xmm1, XMMWORD PTR [ecx]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0

; 54   : 	_Right = _Move(_Tmp);

  00015	f3 0f 7f 08	 movdqu	 XMMWORD PTR [eax], xmm1

; 55   : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$swap@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXAAUTPatchDrawStruct@CMapOutdoor@@0@Z ENDP ; std::swap<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z PROC ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 12		 je	 SHORT $LN5@Move
$LL7@Move:

; 2420 : 		*_Dest = _STD move(*_First);

  00010	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  00014	83 c1 10	 add	 ecx, 16			; 00000010H
  00017	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0001b	83 c0 10	 add	 eax, 16			; 00000010H
  0001e	3b ca		 cmp	 ecx, edx
  00020	75 ee		 jne	 SHORT $LL7@Move
$LN5@Move:

; 2442 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ENDP ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 20
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z PROC ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2881 : 	{	// move merging ranges, both using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 2882 : 	if (_First1 != _Last1 && _First2 != _Last2)

  0002f	8b 7d 0c	 mov	 edi, DWORD PTR __First1$[ebp]
  00032	8b 5d 18	 mov	 ebx, DWORD PTR __Last2$[ebp]
  00035	8b 75 14	 mov	 esi, DWORD PTR __First2$[ebp]
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	3b 7d 10	 cmp	 edi, DWORD PTR __Last1$[ebp]
  00042	0f 84 98 00 00
	00		 je	 $LN93@Merge
  00048	3b f3		 cmp	 esi, ebx
  0004a	0f 84 90 00 00
	00		 je	 $LN93@Merge
$LL6@Merge:

; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

  00050	57		 push	 edi
  00051	56		 push	 esi
  00052	8d 4d 30	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00055	e8 00 00 00 00	 call	 ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
; File a:\vs\vc\include\xmemory

; 797  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

  0005a	8b 4d 2c	 mov	 ecx, DWORD PTR __Dest$[ebp+16]
; File a:\vs\vc\include\algorithm

; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

  0005d	84 c0		 test	 al, al
; File a:\vs\vc\include\xmemory

; 797  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File a:\vs\vc\include\algorithm

; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

  00062	74 3e		 je	 SHORT $LN4@Merge
; File a:\vs\vc\include\xmemory

; 797  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

  00064	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00067	73 16		 jae	 SHORT $LN23@Merge

; 799  : 				_STD forward<_Ty>(_Val);	// below high water mark, move

  00069	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
; File a:\vs\vc\include\algorithm

; 2887 : 				*_Dest++ = _Move(*_First2++);

  0006d	83 c6 10	 add	 esi, 16			; 00000010H
; File a:\vs\vc\include\xmemory

; 799  : 				_STD forward<_Ty>(_Val);	// below high water mark, move

  00070	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  00074	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+16]
  00077	83 40 04 10	 add	 DWORD PTR [eax+4], 16	; 00000010H
; File a:\vs\vc\include\algorithm

; 2888 : 				if (_First2 == _Last2)

  0007b	3b f3		 cmp	 esi, ebx

; 2891 : 			else

  0007d	eb 5b		 jmp	 SHORT $LN106@Merge
$LN23@Merge:
; File a:\vs\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  0007f	85 c0		 test	 eax, eax
  00081	74 0b		 je	 SHORT $LN32@Merge
  00083	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
  00087	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0008b	8b 4d 2c	 mov	 ecx, DWORD PTR __Dest$[ebp+16]
$LN32@Merge:
; File a:\vs\vc\include\xmemory

; 804  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

  0008e	83 41 04 10	 add	 DWORD PTR [ecx+4], 16	; 00000010H
; File a:\vs\vc\include\algorithm

; 2887 : 				*_Dest++ = _Move(*_First2++);

  00092	83 c6 10	 add	 esi, 16			; 00000010H
; File a:\vs\vc\include\xmemory

; 804  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

  00095	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+16]
; File a:\vs\vc\include\algorithm

; 2888 : 				if (_First2 == _Last2)

  00098	3b f3		 cmp	 esi, ebx
; File a:\vs\vc\include\xmemory

; 804  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

  0009a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File a:\vs\vc\include\algorithm

; 2891 : 			else

  000a0	eb 38		 jmp	 SHORT $LN106@Merge
$LN4@Merge:
; File a:\vs\vc\include\xmemory

; 797  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

  000a2	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000a5	73 11		 jae	 SHORT $LN45@Merge

; 799  : 				_STD forward<_Ty>(_Val);	// below high water mark, move

  000a7	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]
  000ab	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  000af	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+16]
  000b2	83 40 04 10	 add	 DWORD PTR [eax+4], 16	; 00000010H

; 800  : 		else

  000b6	eb 1c		 jmp	 SHORT $LN44@Merge
$LN45@Merge:
; File a:\vs\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  000b8	85 c0		 test	 eax, eax
  000ba	74 0b		 je	 SHORT $LN54@Merge
  000bc	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]
  000c0	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  000c4	8b 4d 2c	 mov	 ecx, DWORD PTR __Dest$[ebp+16]
$LN54@Merge:
; File a:\vs\vc\include\xmemory

; 804  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

  000c7	83 41 04 10	 add	 DWORD PTR [ecx+4], 16	; 00000010H
  000cb	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+16]
  000ce	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000d1	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN44@Merge:
; File a:\vs\vc\include\algorithm

; 2893 : 				*_Dest++ = _Move(*_First1++);

  000d4	83 c7 10	 add	 edi, 16			; 00000010H

; 2894 : 				if (_First1 == _Last1)

  000d7	3b 7d 10	 cmp	 edi, DWORD PTR __Last1$[ebp]
$LN106@Merge:
  000da	0f 85 70 ff ff
	ff		 jne	 $LL6@Merge
$LN93@Merge:

; 2899 : 	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail

  000e0	83 ec 14	 sub	 esp, 20			; 00000014H
  000e3	8b cc		 mov	 ecx, esp
  000e5	ff 75 10	 push	 DWORD PTR __Last1$[ebp]
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  000e8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 759  : 		_Buf._Current = 0;

  000ee	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  000f5	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  000fc	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 778  : 		_Pbuf = _Right._Pbuf;

  00103	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+16]
  00106	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 2899 : 	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail

  00109	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  0010c	57		 push	 edi
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
  00113	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\xmemory

; 778  : 		_Pbuf = _Right._Pbuf;

  00116	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00119	89 45 2c	 mov	 DWORD PTR __Dest$[ebp+16], eax

; 767  : 		if (_Buf._Begin != 0)

  0011c	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  0011f	85 c0		 test	 eax, eax
  00121	74 09		 je	 SHORT $LN74@Merge

; 41   : 	operator delete(_Pbuf);

  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00129	83 c4 04	 add	 esp, 4
$LN74@Merge:
; File a:\vs\vc\include\algorithm

; 2900 : 	return (_Move(_First2, _Last2, _Dest));

  0012c	83 ec 14	 sub	 esp, 20			; 00000014H
  0012f	8b cc		 mov	 ecx, esp
  00131	53		 push	 ebx
  00132	56		 push	 esi
  00133	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  00136	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 759  : 		_Buf._Current = 0;

  0013c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  00143	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  0014a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 778  : 		_Pbuf = _Right._Pbuf;

  00151	8b 45 2c	 mov	 eax, DWORD PTR __Dest$[ebp+16]
; File a:\vs\vc\include\algorithm

; 2900 : 	return (_Move(_First2, _Last2, _Dest));

  00154	56		 push	 esi
; File a:\vs\vc\include\xmemory

; 778  : 		_Pbuf = _Right._Pbuf;

  00155	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 2900 : 	return (_Move(_First2, _Last2, _Dest));

  00158	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  0015d	8b 45 1c	 mov	 eax, DWORD PTR __Dest$[ebp]
; File a:\vs\vc\include\algorithm

; 2900 : 	return (_Move(_First2, _Last2, _Dest));

  00160	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  00163	85 c0		 test	 eax, eax
  00165	74 09		 je	 SHORT $LN103@Merge

; 41   : 	operator delete(_Pbuf);

  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0016d	83 c4 04	 add	 esp, 4
$LN103@Merge:
; File a:\vs\vc\include\algorithm

; 2900 : 	return (_Move(_First2, _Last2, _Dest));

  00170	8b c6		 mov	 eax, esi

; 2901 : 	}

  00172	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00175	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017c	59		 pop	 ecx
  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z$0:
  00000	8d 4d 1c	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::~_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
__ehhandler$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z ENDP ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z PROC ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]

; 2526 : 	while (_First != _Last)

  00006	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2526 : 	while (_First != _Last)

  0000c	3b d1		 cmp	 edx, ecx
  0000e	74 13		 je	 SHORT $LN5@Move_backw
$LL6@Move_backw:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00010	f3 0f 6f 41 f0	 movdqu	 xmm0, XMMWORD PTR [ecx-16]
  00015	83 e9 10	 sub	 ecx, 16			; 00000010H
  00018	83 e8 10	 sub	 eax, 16			; 00000010H
  0001b	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0001f	3b ca		 cmp	 ecx, edx
  00021	75 ed		 jne	 SHORT $LL6@Move_backw
$LN5@Move_backw:

; 2549 : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ENDP ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z PROC ; std::_Move<CMapOutdoor::TPatchDrawStruct &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YA$$QAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ENDP ; std::_Move<CMapOutdoor::TPatchDrawStruct &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<CGraphicThingInstance * *,CGraphicThingInstance * *>, COMDAT

; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2536 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi

; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000d	2b c8		 sub	 ecx, eax
  0000f	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00012	51		 push	 ecx
  00013	2b f1		 sub	 esi, ecx
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2539 : 	return (_Dest - _Count);

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi

; 2540 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<CGraphicThingInstance * *,CGraphicThingInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAPAVCGraphicThingInstance@@PAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAPAVCGraphicThingInstance@@PAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z PROC ; std::_Pop_heap_0<CGraphicThingInstance * *,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]

; 2395 : 	*_Dest = _Move(*_First);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00009	ff 75 10	 push	 DWORD PTR __Pred$[ebp]

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  0000c	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0000f	89 45 0c	 mov	 DWORD PTR __Val$[ebp], eax

; 2395 : 	*_Dest = _Move(*_First);

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00017	2b d1		 sub	 edx, ecx
  00019	8d 45 0c	 lea	 eax, DWORD PTR __Val$[ebp]
  0001c	83 ea 04	 sub	 edx, 4
  0001f	50		 push	 eax
  00020	c1 fa 02	 sar	 edx, 2
  00023	52		 push	 edx
  00024	6a 00		 push	 0
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Adjust_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  0002c	83 c4 14	 add	 esp, 20			; 00000014H

; 2406 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2407 : 		_Move(_Val), _Pred, _Dist_type(_First));
; 2408 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Pop_heap_0@PAPAVCGraphicThingInstance@@PAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z ENDP ; std::_Pop_heap_0<CGraphicThingInstance * *,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__Idx$1$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Push_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2313 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Hole$[ebp]
  00008	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0000b	99		 cdq
  0000c	2b c2		 sub	 eax, edx
  0000e	d1 f8		 sar	 eax, 1
  00010	89 45 fc	 mov	 DWORD PTR __Idx$1$[ebp], eax

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00013	39 5d 10	 cmp	 DWORD PTR __Top$[ebp], ebx
  00016	0f 8d d4 00 00
	00		 jge	 $LN32@Push_heap
  0001c	56		 push	 esi
  0001d	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00020	57		 push	 edi
$LL3@Push_heap:
  00021	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00024	8b 34 86	 mov	 esi, DWORD PTR [esi+eax*4]
  00027	8b 39		 mov	 edi, DWORD PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0002f	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00034	8b ce		 mov	 ecx, esi
  00036	8b d8		 mov	 ebx, eax
  00038	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0003d	8b cf		 mov	 ecx, edi
  0003f	8b f0		 mov	 esi, eax
  00041	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00046	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  0004b	f3 0f 10 5b 34	 movss	 xmm3, DWORD PTR [ebx+52]
  00050	0f 28 e5	 movaps	 xmm4, xmm5
  00053	f3 0f 5c 26	 subss	 xmm4, DWORD PTR [esi]
  00057	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  0005b	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  00060	0f 28 cb	 movaps	 xmm1, xmm3
  00063	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [esi+4]
  00068	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
; File a:\vs\vc\include\algorithm

; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0006d	8b 55 0c	 mov	 edx, DWORD PTR __Hole$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00070	0f 28 c2	 movaps	 xmm0, xmm2
  00073	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  00078	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0007d	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00081	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00085	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00089	f3 0f 59 db	 mulss	 xmm3, xmm3
  0008d	f3 0f 58 e1	 addss	 xmm4, xmm1
  00091	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00095	f3 0f 58 eb	 addss	 xmm5, xmm3
  00099	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0009d	f3 0f 58 e0	 addss	 xmm4, xmm0
  000a1	f3 0f 58 ea	 addss	 xmm5, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  000a5	0f 2f ec	 comiss	 xmm5, xmm4
; File a:\vs\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

  000a8	76 34		 jbe	 SHORT $LN33@Push_heap

; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __Idx$1$[ebp]

; 2319 : 		_Hole = _Idx;

  000ad	8b d9		 mov	 ebx, ecx
  000af	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  000b2	89 5d 0c	 mov	 DWORD PTR __Hole$[ebp], ebx
  000b5	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  000b8	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax
  000bb	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  000be	99		 cdq
  000bf	2b c2		 sub	 eax, edx
  000c1	d1 f8		 sar	 eax, 1
  000c3	89 45 fc	 mov	 DWORD PTR __Idx$1$[ebp], eax
  000c6	39 5d 10	 cmp	 DWORD PTR __Top$[ebp], ebx
  000c9	0f 8c 52 ff ff
	ff		 jl	 $LL3@Push_heap

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  000cf	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000d2	5f		 pop	 edi
  000d3	8b 00		 mov	 eax, DWORD PTR [eax]
  000d5	89 04 9e	 mov	 DWORD PTR [esi+ebx*4], eax
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 2323 : 	}

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
$LN33@Push_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  000de	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]
  000e8	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  000eb	5b		 pop	 ebx

; 2323 : 	}

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
$LN32@Push_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  000f0	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000f8	89 0c 98	 mov	 DWORD PTR [eax+ebx*4], ecx
  000fb	5b		 pop	 ebx

; 2323 : 	}

  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
??$_Push_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Push_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>, COMDAT

; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2526 : 	while (_First != _Last)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	3b f1		 cmp	 esi, ecx
  0000f	74 15		 je	 SHORT $LN1@Move_backw
$LL2@Move_backw:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00011	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00014	83 e9 08	 sub	 ecx, 8
  00017	83 e8 08	 sub	 eax, 8
  0001a	89 10		 mov	 DWORD PTR [eax], edx
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00022	3b ce		 cmp	 ecx, esi
  00024	75 eb		 jne	 SHORT $LL2@Move_backw
$LN1@Move_backw:
  00026	5e		 pop	 esi

; 2528 : 	return (_Dest);
; 2529 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z
_TEXT	SEGMENT
__Val$ = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z PROC ; std::_Pop_heap_0<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>, COMDAT

; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]

; 2395 : 	*_Dest = _Move(*_First);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  0000c	ff 75 10	 push	 DWORD PTR __Pred$[ebp]

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  0000f	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00012	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
  00015	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00018	89 45 fc	 mov	 DWORD PTR __Val$[ebp+4], eax

; 2395 : 	*_Dest = _Move(*_First);

  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	89 42 f8	 mov	 DWORD PTR [edx-8], eax
  00020	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00023	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00026	2b d1		 sub	 edx, ecx
  00028	8d 45 f8	 lea	 eax, DWORD PTR __Val$[ebp]
  0002b	83 ea 08	 sub	 edx, 8
  0002e	50		 push	 eax
  0002f	c1 fa 03	 sar	 edx, 3
  00032	52		 push	 edx
  00033	6a 00		 push	 0
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Adjust_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
  0003b	83 c4 14	 add	 esp, 20			; 00000014H

; 2406 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2407 : 		_Move(_Val), _Pred, _Dist_type(_First));
; 2408 : 	}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Pop_heap_0@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z ENDP ; std::_Pop_heap_0<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z PROC ; std::_Push_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>, COMDAT

; 2313 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00004	8b 5d 14	 mov	 ebx, DWORD PTR __Val$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  0000f	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00012	99		 cdq
  00013	2b c2		 sub	 eax, edx
  00015	d1 f8		 sar	 eax, 1
  00017	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  0001a	7d 28		 jge	 SHORT $LN16@Push_heap
  0001c	8d 64 24 00	 npad	 4
$LL3@Push_heap:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00020	8b 4c c6 04	 mov	 ecx, DWORD PTR [esi+eax*8+4]
  00024	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
; File a:\vs\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00027	76 1b		 jbe	 SHORT $LN16@Push_heap

; 2317 : 		{	// move _Hole up to parent
; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00029	8b 0c c6	 mov	 ecx, DWORD PTR [esi+eax*8]
  0002c	89 0c fe	 mov	 DWORD PTR [esi+edi*8], ecx
  0002f	8b 4c c6 04	 mov	 ecx, DWORD PTR [esi+eax*8+4]
  00033	89 4c fe 04	 mov	 DWORD PTR [esi+edi*8+4], ecx

; 2319 : 		_Hole = _Idx;

  00037	8b f8		 mov	 edi, eax
  00039	48		 dec	 eax
  0003a	99		 cdq
  0003b	2b c2		 sub	 eax, edx
  0003d	d1 f8		 sar	 eax, 1
  0003f	39 7d 10	 cmp	 DWORD PTR __Top$[ebp], edi
  00042	7c dc		 jl	 SHORT $LL3@Push_heap
$LN16@Push_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  00044	8b 03		 mov	 eax, DWORD PTR [ebx]
  00046	89 04 fe	 mov	 DWORD PTR [esi+edi*8], eax
  00049	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0004c	89 44 fe 04	 mov	 DWORD PTR [esi+edi*8+4], eax
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 2323 : 	}

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
??$_Push_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ENDP ; std::_Push_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00@Z PROC ; std::_Move_backward<std::pair<float,long> *,std::pair<float,long> *>, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	57		 push	 edi

; 2526 : 	while (_First != _Last)

  0000a	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000d	3b fa		 cmp	 edi, edx
  0000f	74 1c		 je	 SHORT $LN5@Move_backw
  00011	56		 push	 esi
  00012	8b f2		 mov	 esi, edx
  00014	2b f0		 sub	 esi, eax
$LL6@Move_backw:
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
; File a:\vs\vc\include\xutility

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00019	83 e8 08	 sub	 eax, 8
  0001c	83 ea 08	 sub	 edx, 8
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00021	8b 4c 06 04	 mov	 ecx, DWORD PTR [esi+eax+4]
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\xutility

; 2526 : 	while (_First != _Last)

  00028	3b d7		 cmp	 edx, edi
  0002a	75 ea		 jne	 SHORT $LL6@Move_backw
  0002c	5e		 pop	 esi
$LN5@Move_backw:
  0002d	5f		 pop	 edi

; 2549 : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Move_backward@PAU?$pair@MJ@std@@PAU12@@std@@YAPAU?$pair@MJ@0@PAU10@00@Z ENDP ; std::_Move_backward<std::pair<float,long> *,std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z PROC ; std::_Pop_heap<std::pair<float,long> *,std::less<void> >, COMDAT

; 2413 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  0000c	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000f	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00012	f3 0f 10 42 f8	 movss	 xmm0, DWORD PTR [edx-8]
  00017	89 45 fc	 mov	 DWORD PTR __Val$1[ebp+4], eax

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  0001f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00022	89 42 fc	 mov	 DWORD PTR [edx-4], eax
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  00025	8d 45 f8	 lea	 eax, DWORD PTR __Val$1[ebp]
  00028	2b d1		 sub	 edx, ecx
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0002a	f3 0f 11 45 f8	 movss	 DWORD PTR __Val$1[ebp], xmm0
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  0002f	50		 push	 eax
  00030	83 ea 08	 sub	 edx, 8
  00033	c1 fa 03	 sar	 edx, 3
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Adjust_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
  0003f	83 c4 14	 add	 esp, 20			; 00000014H

; 2414 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2415 : 		_Val_type(_First));
; 2416 : 	}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??$_Pop_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ENDP ; std::_Pop_heap<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z PROC ; std::_Adjust_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >, COMDAT

; 2368 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2369 : 	_Diff _Top = _Hole;
; 2370 : 	_Diff _Idx = 2 * _Hole + 2;
; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR __Hole$[ebp]
  0000b	8b de		 mov	 ebx, esi
  0000d	57		 push	 edi
  0000e	8b 7d 10	 mov	 edi, DWORD PTR __Bottom$[ebp]
  00011	8d 0c 75 02 00
	00 00		 lea	 ecx, DWORD PTR [esi*2+2]
  00018	3b cf		 cmp	 ecx, edi
  0001a	7d 3f		 jge	 SHORT $LN38@Adjust_hea
  0001c	8d 64 24 00	 npad	 4
$LL5@Adjust_hea:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00020	f3 0f 10 0c ca	 movss	 xmm1, DWORD PTR [edx+ecx*8]
  00025	f3 0f 10 44 ca
	f8		 movss	 xmm0, DWORD PTR [edx+ecx*8-8]
  0002b	0f 2f c1	 comiss	 xmm0, xmm1
  0002e	77 0f		 ja	 SHORT $LN13@Adjust_hea
  00030	0f 2f c8	 comiss	 xmm1, xmm0
  00033	77 0b		 ja	 SHORT $LN2@Adjust_hea
  00035	8b 44 ca 04	 mov	 eax, DWORD PTR [edx+ecx*8+4]
  00039	3b 44 ca fc	 cmp	 eax, DWORD PTR [edx+ecx*8-4]
  0003d	7d 01		 jge	 SHORT $LN2@Adjust_hea
$LN13@Adjust_hea:
; File a:\vs\vc\include\algorithm

; 2375 : 			--_Idx;

  0003f	49		 dec	 ecx
$LN2@Adjust_hea:
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00040	8b 04 ca	 mov	 eax, DWORD PTR [edx+ecx*8]
  00043	89 04 f2	 mov	 DWORD PTR [edx+esi*8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00046	8b 44 ca 04	 mov	 eax, DWORD PTR [edx+ecx*8+4]
  0004a	89 44 f2 04	 mov	 DWORD PTR [edx+esi*8+4], eax
; File a:\vs\vc\include\algorithm

; 2377 : 		_Hole = _Idx;

  0004e	8b f1		 mov	 esi, ecx
  00050	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00057	3b cf		 cmp	 ecx, edi
  00059	7c c5		 jl	 SHORT $LL5@Adjust_hea
$LN38@Adjust_hea:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  0005b	75 12		 jne	 SHORT $LN1@Adjust_hea
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0005d	8b 44 fa f8	 mov	 eax, DWORD PTR [edx+edi*8-8]
  00061	89 04 f2	 mov	 DWORD PTR [edx+esi*8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00064	8b 44 fa fc	 mov	 eax, DWORD PTR [edx+edi*8-4]
  00068	89 44 f2 04	 mov	 DWORD PTR [edx+esi*8+4], eax
; File a:\vs\vc\include\algorithm

; 2383 : 		_Hole = _Bottom - 1;

  0006c	8d 77 ff	 lea	 esi, DWORD PTR [edi-1]
$LN1@Adjust_hea:

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  0006f	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00072	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00075	53		 push	 ebx
  00076	56		 push	 esi
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ??$_Push_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Push_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
  0007d	83 c4 14	 add	 esp, 20			; 00000014H
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx

; 2386 : 	}

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ENDP ; std::_Adjust_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z PROC ; std::_Move<std::pair<float,long> &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAU?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z ENDP ; std::_Move<std::pair<float,long> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$pair@MJ@std@@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$pair@MJ@std@@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@@Z PROC ; std::forward<std::pair<float,long> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$pair@MJ@std@@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@@Z ENDP ; std::forward<std::pair<float,long> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@MJ@std@@YAXAAU?$pair@MJ@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@MJ@std@@YAXAAU?$pair@MJ@0@0@Z PROC		; std::swap<float,long>, COMDAT

; 208  : 	{	// swap _Left and _Right pairs

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	}
; 56   : 
; 57   : 		// TEMPLATE FUNCTION _Swap_adl
; 58   : template<class _Ty> inline
; 59   : 	void _Swap_adl(_Ty& _Left, _Ty& _Right)
; 60   : 	{	// exchange values stored at _Left and _Right, using ADL
; 61   : 	swap(_Left, _Right);
; 62   : 	}
; 63   : 
; 64   : 		// STRUCT piecewise_construct_t
; 65   : struct piecewise_construct_t
; 66   : 	{	// tag type for pair tuple arguments
; 67   : 	};
; 68   : 
; 69   : const piecewise_construct_t piecewise_construct =
; 70   : 	piecewise_construct_t();
; 71   : 
; 72   : 		// TEMPLATE STRUCT pair
; 73   : 
; 74   : template<class...>
; 75   : 	class tuple;
; 76   : 
; 77   : 
; 78   : template<class _Ty1,
; 79   : 	class _Ty2>
; 80   : 	struct pair
; 81   : 	{	// store a pair of values
; 82   : 	typedef pair<_Ty1, _Ty2> _Myt;
; 83   : 	typedef _Ty1 first_type;
; 84   : 	typedef _Ty2 second_type;
; 85   : 
; 86   : 	pair()
; 87   : 		: first(), second()
; 88   : 		{	// default construct
; 89   : 		}
; 90   : 
; 91   : 	pair(const _Ty1& _Val1, const _Ty2& _Val2)
; 92   : 		: first(_Val1), second(_Val2)
; 93   : 		{	// construct from specified values
; 94   : 		}
; 95   : 
; 96   : 	template<class _Other1,
; 97   : 		class _Other2,
; 98   : 		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
; 99   : 			&& is_convertible<const _Other2&, _Ty2>::value,
; 100  : 			void>::type>
; 101  : 		pair(const pair<_Other1, _Other2>& _Right)
; 102  : 		: first(_Right.first), second(_Right.second)
; 103  : 		{	// construct from compatible pair
; 104  : 		}
; 105  : 
; 106  : 	template<class _Other1,
; 107  : 		class _Other2>
; 108  : 		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
; 109  : 		{	// assign from compatible pair
; 110  : 		first = _Right.first;
; 111  : 		second = _Right.second;
; 112  : 		return (*this);
; 113  : 		}
; 114  : 
; 115  : 
; 116  : 	template<class _Tuple1,
; 117  : 		class _Tuple2,
; 118  : 		size_t... _Indexes1,
; 119  : 		size_t... _Indexes2> inline
; 120  : 		pair(_Tuple1& _Val1,
; 121  : 			_Tuple2& _Val2,
; 122  : 			_Arg_idx<_Indexes1...>,
; 123  : 			_Arg_idx<_Indexes2...>);
; 124  : 
; 125  : 	template<class... _Types1,
; 126  : 		class... _Types2> inline
; 127  : 		pair(piecewise_construct_t,
; 128  : 			tuple<_Types1...> _Val1,
; 129  : 			tuple<_Types2...> _Val2)
; 130  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Types1&&...>::value
; 131  : 				&& is_nothrow_constructible<_Ty2, _Types2&&...>::value));
; 132  : 
; 133  : 
; 134  : 	template<class _Other1,
; 135  : 		class _Other2,
; 136  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 137  : 			&& is_convertible<_Other2, _Ty2>::value,
; 138  : 			void>::type>
; 139  : 		pair(_Other1&& _Val1, _Other2&& _Val2)
; 140  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 141  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 142  : 		: first(_STD forward<_Other1>(_Val1)),
; 143  : 				second(_STD forward<_Other2>(_Val2))
; 144  : 		{	// construct from moved values
; 145  : 		}
; 146  : 
; 147  : 	template<class _Other1,
; 148  : 		class _Other2,
; 149  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 150  : 			&& is_convertible<_Other2, _Ty2>::value,
; 151  : 			void>::type>
; 152  : 		pair(pair<_Other1, _Other2>&& _Right)
; 153  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 154  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 155  : 		: first(_STD forward<_Other1>(_Right.first)),
; 156  : 			second(_STD forward<_Other2>(_Right.second))
; 157  : 		{	// construct from moved compatible pair
; 158  : 		}
; 159  : 
; 160  : 	template<class _Other1,
; 161  : 		class _Other2>
; 162  : 		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
; 163  : 			_NOEXCEPT_OP((is_nothrow_assignable<_Ty1, _Other1&&>::value
; 164  : 				&& is_nothrow_assignable<_Ty2, _Other2&&>::value))
; 165  : 		{	// assign from moved compatible pair
; 166  : 		first = _STD forward<_Other1>(_Right.first);
; 167  : 		second = _STD forward<_Other2>(_Right.second);
; 168  : 		return (*this);
; 169  : 		}
; 170  : 
; 171  : 	_Myt& operator=(_Myt&& _Right)
; 172  : 		_NOEXCEPT_OP((is_nothrow_move_assignable<_Ty1>::value
; 173  : 			&& is_nothrow_move_assignable<_Ty2>::value))
; 174  : 		{	// assign from moved pair
; 175  : 		first = _STD forward<_Ty1>(_Right.first);
; 176  : 		second = _STD forward<_Ty2>(_Right.second);
; 177  : 		return (*this);
; 178  : 		}
; 179  : 
; 180  : 	void swap(_Myt& _Right)
; 181  : 		_NOEXCEPT_OP(_NOEXCEPT_OP(_Swap_adl(this->first, _Right.first))
; 182  : 			&& _NOEXCEPT_OP(_Swap_adl(this->second, _Right.second)))
; 183  : 		{	// exchange contents with _Right
; 184  : 		if (this != &_Right)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000a	3b d6		 cmp	 edx, esi
  0000c	74 18		 je	 SHORT $LN18@swap

; 53   : 	_Left = _Move(_Right);

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00014	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00016	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  0001a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 53   : 	_Left = _Move(_Right);

  0001d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00020	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00023	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN18@swap:
  00026	5e		 pop	 esi

; 209  : 	_Left.swap(_Right);
; 210  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$swap@MJ@std@@YAXAAU?$pair@MJ@0@0@Z ENDP		; std::swap<float,long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z PROC ; std::_Med3<std::pair<float,long> *,std::less<void> >, COMDAT

; 3032 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	57		 push	 edi
  0000b	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000f	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00013	0f 2f c8	 comiss	 xmm1, xmm0
  00016	77 0d		 ja	 SHORT $LN11@Med3
  00018	0f 2f c1	 comiss	 xmm0, xmm1
  0001b	77 20		 ja	 SHORT $LN32@Med3
  0001d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00020	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00023	7d 18		 jge	 SHORT $LN32@Med3
$LN11@Med3:

; 55   : 	}
; 56   : 
; 57   : 		// TEMPLATE FUNCTION _Swap_adl
; 58   : template<class _Ty> inline
; 59   : 	void _Swap_adl(_Ty& _Left, _Ty& _Right)
; 60   : 	{	// exchange values stored at _Left and _Right, using ADL
; 61   : 	swap(_Left, _Right);
; 62   : 	}
; 63   : 
; 64   : 		// STRUCT piecewise_construct_t
; 65   : struct piecewise_construct_t
; 66   : 	{	// tag type for pair tuple arguments
; 67   : 	};
; 68   : 
; 69   : const piecewise_construct_t piecewise_construct =
; 70   : 	piecewise_construct_t();
; 71   : 
; 72   : 		// TEMPLATE STRUCT pair
; 73   : 
; 74   : template<class...>
; 75   : 	class tuple;
; 76   : 
; 77   : 
; 78   : template<class _Ty1,
; 79   : 	class _Ty2>
; 80   : 	struct pair
; 81   : 	{	// store a pair of values
; 82   : 	typedef pair<_Ty1, _Ty2> _Myt;
; 83   : 	typedef _Ty1 first_type;
; 84   : 	typedef _Ty2 second_type;
; 85   : 
; 86   : 	pair()
; 87   : 		: first(), second()
; 88   : 		{	// default construct
; 89   : 		}
; 90   : 
; 91   : 	pair(const _Ty1& _Val1, const _Ty2& _Val2)
; 92   : 		: first(_Val1), second(_Val2)
; 93   : 		{	// construct from specified values
; 94   : 		}
; 95   : 
; 96   : 	template<class _Other1,
; 97   : 		class _Other2,
; 98   : 		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
; 99   : 			&& is_convertible<const _Other2&, _Ty2>::value,
; 100  : 			void>::type>
; 101  : 		pair(const pair<_Other1, _Other2>& _Right)
; 102  : 		: first(_Right.first), second(_Right.second)
; 103  : 		{	// construct from compatible pair
; 104  : 		}
; 105  : 
; 106  : 	template<class _Other1,
; 107  : 		class _Other2>
; 108  : 		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
; 109  : 		{	// assign from compatible pair
; 110  : 		first = _Right.first;
; 111  : 		second = _Right.second;
; 112  : 		return (*this);
; 113  : 		}
; 114  : 
; 115  : 
; 116  : 	template<class _Tuple1,
; 117  : 		class _Tuple2,
; 118  : 		size_t... _Indexes1,
; 119  : 		size_t... _Indexes2> inline
; 120  : 		pair(_Tuple1& _Val1,
; 121  : 			_Tuple2& _Val2,
; 122  : 			_Arg_idx<_Indexes1...>,
; 123  : 			_Arg_idx<_Indexes2...>);
; 124  : 
; 125  : 	template<class... _Types1,
; 126  : 		class... _Types2> inline
; 127  : 		pair(piecewise_construct_t,
; 128  : 			tuple<_Types1...> _Val1,
; 129  : 			tuple<_Types2...> _Val2)
; 130  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Types1&&...>::value
; 131  : 				&& is_nothrow_constructible<_Ty2, _Types2&&...>::value));
; 132  : 
; 133  : 
; 134  : 	template<class _Other1,
; 135  : 		class _Other2,
; 136  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 137  : 			&& is_convertible<_Other2, _Ty2>::value,
; 138  : 			void>::type>
; 139  : 		pair(_Other1&& _Val1, _Other2&& _Val2)
; 140  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 141  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 142  : 		: first(_STD forward<_Other1>(_Val1)),
; 143  : 				second(_STD forward<_Other2>(_Val2))
; 144  : 		{	// construct from moved values
; 145  : 		}
; 146  : 
; 147  : 	template<class _Other1,
; 148  : 		class _Other2,
; 149  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 150  : 			&& is_convertible<_Other2, _Ty2>::value,
; 151  : 			void>::type>
; 152  : 		pair(pair<_Other1, _Other2>&& _Right)
; 153  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 154  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 155  : 		: first(_STD forward<_Other1>(_Right.first)),
; 156  : 			second(_STD forward<_Other2>(_Right.second))
; 157  : 		{	// construct from moved compatible pair
; 158  : 		}
; 159  : 
; 160  : 	template<class _Other1,
; 161  : 		class _Other2>
; 162  : 		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
; 163  : 			_NOEXCEPT_OP((is_nothrow_assignable<_Ty1, _Other1&&>::value
; 164  : 				&& is_nothrow_assignable<_Ty2, _Other2&&>::value))
; 165  : 		{	// assign from moved compatible pair
; 166  : 		first = _STD forward<_Other1>(_Right.first);
; 167  : 		second = _STD forward<_Other2>(_Right.second);
; 168  : 		return (*this);
; 169  : 		}
; 170  : 
; 171  : 	_Myt& operator=(_Myt&& _Right)
; 172  : 		_NOEXCEPT_OP((is_nothrow_move_assignable<_Ty1>::value
; 173  : 			&& is_nothrow_move_assignable<_Ty2>::value))
; 174  : 		{	// assign from moved pair
; 175  : 		first = _STD forward<_Ty1>(_Right.first);
; 176  : 		second = _STD forward<_Ty2>(_Right.second);
; 177  : 		return (*this);
; 178  : 		}
; 179  : 
; 180  : 	void swap(_Myt& _Right)
; 181  : 		_NOEXCEPT_OP(_NOEXCEPT_OP(_Swap_adl(this->first, _Right.first))
; 182  : 			&& _NOEXCEPT_OP(_Swap_adl(this->second, _Right.second)))
; 183  : 		{	// exchange contents with _Right
; 184  : 		if (this != &_Right)

  00025	3b d6		 cmp	 edx, esi
  00027	74 14		 je	 SHORT $LN32@Med3

; 53   : 	_Left = _Move(_Right);

  00029	f3 0f 11 0a	 movss	 DWORD PTR [edx], xmm1

; 54   : 	_Right = _Move(_Tmp);

  0002d	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00031	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 53   : 	_Left = _Move(_Right);

  00034	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00037	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0003a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN32@Med3:

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  0003d	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  00040	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  00044	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00048	0f 2f c8	 comiss	 xmm1, xmm0
  0004b	77 0d		 ja	 SHORT $LN45@Med3
  0004d	0f 2f c1	 comiss	 xmm0, xmm1
  00050	77 52		 ja	 SHORT $LN100@Med3
  00052	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00055	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00058	7d 4a		 jge	 SHORT $LN100@Med3
$LN45@Med3:

; 55   : 	}
; 56   : 
; 57   : 		// TEMPLATE FUNCTION _Swap_adl
; 58   : template<class _Ty> inline
; 59   : 	void _Swap_adl(_Ty& _Left, _Ty& _Right)
; 60   : 	{	// exchange values stored at _Left and _Right, using ADL
; 61   : 	swap(_Left, _Right);
; 62   : 	}
; 63   : 
; 64   : 		// STRUCT piecewise_construct_t
; 65   : struct piecewise_construct_t
; 66   : 	{	// tag type for pair tuple arguments
; 67   : 	};
; 68   : 
; 69   : const piecewise_construct_t piecewise_construct =
; 70   : 	piecewise_construct_t();
; 71   : 
; 72   : 		// TEMPLATE STRUCT pair
; 73   : 
; 74   : template<class...>
; 75   : 	class tuple;
; 76   : 
; 77   : 
; 78   : template<class _Ty1,
; 79   : 	class _Ty2>
; 80   : 	struct pair
; 81   : 	{	// store a pair of values
; 82   : 	typedef pair<_Ty1, _Ty2> _Myt;
; 83   : 	typedef _Ty1 first_type;
; 84   : 	typedef _Ty2 second_type;
; 85   : 
; 86   : 	pair()
; 87   : 		: first(), second()
; 88   : 		{	// default construct
; 89   : 		}
; 90   : 
; 91   : 	pair(const _Ty1& _Val1, const _Ty2& _Val2)
; 92   : 		: first(_Val1), second(_Val2)
; 93   : 		{	// construct from specified values
; 94   : 		}
; 95   : 
; 96   : 	template<class _Other1,
; 97   : 		class _Other2,
; 98   : 		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
; 99   : 			&& is_convertible<const _Other2&, _Ty2>::value,
; 100  : 			void>::type>
; 101  : 		pair(const pair<_Other1, _Other2>& _Right)
; 102  : 		: first(_Right.first), second(_Right.second)
; 103  : 		{	// construct from compatible pair
; 104  : 		}
; 105  : 
; 106  : 	template<class _Other1,
; 107  : 		class _Other2>
; 108  : 		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
; 109  : 		{	// assign from compatible pair
; 110  : 		first = _Right.first;
; 111  : 		second = _Right.second;
; 112  : 		return (*this);
; 113  : 		}
; 114  : 
; 115  : 
; 116  : 	template<class _Tuple1,
; 117  : 		class _Tuple2,
; 118  : 		size_t... _Indexes1,
; 119  : 		size_t... _Indexes2> inline
; 120  : 		pair(_Tuple1& _Val1,
; 121  : 			_Tuple2& _Val2,
; 122  : 			_Arg_idx<_Indexes1...>,
; 123  : 			_Arg_idx<_Indexes2...>);
; 124  : 
; 125  : 	template<class... _Types1,
; 126  : 		class... _Types2> inline
; 127  : 		pair(piecewise_construct_t,
; 128  : 			tuple<_Types1...> _Val1,
; 129  : 			tuple<_Types2...> _Val2)
; 130  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Types1&&...>::value
; 131  : 				&& is_nothrow_constructible<_Ty2, _Types2&&...>::value));
; 132  : 
; 133  : 
; 134  : 	template<class _Other1,
; 135  : 		class _Other2,
; 136  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 137  : 			&& is_convertible<_Other2, _Ty2>::value,
; 138  : 			void>::type>
; 139  : 		pair(_Other1&& _Val1, _Other2&& _Val2)
; 140  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 141  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 142  : 		: first(_STD forward<_Other1>(_Val1)),
; 143  : 				second(_STD forward<_Other2>(_Val2))
; 144  : 		{	// construct from moved values
; 145  : 		}
; 146  : 
; 147  : 	template<class _Other1,
; 148  : 		class _Other2,
; 149  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 150  : 			&& is_convertible<_Other2, _Ty2>::value,
; 151  : 			void>::type>
; 152  : 		pair(pair<_Other1, _Other2>&& _Right)
; 153  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 154  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 155  : 		: first(_STD forward<_Other1>(_Right.first)),
; 156  : 			second(_STD forward<_Other2>(_Right.second))
; 157  : 		{	// construct from moved compatible pair
; 158  : 		}
; 159  : 
; 160  : 	template<class _Other1,
; 161  : 		class _Other2>
; 162  : 		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
; 163  : 			_NOEXCEPT_OP((is_nothrow_assignable<_Ty1, _Other1&&>::value
; 164  : 				&& is_nothrow_assignable<_Ty2, _Other2&&>::value))
; 165  : 		{	// assign from moved compatible pair
; 166  : 		first = _STD forward<_Other1>(_Right.first);
; 167  : 		second = _STD forward<_Other2>(_Right.second);
; 168  : 		return (*this);
; 169  : 		}
; 170  : 
; 171  : 	_Myt& operator=(_Myt&& _Right)
; 172  : 		_NOEXCEPT_OP((is_nothrow_move_assignable<_Ty1>::value
; 173  : 			&& is_nothrow_move_assignable<_Ty2>::value))
; 174  : 		{	// assign from moved pair
; 175  : 		first = _STD forward<_Ty1>(_Right.first);
; 176  : 		second = _STD forward<_Ty2>(_Right.second);
; 177  : 		return (*this);
; 178  : 		}
; 179  : 
; 180  : 	void swap(_Myt& _Right)
; 181  : 		_NOEXCEPT_OP(_NOEXCEPT_OP(_Swap_adl(this->first, _Right.first))
; 182  : 			&& _NOEXCEPT_OP(_Swap_adl(this->second, _Right.second)))
; 183  : 		{	// exchange contents with _Right
; 184  : 		if (this != &_Right)

  0005a	3b fa		 cmp	 edi, edx
  0005c	74 14		 je	 SHORT $LN66@Med3

; 53   : 	_Left = _Move(_Right);

  0005e	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1

; 54   : 	_Right = _Move(_Tmp);

  00062	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00066	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 53   : 	_Left = _Move(_Right);

  00069	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0006f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN66@Med3:

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00072	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00076	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  0007a	0f 2f c8	 comiss	 xmm1, xmm0
  0007d	77 0d		 ja	 SHORT $LN79@Med3
  0007f	0f 2f c1	 comiss	 xmm0, xmm1
  00082	77 20		 ja	 SHORT $LN100@Med3
  00084	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00087	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0008a	7d 18		 jge	 SHORT $LN100@Med3
$LN79@Med3:

; 55   : 	}
; 56   : 
; 57   : 		// TEMPLATE FUNCTION _Swap_adl
; 58   : template<class _Ty> inline
; 59   : 	void _Swap_adl(_Ty& _Left, _Ty& _Right)
; 60   : 	{	// exchange values stored at _Left and _Right, using ADL
; 61   : 	swap(_Left, _Right);
; 62   : 	}
; 63   : 
; 64   : 		// STRUCT piecewise_construct_t
; 65   : struct piecewise_construct_t
; 66   : 	{	// tag type for pair tuple arguments
; 67   : 	};
; 68   : 
; 69   : const piecewise_construct_t piecewise_construct =
; 70   : 	piecewise_construct_t();
; 71   : 
; 72   : 		// TEMPLATE STRUCT pair
; 73   : 
; 74   : template<class...>
; 75   : 	class tuple;
; 76   : 
; 77   : 
; 78   : template<class _Ty1,
; 79   : 	class _Ty2>
; 80   : 	struct pair
; 81   : 	{	// store a pair of values
; 82   : 	typedef pair<_Ty1, _Ty2> _Myt;
; 83   : 	typedef _Ty1 first_type;
; 84   : 	typedef _Ty2 second_type;
; 85   : 
; 86   : 	pair()
; 87   : 		: first(), second()
; 88   : 		{	// default construct
; 89   : 		}
; 90   : 
; 91   : 	pair(const _Ty1& _Val1, const _Ty2& _Val2)
; 92   : 		: first(_Val1), second(_Val2)
; 93   : 		{	// construct from specified values
; 94   : 		}
; 95   : 
; 96   : 	template<class _Other1,
; 97   : 		class _Other2,
; 98   : 		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
; 99   : 			&& is_convertible<const _Other2&, _Ty2>::value,
; 100  : 			void>::type>
; 101  : 		pair(const pair<_Other1, _Other2>& _Right)
; 102  : 		: first(_Right.first), second(_Right.second)
; 103  : 		{	// construct from compatible pair
; 104  : 		}
; 105  : 
; 106  : 	template<class _Other1,
; 107  : 		class _Other2>
; 108  : 		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
; 109  : 		{	// assign from compatible pair
; 110  : 		first = _Right.first;
; 111  : 		second = _Right.second;
; 112  : 		return (*this);
; 113  : 		}
; 114  : 
; 115  : 
; 116  : 	template<class _Tuple1,
; 117  : 		class _Tuple2,
; 118  : 		size_t... _Indexes1,
; 119  : 		size_t... _Indexes2> inline
; 120  : 		pair(_Tuple1& _Val1,
; 121  : 			_Tuple2& _Val2,
; 122  : 			_Arg_idx<_Indexes1...>,
; 123  : 			_Arg_idx<_Indexes2...>);
; 124  : 
; 125  : 	template<class... _Types1,
; 126  : 		class... _Types2> inline
; 127  : 		pair(piecewise_construct_t,
; 128  : 			tuple<_Types1...> _Val1,
; 129  : 			tuple<_Types2...> _Val2)
; 130  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Types1&&...>::value
; 131  : 				&& is_nothrow_constructible<_Ty2, _Types2&&...>::value));
; 132  : 
; 133  : 
; 134  : 	template<class _Other1,
; 135  : 		class _Other2,
; 136  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 137  : 			&& is_convertible<_Other2, _Ty2>::value,
; 138  : 			void>::type>
; 139  : 		pair(_Other1&& _Val1, _Other2&& _Val2)
; 140  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 141  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 142  : 		: first(_STD forward<_Other1>(_Val1)),
; 143  : 				second(_STD forward<_Other2>(_Val2))
; 144  : 		{	// construct from moved values
; 145  : 		}
; 146  : 
; 147  : 	template<class _Other1,
; 148  : 		class _Other2,
; 149  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 150  : 			&& is_convertible<_Other2, _Ty2>::value,
; 151  : 			void>::type>
; 152  : 		pair(pair<_Other1, _Other2>&& _Right)
; 153  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 154  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 155  : 		: first(_STD forward<_Other1>(_Right.first)),
; 156  : 			second(_STD forward<_Other2>(_Right.second))
; 157  : 		{	// construct from moved compatible pair
; 158  : 		}
; 159  : 
; 160  : 	template<class _Other1,
; 161  : 		class _Other2>
; 162  : 		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
; 163  : 			_NOEXCEPT_OP((is_nothrow_assignable<_Ty1, _Other1&&>::value
; 164  : 				&& is_nothrow_assignable<_Ty2, _Other2&&>::value))
; 165  : 		{	// assign from moved compatible pair
; 166  : 		first = _STD forward<_Other1>(_Right.first);
; 167  : 		second = _STD forward<_Other2>(_Right.second);
; 168  : 		return (*this);
; 169  : 		}
; 170  : 
; 171  : 	_Myt& operator=(_Myt&& _Right)
; 172  : 		_NOEXCEPT_OP((is_nothrow_move_assignable<_Ty1>::value
; 173  : 			&& is_nothrow_move_assignable<_Ty2>::value))
; 174  : 		{	// assign from moved pair
; 175  : 		first = _STD forward<_Ty1>(_Right.first);
; 176  : 		second = _STD forward<_Ty2>(_Right.second);
; 177  : 		return (*this);
; 178  : 		}
; 179  : 
; 180  : 	void swap(_Myt& _Right)
; 181  : 		_NOEXCEPT_OP(_NOEXCEPT_OP(_Swap_adl(this->first, _Right.first))
; 182  : 			&& _NOEXCEPT_OP(_Swap_adl(this->second, _Right.second)))
; 183  : 		{	// exchange contents with _Right
; 184  : 		if (this != &_Right)

  0008c	3b d6		 cmp	 edx, esi
  0008e	74 14		 je	 SHORT $LN100@Med3

; 53   : 	_Left = _Move(_Right);

  00090	f3 0f 11 0a	 movss	 DWORD PTR [edx], xmm1

; 54   : 	_Right = _Move(_Tmp);

  00094	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00098	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 53   : 	_Left = _Move(_Right);

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  000a1	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN100@Med3:
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
; File a:\vs\vc\include\algorithm

; 3041 : 	}

  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ENDP ; std::_Med3<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAPAUTPatchDrawStruct@CMapOutdoor@@AAHX@?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@QAE@AAPAUTPatchDrawStruct@CMapOutdoor@@AAH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAUTPatchDrawStruct@CMapOutdoor@@AAHX@?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@QAE@AAPAUTPatchDrawStruct@CMapOutdoor@@AAH@Z PROC ; std::pair<CMapOutdoor::TPatchDrawStruct *,int>::pair<CMapOutdoor::TPatchDrawStruct *,int><CMapOutdoor::TPatchDrawStruct * &,int &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAUTPatchDrawStruct@CMapOutdoor@@AAHX@?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@QAE@AAPAUTPatchDrawStruct@CMapOutdoor@@AAH@Z ENDP ; std::pair<CMapOutdoor::TPatchDrawStruct *,int>::pair<CMapOutdoor::TPatchDrawStruct *,int><CMapOutdoor::TPatchDrawStruct * &,int &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$construct@UTPatchDrawStruct@CMapOutdoor@@U12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@U12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USCRCWithNumber@CArea@@U12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@USCRCWithNumber@CArea@@U12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::destroy<CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::destroy<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@MJ@std@@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@MJ@std@@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@@Z PROC ; std::allocator<std::pair<float,long> >::destroy<std::pair<float,long> >, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@MJ@std@@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@@Z ENDP ; std::allocator<std::pair<float,long> >::destroy<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@USCRCWithNumber@CArea@@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USCRCWithNumber@CArea@@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z PROC ; std::allocator<CArea::SCRCWithNumber>::destroy<CArea::SCRCWithNumber>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@USCRCWithNumber@CArea@@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z ENDP ; std::allocator<CArea::SCRCWithNumber>::destroy<CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@J@std@@YA$$QAJAAJ@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@J@std@@YA$$QAJAAJ@Z PROC			; std::forward<long>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@J@std@@YA$$QAJAAJ@Z ENDP			; std::forward<long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
$T2 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z PROC ; std::_Buffered_rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>, COMDAT

; 2173 : 	{	// rotate [_First, _Last) using temp buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 2174 : 	if (_Count1 == 0 || _Count2 == 0)

  00007	8b 5d 14	 mov	 ebx, DWORD PTR __Count1$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 18	 mov	 esi, DWORD PTR __Count2$[ebp]
  0000e	57		 push	 edi
  0000f	85 db		 test	 ebx, ebx
  00011	0f 84 3f 01 00
	00		 je	 $LN6@Buffered_r
  00017	85 f6		 test	 esi, esi
  00019	0f 84 37 01 00
	00		 je	 $LN6@Buffered_r

; 2175 : 		{	// do nothing
; 2176 : 		_STD advance(_First, _Count2);
; 2177 : 		return (_First);
; 2178 : 		}
; 2179 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

  0001f	8b 7d 1c	 mov	 edi, DWORD PTR __Tempbuf$[ebp]
  00022	3b de		 cmp	 ebx, esi
  00024	0f 8f 80 00 00
	00		 jg	 $LN4@Buffered_r
  0002a	8b cf		 mov	 ecx, edi
  0002c	e8 00 00 00 00	 call	 ?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Maxlen
  00031	3b d8		 cmp	 ebx, eax
  00033	7f 75		 jg	 SHORT $LN4@Buffered_r
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  00035	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2181 : 		_Move(_First, _Mid, _Tempbuf._Init());

  00038	83 ec 14	 sub	 esp, 20			; 00000014H
  0003b	8b 5d 0c	 mov	 ebx, DWORD PTR __Mid$[ebp]
  0003e	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\algorithm

; 2181 : 		_Move(_First, _Mid, _Tempbuf._Init());

  00046	8b cc		 mov	 ecx, esp
  00048	53		 push	 ebx
  00049	56		 push	 esi
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  0004a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 759  : 		_Buf._Current = 0;

  00050	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  00057	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  0005e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
; 777  : 		{	// assign _Right (share active buffer)
; 778  : 		_Pbuf = _Right._Pbuf;

  00065	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00068	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 2181 : 		_Move(_First, _Mid, _Tempbuf._Init());

  0006b	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  00074	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
; File a:\vs\vc\include\algorithm

; 2181 : 		_Move(_First, _Mid, _Tempbuf._Init());

  00077	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  0007a	85 c0		 test	 eax, eax
  0007c	74 09		 je	 SHORT $LN34@Buffered_r

; 41   : 	operator delete(_Pbuf);

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00084	83 c4 04	 add	 esp, 4
$LN34@Buffered_r:
; File a:\vs\vc\include\algorithm

; 2182 : 		_Move(_Mid, _Last, _First);

  00087	56		 push	 esi
  00088	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0008b	56		 push	 esi
  0008c	53		 push	 ebx
  0008d	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
; File a:\vs\vc\include\xmemory

; 837  : 		return (_Pbuf->_Current);

  00092	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2184 : 			_Last));

  00095	56		 push	 esi
  00096	ff 70 04	 push	 DWORD PTR [eax+4]
  00099	ff 30		 push	 DWORD PTR [eax]
  0009b	e8 00 00 00 00	 call	 ??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
  000a0	83 c4 18	 add	 esp, 24			; 00000018H

; 2196 : 	}

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN4@Buffered_r:

; 2185 : 		}
; 2186 : 	else if (_Count2 <= _Tempbuf._Maxlen())

  000aa	8b cf		 mov	 ecx, edi
  000ac	e8 00 00 00 00	 call	 ?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Maxlen
  000b1	3b f0		 cmp	 esi, eax

; 2188 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000b3	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  000b6	7f 72		 jg	 SHORT $LN2@Buffered_r
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  000b8	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2188 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000bb	83 ec 14	 sub	 esp, 20			; 00000014H
  000be	8b 5d 0c	 mov	 ebx, DWORD PTR __Mid$[ebp]
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  000c1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\algorithm

; 2188 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000c6	8b cc		 mov	 ecx, esp
  000c8	56		 push	 esi
  000c9	53		 push	 ebx
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  000ca	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 759  : 		_Buf._Current = 0;

  000d0	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  000d7	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  000de	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
; 777  : 		{	// assign _Right (share active buffer)
; 778  : 		_Pbuf = _Right._Pbuf;

  000e5	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000e8	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 2188 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000eb	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  000f4	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
; File a:\vs\vc\include\algorithm

; 2188 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000f7	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  000fa	85 c0		 test	 eax, eax
  000fc	74 09		 je	 SHORT $LN54@Buffered_r

; 41   : 	operator delete(_Pbuf);

  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00104	83 c4 04	 add	 esp, 4
$LN54@Buffered_r:
; File a:\vs\vc\include\algorithm

; 2189 : 		_Move_backward(_First, _Mid, _Last);

  00107	56		 push	 esi
  00108	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0010b	53		 push	 ebx
  0010c	56		 push	 esi
  0010d	e8 00 00 00 00	 call	 ??$_Move_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ; std::_Move_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
; File a:\vs\vc\include\xmemory

; 837  : 		return (_Pbuf->_Current);

  00112	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2190 : 		return (_Move(_Tempbuf._First(), _Tempbuf._Last(), _First));

  00115	56		 push	 esi
  00116	ff 70 04	 push	 DWORD PTR [eax+4]
  00119	ff 30		 push	 DWORD PTR [eax]
  0011b	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
  00120	83 c4 18	 add	 esp, 24			; 00000018H

; 2196 : 	}

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
$LN2@Buffered_r:
; File a:\vs\vc\include\xutility

; 3243 : 	if (_First != _Mid && _Mid != _Last)

  0012a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0012d	8b 7d 0c	 mov	 edi, DWORD PTR __Mid$[ebp]
  00130	3b df		 cmp	 ebx, edi
  00132	74 13		 je	 SHORT $LN71@Buffered_r
  00134	3b fe		 cmp	 edi, esi
  00136	74 0f		 je	 SHORT $LN71@Buffered_r

; 751  : 	}
; 752  : 
; 753  : template<class _InIt> inline
; 754  : 	typename iterator_traits<_InIt>::difference_type
; 755  : 		distance(_InIt _First, _InIt _Last)
; 756  : 	{	// return distance between iterators
; 757  : 	typename iterator_traits<_InIt>::difference_type _Off = 0;
; 758  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 759  : 	return (_Off);
; 760  : 	}
; 761  : 
; 762  : template<class _InIt,
; 763  : 	class _Diff> inline
; 764  : 		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
; 765  : 	{	// add to _Off distance between iterators
; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}
; 768  : 
; 769  : 		// TEMPLATE FUNCTION next
; 770  : template<class _FwdIt> inline
; 771  : 	_FwdIt next(_FwdIt _First,
; 772  : 		typename iterator_traits<_FwdIt>::difference_type _Off = 1)
; 773  : 	{	// increment iterator
; 774  : 	static_assert((is_base_of<forward_iterator_tag,
; 775  : 		typename iterator_traits<_FwdIt>::iterator_category>::value),
; 776  : 		"next requires forward iterator");
; 777  : 
; 778  : 	_STD advance(_First, _Off);
; 779  : 	return (_First);
; 780  : 	}
; 781  : 
; 782  : 		// TEMPLATE FUNCTION prev
; 783  : template<class _BidIt> inline
; 784  : 	_BidIt prev(_BidIt _First,
; 785  : 		typename iterator_traits<_BidIt>::difference_type _Off = 1)
; 786  : 	{	// decrement iterator
; 787  : 	static_assert((is_base_of<bidirectional_iterator_tag,
; 788  : 		typename iterator_traits<_BidIt>::iterator_category>::value),
; 789  : 		"prev requires bidirectional iterator");
; 790  : 
; 791  : 	_STD advance(_First, -_Off);
; 792  : 	return (_First);
; 793  : 	}
; 794  : 
; 795  : 
; 796  : 		// TEMPLATE CLASS _Revranit
; 797  : template<class _Ty>
; 798  : 	struct pointer_traits;
; 799  : 
; 800  : template<class _RanIt,
; 801  : 	class _Base>
; 802  : 	class _Revranit
; 803  : 		: public _Base
; 804  : 	{	// wrap iterator to run it backwards
; 805  : public:
; 806  : 	typedef _Revranit<_RanIt, _Base> _Myt;
; 807  : 	typedef typename _Base::difference_type difference_type;
; 808  : 	typedef typename _Base::pointer pointer;
; 809  : 	typedef typename _Base::reference reference;
; 810  : 	typedef _RanIt iterator_type;
; 811  : 
; 812  : 	_Revranit()
; 813  : 		{	// construct with default wrapped iterator
; 814  : 		}
; 815  : 
; 816  : 	explicit _Revranit(_RanIt _Right)
; 817  : 		: current(_Right)
; 818  : 		{	// construct wrapped iterator from _Right
; 819  : 		}
; 820  : 
; 821  : 	template<class _RanIt2,
; 822  : 		class _Base2>
; 823  : 		_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
; 824  : 		: current(_Right.base())
; 825  : 		{	// initialize with compatible base
; 826  : 		}
; 827  : 
; 828  : 	_RanIt base() const
; 829  : 		{	// return wrapped iterator
; 830  : 		return (current);
; 831  : 		}
; 832  : 
; 833  : 	reference operator*() const
; 834  : 		{	// return designated value
; 835  : 		_RanIt _Tmp = current;
; 836  : 		return (*--_Tmp);
; 837  : 		}
; 838  : 
; 839  : 	pointer operator->() const
; 840  : 		{	// return pointer to class object
; 841  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 842  : 		}
; 843  : 
; 844  : 	_Myt& operator++()
; 845  : 		{	// preincrement
; 846  : 		--current;
; 847  : 		return (*this);
; 848  : 		}
; 849  : 
; 850  : 	_Myt operator++(int)
; 851  : 		{	// postincrement
; 852  : 		_Myt _Tmp = *this;
; 853  : 		--current;
; 854  : 		return (_Tmp);
; 855  : 		}
; 856  : 
; 857  : 	_Myt& operator--()
; 858  : 		{	// predecrement
; 859  : 		++current;
; 860  : 		return (*this);
; 861  : 		}
; 862  : 
; 863  : 	_Myt operator--(int)
; 864  : 		{	// postdecrement
; 865  : 		_Myt _Tmp = *this;
; 866  : 		++current;
; 867  : 		return (_Tmp);
; 868  : 		}
; 869  : 
; 870  : 	template<class _RanIt2,
; 871  : 		class _Base2>
; 872  : 		bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
; 873  : 		{	// test for iterator equality
; 874  : 		return (current == _Right.base());
; 875  : 		}
; 876  : 
; 877  : // N.B. functions valid for random-access iterators only beyond this point
; 878  : 
; 879  : 	_Myt& operator+=(difference_type _Off)
; 880  : 		{	// increment by integer
; 881  : 		current -= _Off;
; 882  : 		return (*this);
; 883  : 		}
; 884  : 
; 885  : 	_Myt operator+(difference_type _Off) const
; 886  : 		{	// return this + integer
; 887  : 		return (_Myt(current - _Off));
; 888  : 		}
; 889  : 
; 890  : 	_Myt& operator-=(difference_type _Off)
; 891  : 		{	// decrement by integer
; 892  : 		current += _Off;
; 893  : 		return (*this);
; 894  : 		}
; 895  : 
; 896  : 	_Myt operator-(difference_type _Off) const
; 897  : 		{	// return this - integer
; 898  : 		return (_Myt(current + _Off));
; 899  : 		}
; 900  : 
; 901  : 	reference operator[](difference_type _Off) const
; 902  : 		{	// subscript
; 903  : 		return (*(*this + _Off));
; 904  : 		}
; 905  : 
; 906  : 	template<class _RanIt2,
; 907  : 		class _Base2>
; 908  : 		bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
; 909  : 		{	// test if this < _Right
; 910  : 		return (_Right.base() < current);
; 911  : 		}
; 912  : 
; 913  : 	difference_type operator-(const _Myt& _Right) const
; 914  : 		{	// return difference of iterators
; 915  : 		return (_Right.base() - current);
; 916  : 		}
; 917  : 
; 918  : protected:
; 919  : 	_RanIt current;	// the wrapped iterator
; 920  : 	};
; 921  : 
; 922  : 		// _Revranit TEMPLATE OPERATORS
; 923  : template<class _RanIt,
; 924  : 	class _Base,
; 925  : 	class _Diff> inline
; 926  : 	_Revranit<_RanIt, _Base>
; 927  : 		operator+(_Diff _Off,
; 928  : 		const _Revranit<_RanIt, _Base>& _Right)
; 929  : 	{	// return reverse_iterator + integer
; 930  : 	return (_Right + _Off);
; 931  : 	}
; 932  : 
; 933  : template<class _RanIt1,
; 934  : 	class _Base1,
; 935  : 	class _RanIt2,
; 936  : 	class _Base2>
; 937  : 	auto inline operator-(
; 938  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 939  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 940  : 			-> decltype(_Right.base() - _Left.base())
; 941  : 	{	// return difference of reverse_iterators
; 942  : 	return (_Right.base() - _Left.base());
; 943  : 	}
; 944  : 
; 945  : template<class _RanIt1,
; 946  : 	class _Base1,
; 947  : 	class _RanIt2,
; 948  : 	class _Base2> inline
; 949  : 	bool operator==(
; 950  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 951  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 952  : 	{	// test for reverse_iterator equality
; 953  : 	return (_Left._Equal(_Right));
; 954  : 	}
; 955  : 
; 956  : template<class _RanIt1,
; 957  : 	class _Base1,
; 958  : 	class _RanIt2,
; 959  : 	class _Base2> inline
; 960  : 	bool operator!=(
; 961  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 962  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 963  : 	{	// test for reverse_iterator inequality
; 964  : 	return (!(_Left == _Right));
; 965  : 	}
; 966  : 
; 967  : template<class _RanIt1,
; 968  : 	class _Base1,
; 969  : 	class _RanIt2,
; 970  : 	class _Base2> inline
; 971  : 	bool operator<(
; 972  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 973  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 974  : 	{	// test for reverse_iterator < reverse_iterator
; 975  : 	return (_Left._Less(_Right));
; 976  : 	}
; 977  : 
; 978  : template<class _RanIt1,
; 979  : 	class _Base1,
; 980  : 	class _RanIt2,
; 981  : 	class _Base2> inline
; 982  : 	bool operator>(
; 983  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 984  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 985  : 	{	// test for reverse_iterator > reverse_iterator
; 986  : 	return (_Right < _Left);
; 987  : 	}
; 988  : 
; 989  : template<class _RanIt1,
; 990  : 	class _Base1,
; 991  : 	class _RanIt2,
; 992  : 	class _Base2> inline
; 993  : 	bool operator<=(
; 994  : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 995  : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 996  : 	{	// test for reverse_iterator <= reverse_iterator
; 997  : 	return (!(_Right < _Left));
; 998  : 	}
; 999  : 
; 1000 : template<class _RanIt1,
; 1001 : 	class _Base1,
; 1002 : 	class _RanIt2,
; 1003 : 	class _Base2> inline
; 1004 : 	bool operator>=(
; 1005 : 		const _Revranit<_RanIt1, _Base1>& _Left,
; 1006 : 		const _Revranit<_RanIt2, _Base2>& _Right)
; 1007 : 	{	// test for reverse_iterator >= reverse_iterator
; 1008 : 	return (!(_Left < _Right));
; 1009 : 	}
; 1010 : 
; 1011 : 		// TEMPLATE CLASS reverse_iterator
; 1012 : template<class _RanIt>
; 1013 : 	class reverse_iterator
; 1014 : 		: public _Revranit<_RanIt, iterator<
; 1015 : 			typename iterator_traits<_RanIt>::iterator_category,
; 1016 : 			typename iterator_traits<_RanIt>::value_type,
; 1017 : 			typename iterator_traits<_RanIt>::difference_type,
; 1018 : 			typename iterator_traits<_RanIt>::pointer,
; 1019 : 			typename iterator_traits<_RanIt>::reference> >
; 1020 : 	{	// wrap iterator to run it backwards
; 1021 : 	typedef reverse_iterator<_RanIt> _Myt;
; 1022 : 	typedef _Revranit<_RanIt, iterator<
; 1023 : 		typename iterator_traits<_RanIt>::iterator_category,
; 1024 : 		typename iterator_traits<_RanIt>::value_type,
; 1025 : 		typename iterator_traits<_RanIt>::difference_type,
; 1026 : 		typename iterator_traits<_RanIt>::pointer,
; 1027 : 		typename iterator_traits<_RanIt>::reference> > _Mybase;
; 1028 : 
; 1029 : public:
; 1030 : 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
; 1031 : 	typedef typename iterator_traits<_RanIt>::pointer pointer;
; 1032 : 	typedef typename iterator_traits<_RanIt>::reference reference;
; 1033 : 	typedef _RanIt iterator_type;
; 1034 : 
; 1035 : 	reverse_iterator()
; 1036 : 		{	// construct with default wrapped iterator
; 1037 : 		}
; 1038 : 
; 1039 : 	explicit reverse_iterator(_RanIt _Right)
; 1040 : 		: _Mybase(_Right)
; 1041 : 		{	// construct wrapped iterator from _Right
; 1042 : 		}
; 1043 : 
; 1044 : 	template<class _Other>
; 1045 : 		reverse_iterator(const reverse_iterator<_Other>& _Right)
; 1046 : 		: _Mybase(_Right.base())
; 1047 : 		{	// initialize with compatible base
; 1048 : 		}
; 1049 : 
; 1050 : 	reverse_iterator(_Mybase _Right)
; 1051 : 		: _Mybase(_Right)
; 1052 : 		{	// construct wrapped iterator from base object
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class _Other>
; 1056 : 		_Myt& operator=(const reverse_iterator<_Other>& _Right)
; 1057 : 		{	// assign from compatible base
; 1058 : 		this->current = _Right.base();
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& operator++()
; 1063 : 		{	// preincrement
; 1064 : 		++*((_Mybase *)this);
; 1065 : 		return (*this);
; 1066 : 		}
; 1067 : 
; 1068 : 	_Myt operator++(int)
; 1069 : 		{	// postincrement
; 1070 : 		_Myt _Tmp = *this;
; 1071 : 		++*this;
; 1072 : 		return (_Tmp);
; 1073 : 		}
; 1074 : 
; 1075 : 	_Myt& operator--()
; 1076 : 		{	// predecrement
; 1077 : 		--*((_Mybase *)this);
; 1078 : 		return (*this);
; 1079 : 		}
; 1080 : 
; 1081 : 	_Myt operator--(int)
; 1082 : 		{	// postdecrement
; 1083 : 		_Myt _Tmp = *this;
; 1084 : 		--*this;
; 1085 : 		return (_Tmp);
; 1086 : 		}
; 1087 : 
; 1088 : 	_Myt& operator+=(difference_type _Off)
; 1089 : 		{	// increment by integer
; 1090 : 		*((_Mybase *)this) += _Off;
; 1091 : 		return (*this);
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt operator+(difference_type _Off) const
; 1095 : 		{	// return this + integer
; 1096 : 		_Myt _Tmp = *this;
; 1097 : 		return (_Tmp += _Off);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Myt& operator-=(difference_type _Off)
; 1101 : 		{	// decrement by integer
; 1102 : 		*((_Mybase *)this) -= _Off;
; 1103 : 		return (*this);
; 1104 : 		}
; 1105 : 
; 1106 : 	_Myt operator-(difference_type _Off) const
; 1107 : 		{	// return this - integer
; 1108 : 		_Myt _Tmp = *this;
; 1109 : 		return (_Tmp -= _Off);
; 1110 : 		}
; 1111 : 	};
; 1112 : 
; 1113 : template<class _RanIt>
; 1114 : 	struct _Is_checked_helper<reverse_iterator<_RanIt> >
; 1115 : 		: public _Is_checked_helper<_RanIt>
; 1116 : 	{	// mark reverse_iterator as checked if its wrapped iterator is checked
; 1117 : 	};
; 1118 : 
; 1119 : 		// reverse_iterator TEMPLATE OPERATORS
; 1120 : template<class _RanIt,
; 1121 : 	class _Diff> inline
; 1122 : 	reverse_iterator<_RanIt> operator+(_Diff _Off,
; 1123 : 		const reverse_iterator<_RanIt>& _Right)
; 1124 : 	{	// return reverse_iterator + integer
; 1125 : 	return (_Right + _Off);
; 1126 : 	}
; 1127 : 
; 1128 : template<class _RanIt1,
; 1129 : 	class _RanIt2>
; 1130 : 	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
; 1131 : 		const reverse_iterator<_RanIt2>& _Right)
; 1132 : 			-> decltype(_Right.base() - _Left.base())
; 1133 : 	{	// return difference of reverse_iterators
; 1134 : 	return (_Right.base() - _Left.base());
; 1135 : 	}
; 1136 : 
; 1137 : template<class _RanIt1,
; 1138 : 	class _RanIt2> inline
; 1139 : 	bool operator==(const reverse_iterator<_RanIt1>& _Left,
; 1140 : 		const reverse_iterator<_RanIt2>& _Right)
; 1141 : 	{	// test for reverse_iterator equality
; 1142 : 	return (_Left._Equal(_Right));
; 1143 : 	}
; 1144 : 
; 1145 : template<class _RanIt1,
; 1146 : 	class _RanIt2> inline
; 1147 : 	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
; 1148 : 		const reverse_iterator<_RanIt2>& _Right)
; 1149 : 	{	// test for reverse_iterator inequality
; 1150 : 	return (!(_Left == _Right));
; 1151 : 	}
; 1152 : 
; 1153 : template<class _RanIt1,
; 1154 : 	class _RanIt2> inline
; 1155 : 	bool operator<(const reverse_iterator<_RanIt1>& _Left,
; 1156 : 		const reverse_iterator<_RanIt2>& _Right)
; 1157 : 	{	// test for reverse_iterator < reverse_iterator
; 1158 : 	return (_Left._Less(_Right));
; 1159 : 	}
; 1160 : 
; 1161 : template<class _RanIt1,
; 1162 : 	class _RanIt2> inline
; 1163 : 	bool operator>(const reverse_iterator<_RanIt1>& _Left,
; 1164 : 		const reverse_iterator<_RanIt2>& _Right)
; 1165 : 	{	// test for reverse_iterator > reverse_iterator
; 1166 : 	return (_Right < _Left);
; 1167 : 	}
; 1168 : 
; 1169 : template<class _RanIt1,
; 1170 : 	class _RanIt2> inline
; 1171 : 	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
; 1172 : 		const reverse_iterator<_RanIt2>& _Right)
; 1173 : 	{	// test for reverse_iterator <= reverse_iterator
; 1174 : 	return (!(_Right < _Left));
; 1175 : 	}
; 1176 : 
; 1177 : template<class _RanIt1,
; 1178 : 	class _RanIt2> inline
; 1179 : 	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
; 1180 : 		const reverse_iterator<_RanIt2>& _Right)
; 1181 : 	{	// test for reverse_iterator >= reverse_iterator
; 1182 : 	return (!(_Left < _Right));
; 1183 : 	}
; 1184 : 
; 1185 : 
; 1186 : 		// TEMPLATE FUNCTIONS begin AND end
; 1187 : template<class _Container>
; 1188 : 	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
; 1189 : 	{	// get beginning of sequence
; 1190 : 	return (_Cont.begin());
; 1191 : 	}
; 1192 : 
; 1193 : template<class _Container>
; 1194 : 	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
; 1195 : 	{	// get beginning of sequence
; 1196 : 	return (_Cont.begin());
; 1197 : 	}
; 1198 : 
; 1199 : template<class _Container>
; 1200 : 	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
; 1201 : 	{	// get end of sequence
; 1202 : 	return (_Cont.end());
; 1203 : 	}
; 1204 : 
; 1205 : template<class _Container>
; 1206 : 	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
; 1207 : 	{	// get end of sequence
; 1208 : 	return (_Cont.end());
; 1209 : 	}
; 1210 : 
; 1211 : template<class _Ty,
; 1212 : 	size_t _Size> inline
; 1213 : 	_Ty *begin(_Ty (&_Array)[_Size])
; 1214 : 	{	// get beginning of array
; 1215 : 	return (_Array);
; 1216 : 	}
; 1217 : 
; 1218 : template<class _Ty,
; 1219 : 	size_t _Size> inline
; 1220 : 	_Ty *end(_Ty (&_Array)[_Size])
; 1221 : 	{	// get end of array
; 1222 : 	return (_Array + _Size);
; 1223 : 	}
; 1224 : 
; 1225 : 		// TEMPLATE FUNCTIONS cbegin AND cend
; 1226 : template<class _Container>
; 1227 : 	auto inline cbegin(const _Container& _Cont) -> decltype(_STD begin(_Cont))
; 1228 : 	{	// get beginning of sequence
; 1229 : 	return (_STD begin(_Cont));
; 1230 : 	}
; 1231 : 
; 1232 : template<class _Container>
; 1233 : 	auto inline cend(const _Container& _Cont) -> decltype(_STD end(_Cont))
; 1234 : 	{	// get end of sequence
; 1235 : 	return (_STD end(_Cont));
; 1236 : 	}
; 1237 : 
; 1238 : 		// TEMPLATE FUNCTIONS rbegin AND rend
; 1239 : template<class _Container>
; 1240 : 	auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
; 1241 : 	{	// get beginning of reversed sequence
; 1242 : 	return (_Cont.rbegin());
; 1243 : 	}
; 1244 : 
; 1245 : template<class _Container>
; 1246 : 	auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
; 1247 : 	{	// get beginning of reversed sequence
; 1248 : 	return (_Cont.rbegin());
; 1249 : 	}
; 1250 : 
; 1251 : template<class _Container>
; 1252 : 	auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
; 1253 : 	{	// get end of reversed sequence
; 1254 : 	return (_Cont.rend());
; 1255 : 	}
; 1256 : 
; 1257 : template<class _Container>
; 1258 : 	auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
; 1259 : 	{	// get end of reversed sequence
; 1260 : 	return (_Cont.rend());
; 1261 : 	}
; 1262 : 
; 1263 : template<class _Ty,
; 1264 : 	size_t _Size> inline
; 1265 : 	reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
; 1266 : 	{	// get beginning of reversed array
; 1267 : 	return (reverse_iterator<_Ty *>(_Array + _Size));
; 1268 : 	}
; 1269 : 
; 1270 : template<class _Ty,
; 1271 : 	size_t _Size> inline
; 1272 : 	reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
; 1273 : 	{	// get end of reversed array
; 1274 : 	return (reverse_iterator<_Ty *>(_Array));
; 1275 : 	}
; 1276 : 
; 1277 : template<class _Elem> inline
; 1278 : 	reverse_iterator<const _Elem *> rbegin(initializer_list<_Elem> _Ilist)
; 1279 : 	{	// get beginning of reversed sequence
; 1280 : 	return (reverse_iterator<const _Elem *>(_Ilist.end()));
; 1281 : 	}
; 1282 : 
; 1283 : template<class _Elem> inline
; 1284 : 	reverse_iterator<const _Elem *> rend(initializer_list<_Elem> _Ilist)
; 1285 : 	{	// get end of reversed sequence
; 1286 : 	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
; 1287 : 	}
; 1288 : 
; 1289 : 		// TEMPLATE FUNCTIONS crbegin AND crend
; 1290 : template<class _Container>
; 1291 : 	auto inline crbegin(const _Container& _Cont) -> decltype(_STD rbegin(_Cont))
; 1292 : 	{	// get beginning of reversed sequence
; 1293 : 	return (_STD rbegin(_Cont));
; 1294 : 	}
; 1295 : 
; 1296 : template<class _Container>
; 1297 : 	auto inline crend(const _Container& _Cont) -> decltype(_STD rend(_Cont))
; 1298 : 	{	// get end of reversed sequence
; 1299 : 	return (_STD rend(_Cont));
; 1300 : 	}
; 1301 : 
; 1302 : 
; 1303 : 		// TEMPLATE CLASS _Array_const_iterator
; 1304 : template<class _Ty,
; 1305 : 	size_t _Size>
; 1306 : 	class _Array_const_iterator
; 1307 : 		: public _Iterator012<random_access_iterator_tag,
; 1308 : 			_Ty,
; 1309 : 			ptrdiff_t,
; 1310 : 			const _Ty *,
; 1311 : 			const _Ty&,
; 1312 : 			_Iterator_base>
; 1313 : 	{	// iterator for nonmutable array
; 1314 : public:
; 1315 : 	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
; 1316 : 	typedef random_access_iterator_tag iterator_category;
; 1317 : 
; 1318 : 	typedef _Ty value_type;
; 1319 : 	typedef size_t size_type;
; 1320 : 	typedef ptrdiff_t difference_type;
; 1321 : 	typedef const _Ty *pointer;
; 1322 : 	typedef const _Ty& reference;
; 1323 : 	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
; 1324 : 	enum {_EEN_IDL =
; 1325 : 		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator
; 1326 : 
; 1327 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 1328 : 	_Array_const_iterator()
; 1329 : 		{	// construct with null pointer
; 1330 : 		_Ptr = 0;
; 1331 : 		}
; 1332 : 
; 1333 : 	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
; 1334 : 		{	// construct with pointer and offset
; 1335 : 		_Ptr = _Parg + _Off;
; 1336 : 		}
; 1337 : 
; 1338 : 	typedef pointer _Unchecked_type;
; 1339 : 
; 1340 : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 1341 : 		{	// reset from unchecked iterator
; 1342 : 		_Ptr = _Right;
; 1343 : 		return (*this);
; 1344 : 		}
; 1345 : 
; 1346 : 	_Unchecked_type _Unchecked() const
; 1347 : 		{	// make an unchecked iterator
; 1348 : 		return (_Ptr);
; 1349 : 		}
; 1350 : 
; 1351 : 	reference operator*() const
; 1352 : 		{	// return designated object
; 1353 : 		return (*_Ptr);
; 1354 : 		}
; 1355 : 
; 1356 : 	pointer operator->() const
; 1357 : 		{	// return pointer to class object
; 1358 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 1359 : 		}
; 1360 : 
; 1361 : 	_Myiter& operator++()
; 1362 : 		{	// preincrement
; 1363 : 		++_Ptr;
; 1364 : 		return (*this);
; 1365 : 		}
; 1366 : 
; 1367 : 	_Myiter operator++(int)
; 1368 : 		{	// postincrement
; 1369 : 		_Myiter _Tmp = *this;
; 1370 : 		++*this;
; 1371 : 		return (_Tmp);
; 1372 : 		}
; 1373 : 
; 1374 : 	_Myiter& operator--()
; 1375 : 		{	// predecrement
; 1376 : 		--_Ptr;
; 1377 : 		return (*this);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myiter operator--(int)
; 1381 : 		{	// postdecrement
; 1382 : 		_Myiter _Tmp = *this;
; 1383 : 		--*this;
; 1384 : 		return (_Tmp);
; 1385 : 		}
; 1386 : 
; 1387 : 	_Myiter& operator+=(difference_type _Off)
; 1388 : 		{	// increment by integer
; 1389 : 		_Ptr += _Off;
; 1390 : 		return (*this);
; 1391 : 		}
; 1392 : 
; 1393 : 	_Myiter operator+(difference_type _Off) const
; 1394 : 		{	// return this + integer
; 1395 : 		_Myiter _Tmp = *this;
; 1396 : 		return (_Tmp += _Off);
; 1397 : 		}
; 1398 : 
; 1399 : 	_Myiter& operator-=(difference_type _Off)
; 1400 : 		{	// decrement by integer
; 1401 : 		return (*this += -_Off);
; 1402 : 		}
; 1403 : 
; 1404 : 	_Myiter operator-(difference_type _Off) const
; 1405 : 		{	// return this - integer
; 1406 : 		_Myiter _Tmp = *this;
; 1407 : 		return (_Tmp -= _Off);
; 1408 : 		}
; 1409 : 
; 1410 : 	difference_type operator-(const _Myiter& _Right) const
; 1411 : 		{	// return difference of iterators
; 1412 : 		return (_Ptr - _Right._Ptr);
; 1413 : 		}
; 1414 : 
; 1415 : 	reference operator[](difference_type _Off) const
; 1416 : 		{	// subscript
; 1417 : 		return (*(*this + _Off));
; 1418 : 		}
; 1419 : 
; 1420 : 	bool operator==(const _Myiter& _Right) const
; 1421 : 		{	// test for iterator equality
; 1422 : 		return (_Ptr == _Right._Ptr);
; 1423 : 		}
; 1424 : 
; 1425 : 	bool operator!=(const _Myiter& _Right) const
; 1426 : 		{	// test for iterator inequality
; 1427 : 		return (!(*this == _Right));
; 1428 : 		}
; 1429 : 
; 1430 : 	bool operator<(const _Myiter& _Right) const
; 1431 : 		{	// test if this < _Right
; 1432 : 		return (_Ptr < _Right._Ptr);
; 1433 : 		}
; 1434 : 
; 1435 : 	bool operator>(const _Myiter& _Right) const
; 1436 : 		{	// test if this > _Right
; 1437 : 		return (_Right < *this);
; 1438 : 		}
; 1439 : 
; 1440 : 	bool operator<=(const _Myiter& _Right) const
; 1441 : 		{	// test if this <= _Right
; 1442 : 		return (!(_Right < *this));
; 1443 : 		}
; 1444 : 
; 1445 : 	bool operator>=(const _Myiter& _Right) const
; 1446 : 		{	// test if this >= _Right
; 1447 : 		return (!(*this < _Right));
; 1448 : 		}
; 1449 : 
; 1450 : 	pointer _Ptr;	// beginning of array
; 1451 : 
; 1452 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 1453 : 	_Array_const_iterator()
; 1454 : 		{	// construct with null pointer
; 1455 : 		_Ptr = 0;
; 1456 : 		_Idx = 0;
; 1457 : 		}
; 1458 : 
; 1459 : 	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
; 1460 : 		{	// construct with pointer and offset
; 1461 : 		_Ptr = _Parg;
; 1462 : 		_Idx = _Off;
; 1463 : 		}
; 1464 : 
; 1465 : 	typedef pointer _Unchecked_type;
; 1466 : 
; 1467 : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 1468 : 		{	// reset from unchecked iterator
; 1469 : 		_Idx = _Right - _Ptr;
; 1470 : 		return (*this);
; 1471 : 		}
; 1472 : 
; 1473 : 	_Unchecked_type _Unchecked() const
; 1474 : 		{	// make an unchecked iterator
; 1475 : 		return (_Ptr + _Idx);
; 1476 : 		}
; 1477 : 
; 1478 : 	reference operator*() const
; 1479 : 		{	// return designated object
; 1480 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1481 : 		if (_Ptr == 0
; 1482 : 			|| _Size <= _Idx)
; 1483 : 			{	// report error
; 1484 : 			_DEBUG_ERROR("array iterator not dereferencable");
; 1485 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1486 : 			}
; 1487 : 
; 1488 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1489 : 		_SCL_SECURE_VALIDATE(_Ptr != 0);
; 1490 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1492 : 
; 1493 : 		_Analysis_assume_(_Ptr != 0);
; 1494 : 
; 1495 : 		return (_Ptr[_Idx]);
; 1496 : 		}
; 1497 : 
; 1498 : 	pointer operator->() const
; 1499 : 		{	// return pointer to class object
; 1500 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 1501 : 		}
; 1502 : 
; 1503 : 	_Myiter& operator++()
; 1504 : 		{	// preincrement
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 		if (_Ptr == 0
; 1507 : 			|| _Size <= _Idx)
; 1508 : 			{	// report error
; 1509 : 			_DEBUG_ERROR("array iterator not incrementable");
; 1510 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1511 : 			}
; 1512 : 
; 1513 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1514 : 		_SCL_SECURE_VALIDATE(_Ptr != 0);
; 1515 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
; 1516 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1517 : 
; 1518 : 		++_Idx;
; 1519 : 		return (*this);
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myiter operator++(int)
; 1523 : 		{	// postincrement
; 1524 : 		_Myiter _Tmp = *this;
; 1525 : 		++*this;
; 1526 : 		return (_Tmp);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myiter& operator--()
; 1530 : 		{	// predecrement
; 1531 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1532 : 		if (_Ptr == 0
; 1533 : 			|| _Idx <= 0)
; 1534 : 			{	// report error
; 1535 : 			_DEBUG_ERROR("array iterator not decrementable");
; 1536 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1537 : 			}
; 1538 : 
; 1539 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1540 : 		_SCL_SECURE_VALIDATE(_Ptr != 0);
; 1541 : 		_SCL_SECURE_VALIDATE_RANGE(0 < _Idx);
; 1542 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1543 : 
; 1544 : 		--_Idx;
; 1545 : 		return (*this);
; 1546 : 		}
; 1547 : 
; 1548 : 	_Myiter operator--(int)
; 1549 : 		{	// postdecrement
; 1550 : 		_Myiter _Tmp = *this;
; 1551 : 		--*this;
; 1552 : 		return (_Tmp);
; 1553 : 		}
; 1554 : 
; 1555 : 	_Myiter& operator+=(difference_type _Off)
; 1556 : 		{	// increment by integer
; 1557 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1558 : 		if (_Size < _Idx + _Off)
; 1559 : 			{	// report error
; 1560 : 			_DEBUG_ERROR("array iterator + offset out of range");
; 1561 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1562 : 			}
; 1563 : 
; 1564 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1565 : 		_SCL_SECURE_VALIDATE_RANGE(_Idx + _Off <= _Size);
; 1566 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1567 : 
; 1568 : 		_Idx += _Off;
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myiter operator+(difference_type _Off) const
; 1573 : 		{	// return this + integer
; 1574 : 		_Myiter _Tmp = *this;
; 1575 : 		return (_Tmp += _Off);
; 1576 : 		}
; 1577 : 
; 1578 : 	_Myiter& operator-=(difference_type _Off)
; 1579 : 		{	// decrement by integer
; 1580 : 		return (*this += -_Off);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myiter operator-(difference_type _Off) const
; 1584 : 		{	// return this - integer
; 1585 : 		_Myiter _Tmp = *this;
; 1586 : 		return (_Tmp -= _Off);
; 1587 : 		}
; 1588 : 
; 1589 : 	difference_type operator-(const _Myiter& _Right) const
; 1590 : 		{	// return difference of iterators
; 1591 : 		_Compat(_Right);
; 1592 : 		return (_Idx < _Right._Idx
; 1593 : 			? -(difference_type)(_Right._Idx - _Idx)
; 1594 : 			: (difference_type)_Idx - _Right._Idx);
; 1595 : 		}
; 1596 : 
; 1597 : 	reference operator[](difference_type _Off) const
; 1598 : 		{	// subscript
; 1599 : 		return (*(*this + _Off));
; 1600 : 		}
; 1601 : 
; 1602 : 	bool operator==(const _Myiter& _Right) const
; 1603 : 		{	// test for iterator equality
; 1604 : 		_Compat(_Right);
; 1605 : 		return (_Idx == _Right._Idx);
; 1606 : 		}
; 1607 : 
; 1608 : 	bool operator!=(const _Myiter& _Right) const
; 1609 : 		{	// test for iterator inequality
; 1610 : 		return (!(*this == _Right));
; 1611 : 		}
; 1612 : 
; 1613 : 	bool operator<(const _Myiter& _Right) const
; 1614 : 		{	// test if this < _Right
; 1615 : 		_Compat(_Right);
; 1616 : 		return (_Idx < _Right._Idx);
; 1617 : 		}
; 1618 : 
; 1619 : 	bool operator>(const _Myiter& _Right) const
; 1620 : 		{	// test if this > _Right
; 1621 : 		return (_Right < *this);
; 1622 : 		}
; 1623 : 
; 1624 : 	bool operator<=(const _Myiter& _Right) const
; 1625 : 		{	// test if this <= _Right
; 1626 : 		return (!(_Right < *this));
; 1627 : 		}
; 1628 : 
; 1629 : 	bool operator>=(const _Myiter& _Right) const
; 1630 : 		{	// test if this >= _Right
; 1631 : 		return (!(*this < _Right));
; 1632 : 		}
; 1633 : 
; 1634 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1635 : 	void _Compat(const _Myiter& _Right) const
; 1636 : 		{	// test for compatible iterator pair
; 1637 : 		if (_Ptr != _Right._Ptr)
; 1638 : 			{	// report error
; 1639 : 			_DEBUG_ERROR("array iterators incompatible");
; 1640 : 			_SCL_SECURE_INVALID_ARGUMENT;
; 1641 : 			}
; 1642 : 		}
; 1643 : 
; 1644 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1645 : 	void _Compat(const _Myiter& _Right) const
; 1646 : 		{	// test for compatible iterator pair
; 1647 : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr == _Right._Ptr);
; 1648 : 		}
; 1649 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1650 : 
; 1651 : 	pointer _Ptr;	// beginning of array
; 1652 : 	size_t _Idx;	// offset into array
; 1653 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 1654 : 	};
; 1655 : 
; 1656 : template<class _Ty,
; 1657 : 	size_t _Size> inline
; 1658 : 	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
; 1659 : 		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
; 1660 : 	{	// convert to unchecked
; 1661 : 	return (_Iter._Unchecked());
; 1662 : 	}
; 1663 : 
; 1664 : template<class _Ty,
; 1665 : 	size_t _Size> inline
; 1666 : 	_Array_const_iterator<_Ty, _Size>&
; 1667 : 		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
; 1668 : 			typename _Array_const_iterator<_Ty, _Size>
; 1669 : 				::_Unchecked_type _Right)
; 1670 : 	{	// convert to checked
; 1671 : 	return (_Iter._Rechecked(_Right));
; 1672 : 	}
; 1673 : 
; 1674 : template<class _Ty,
; 1675 : 	size_t _Size> inline
; 1676 : 	_Array_const_iterator<_Ty, _Size> operator+(
; 1677 : 		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
; 1678 : 		_Array_const_iterator<_Ty, _Size> _Next)
; 1679 : 	{	// add offset to iterator
; 1680 : 	return (_Next += _Off);
; 1681 : 	}
; 1682 : 
; 1683 : 		// TEMPLATE CLASS _Array_iterator
; 1684 : template<class _Ty,
; 1685 : 	size_t _Size>
; 1686 : 	class _Array_iterator
; 1687 : 		: public _Array_const_iterator<_Ty, _Size>
; 1688 : 	{	// iterator for mutable array
; 1689 : public:
; 1690 : 	typedef _Array_iterator<_Ty, _Size> _Myiter;
; 1691 : 	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
; 1692 : 	typedef random_access_iterator_tag iterator_category;
; 1693 : 
; 1694 : 	typedef _Ty value_type;
; 1695 : 	typedef size_t size_type;
; 1696 : 	typedef ptrdiff_t difference_type;
; 1697 : 	typedef _Ty *pointer;
; 1698 : 	typedef _Ty& reference;
; 1699 : 
; 1700 : 	_Array_iterator()
; 1701 : 		{	// construct with null pointer
; 1702 : 		}
; 1703 : 
; 1704 : 	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
; 1705 : 		: _Mybase(_Parg, _Off)
; 1706 : 		{	// construct with pointer and offset
; 1707 : 		}
; 1708 : 	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
; 1709 : 	enum {_EEN_IDL =
; 1710 : 		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator
; 1711 : 
; 1712 : 	typedef pointer _Unchecked_type;
; 1713 : 
; 1714 : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 1715 : 		{	// reset from unchecked iterator
; 1716 : 		((_Mybase *)this)->_Rechecked(_Right);
; 1717 : 		return (*this);
; 1718 : 		}
; 1719 : 
; 1720 : 	_Unchecked_type _Unchecked() const
; 1721 : 		{	// make an unchecked iterator
; 1722 : 		return ((pointer)((_Mybase *)this)->_Unchecked());
; 1723 : 		}
; 1724 : 
; 1725 : 	reference operator*() const
; 1726 : 		{	// return designated object
; 1727 : 		return ((reference)**(_Mybase *)this);
; 1728 : 		}
; 1729 : 
; 1730 : 	pointer operator->() const
; 1731 : 		{	// return pointer to class object
; 1732 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 1733 : 		}
; 1734 : 
; 1735 : 	_Myiter& operator++()
; 1736 : 		{	// preincrement
; 1737 : 		++*(_Mybase *)this;
; 1738 : 		return (*this);
; 1739 : 		}
; 1740 : 
; 1741 : 	_Myiter operator++(int)
; 1742 : 		{	// postincrement
; 1743 : 		_Myiter _Tmp = *this;
; 1744 : 		++*this;
; 1745 : 		return (_Tmp);
; 1746 : 		}
; 1747 : 
; 1748 : 	_Myiter& operator--()
; 1749 : 		{	// predecrement
; 1750 : 		--*(_Mybase *)this;
; 1751 : 		return (*this);
; 1752 : 		}
; 1753 : 
; 1754 : 	_Myiter operator--(int)
; 1755 : 		{	// postdecrement
; 1756 : 		_Myiter _Tmp = *this;
; 1757 : 		--*this;
; 1758 : 		return (_Tmp);
; 1759 : 		}
; 1760 : 
; 1761 : 	_Myiter& operator+=(difference_type _Off)
; 1762 : 		{	// increment by integer
; 1763 : 		*(_Mybase *)this += _Off;
; 1764 : 		return (*this);
; 1765 : 		}
; 1766 : 
; 1767 : 	_Myiter operator+(difference_type _Off) const
; 1768 : 		{	// return this + integer
; 1769 : 		_Myiter _Tmp = *this;
; 1770 : 		return (_Tmp += _Off);
; 1771 : 		}
; 1772 : 
; 1773 : 	_Myiter& operator-=(difference_type _Off)
; 1774 : 		{	// decrement by integer
; 1775 : 		return (*this += -_Off);
; 1776 : 		}
; 1777 : 
; 1778 : 	_Myiter operator-(difference_type _Off) const
; 1779 : 		{	// return this - integer
; 1780 : 		_Myiter _Tmp = *this;
; 1781 : 		return (_Tmp -= _Off);
; 1782 : 		}
; 1783 : 
; 1784 : 	difference_type operator-(const _Mybase& _Right) const
; 1785 : 		{	// return difference of iterators
; 1786 : 		return (*(_Mybase *)this - _Right);
; 1787 : 		}
; 1788 : 
; 1789 : 	reference operator[](difference_type _Off) const
; 1790 : 		{	// subscript
; 1791 : 		return (*(*this + _Off));
; 1792 : 		}
; 1793 : 	};
; 1794 : 
; 1795 : template<class _Ty,
; 1796 : 	size_t _Size> inline
; 1797 : 	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
; 1798 : 		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
; 1799 : 	{	// convert to unchecked
; 1800 : 	return (_Iter._Unchecked());
; 1801 : 	}
; 1802 : 
; 1803 : template<class _Ty,
; 1804 : 	size_t _Size> inline
; 1805 : 	_Array_iterator<_Ty, _Size>&
; 1806 : 		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
; 1807 : 			typename _Array_iterator<_Ty, _Size>
; 1808 : 				::_Unchecked_type _Right)
; 1809 : 	{	// convert to checked
; 1810 : 	return (_Iter._Rechecked(_Right));
; 1811 : 	}
; 1812 : 
; 1813 : template<class _Ty,
; 1814 : 	size_t _Size> inline
; 1815 : 	_Array_iterator<_Ty, _Size> operator+(
; 1816 : 		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
; 1817 : 		_Array_iterator<_Ty, _Size> _Next)
; 1818 : 	{	// add offset to iterator
; 1819 : 	return (_Next += _Off);
; 1820 : 	}
; 1821 : 
; 1822 : 		// TEMPLATE CLASS move_iterator
; 1823 : template<class _RanIt>
; 1824 : 	class move_iterator
; 1825 : 	{	// wrap iterator to move rvalues
; 1826 : public:
; 1827 : 	typedef move_iterator<_RanIt> _Myt;
; 1828 : 	typedef typename iterator_traits<_RanIt>::iterator_category
; 1829 : 		iterator_category;
; 1830 : 	typedef typename iterator_traits<_RanIt>::value_type
; 1831 : 		value_type;
; 1832 : 	typedef typename iterator_traits<_RanIt>::difference_type
; 1833 : 		difference_type;
; 1834 : 	typedef _RanIt pointer;
; 1835 : 	typedef value_type&& reference;
; 1836 : 	typedef _RanIt iterator_type;
; 1837 : 
; 1838 : 	move_iterator()
; 1839 : 		{	// construct with default wrapped iterator
; 1840 : 		}
; 1841 : 
; 1842 : 	explicit move_iterator(iterator_type _Right)
; 1843 : 		: current(_Right)
; 1844 : 		{	// construct wrapped iterator from _Right
; 1845 : 		}
; 1846 : 
; 1847 : 	template<class _RanIt2>
; 1848 : 		move_iterator(const move_iterator<_RanIt2>& _Right)
; 1849 : 		: current(_Right.base())
; 1850 : 		{	// initialize with compatible base
; 1851 : 		}
; 1852 : 
; 1853 : 	template<class _RanIt2>
; 1854 : 		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
; 1855 : 		{	// assign with compatible base
; 1856 : 		current = _Right.base();
; 1857 : 		return (*this);
; 1858 : 		}
; 1859 : 
; 1860 : 	_RanIt base() const
; 1861 : 		{	// return wrapped iterator
; 1862 : 		return (current);
; 1863 : 		}
; 1864 : 
; 1865 : 	reference operator*() const
; 1866 : 		{	// return designated value
; 1867 : 		return (_STD move(*current));
; 1868 : 		}
; 1869 : 
; 1870 : 	pointer operator->() const
; 1871 : 		{	// return pointer to class object
; 1872 : 		return (current);
; 1873 : 		}
; 1874 : 
; 1875 : 	_Myt& operator++()
; 1876 : 		{	// preincrement
; 1877 : 		++current;
; 1878 : 		return (*this);
; 1879 : 		}
; 1880 : 
; 1881 : 	_Myt operator++(int)
; 1882 : 		{	// postincrement
; 1883 : 		_Myt _Tmp = *this;
; 1884 : 		++current;
; 1885 : 		return (_Tmp);
; 1886 : 		}
; 1887 : 
; 1888 : 	_Myt& operator--()
; 1889 : 		{	// predecrement
; 1890 : 		--current;
; 1891 : 		return (*this);
; 1892 : 		}
; 1893 : 
; 1894 : 	_Myt operator--(int)
; 1895 : 		{	// postdecrement
; 1896 : 		_Myt _Tmp = *this;
; 1897 : 		--current;
; 1898 : 		return (_Tmp);
; 1899 : 		}
; 1900 : 
; 1901 : 	template<class _RanIt2>
; 1902 : 		bool _Equal(const move_iterator<_RanIt2>& _Right) const
; 1903 : 		{	// test for iterator equality
; 1904 : 		return (current == _Right.base());
; 1905 : 		}
; 1906 : 
; 1907 : // N.B. functions valid for random-access iterators only beyond this point
; 1908 : 
; 1909 : 	_Myt& operator+=(difference_type _Off)
; 1910 : 		{	// increment by integer
; 1911 : 		current += _Off;
; 1912 : 		return (*this);
; 1913 : 		}
; 1914 : 
; 1915 : 	_Myt operator+(difference_type _Off) const
; 1916 : 		{	// return this + integer
; 1917 : 		return (_Myt(current + _Off));
; 1918 : 		}
; 1919 : 
; 1920 : 	_Myt& operator-=(difference_type _Off)
; 1921 : 		{	// decrement by integer
; 1922 : 		current -= _Off;
; 1923 : 		return (*this);
; 1924 : 		}
; 1925 : 
; 1926 : 	_Myt operator-(difference_type _Off) const
; 1927 : 		{	// return this - integer
; 1928 : 		return (_Myt(current - _Off));
; 1929 : 		}
; 1930 : 
; 1931 : 	reference operator[](difference_type _Off) const
; 1932 : 		{	// subscript
; 1933 : 		return (_STD move(current[_Off]));
; 1934 : 		}
; 1935 : 
; 1936 : 	template<class _RanIt2>
; 1937 : 		bool _Less(const move_iterator<_RanIt2>& _Right) const
; 1938 : 		{	// test if this < _Right
; 1939 : 		return (current < _Right.base());
; 1940 : 		}
; 1941 : 
; 1942 : 	difference_type operator-(const _Myt& _Right) const
; 1943 : 		{	// return difference of iterators
; 1944 : 		return (current - _Right.base());
; 1945 : 		}
; 1946 : 
; 1947 : protected:
; 1948 : 	iterator_type current;	// the wrapped iterator
; 1949 : 	};
; 1950 : 
; 1951 : template<class _RanIt>
; 1952 : 	struct _Is_checked_helper<move_iterator<_RanIt> >
; 1953 : 		: public _Is_checked_helper<_RanIt>
; 1954 : 	{	// mark move_iterator as checked if its wrapped iterator is checked
; 1955 : 	};
; 1956 : 
; 1957 : 		// move_iterator TEMPLATE OPERATORS
; 1958 : template<class _RanIt,
; 1959 : 	class _Diff> inline
; 1960 : 	move_iterator<_RanIt>
; 1961 : 		operator+(_Diff _Off,
; 1962 : 		const move_iterator<_RanIt>& _Right)
; 1963 : 	{	// return move_iterator + integer
; 1964 : 	return (_Right + _Off);
; 1965 : 	}
; 1966 : 
; 1967 : template<class _RanIt1,
; 1968 : 	class _RanIt2>
; 1969 : 	auto inline operator-(
; 1970 : 		move_iterator<_RanIt1>& _Left,
; 1971 : 		const move_iterator<_RanIt2>& _Right)
; 1972 : 			-> decltype(_Left.base() - _Right.base())
; 1973 : 	{	// test for move_iterator equality
; 1974 : 	return (_Left.base() - _Right.base());
; 1975 : 	}
; 1976 : 
; 1977 : template<class _RanIt1,
; 1978 : 	class _RanIt2> inline
; 1979 : 	bool operator==(
; 1980 : 		const move_iterator<_RanIt1>& _Left,
; 1981 : 		const move_iterator<_RanIt2>& _Right)
; 1982 : 	{	// test for move_iterator equality
; 1983 : 	return (_Left._Equal(_Right));
; 1984 : 	}
; 1985 : 
; 1986 : template<class _RanIt1,
; 1987 : 	class _RanIt2> inline
; 1988 : 	bool operator!=(
; 1989 : 		const move_iterator<_RanIt1>& _Left,
; 1990 : 		const move_iterator<_RanIt2>& _Right)
; 1991 : 	{	// test for move_iterator inequality
; 1992 : 	return (!(_Left == _Right));
; 1993 : 	}
; 1994 : 
; 1995 : template<class _RanIt1,
; 1996 : 	class _RanIt2> inline
; 1997 : 	bool operator<(
; 1998 : 		const move_iterator<_RanIt1>& _Left,
; 1999 : 		const move_iterator<_RanIt2>& _Right)
; 2000 : 	{	// test for move_iterator < move_iterator
; 2001 : 	return (_Left._Less(_Right));
; 2002 : 	}
; 2003 : 
; 2004 : template<class _RanIt1,
; 2005 : 	class _RanIt2> inline
; 2006 : 	bool operator>(
; 2007 : 		const move_iterator<_RanIt1>& _Left,
; 2008 : 		const move_iterator<_RanIt2>& _Right)
; 2009 : 	{	// test for move_iterator > move_iterator
; 2010 : 	return (_Right < _Left);
; 2011 : 	}
; 2012 : 
; 2013 : template<class _RanIt1,
; 2014 : 	class _RanIt2> inline
; 2015 : 	bool operator<=(
; 2016 : 		const move_iterator<_RanIt1>& _Left,
; 2017 : 		const move_iterator<_RanIt2>& _Right)
; 2018 : 	{	// test for move_iterator <= move_iterator
; 2019 : 	return (!(_Right < _Left));
; 2020 : 	}
; 2021 : 
; 2022 : template<class _RanIt1,
; 2023 : 	class _RanIt2> inline
; 2024 : 	bool operator>=(
; 2025 : 		const move_iterator<_RanIt1>& _Left,
; 2026 : 		const move_iterator<_RanIt2>& _Right)
; 2027 : 	{	// test for move_iterator >= move_iterator
; 2028 : 	return (!(_Left < _Right));
; 2029 : 	}
; 2030 : 
; 2031 : 		// TEMPLATE FUNCTION make_move_iterator
; 2032 : template<class _RanIt> inline
; 2033 : 	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
; 2034 : 	{	// make move_iterator from iterator
; 2035 : 	return (move_iterator<_RanIt>(_Iter));
; 2036 : 	}
; 2037 : 
; 2038 : 		// TEMPLATE FUNCTION copy
; 2039 : template<class _InIt,
; 2040 : 	class _OutIt> inline
; 2041 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2042 : 		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
; 2043 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)
; 2045 : 		*_Dest = *_First;
; 2046 : 	return (_Dest);
; 2047 : 	}
; 2048 : 
; 2049 : template<class _InIt,
; 2050 : 	class _OutIt> inline
; 2051 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2052 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2053 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars
; 2054 : 	ptrdiff_t _Count = _Last - _First;
; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));
; 2057 : 	return (_Dest + _Count);
; 2058 : 	}
; 2059 : 
; 2060 : template<class _InIt,
; 2061 : 	class _OutIt> inline
; 2062 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2063 : 		_OutIt _Dest)
; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2067 : 	}
; 2068 : 
; 2069 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2070 : template<class _InIt,
; 2071 : 	class _OutIt> inline
; 2072 : 	_OutIt copy(_InIt _First, _InIt _Last,
; 2073 : 		_OutIt _Dest)
; 2074 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2075 : 	return (_Rechecked(_Dest,
; 2076 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2077 : 			_Unchecked(_Dest))));
; 2078 : 	}
; 2079 : 
; 2080 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2081 : template<class _InIt,
; 2082 : 	class _OutIt> inline
; 2083 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2084 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2085 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2086 : 	return (_Copy_impl(_First, _Last,
; 2087 : 		_Dest));
; 2088 : 	}
; 2089 : 
; 2090 : template<class _InIt,
; 2091 : 	class _OutIt> inline
; 2092 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2093 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2094 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators
; 2095 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2096 : 	_Copy_impl(_First, _Last,
; 2097 : 		_Unchecked(_Dest));
; 2098 : 	return (_Ans);
; 2099 : 	}
; 2100 : 
; 2101 : template<class _InIt,
; 2102 : 	class _OutIt> inline
; 2103 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2104 : 		_OutIt _Dest, true_type)
; 2105 : 	{	// copy [_First, _Last) to [_Dest, ...), checked dest
; 2106 : 	return (_Copy_impl(_First, _Last,
; 2107 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2108 : 	}
; 2109 : 
; 2110 : template<class _InIt,
; 2111 : 	class _OutIt> inline
; 2112 : _SCL_INSECURE_DEPRECATE
; 2113 : 	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
; 2114 : 		_OutIt _Dest, false_type)
; 2115 : 	{	// copy [_First, _Last) to [_Dest, ...), unchecked dest
; 2116 : 	return (_Copy_impl(_First, _Last,
; 2117 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2118 : 	}
; 2119 : 
; 2120 : template<class _InIt,
; 2121 : 	class _OutIt> inline
; 2122 : 	_OutIt copy(_InIt _First, _InIt _Last,
; 2123 : 		_OutIt _Dest)
; 2124 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2125 : 	if (_First == _Last)
; 2126 : 		return (_Dest);
; 2127 : 	else
; 2128 : 		{	// worth copying, check then copy
; 2129 : 		_DEBUG_RANGE(_First, _Last);
; 2130 : 		_DEBUG_POINTER(_Dest);
; 2131 : 		return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2132 : 			_Dest, _Is_checked(_Dest)));
; 2133 : 		}
; 2134 : 	}
; 2135 : 
; 2136 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2137 : template<class _InIt,
; 2138 : 	class _OutTy,
; 2139 : 	size_t _OutSize> inline
; 2140 : 	_OutTy *copy(_InIt _First, _InIt _Last,
; 2141 : 		_OutTy (&_Dest)[_OutSize])
; 2142 : 	{	// copy [_First, _Last) to [_Dest, ...)
; 2143 : 	return (_Unchecked(
; 2144 : 		_STD copy(_First, _Last,
; 2145 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2146 : 	}
; 2147 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2148 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2149 : 
; 2150 : 		// TEMPLATE FUNCTION copy_n
; 2151 : template<class _InIt,
; 2152 : 	class _Diff,
; 2153 : 	class _OutIt> inline
; 2154 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2155 : 		_OutIt _Dest, input_iterator_tag)
; 2156 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), input iterators
; 2157 : 	*_Dest = *_First;	// 0 < _Count has been guaranteed
; 2158 : 	while (0 < --_Count)
; 2159 : 		*++_Dest = *++_First;
; 2160 : 	return (++_Dest);
; 2161 : 	}
; 2162 : 
; 2163 : template<class _InIt,
; 2164 : 	class _Diff,
; 2165 : 	class _OutIt> inline
; 2166 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2167 : 		_OutIt _Dest, forward_iterator_tag)
; 2168 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), forward iterators
; 2169 : 	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
; 2170 : 		*_Dest = *_First;
; 2171 : 	return (_Dest);
; 2172 : 	}
; 2173 : 
; 2174 : template<class _InIt,
; 2175 : 	class _Diff,
; 2176 : 	class _OutIt> inline
; 2177 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2178 : 		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
; 2179 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary iterators
; 2180 : 	return (_Copy_n(_First, _Count,
; 2181 : 		_Dest, _Iter_cat(_First)));
; 2182 : 	}
; 2183 : template<class _InIt,
; 2184 : 	class _Diff,
; 2185 : 	class _OutIt> inline
; 2186 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2187 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2188 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), pointers to scalars
; 2189 : 	_CSTD memmove(&*_Dest, &*_First,
; 2190 : 		_Count * sizeof (*_First));
; 2191 : 	return (_Dest + _Count);
; 2192 : 	}
; 2193 : 
; 2194 : template<class _InIt,
; 2195 : 	class _Diff,
; 2196 : 	class _OutIt> inline
; 2197 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2198 : 		_OutIt _Dest)
; 2199 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked
; 2200 : 	return (_Copy_n(_First, _Count,
; 2201 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2202 : 	}
; 2203 : 
; 2204 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2205 : template<class _InIt,
; 2206 : 	class _Diff,
; 2207 : 	class _OutIt> inline
; 2208 : 	_OutIt copy_n(_InIt _First, _Diff _Count,
; 2209 : 		_OutIt _Dest)
; 2210 : 	{	// copy [_First, _First + _Count) to [_Dest, ...)
; 2211 : 	if (_Count <= 0)
; 2212 : 		return (_Dest);
; 2213 : 	else
; 2214 : 		return (_Rechecked(_Dest,
; 2215 : 			_Copy_n(_Unchecked(_First), _Count,
; 2216 : 				_Unchecked(_Dest))));
; 2217 : 	}
; 2218 : 
; 2219 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2220 : template<class _InIt,
; 2221 : 	class _Diff,
; 2222 : 	class _OutIt> inline
; 2223 : 	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
; 2224 : 		_OutIt _Dest, _Mutable_iterator_tag)
; 2225 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary dest
; 2226 : 	return (_Copy_n(_First, _Count,
; 2227 : 		_Dest));
; 2228 : 	}
; 2229 : 
; 2230 : template<class _InIt,
; 2231 : 	class _Diff,
; 2232 : 	class _OutIt> inline
; 2233 : 	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
; 2234 : 		_OutIt _Dest, random_access_iterator_tag)
; 2235 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access dest
; 2236 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2237 : 	_Copy_n(_First, _Count,
; 2238 : 		_Unchecked(_Dest));
; 2239 : 	return (_Ans);
; 2240 : 	}
; 2241 : 
; 2242 : template<class _InIt,
; 2243 : 	class _Diff,
; 2244 : 	class _OutIt> inline
; 2245 : 	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
; 2246 : 		_OutIt _Dest, input_iterator_tag)
; 2247 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input
; 2248 : 	return (_Copy_n2(_First, _Count,
; 2249 : 		_Dest, _Iter_cat(_Dest)));
; 2250 : 	}
; 2251 : 
; 2252 : template<class _InIt,
; 2253 : 	class _Diff,
; 2254 : 	class _OutIt> inline
; 2255 : 	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
; 2256 : 		_OutIt _Dest, random_access_iterator_tag)
; 2257 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access input
; 2258 : 	_InIt _Last = _First + _Count;	// also checks range
; 2259 : 	_Last = _Last;	// to quiet diagnostics
; 2260 : 	return (_Copy_n2(_Unchecked(_First), _Count,
; 2261 : 		_Dest, _Iter_cat(_Dest)));
; 2262 : 	}
; 2263 : 
; 2264 : template<class _InIt,
; 2265 : 	class _Diff,
; 2266 : 	class _OutIt> inline
; 2267 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2268 : 		_OutIt _Dest, true_type)
; 2269 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), checked dest
; 2270 : 	return (_Copy_n1(_First, _Count,
; 2271 : 		_Dest, _Iter_cat(_First)));
; 2272 : 	}
; 2273 : 
; 2274 : template<class _InIt,
; 2275 : 	class _Diff,
; 2276 : 	class _OutIt> inline
; 2277 : _SCL_INSECURE_DEPRECATE
; 2278 : 	_OutIt _Copy_n(_InIt _First, _Diff _Count,
; 2279 : 		_OutIt _Dest, false_type)
; 2280 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked dest
; 2281 : 	return (_Copy_n1(_First, _Count,
; 2282 : 		_Dest, _Iter_cat(_First)));
; 2283 : 	}
; 2284 : 
; 2285 : template<class _InIt,
; 2286 : 	class _Diff,
; 2287 : 	class _OutIt> inline
; 2288 : 	_OutIt copy_n(_InIt _First, _Diff _Count,
; 2289 : 		_OutIt _Dest)
; 2290 : 	{	// copy [_First, _First + _Count) to [_Dest, ...)
; 2291 : 	_DEBUG_POINTER(_First);
; 2292 : 	_DEBUG_POINTER(_Dest);
; 2293 : 	if (_Count <= 0)
; 2294 : 		return (_Dest);
; 2295 : 	else
; 2296 : 		return (_Copy_n(_First, _Count,
; 2297 : 			_Dest, _Is_checked(_Dest)));
; 2298 : 	}
; 2299 : 
; 2300 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2301 : template<class _InTy,
; 2302 : 	size_t _InSize,
; 2303 : 	class _Diff,
; 2304 : 	class _OutIt> inline
; 2305 : 	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,
; 2306 : 		_OutIt _Dest)
; 2307 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), array input
; 2308 : 	return (_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
; 2309 : 		_Dest));
; 2310 : 	}
; 2311 : 
; 2312 : template<class _InIt,
; 2313 : 	class _Diff,
; 2314 : 	class _OutTy,
; 2315 : 	size_t _OutSize> inline
; 2316 : 	_OutTy *copy_n(_InIt _First, _Diff _Count,
; 2317 : 		_OutTy (&_Dest)[_OutSize])
; 2318 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
; 2319 : 	return (_Unchecked(
; 2320 : 		_STD copy_n(_First, _Count,
; 2321 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2322 : 	}
; 2323 : 
; 2324 : template<class _InTy,
; 2325 : 	size_t _InSize,
; 2326 : 	class _Diff,
; 2327 : 	class _OutTy,
; 2328 : 	size_t _OutSize> inline
; 2329 : 	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,
; 2330 : 		_OutTy (&_Dest)[_OutSize])
; 2331 : 	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest
; 2332 : 	return (_Unchecked(
; 2333 : 		_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
; 2334 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2335 : 	}
; 2336 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2337 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2338 : 
; 2339 : 		// TEMPLATE FUNCTION copy_backward
; 2340 : template<class _BidIt1,
; 2341 : 	class _BidIt2> inline
; 2342 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2343 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2344 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2345 : 	while (_First != _Last)
; 2346 : 		*--_Dest = *--_Last;
; 2347 : 	return (_Dest);
; 2348 : 	}
; 2349 : 
; 2350 : template<class _InIt,
; 2351 : 	class _OutIt> inline
; 2352 : 	_OutIt _Copy_backward(_InIt _First, _InIt _Last,
; 2353 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2354 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2355 : 	ptrdiff_t _Count = _Last - _First;
; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));
; 2358 : 	return (_Dest - _Count);
; 2359 : 	}
; 2360 : 
; 2361 : template<class _BidIt1,
; 2362 : 	class _BidIt2> inline
; 2363 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2364 : 		_BidIt2 _Dest)
; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked
; 2366 : 	return (_Copy_backward(_First, _Last,
; 2367 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2368 : 	}
; 2369 : 
; 2370 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2371 : template<class _BidIt1,
; 2372 : 	class _BidIt2> inline
; 2373 : 	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2374 : 		_BidIt2 _Dest)
; 2375 : 	{	// copy [_First, _Last) backwards to [..., _Dest)
; 2376 : 	return (_Rechecked(_Dest,
; 2377 : 		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2378 : 			_Unchecked(_Dest))));
; 2379 : 	}
; 2380 : 
; 2381 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2382 : template<class _BidIt1,
; 2383 : 	class _BidIt2> inline
; 2384 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2385 : 		_BidIt2 _Dest, true_type)
; 2386 : 	{	// copy [_First, _Last) backwards to [..., _Dest), checked dest
; 2387 : 	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2388 : 		_Dest));
; 2389 : 	}
; 2390 : 
; 2391 : template<class _BidIt1,
; 2392 : 	class _BidIt2> inline
; 2393 : _SCL_INSECURE_DEPRECATE
; 2394 : 	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2395 : 		_BidIt2 _Dest, false_type)
; 2396 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2397 : 	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2398 : 		_Dest));
; 2399 : 	}
; 2400 : 
; 2401 : template<class _BidIt1,
; 2402 : 	class _BidIt2> inline
; 2403 : 	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
; 2404 : 		_BidIt2 _Dest)
; 2405 : 	{	// copy [_First, _Last) backwards to [..., _Dest)
; 2406 : 	_DEBUG_RANGE(_First, _Last);
; 2407 : 	_DEBUG_POINTER(_Dest);
; 2408 : 	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2409 : 		_Dest, _Is_checked(_Dest)));
; 2410 : 	}
; 2411 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2412 : 
; 2413 : 		// TEMPLATE FUNCTION move
; 2414 : template<class _InIt,
; 2415 : 	class _OutIt> inline
; 2416 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2417 : 		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)
; 2420 : 		*_Dest = _STD move(*_First);
; 2421 : 	return (_Dest);
; 2422 : 	}
; 2423 : 
; 2424 : template<class _InIt,
; 2425 : 	class _OutIt> inline
; 2426 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2427 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2428 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars
; 2429 : 	ptrdiff_t _Count = _Last - _First;
; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));
; 2432 : 	return (_Dest + _Count);
; 2433 : 	}
; 2434 : 
; 2435 : template<class _InIt,
; 2436 : 	class _OutIt> inline
; 2437 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2438 : 		_OutIt _Dest)
; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked
; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}
; 2443 : 
; 2444 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2445 : template<class _InIt,
; 2446 : 	class _OutIt> inline
; 2447 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2448 : 		_OutIt _Dest)
; 2449 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2450 : 	return (_Rechecked(_Dest,
; 2451 : 		_Move(_Unchecked(_First), _Unchecked(_Last),
; 2452 : 			_Unchecked(_Dest))));
; 2453 : 	}
; 2454 : 
; 2455 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2456 : template<class _InIt,
; 2457 : 	class _OutIt> inline
; 2458 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2459 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2460 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2461 : 	return (_Move(_First, _Last,
; 2462 : 		_Dest));
; 2463 : 	}
; 2464 : 
; 2465 : template<class _InIt,
; 2466 : 	class _OutIt> inline
; 2467 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2468 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2469 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators
; 2470 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2471 : 	_Move(_First, _Last,
; 2472 : 		_Unchecked(_Dest));
; 2473 : 	return (_Ans);
; 2474 : 	}
; 2475 : 
; 2476 : template<class _InIt,
; 2477 : 	class _OutIt> inline
; 2478 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2479 : 		_OutIt _Dest, true_type)
; 2480 : 	{	// move [_First, _Last) to [_Dest, ...), checked dest
; 2481 : 	return (_Move(_First, _Last,
; 2482 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2483 : 	}
; 2484 : 
; 2485 : template<class _InIt,
; 2486 : 	class _OutIt> inline
; 2487 : _SCL_INSECURE_DEPRECATE
; 2488 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2489 : 		_OutIt _Dest, false_type)
; 2490 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked dest
; 2491 : 	return (_Move(_First, _Last,
; 2492 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2493 : 	}
; 2494 : 
; 2495 : template<class _InIt,
; 2496 : 	class _OutIt> inline
; 2497 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2498 : 		_OutIt _Dest)
; 2499 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2500 : 	_DEBUG_RANGE(_First, _Last);
; 2501 : 	_DEBUG_POINTER(_Dest);
; 2502 : 	return (_Move(_Unchecked(_First), _Unchecked(_Last),
; 2503 : 		_Dest, _Is_checked(_Dest)));
; 2504 : 	}
; 2505 : 
; 2506 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2507 : template<class _InIt,
; 2508 : 	class _OutTy,
; 2509 : 	size_t _OutSize> inline
; 2510 : 	_OutTy *move(_InIt _First, _InIt _Last,
; 2511 : 		_OutTy (&_Dest)[_OutSize])
; 2512 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2513 : 	return (_Unchecked(
; 2514 : 		_STD move(_First, _Last,
; 2515 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2516 : 	}
; 2517 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2518 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2519 : 
; 2520 : 		// TEMPLATE FUNCTION move_backward
; 2521 : template<class _BidIt1,
; 2522 : 	class _BidIt2> inline
; 2523 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2524 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2526 : 	while (_First != _Last)
; 2527 : 		*--_Dest = _STD move(*--_Last);
; 2528 : 	return (_Dest);
; 2529 : 	}
; 2530 : 
; 2531 : template<class _InIt,
; 2532 : 	class _OutIt> inline
; 2533 : 	_OutIt _Move_backward(_InIt _First, _InIt _Last,
; 2534 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2536 : 	ptrdiff_t _Count = _Last - _First;
; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));
; 2539 : 	return (_Dest - _Count);
; 2540 : 	}
; 2541 : 
; 2542 : template<class _BidIt1,
; 2543 : 	class _BidIt2> inline
; 2544 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2545 : 		_BidIt2 _Dest)
; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked
; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2549 : 	}
; 2550 : 
; 2551 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2552 : template<class _BidIt1,
; 2553 : 	class _BidIt2> inline
; 2554 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2555 : 		_BidIt2 _Dest)
; 2556 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2557 : 	return (_Rechecked(_Dest,
; 2558 : 		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2559 : 			_Unchecked(_Dest))));
; 2560 : 	}
; 2561 : 
; 2562 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2563 : template<class _BidIt1,
; 2564 : 	class _BidIt2> inline
; 2565 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2566 : 		_BidIt2 _Dest, true_type)
; 2567 : 	{	// move [_First, _Last) backwards to [..., _Dest), checked dest
; 2568 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2569 : 		_Dest));
; 2570 : 	}
; 2571 : 
; 2572 : template<class _BidIt1,
; 2573 : 	class _BidIt2> inline
; 2574 : _SCL_INSECURE_DEPRECATE
; 2575 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2576 : 		_BidIt2 _Dest, false_type)
; 2577 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2578 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2579 : 		_Dest));
; 2580 : 	}
; 2581 : 
; 2582 : template<class _BidIt1,
; 2583 : 	class _BidIt2> inline
; 2584 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2585 : 		_BidIt2 _Dest)
; 2586 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2587 : 	_DEBUG_RANGE(_First, _Last);
; 2588 : 	_DEBUG_POINTER(_Dest);
; 2589 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2590 : 		_Dest, _Is_checked(_Dest)));
; 2591 : 	}
; 2592 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2593 : 
; 2594 : 		// TEMPLATE FUNCTION fill
; 2595 : template<class _FwdIt,
; 2596 : 	class _Ty> inline
; 2597 : 	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2598 : 	{	// copy _Val through [_First, _Last)
; 2599 : 	for (; _First != _Last; ++_First)
; 2600 : 		*_First = _Val;
; 2601 : 	}
; 2602 : 
; 2603 : inline void _Fill(char *_First, char *_Last, char _Val)
; 2604 : 	{	// copy char _Val through [_First, _Last)
; 2605 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2606 : 	}
; 2607 : 
; 2608 : inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
; 2609 : 	{	// copy signed char _Val through [_First, _Last)
; 2610 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2611 : 	}
; 2612 : 
; 2613 : inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
; 2614 : 	{	// copy unsigned char _Val through [_First, _Last)
; 2615 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2616 : 	}
; 2617 : 
; 2618 : template<class _FwdIt,
; 2619 : 	class _Ty> inline
; 2620 : 	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2621 : 	{	// copy _Val through [_First, _Last)
; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}
; 2625 : 
; 2626 : 		// TEMPLATE FUNCTION fill_n
; 2627 : template<class _OutIt,
; 2628 : 	class _Diff,
; 2629 : 	class _Ty> inline
; 2630 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)
; 2633 : 		*_Dest = _Val;
; 2634 : 	return (_Dest);
; 2635 : 	}
; 2636 : 
; 2637 : inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)
; 2639 : 	_CSTD memset(_Dest, _Val, _Count);
; 2640 : 	return (_Dest + _Count);
; 2641 : 	}
; 2642 : 
; 2643 : inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
; 2644 : 	signed char _Val)
; 2645 : 	{	// copy signed char _Val _Count times through [_Dest, ...)
; 2646 : 	_CSTD memset(_Dest, _Val, _Count);
; 2647 : 	return (_Dest + _Count);
; 2648 : 	}
; 2649 : 
; 2650 : inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
; 2651 : 	unsigned char _Val)
; 2652 : 	{	// copy unsigned char _Val _Count times through [_Dest, ...)
; 2653 : 	_CSTD memset(_Dest, _Val, _Count);
; 2654 : 	return (_Dest + _Count);
; 2655 : 	}
; 2656 : 
; 2657 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2658 : template<class _OutIt,
; 2659 : 	class _Diff,
; 2660 : 	class _Ty> inline
; 2661 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2662 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2663 : 	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
; 2664 : 	}
; 2665 : 
; 2666 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2667 : template<class _OutIt,
; 2668 : 	class _Diff,
; 2669 : 	class _Ty> inline
; 2670 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2671 : 		_Mutable_iterator_tag)
; 2672 : 	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator
; 2673 : 	return (_Fill_n(_Dest, _Count, _Val));
; 2674 : 	}
; 2675 : 
; 2676 : template<class _OutIt,
; 2677 : 	class _Diff,
; 2678 : 	class _Ty> inline
; 2679 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2680 : 		random_access_iterator_tag)
; 2681 : 	{	// copy _Val _Count times through [_Dest, ...), random-access iterator
; 2682 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2683 : 	_Fill_n(_Unchecked(_Dest), _Count, _Val);
; 2684 : 	return (_Ans);
; 2685 : 	}
; 2686 : 
; 2687 : template<class _OutIt,
; 2688 : 	class _Diff,
; 2689 : 	class _Ty> inline
; 2690 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2691 : 		true_type)
; 2692 : 	{	// copy _Val _Count times through [_Dest, ...), checked dest
; 2693 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2694 : 		_Iter_cat(_Dest)));
; 2695 : 	}
; 2696 : 
; 2697 : template<class _OutIt,
; 2698 : 	class _Diff,
; 2699 : 	class _Ty> inline
; 2700 : _SCL_INSECURE_DEPRECATE
; 2701 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2702 : 		false_type)
; 2703 : 	{	// copy _Val _Count times through [_Dest, ...), unchecked dest
; 2704 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2705 : 		_Iter_cat(_Dest)));
; 2706 : 	}
; 2707 : 
; 2708 : template<class _OutIt,
; 2709 : 	class _Diff,
; 2710 : 	class _Ty> inline
; 2711 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2712 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2713 : 	_DEBUG_POINTER(_Dest);
; 2714 : 	return (_Fill_n(_Dest, _Count, _Val,
; 2715 : 		_Is_checked(_Dest)));
; 2716 : 	}
; 2717 : 
; 2718 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2719 : template<class _OutTy,
; 2720 : 	size_t _OutSize,
; 2721 : 	class _Diff,
; 2722 : 	class _Ty> inline
; 2723 : 	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
; 2724 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2725 : 	return (_Unchecked(_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
; 2726 : 		_Count, _Val)));
; 2727 : 	}
; 2728 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2729 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2730 : 
; 2731 : 		// TEMPLATE FUNCTION equal
; 2732 : template<class _InIt1,
; 2733 : 	class _InIt2> inline
; 2734 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
; 2735 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2736 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2737 : 		if (!(*_First1 == *_First2))
; 2738 : 			return (false);
; 2739 : 	return (true);
; 2740 : 	}
; 2741 : 
; 2742 : inline bool _Equal(const char *_First1, const char *_Last1,
; 2743 : 	const char *_First2)
; 2744 : 	{	// compare [_First1, _Last1) to [_First2, ...), for chars
; 2745 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2746 : 	}
; 2747 : 
; 2748 : inline bool _Equal(const signed char *_First1, const signed char *_Last1,
; 2749 : 	const signed char *_First2)
; 2750 : 	{	// compare [_First1, _Last1) to [_First2, ...), for signed chars
; 2751 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2752 : 	}
; 2753 : 
; 2754 : inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
; 2755 : 	const unsigned char *_First2)
; 2756 : 	{	// compare [_First1, _Last1) to [_First2, ...), for unsigned chars
; 2757 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2758 : 	}
; 2759 : 
; 2760 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2761 : template<class _InIt1,
; 2762 : 	class _InIt2> inline
; 2763 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2764 : 		_InIt2 _First2)
; 2765 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2766 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2767 : 		_Unchecked(_First2)));
; 2768 : 	}
; 2769 : 
; 2770 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2771 : template<class _InIt1,
; 2772 : 	class _InIt2> inline
; 2773 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2774 : 		_InIt2 _First2, true_type)
; 2775 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked dest
; 2776 : 	return (_Equal(_First1, _Last1,
; 2777 : 		_First2));
; 2778 : 	}
; 2779 : 
; 2780 : template<class _InIt1,
; 2781 : 	class _InIt2> inline
; 2782 : _SCL_INSECURE_DEPRECATE
; 2783 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2784 : 		_InIt2 _First2, false_type)
; 2785 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked dest
; 2786 : 	return (_Equal(_First1, _Last1,
; 2787 : 		_First2));
; 2788 : 	}
; 2789 : 
; 2790 : template<class _InIt1,
; 2791 : 	class _InIt2> inline
; 2792 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2793 : 		_InIt2 _First2)
; 2794 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2795 : 	_DEBUG_RANGE(_First1, _Last1);
; 2796 : 	_DEBUG_POINTER(_First2);
; 2797 : 	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
; 2798 : 		_First2, _Is_checked(_First2)));
; 2799 : 	}
; 2800 : 
; 2801 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2802 : template<class _InIt1,
; 2803 : 	class _InTy,
; 2804 : 	size_t _InSize> inline
; 2805 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InTy (&_First2)[_InSize])
; 2807 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2808 : 	return (_STD equal(_First1, _Last1,
; 2809 : 		_Array_iterator<_InTy, _InSize>(_First2)));
; 2810 : 	}
; 2811 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2812 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2813 : 
; 2814 : 		// TEMPLATE FUNCTION equal WITH PRED
; 2815 : template<class _InIt1,
; 2816 : 	class _InIt2,
; 2817 : 	class _Pr> inline
; 2818 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
; 2819 : 		_InIt2 _First2, _Pr _Pred)
; 2820 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
; 2821 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2822 : 		if (!_Pred(*_First1, *_First2))
; 2823 : 			return (false);
; 2824 : 	return (true);
; 2825 : 	}
; 2826 : 
; 2827 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2828 : template<class _InIt1,
; 2829 : 	class _InIt2,
; 2830 : 	class _Pr> inline
; 2831 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2832 : 		_InIt2 _First2, _Pr _Pred)
; 2833 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2834 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2835 : 		_Unchecked(_First2), _Pred));
; 2836 : 	}
; 2837 : 
; 2838 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2839 : template<class _InIt1,
; 2840 : 	class _InIt2,
; 2841 : 	class _Pr> inline
; 2842 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2843 : 		_InIt2 _First2, _Pr _Pred, true_type)
; 2844 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked input
; 2845 : 	return (_Equal(_First1, _Last1,
; 2846 : 		_First2, _Pred));
; 2847 : 	}
; 2848 : 
; 2849 : template<class _InIt1,
; 2850 : 	class _InIt2,
; 2851 : 	class _Pr> inline
; 2852 : _SCL_INSECURE_DEPRECATE
; 2853 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2854 : 		_InIt2 _First2, _Pr _Pred, false_type)
; 2855 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked input
; 2856 : 	return (_Equal(_First1, _Last1,
; 2857 : 		_First2, _Pred));
; 2858 : 	}
; 2859 : 
; 2860 : template<class _InIt1,
; 2861 : 	class _InIt2,
; 2862 : 	class _Pr> inline
; 2863 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2864 : 		_InIt2 _First2, _Pr _Pred)
; 2865 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2866 : 	_DEBUG_RANGE(_First1, _Last1);
; 2867 : 	_DEBUG_POINTER(_First2);
; 2868 : 	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
; 2869 : 		_First2, _Pred, _Is_checked(_First2)));
; 2870 : 	}
; 2871 : 
; 2872 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2873 : template<class _InIt1,
; 2874 : 	class _InTy,
; 2875 : 	size_t _InSize,
; 2876 : 	class _Pr> inline
; 2877 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2878 : 		_InTy (&_First2)[_InSize], _Pr _Pred)
; 2879 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2880 : 	return (_STD equal(_First1, _Last1,
; 2881 : 		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
; 2882 : 	}
; 2883 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2884 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2885 : 
; 2886 : 		// TEMPLATE FUNCTION lexicographical_compare
; 2887 : template<class _InIt1,
; 2888 : 	class _InIt2> inline
; 2889 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2890 : 		_InIt2 _First2, _InIt2 _Last2)
; 2891 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2892 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2893 : 		if (_DEBUG_LT(*_First1, *_First2))
; 2894 : 			return (true);
; 2895 : 		else if (*_First2 < *_First1)
; 2896 : 			return (false);
; 2897 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2898 : 	}
; 2899 : 
; 2900 : inline bool _Lexicographical_compare(
; 2901 : 	const unsigned char *_First1, const unsigned char *_Last1,
; 2902 : 	const unsigned char *_First2, const unsigned char *_Last2)
; 2903 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for unsigned char
; 2904 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2905 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2906 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2907 : 	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
; 2908 : 	}
; 2909 : 
; 2910 :  #if CHAR_MAX == UCHAR_MAX
; 2911 : inline bool _Lexicographical_compare(
; 2912 : 	const char *_First1, const char *_Last1,
; 2913 : 	const char *_First2, const char *_Last2)
; 2914 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for nonnegative char
; 2915 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2916 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2917 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2918 : 	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
; 2919 : 	}
; 2920 :  #endif /* CHAR_MAX == UCHAR_MAX */
; 2921 : 
; 2922 : template<class _InIt1,
; 2923 : 	class _InIt2> inline
; 2924 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2925 : 		_InIt2 _First2, _InIt2 _Last2)
; 2926 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2927 : 	_DEBUG_RANGE(_First1, _Last1);
; 2928 : 	_DEBUG_RANGE(_First2, _Last2);
; 2929 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2930 : 		_Unchecked(_First2), _Unchecked(_Last2)));
; 2931 : 	}
; 2932 : 
; 2933 : 		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
; 2934 : template<class _InIt1,
; 2935 : 	class _InIt2,
; 2936 : 	class _Pr> inline
; 2937 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2938 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2939 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2940 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2941 : 		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
; 2942 : 			return (true);
; 2943 : 		else if (_Pred(*_First2, *_First1))
; 2944 : 			return (false);
; 2945 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2946 : 	}
; 2947 : 
; 2948 : template<class _InIt1,
; 2949 : 	class _InIt2,
; 2950 : 	class _Pr> inline
; 2951 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2952 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2953 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2954 : 	_DEBUG_RANGE(_First1, _Last1);
; 2955 : 	_DEBUG_RANGE(_First2, _Last2);
; 2956 : 	_DEBUG_POINTER(_Pred);
; 2957 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2958 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
; 2959 : 	}
; 2960 : 
; 2961 : 		// TEMPLATE FUNCTION find
; 2962 : template<class _Ty,
; 2963 : 	class _Ignored> inline
; 2964 : 	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
; 2965 : 	{	// signed _Elem, signed _Ty
; 2966 : 	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);
; 2967 : 	}
; 2968 : 
; 2969 : template<class _Ty> inline
; 2970 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
; 2971 : 	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
; 2972 : 	return (_Val <= SCHAR_MAX || static_cast<_Ty>(SCHAR_MIN) <= _Val);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _Ty> inline
; 2976 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
; 2977 : 	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
; 2978 : 	return (_Val <= SCHAR_MAX);
; 2979 : 	}
; 2980 : 
; 2981 : template<class _Ty,
; 2982 : 	class _Ignored> inline
; 2983 : 	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
; 2984 : 	{	// unsigned _Elem, signed _Ty
; 2985 : 	return (0 <= _Val && _Val <= UCHAR_MAX);
; 2986 : 	}
; 2987 : 
; 2988 : template<class _Ty,
; 2989 : 	class _Ignored> inline
; 2990 : 	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
; 2991 : 	{	// unsigned _Elem, unsigned _Ty
; 2992 : 	return (_Val <= UCHAR_MAX);
; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))
; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));
; 3018 : 	return (_First ? _First : _Last);
; 3019 : 	}
; 3020 : 
; 3021 : template<class _InIt,
; 3022 : 	class _Ty> inline
; 3023 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
; 3024 : 	{	// find first matching _Val
; 3025 : 	for (; _First != _Last; ++_First)
; 3026 : 		if (*_First == _Val)
; 3027 : 			break;
; 3028 : 	return (_First);
; 3029 : 	}
; 3030 : 
; 3031 : template<class _InIt,
; 3032 : 	class _Ty> inline
; 3033 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3034 : 	{	// find first matching _Val
; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));
; 3046 : 	}
; 3047 : 
; 3048 : template<class _InIt,
; 3049 : 	class _Ty> inline
; 3050 : 	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3051 : 	{	// find first matching _Val
; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 3055 : 	}
; 3056 : 
; 3057 : 		// TEMPLATE FUNCTION _Find_pr WITH PREDICATE
; 3058 : template<class _InIt,
; 3059 : 	class _Ty,
; 3060 : 	class _Pr> inline
; 3061 : 	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
; 3062 : 	{	// find first matching _Val, using _Pred
; 3063 : 	for (; _First != _Last; ++_First)
; 3064 : 		if (_Pred(*_First, _Val))
; 3065 : 			break;
; 3066 : 	return (_First);
; 3067 : 	}
; 3068 : 
; 3069 : 		// TEMPLATE FUNCTION count
; 3070 : template<class _InIt,
; 3071 : 	class _Ty> inline
; 3072 : 	typename iterator_traits<_InIt>::difference_type
; 3073 : 		_Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3074 : 	{	// count elements that match _Val
; 3075 : 	typename iterator_traits<_InIt>::difference_type _Count = 0;
; 3076 : 
; 3077 : 	for (; _First != _Last; ++_First)
; 3078 : 		if (*_First == _Val)
; 3079 : 			++_Count;
; 3080 : 	return (_Count);
; 3081 : 	}
; 3082 : 
; 3083 : template<class _InIt,
; 3084 : 	class _Ty> inline
; 3085 : 	typename iterator_traits<_InIt>::difference_type
; 3086 : 		count(_InIt _First, _InIt _Last, const _Ty& _Val)
; 3087 : 	{	// count elements that match _Val
; 3088 : 	_DEBUG_RANGE(_First, _Last);
; 3089 : 	return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
; 3090 : 	}
; 3091 : 
; 3092 : 		// TEMPLATE FUNCTION _Count_pr WITH PREDICATE
; 3093 : template<class _InIt,
; 3094 : 	class _Ty,
; 3095 : 	class _Pr> inline
; 3096 : 	typename iterator_traits<_InIt>::difference_type
; 3097 : 		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
; 3098 : 	{	// count elements that match _Val, using _Pred
; 3099 : 	typename iterator_traits<_InIt>::difference_type _Count = 0;
; 3100 : 
; 3101 : 	for (; _First != _Last; ++_First)
; 3102 : 		if (_Pred(*_First, _Val))
; 3103 : 			++_Count;
; 3104 : 	return (_Count);
; 3105 : 	}
; 3106 : 
; 3107 : 		// TEMPLATE FUNCTION is_permutation WITH PREDICATE
; 3108 : template<class _FwdIt1,
; 3109 : 	class _FwdIt2,
; 3110 : 	class _Pr> inline
; 3111 : 	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
; 3112 : 		_FwdIt2 _First2, _Pr _Pred)
; 3113 : 	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
; 3114 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 3115 : 		if (!_Pred(*_First1, *_First2))
; 3116 : 			break;	// find first inequality
; 3117 : 	if (_First1 != _Last1)
; 3118 : 		{	// check match counts in suffix
; 3119 : 		_FwdIt2 _Last2 = _First2;
; 3120 : 		advance(_Last2, distance(_First1, _Last1));
; 3121 : 		for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
; 3122 : 			if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
; 3123 : 				{	// new value, compare match counts
; 3124 : 				typename iterator_traits<_FwdIt2>::difference_type _Count =
; 3125 : 					_Count_pr(_First2, _Last2, *_Next1, _Pred);
; 3126 : 				if (_Count == 0
; 3127 : 					|| _Count != _Count_pr(_Next1, _Last1, *_Next1, _Pred))
; 3128 : 					return (false);	// match counts differ, fail
; 3129 : 				}
; 3130 : 		}
; 3131 : 	return (true);
; 3132 : 	}
; 3133 : 
; 3134 : template<class _FwdIt1,
; 3135 : 	class _FwdIt2,
; 3136 : 	class _Pr> inline
; 3137 : 	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
; 3138 : 		_FwdIt2 _First2, _Pr _Pred)
; 3139 : 	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
; 3140 : 	_DEBUG_RANGE(_First1, _Last1);
; 3141 : 	_DEBUG_POINTER(_Pred);
; 3142 : 	return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
; 3143 : 		_Unchecked(_First2), _Pred);
; 3144 : 	}
; 3145 : 
; 3146 : 		// TEMPLATE FUNCTION is_permutation
; 3147 : template<class _FwdIt1,
; 3148 : 	class _FwdIt2> inline
; 3149 : 	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
; 3150 : 		_FwdIt2 _First2)
; 3151 : 	{	// test if [_First1, _Last1) == permuted [_First2, ...)
; 3152 : 	return (_STD is_permutation(_First1, _Last1,
; 3153 : 		_First2, equal_to<>()));
; 3154 : 	}
; 3155 : 
; 3156 : 		// TEMPLATE FUNCTION reverse
; 3157 : template<class _BidIt> inline
; 3158 : 	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
; 3159 : 	{	// reverse elements in [_First, _Last), bidirectional iterators
; 3160 : 	for (; _First != _Last && _First != --_Last; ++_First)
; 3161 : 		_STD iter_swap(_First, _Last);
; 3162 : 	}
; 3163 : 
; 3164 : template<class _BidIt> inline
; 3165 : 	void reverse(_BidIt _First, _BidIt _Last)
; 3166 : 	{	// reverse elements in [_First, _Last)
; 3167 : 	_DEBUG_RANGE(_First, _Last);
; 3168 : 	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 3169 : 	}
; 3170 : 
; 3171 : 		// TEMPLATE FUNCTION rotate
; 3172 : template<class _FwdIt> inline
; 3173 : 	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
; 3174 : 		forward_iterator_tag)
; 3175 : 	{	// rotate [_First, _Last), forward iterators
; 3176 : 	for (_FwdIt _Next = _Mid; ; )
; 3177 : 		{	// swap [_First, ...) into place
; 3178 : 		_STD iter_swap(_First, _Next);
; 3179 : 		if (++_First == _Mid)
; 3180 : 			if (++_Next == _Last)
; 3181 : 				break;	// done, quit
; 3182 : 			else
; 3183 : 				_Mid = _Next;	// mark end of next interval
; 3184 : 		else if (++_Next == _Last)
; 3185 : 			_Next = _Mid;	// wrap to last end
; 3186 : 		}
; 3187 : 	}
; 3188 : 
; 3189 : template<class _BidIt> inline
; 3190 : 	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
; 3191 : 		bidirectional_iterator_tag)
; 3192 : 	{	// rotate [_First, _Last), bidirectional iterators
; 3193 : 	_STD reverse(_First, _Mid);
; 3194 : 	_STD reverse(_Mid, _Last);
; 3195 : 	_STD reverse(_First, _Last);
; 3196 : 	}
; 3197 : 
; 3198 : template<class _RanIt,
; 3199 : 	class _Diff,
; 3200 : 	class _Ty> inline
; 3201 : 	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
; 3202 : 	{	// rotate [_First, _Last), random-access iterators
; 3203 : 	_Diff _Shift = _Mid - _First;
; 3204 : 	_Diff _Count = _Last - _First;
; 3205 : 
; 3206 : 	for (_Diff _Factor = _Shift; _Factor != 0; )
; 3207 : 		{	// find subcycle count as GCD of shift count and length
; 3208 : 		_Diff _Tmp = _Count % _Factor;
; 3209 : 		_Count = _Factor;
; 3210 : 		_Factor = _Tmp;
; 3211 : 		}
; 3212 : 
; 3213 : 	if (_Count < _Last - _First)
; 3214 : 		for (; 0 < _Count; --_Count)
; 3215 : 			{	// rotate each subcycle
; 3216 : 			_RanIt _Hole = _First + _Count;
; 3217 : 			_RanIt _Next = _Hole;
; 3218 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
; 3219 : 			for (; ; )
; 3220 : 				{	// percolate elements back around subcycle
; 3221 : 				iter_swap(_Next, _Next1);
; 3222 : 				_Next = _Next1;
; 3223 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 3224 : 					: _First + (_Shift - (_Last - _Next1));
; 3225 : 				if (_Next1 == _Hole)
; 3226 : 					break;
; 3227 : 				}
; 3228 : 			}
; 3229 : 	}
; 3230 : 
; 3231 : template<class _RanIt> inline
; 3232 : 	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
; 3233 : 		random_access_iterator_tag)
; 3234 : 	{	// rotate [_First, _Last), random-access iterators
; 3235 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

  00138	6a 00		 push	 0
  0013a	6a 00		 push	 0
  0013c	56		 push	 esi
  0013d	57		 push	 edi
  0013e	53		 push	 ebx
  0013f	e8 00 00 00 00	 call	 ??$_Rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00PAH0@Z ; std::_Rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>
  00144	83 c4 14	 add	 esp, 20			; 00000014H
$LN71@Buffered_r:

; 691  : 	}
; 692  : 
; 693  : template<class _InIt,
; 694  : 	class _Diff> inline
; 695  : 	void advance(_InIt& _Where, _Diff _Off)
; 696  : 	{	// increment iterator by offset, arbitrary iterators
; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}
; 699  : 
; 700  : 		// TEMPLATE FUNCTION _Dist_type
; 701  : 
; 702  : template<class _Iter> inline
; 703  : 	typename iterator_traits<_Iter>::difference_type
; 704  : 		*_Dist_type(_Iter)
; 705  : 	{	// return distance type from arbitrary argument
; 706  : 	return (0);
; 707  : 	}
; 708  : 
; 709  : 		// TEMPLATE FUNCTIONS distance and _Distance
; 710  : template<class _InIt,
; 711  : 	class _Diff> inline
; 712  : 		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
; 713  : 			input_iterator_tag)
; 714  : 	{	// add to _Off distance between input iterators
; 715  : 	for (; _First != _Last; ++_First)
; 716  : 		++_Off;
; 717  : 	}
; 718  : 
; 719  : template<class _FwdIt,
; 720  : 	class _Diff> inline
; 721  : 		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
; 722  : 			forward_iterator_tag)
; 723  : 	{	// add to _Off distance between forward iterators (redundant)
; 724  : 	for (; _First != _Last; ++_First)
; 725  : 		++_Off;
; 726  : 	}
; 727  : 
; 728  : template<class _BidIt,
; 729  : 	class _Diff> inline
; 730  : 		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
; 731  : 			bidirectional_iterator_tag)
; 732  : 	{	// add to _Off distance between bidirectional iterators (redundant)
; 733  : 	for (; _First != _Last; ++_First)
; 734  : 		++_Off;
; 735  : 	}
; 736  : 
; 737  : template<class _RanIt,
; 738  : 	class _Diff> inline
; 739  : 		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
; 740  : 			random_access_iterator_tag)
; 741  : 	{	// add to _Off distance between random-access iterators
; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

  00147	2b f7		 sub	 esi, edi

; 690  : 	_Where += _Off;

  00149	83 e6 f0	 and	 esi, -16		; fffffff0H
  0014c	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
; File a:\vs\vc\include\algorithm

; 2196 : 	}

  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
$LN6@Buffered_r:
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00156	c1 e6 04	 shl	 esi, 4
  00159	03 75 08	 add	 esi, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\algorithm

; 2196 : 	}

  0015c	5f		 pop	 edi
  0015d	8b c6		 mov	 eax, esi
  0015f	5e		 pop	 esi
  00160	5b		 pop	 ebx
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
??$_Buffered_rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ENDP ; std::_Buffered_rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2580 : 	{	// find first element that _Val is before, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2581 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2582 : 	return (_Rechecked(_First,
; 2583 : 		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2584 : 			_Dist_type(_First))));

  00003	6a 00		 push	 0
  00005	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ; std::_Upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  00016	83 c4 14	 add	 esp, 20			; 00000014H

; 2585 : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2531 : 	{	// find first element not before _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));

  00003	6a 00		 push	 0
  00005	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ; std::_Lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  00016	83 c4 14	 add	 esp, 20			; 00000014H

; 2536 : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Merge_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Merge_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2850 : 	{	// merge backwards to _Dest, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2851 : 	if (_First1 != _Last1 && _First2 != _Last2)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00006	8b 4d 10	 mov	 ecx, DWORD PTR __First2$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 14	 mov	 ebx, DWORD PTR __Last2$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 18	 mov	 esi, DWORD PTR __Dest$[ebp]
  00011	57		 push	 edi
  00012	8b 7d 0c	 mov	 edi, DWORD PTR __Last1$[ebp]
  00015	3b c7		 cmp	 eax, edi
  00017	74 33		 je	 SHORT $LN37@Merge_back
  00019	3b cb		 cmp	 ecx, ebx
  0001b	74 46		 je	 SHORT $LN18@Merge_back
  0001d	8d 49 00	 npad	 3
$LL6@Merge_back:

; 2852 : 		for (; ; )
; 2853 : 			{	// merge either first or second
; 2854 : 			if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

  00020	83 ef 10	 sub	 edi, 16			; 00000010H
  00023	8d 4d 1c	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00026	57		 push	 edi
  00027	83 eb 10	 sub	 ebx, 16			; 00000010H
  0002a	53		 push	 ebx
  0002b	e8 00 00 00 00	 call	 ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()

; 2855 : 				{	// merge first
; 2856 : 				*--_Dest = _Move(*_Last1);

  00030	83 ee 10	 sub	 esi, 16			; 00000010H
  00033	84 c0		 test	 al, al
  00035	74 53		 je	 SHORT $LN4@Merge_back
  00037	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]

; 2857 : 				++_Last2;
; 2858 : 				if (_First1 == _Last1)

  0003b	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003e	83 c3 10	 add	 ebx, 16			; 00000010H
  00041	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  00045	3b c7		 cmp	 eax, edi
  00047	75 d7		 jne	 SHORT $LL6@Merge_back
  00049	8b 4d 10	 mov	 ecx, DWORD PTR __First2$[ebp]
$LN37@Merge_back:
; File a:\vs\vc\include\xutility

; 2526 : 	while (_First != _Last)

  0004c	3b cb		 cmp	 ecx, ebx
  0004e	74 13		 je	 SHORT $LN18@Merge_back
$LL19@Merge_back:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00050	f3 0f 6f 43 f0	 movdqu	 xmm0, XMMWORD PTR [ebx-16]
  00055	83 eb 10	 sub	 ebx, 16			; 00000010H
  00058	83 ee 10	 sub	 esi, 16			; 00000010H
  0005b	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0005f	3b d9		 cmp	 ebx, ecx
  00061	75 ed		 jne	 SHORT $LL19@Merge_back
$LN18@Merge_back:

; 2526 : 	while (_First != _Last)

  00063	3b c7		 cmp	 eax, edi
  00065	74 1c		 je	 SHORT $LN47@Merge_back
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL29@Merge_back:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00070	f3 0f 6f 47 f0	 movdqu	 xmm0, XMMWORD PTR [edi-16]
  00075	83 ef 10	 sub	 edi, 16			; 00000010H
  00078	83 ee 10	 sub	 esi, 16			; 00000010H
  0007b	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0007f	3b f8		 cmp	 edi, eax
  00081	75 ed		 jne	 SHORT $LL29@Merge_back
$LN47@Merge_back:
  00083	5f		 pop	 edi
; File a:\vs\vc\include\algorithm

; 2871 : 	return (_Move_backward(_First1, _Last1, _Dest));

  00084	8b c6		 mov	 eax, esi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 2872 : 	}

  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
$LN4@Merge_back:

; 2859 : 					break;
; 2860 : 				}
; 2861 : 			else
; 2862 : 				{	// merge second
; 2863 : 				*--_Dest = _Move(*_Last2);

  0008a	f3 0f 6f 03	 movdqu	 xmm0, XMMWORD PTR [ebx]

; 2864 : 				++_Last1;
; 2865 : 				if (_First2 == _Last2)

  0008e	8b 4d 10	 mov	 ecx, DWORD PTR __First2$[ebp]
  00091	83 c7 10	 add	 edi, 16			; 00000010H
  00094	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  00098	3b cb		 cmp	 ecx, ebx
  0009a	75 84		 jne	 SHORT $LL6@Merge_back
  0009c	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0009f	eb ab		 jmp	 SHORT $LN37@Merge_back
??$_Merge_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Merge_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2881 : 	{	// move merging ranges, both using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2882 : 	if (_First1 != _Last1 && _First2 != _Last2)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last1$[ebp]
  00006	8b 45 14	 mov	 eax, DWORD PTR __Last2$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First1$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 18	 mov	 esi, DWORD PTR __Dest$[ebp]
  00011	57		 push	 edi
  00012	8b 7d 10	 mov	 edi, DWORD PTR __First2$[ebp]
  00015	3b d9		 cmp	 ebx, ecx
  00017	74 49		 je	 SHORT $LN18@Merge
  00019	3b f8		 cmp	 edi, eax
  0001b	74 29		 je	 SHORT $LN39@Merge
  0001d	8d 49 00	 npad	 3
$LL6@Merge:

; 2883 : 		for (; ; )
; 2884 : 			{	// merge either first or second
; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

  00020	53		 push	 ebx
  00021	57		 push	 edi
  00022	8d 4d 1c	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00025	e8 00 00 00 00	 call	 ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
  0002a	84 c0		 test	 al, al
  0002c	74 5b		 je	 SHORT $LN4@Merge

; 2886 : 				{	// merge first
; 2887 : 				*_Dest++ = _Move(*_First2++);

  0002e	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]

; 2888 : 				if (_First2 == _Last2)

  00032	8b 45 14	 mov	 eax, DWORD PTR __Last2$[ebp]
  00035	83 c7 10	 add	 edi, 16			; 00000010H
  00038	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0003c	83 c6 10	 add	 esi, 16			; 00000010H
  0003f	3b f8		 cmp	 edi, eax
  00041	75 dd		 jne	 SHORT $LL6@Merge
  00043	8b 4d 0c	 mov	 ecx, DWORD PTR __Last1$[ebp]
$LN39@Merge:
; File a:\vs\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  00046	3b d9		 cmp	 ebx, ecx
  00048	74 18		 je	 SHORT $LN18@Merge
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL20@Merge:

; 2420 : 		*_Dest = _STD move(*_First);

  00050	f3 0f 6f 03	 movdqu	 xmm0, XMMWORD PTR [ebx]
  00054	83 c3 10	 add	 ebx, 16			; 00000010H
  00057	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0005b	83 c6 10	 add	 esi, 16			; 00000010H
  0005e	3b d9		 cmp	 ebx, ecx
  00060	75 ee		 jne	 SHORT $LL20@Merge
$LN18@Merge:

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  00062	3b f8		 cmp	 edi, eax
  00064	74 1c		 je	 SHORT $LN49@Merge
  00066	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL31@Merge:

; 2420 : 		*_Dest = _STD move(*_First);

  00070	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]
  00074	83 c7 10	 add	 edi, 16			; 00000010H
  00077	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0007b	83 c6 10	 add	 esi, 16			; 00000010H
  0007e	3b f8		 cmp	 edi, eax
  00080	75 ee		 jne	 SHORT $LL31@Merge
$LN49@Merge:
  00082	5f		 pop	 edi
; File a:\vs\vc\include\algorithm

; 2900 : 	return (_Move(_First2, _Last2, _Dest));

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 2901 : 	}

  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN4@Merge:

; 2889 : 					break;
; 2890 : 				}
; 2891 : 			else
; 2892 : 				{	// merge second
; 2893 : 				*_Dest++ = _Move(*_First1++);

  00089	f3 0f 6f 03	 movdqu	 xmm0, XMMWORD PTR [ebx]

; 2894 : 				if (_First1 == _Last1)

  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last1$[ebp]
  00090	83 c3 10	 add	 ebx, 16			; 00000010H
  00093	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  00097	83 c6 10	 add	 esi, 16			; 00000010H
  0009a	3b d9		 cmp	 ebx, ecx
  0009c	75 82		 jne	 SHORT $LL6@Merge
  0009e	8b 45 14	 mov	 eax, DWORD PTR __Last2$[ebp]
  000a1	eb a3		 jmp	 SHORT $LN39@Merge
??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Cat$2 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z PROC ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00007	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
  0000a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	83 ec 14	 sub	 esp, 20			; 00000014H
  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00017	8b cc		 mov	 ecx, esp
  00019	ff 75 10	 push	 DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  0001c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File a:\vs\vc\include\xutility

; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00022	ff 75 0c	 push	 DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xmemory

; 759  : 		_Buf._Current = 0;

  00025	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  0002c	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  00033	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 778  : 		_Pbuf = _Right._Pbuf;

  0003a	8b 45 24	 mov	 eax, DWORD PTR __Dest$[ebp+16]
; File a:\vs\vc\include\xutility

; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  0003d	56		 push	 esi
; File a:\vs\vc\include\xmemory

; 778  : 		_Pbuf = _Right._Pbuf;

  0003e	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\xutility

; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00041	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  00046	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
; File a:\vs\vc\include\xutility

; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00049	83 c4 24	 add	 esp, 36			; 00000024H
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  0004c	85 c0		 test	 eax, eax
  0004e	74 09		 je	 SHORT $LN27@Move

; 41   : 	operator delete(_Pbuf);

  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4
$LN27@Move:
; File a:\vs\vc\include\xutility

; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00059	8b c6		 mov	 eax, esi

; 2442 : 	}

  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ENDP ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$iter_swap@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0@Z PROC ; std::iter_swap<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 27   : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);
; 53   : 	_Left = _Move(_Right);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  0000d	f3 0f 6f 09	 movdqu	 xmm1, XMMWORD PTR [ecx]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0

; 54   : 	_Right = _Move(_Tmp);

  00015	f3 0f 7f 08	 movdqu	 XMMWORD PTR [eax], xmm1

; 28   : 	swap(*_Left, *_Right);
; 29   : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$iter_swap@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0@Z ENDP ; std::iter_swap<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHUFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__Chunk2$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
tv190 = 24						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHUFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 3174 : 	{	// copy merging chunks, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3175 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

  00004	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 18	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 14	 mov	 edi, DWORD PTR __Chunk$[ebp]
  0000f	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00012	89 45 fc	 mov	 DWORD PTR __Chunk2$1$[ebp], eax
  00015	3b c3		 cmp	 eax, ebx
  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	7f 2a		 jg	 SHORT $LN3@Chunked_me
  0001c	03 ff		 add	 edi, edi
  0001e	56		 push	 esi
  0001f	90		 npad	 1
$LL5@Chunked_me:

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  00020	ff 75 1c	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00023	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  00026	52		 push	 edx
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00027	8d 34 f9	 lea	 esi, DWORD PTR [ecx+edi*8]
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  0002a	56		 push	 esi
  0002b	51		 push	 ecx
  0002c	51		 push	 ecx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  00033	2b 5d fc	 sub	 ebx, DWORD PTR __Chunk2$1$[ebp]
  00036	83 c4 18	 add	 esp, 24			; 00000018H
  00039	8b d0		 mov	 edx, eax

; 3183 : 		_First = _Mid2;

  0003b	8b c6		 mov	 eax, esi
  0003d	3b 5d fc	 cmp	 ebx, DWORD PTR __Chunk2$1$[ebp]
  00040	7d de		 jge	 SHORT $LL5@Chunked_me
  00042	8b 7d 14	 mov	 edi, DWORD PTR __Chunk$[ebp]
  00045	5e		 pop	 esi
$LN3@Chunked_me:

; 3184 : 		}
; 3185 : 
; 3186 : 	if (_Count <= _Chunk)

  00046	3b df		 cmp	 ebx, edi
  00048	7f 1f		 jg	 SHORT $LN2@Chunked_me
; File a:\vs\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0004d	3b c1		 cmp	 eax, ecx
  0004f	74 2f		 je	 SHORT $LN1@Chunked_me
  00051	2b d0		 sub	 edx, eax
$LL26@Chunked_me:

; 2420 : 		*_Dest = _STD move(*_First);

  00053	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00057	f3 0f 7f 04 02	 movdqu	 XMMWORD PTR [edx+eax], xmm0
  0005c	83 c0 10	 add	 eax, 16			; 00000010H
  0005f	3b c1		 cmp	 eax, ecx
  00061	75 f0		 jne	 SHORT $LL26@Chunked_me
  00063	5f		 pop	 edi
  00064	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 3195 : 	}

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN2@Chunked_me:

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  00069	ff 75 1c	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0006c	c1 e7 04	 shl	 edi, 4
; File a:\vs\vc\include\algorithm

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  0006f	52		 push	 edx
  00070	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00073	03 f8		 add	 edi, eax
; File a:\vs\vc\include\algorithm

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  00075	57		 push	 edi
  00076	57		 push	 edi
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  0007d	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@Chunked_me:
  00080	5f		 pop	 edi
  00081	5b		 pop	 ebx

; 3195 : 	}

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHUFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 20
$T3 = -40						; size = 20
$T4 = -40						; size = 20
tv435 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Mid2$1$ = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 3174 : 	{	// copy merging chunks, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 3175 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

  00028	8b 55 24	 mov	 edx, DWORD PTR __Chunk$[ebp]
  0002b	8b 75 28	 mov	 esi, DWORD PTR __Count$[ebp]
  0002e	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	8d 1c 12	 lea	 ebx, DWORD PTR [edx+edx]
  0003b	3b de		 cmp	 ebx, esi
  0003d	7f 70		 jg	 SHORT $LN3@Chunked_me
  0003f	8b c2		 mov	 eax, edx
  00041	c1 e0 04	 shl	 eax, 4
  00044	89 45 f0	 mov	 DWORD PTR tv435[ebp], eax
$LL5@Chunked_me:

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  00047	ff 75 2c	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0004a	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  0004d	83 ec 14	 sub	 esp, 20			; 00000014H
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00050	03 c2		 add	 eax, edx
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  00052	8b cc		 mov	 ecx, esp
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00054	89 45 28	 mov	 DWORD PTR __Mid2$1$[ebp], eax
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  00057	ff 75 28	 push	 DWORD PTR __Mid2$1$[ebp]
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  0005a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  00060	52		 push	 edx
; File a:\vs\vc\include\xmemory

; 759  : 		_Buf._Current = 0;

  00061	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  00068	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  0006f	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 778  : 		_Pbuf = _Right._Pbuf;

  00076	8b 45 20	 mov	 eax, DWORD PTR __Dest$[ebp+16]
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  00079	52		 push	 edx
; File a:\vs\vc\include\xmemory

; 778  : 		_Pbuf = _Right._Pbuf;

  0007a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 3182 : 		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

  0007d	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00080	57		 push	 edi
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  00087	83 c4 2c	 add	 esp, 44			; 0000002cH
; File a:\vs\vc\include\xmemory

; 778  : 		_Pbuf = _Right._Pbuf;

  0008a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0008d	89 45 20	 mov	 DWORD PTR __Dest$[ebp+16], eax

; 767  : 		if (_Buf._Begin != 0)

  00090	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00093	85 c0		 test	 eax, eax
  00095	74 09		 je	 SHORT $LN41@Chunked_me

; 41   : 	operator delete(_Pbuf);

  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	83 c4 04	 add	 esp, 4
$LN41@Chunked_me:
; File a:\vs\vc\include\algorithm

; 3183 : 		_First = _Mid2;

  000a0	8b 7d 28	 mov	 edi, DWORD PTR __Mid2$1$[ebp]
  000a3	2b f3		 sub	 esi, ebx
  000a5	8b 45 f0	 mov	 eax, DWORD PTR tv435[ebp]
  000a8	3b f3		 cmp	 esi, ebx
  000aa	7d 9b		 jge	 SHORT $LL5@Chunked_me
  000ac	8b 55 24	 mov	 edx, DWORD PTR __Chunk$[ebp]
$LN3@Chunked_me:

; 3184 : 		}
; 3185 : 
; 3186 : 	if (_Count <= _Chunk)

  000af	3b f2		 cmp	 esi, edx
  000b1	7f 38		 jg	 SHORT $LN2@Chunked_me

; 3187 : 		_Move(_First, _Last, _Dest);	// copy partial last chunk

  000b3	83 ec 14	 sub	 esp, 20			; 00000014H
  000b6	8b cc		 mov	 ecx, esp
  000b8	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  000bb	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 759  : 		_Buf._Current = 0;

  000c1	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  000c8	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  000cf	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 778  : 		_Pbuf = _Right._Pbuf;

  000d6	8b 45 20	 mov	 eax, DWORD PTR __Dest$[ebp+16]
  000d9	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 3187 : 		_Move(_First, _Last, _Dest);	// copy partial last chunk

  000dc	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  000df	57		 push	 edi
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
  000e6	83 c4 20	 add	 esp, 32			; 00000020H

; 3188 : 	else

  000e9	eb 40		 jmp	 SHORT $LN110@Chunked_me
$LN2@Chunked_me:

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  000eb	ff 75 2c	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  000ee	c1 e2 04	 shl	 edx, 4
; File a:\vs\vc\include\algorithm

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  000f1	83 ec 14	 sub	 esp, 20			; 00000014H
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  000f4	03 d7		 add	 edx, edi
; File a:\vs\vc\include\algorithm

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  000f6	8b cc		 mov	 ecx, esp
  000f8	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  000fb	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File a:\vs\vc\include\algorithm

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  00101	52		 push	 edx
; File a:\vs\vc\include\xmemory

; 759  : 		_Buf._Current = 0;

  00102	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  00109	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  00110	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 778  : 		_Pbuf = _Right._Pbuf;

  00117	8b 45 20	 mov	 eax, DWORD PTR __Dest$[ebp+16]
; File a:\vs\vc\include\algorithm

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  0011a	52		 push	 edx
; File a:\vs\vc\include\xmemory

; 778  : 		_Pbuf = _Right._Pbuf;

  0011b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 3193 : 		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

  0011e	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00121	57		 push	 edi
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@000V10@UFSortPatchDrawStructWithTerrainNum@3@@Z ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  00128	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN110@Chunked_me:
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  0012b	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  0012e	85 c0		 test	 eax, eax
  00130	74 09		 je	 SHORT $LN75@Chunked_me

; 41   : 	operator delete(_Pbuf);

  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00138	83 c4 04	 add	 esp, 4
$LN75@Chunked_me:

; 767  : 		if (_Buf._Begin != 0)

  0013b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0013e	85 c0		 test	 eax, eax
  00140	74 09		 je	 SHORT $LN85@Chunked_me

; 41   : 	operator delete(_Pbuf);

  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00148	83 c4 04	 add	 esp, 4
$LN85@Chunked_me:
; File a:\vs\vc\include\algorithm

; 3195 : 	}

  0014b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00155	59		 pop	 ecx
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::~_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
__ehhandler$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CMapOutdoor::TPatchDrawStruct *,int>, COMDAT

; 689  : 	{	// increment iterator by offset, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  : 	_Where += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	c1 e1 04	 shl	 ecx, 4
  0000c	01 08		 add	 DWORD PTR [eax], ecx

; 691  : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CMapOutdoor::TPatchDrawStruct *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z
_TEXT	SEGMENT
__Val$1 = -24						; size = 16
tv260 = -8						; size = 4
__Next1$1$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z PROC ; std::_Insertion_sort1<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum,CMapOutdoor::TPatchDrawStruct>, COMDAT

; 2999 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3000 : 	if (_First != _Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	3b d8		 cmp	 ebx, eax
  0000f	0f 84 b4 00 00
	00		 je	 $LN6@Insertion_

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00015	57		 push	 edi
  00016	8d 7b 10	 lea	 edi, DWORD PTR [ebx+16]
  00019	3b f8		 cmp	 edi, eax
  0001b	0f 84 a7 00 00
	00		 je	 $LN40@Insertion_
  00021	56		 push	 esi
  00022	8d 77 f0	 lea	 esi, DWORD PTR [edi-16]
  00025	89 75 f8	 mov	 DWORD PTR tv260[ebp], esi
$LL7@Insertion_:

; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);

  00028	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]

; 3005 : 
; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  0002c	53		 push	 ebx
  0002d	8d 45 e8	 lea	 eax, DWORD PTR __Val$1[ebp]
  00030	89 7d fc	 mov	 DWORD PTR __Next1$1$[ebp], edi
  00033	50		 push	 eax
  00034	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00037	f3 0f 7f 45 e8	 movdqu	 XMMWORD PTR __Val$1[ebp], xmm0
  0003c	e8 00 00 00 00	 call	 ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
  00041	84 c0		 test	 al, al
  00043	74 27		 je	 SHORT $LN5@Insertion_
; File a:\vs\vc\include\xutility

; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00045	8b c7		 mov	 eax, edi

; 2526 : 	while (_First != _Last)

  00047	3b df		 cmp	 ebx, edi
  00049	74 16		 je	 SHORT $LN17@Insertion_
  0004b	eb 03 8d 49 00	 npad	 5
$LL18@Insertion_:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00050	f3 0f 6f 40 f0	 movdqu	 xmm0, XMMWORD PTR [eax-16]
  00055	83 e8 10	 sub	 eax, 16			; 00000010H
  00058	f3 0f 7f 40 10	 movdqu	 XMMWORD PTR [eax+16], xmm0
  0005d	3b c3		 cmp	 eax, ebx
  0005f	75 ef		 jne	 SHORT $LL18@Insertion_
$LN17@Insertion_:
; File a:\vs\vc\include\algorithm

; 3009 : 				*_First = _Move(_Val);

  00061	f3 0f 6f 45 e8	 movdqu	 xmm0, XMMWORD PTR __Val$1[ebp]
  00066	f3 0f 7f 03	 movdqu	 XMMWORD PTR [ebx], xmm0

; 3010 : 				}
; 3011 : 			else

  0006a	eb 49		 jmp	 SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3012 : 				{	// look for insertion point after first
; 3013 : 				for (_BidIt _First1 = _Next1;
; 3014 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3015 : 					_Next1 = _First1)

  0006c	ff 75 f8	 push	 DWORD PTR tv260[ebp]
  0006f	8d 45 e8	 lea	 eax, DWORD PTR __Val$1[ebp]
  00072	50		 push	 eax
  00073	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00076	e8 00 00 00 00	 call	 ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
  0007b	84 c0		 test	 al, al
  0007d	74 27		 je	 SHORT $LN1@Insertion_
  0007f	8b 5d fc	 mov	 ebx, DWORD PTR __Next1$1$[ebp]
$LL3@Insertion_:

; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down

  00082	f3 0f 6f 06	 movdqu	 xmm0, XMMWORD PTR [esi]
  00086	8d 45 e8	 lea	 eax, DWORD PTR __Val$1[ebp]
  00089	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  0008c	f3 0f 7f 03	 movdqu	 XMMWORD PTR [ebx], xmm0
  00090	8b de		 mov	 ebx, esi
  00092	83 ee 10	 sub	 esi, 16			; 00000010H
  00095	56		 push	 esi
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
  0009c	84 c0		 test	 al, al
  0009e	75 e2		 jne	 SHORT $LL3@Insertion_
  000a0	89 5d fc	 mov	 DWORD PTR __Next1$1$[ebp], ebx
  000a3	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
$LN1@Insertion_:

; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole

  000a6	8b 45 fc	 mov	 eax, DWORD PTR __Next1$1$[ebp]
  000a9	f3 0f 6f 45 e8	 movdqu	 xmm0, XMMWORD PTR __Val$1[ebp]
  000ae	8b 75 f8	 mov	 esi, DWORD PTR tv260[ebp]
  000b1	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
$LN4@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  000b5	83 c7 10	 add	 edi, 16			; 00000010H
  000b8	83 c6 10	 add	 esi, 16			; 00000010H
  000bb	89 75 f8	 mov	 DWORD PTR tv260[ebp], esi
  000be	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  000c1	0f 85 61 ff ff
	ff		 jne	 $LL7@Insertion_
  000c7	5e		 pop	 esi
$LN40@Insertion_:
  000c8	5f		 pop	 edi
$LN6@Insertion_:
  000c9	5b		 pop	 ebx

; 3018 : 				}
; 3019 : 			}
; 3020 : 	}

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z ENDP ; std::_Insertion_sort1<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z PROC ; std::_Move_backward<CGraphicThingInstance * *,CGraphicThingInstance * *>, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2536 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi

; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000d	2b c8		 sub	 ecx, eax
  0000f	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00012	51		 push	 ecx
  00013	2b f1		 sub	 esi, ecx
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi

; 2549 : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Move_backward@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z ENDP ; std::_Move_backward<CGraphicThingInstance * *,CGraphicThingInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$1 = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Pop_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2413 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]

; 2395 : 	*_Dest = _Move(*_First);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00009	ff 75 10	 push	 DWORD PTR __Pred$[ebp]

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  0000c	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0000f	89 45 0c	 mov	 DWORD PTR __Val$1[ebp], eax

; 2395 : 	*_Dest = _Move(*_First);

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00017	2b d1		 sub	 edx, ecx
  00019	8d 45 0c	 lea	 eax, DWORD PTR __Val$1[ebp]
  0001c	83 ea 04	 sub	 edx, 4
  0001f	50		 push	 eax
  00020	c1 fa 02	 sar	 edx, 2
  00023	52		 push	 edx
  00024	6a 00		 push	 0
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Adjust_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  0002c	83 c4 14	 add	 esp, 20			; 00000014H

; 2414 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2415 : 		_Val_type(_First));
; 2416 : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Pop_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Pop_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__Top$1$ = -8						; size = 4
__Idx$1$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Adjust_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2368 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2369 : 	_Diff _Top = _Hole;

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Hole$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	56		 push	 esi

; 2370 : 	_Diff _Idx = 2 * _Hole + 2;
; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  0000e	8b 75 10	 mov	 esi, DWORD PTR __Bottom$[ebp]
  00011	8d 0c 55 02 00
	00 00		 lea	 ecx, DWORD PTR [edx*2+2]
  00018	89 4d fc	 mov	 DWORD PTR __Idx$1$[ebp], ecx
  0001b	57		 push	 edi
  0001c	8b fa		 mov	 edi, edx
  0001e	89 7d f8	 mov	 DWORD PTR __Top$1$[ebp], edi
  00021	3b ce		 cmp	 ecx, esi
  00023	0f 8d b9 00 00
	00		 jge	 $LN38@Adjust_hea
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL5@Adjust_hea:

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00030	8b 7c 8b fc	 mov	 edi, DWORD PTR [ebx+ecx*4-4]
  00034	8b 34 8b	 mov	 esi, DWORD PTR [ebx+ecx*4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0003d	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00042	8b ce		 mov	 ecx, esi
  00044	8b d8		 mov	 ebx, eax
  00046	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0004b	8b cf		 mov	 ecx, edi
  0004d	8b f0		 mov	 esi, eax
  0004f	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00054	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  00059	f3 0f 10 5b 34	 movss	 xmm3, DWORD PTR [ebx+52]
  0005e	0f 28 e5	 movaps	 xmm4, xmm5
  00061	f3 0f 5c 26	 subss	 xmm4, DWORD PTR [esi]
  00065	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00069	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  0006e	0f 28 cb	 movaps	 xmm1, xmm3
  00071	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [esi+4]
  00076	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
; File a:\vs\vc\include\algorithm

; 2375 : 			--_Idx;

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __Idx$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007e	0f 28 c2	 movaps	 xmm0, xmm2
  00081	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  00086	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0008b	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0008f	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00093	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00097	f3 0f 59 db	 mulss	 xmm3, xmm3
  0009b	f3 0f 58 e1	 addss	 xmm4, xmm1
  0009f	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000a3	f3 0f 58 eb	 addss	 xmm5, xmm3
  000a7	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000ab	f3 0f 58 e0	 addss	 xmm4, xmm0
  000af	f3 0f 58 ea	 addss	 xmm5, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  000b3	0f 2f ec	 comiss	 xmm5, xmm4
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  000b6	76 01		 jbe	 SHORT $LN2@Adjust_hea

; 2375 : 			--_Idx;

  000b8	49		 dec	 ecx
$LN2@Adjust_hea:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  000b9	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  000bc	8b 55 0c	 mov	 edx, DWORD PTR __Hole$[ebp]
  000bf	8b 75 10	 mov	 esi, DWORD PTR __Bottom$[ebp]
  000c2	8b 04 8b	 mov	 eax, DWORD PTR [ebx+ecx*4]
  000c5	89 04 93	 mov	 DWORD PTR [ebx+edx*4], eax

; 2377 : 		_Hole = _Idx;

  000c8	8b d1		 mov	 edx, ecx
  000ca	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  000d1	89 55 0c	 mov	 DWORD PTR __Hole$[ebp], edx
  000d4	89 4d fc	 mov	 DWORD PTR __Idx$1$[ebp], ecx
  000d7	3b ce		 cmp	 ecx, esi
  000d9	0f 8c 51 ff ff
	ff		 jl	 $LL5@Adjust_hea
  000df	8b 7d f8	 mov	 edi, DWORD PTR __Top$1$[ebp]
$LN38@Adjust_hea:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  000e2	75 0a		 jne	 SHORT $LN1@Adjust_hea

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  000e4	8b 44 b3 fc	 mov	 eax, DWORD PTR [ebx+esi*4-4]
  000e8	89 04 93	 mov	 DWORD PTR [ebx+edx*4], eax

; 2383 : 		_Hole = _Bottom - 1;

  000eb	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  000ee	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  000f1	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  000f4	57		 push	 edi
  000f5	52		 push	 edx
  000f6	53		 push	 ebx
  000f7	e8 00 00 00 00	 call	 ??$_Push_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Push_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  000fc	83 c4 14	 add	 esp, 20			; 00000014H
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx

; 2386 : 	}

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Adjust_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAPAVCGraphicThingInstance@@@std@@YA$$QAPAVCGraphicThingInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAVCGraphicThingInstance@@@std@@YA$$QAPAVCGraphicThingInstance@@AAPAV1@@Z PROC ; std::_Move<CGraphicThingInstance * &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAVCGraphicThingInstance@@@std@@YA$$QAPAVCGraphicThingInstance@@AAPAV1@@Z ENDP ; std::_Move<CGraphicThingInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAPAVCGraphicThingInstance@@@std@@YAAAPAPAVCGraphicThingInstance@@AAPAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAPAVCGraphicThingInstance@@@std@@YAAAPAPAVCGraphicThingInstance@@AAPAPAV1@@Z PROC ; std::forward<CGraphicThingInstance * * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAPAVCGraphicThingInstance@@@std@@YAAAPAPAVCGraphicThingInstance@@AAPAPAV1@@Z ENDP ; std::forward<CGraphicThingInstance * * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@PAVCGraphicThingInstance@@@std@@YAXAAPAVCGraphicThingInstance@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVCGraphicThingInstance@@@std@@YAXAAPAVCGraphicThingInstance@@0@Z PROC ; std::swap<CGraphicThingInstance *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAVCGraphicThingInstance@@@std@@YAXAAPAVCGraphicThingInstance@@0@Z ENDP ; std::swap<CGraphicThingInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 3032 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00009	53		 push	 ebx
  0000a	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 3033 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  0000b	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00012	8b 36		 mov	 esi, DWORD PTR [esi]
  00014	8b 3f		 mov	 edi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00016	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  0001b	8b ce		 mov	 ecx, esi
  0001d	8b d8		 mov	 ebx, eax
  0001f	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  00024	8b cf		 mov	 ecx, edi
  00026	8b f0		 mov	 esi, eax
  00028	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0002d	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  00032	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  00037	0f 28 cd	 movaps	 xmm1, xmm5
  0003a	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  0003e	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00042	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  00047	0f 28 dc	 movaps	 xmm3, xmm4
  0004a	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  0004f	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00054	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00057	0f 28 c2	 movaps	 xmm0, xmm2
  0005a	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  0005f	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00064	f3 0f 59 db	 mulss	 xmm3, xmm3
  00068	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0006c	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00070	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00074	f3 0f 58 d9	 addss	 xmm3, xmm1
  00078	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0007c	f3 0f 58 e5	 addss	 xmm4, xmm5
  00080	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00084	f3 0f 58 d8	 addss	 xmm3, xmm0
  00088	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  0008c	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3033 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  0008f	76 0b		 jbe	 SHORT $LN26@Med3
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00091	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00094	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00096	8b 03		 mov	 eax, DWORD PTR [ebx]
  00098	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  0009a	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN26@Med3:
; File a:\vs\vc\include\algorithm

; 3035 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  0009c	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3035 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  000a5	8b 3a		 mov	 edi, DWORD PTR [edx]
  000a7	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  000a9	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  000ae	8b ce		 mov	 ecx, esi
  000b0	8b d8		 mov	 ebx, eax
  000b2	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  000b7	8b cf		 mov	 ecx, edi
  000b9	8b f0		 mov	 esi, eax
  000bb	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000c0	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  000c5	f3 0f 10 5b 34	 movss	 xmm3, DWORD PTR [ebx+52]
  000ca	0f 28 e5	 movaps	 xmm4, xmm5
  000cd	f3 0f 5c 26	 subss	 xmm4, DWORD PTR [esi]
  000d1	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  000d5	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  000da	0f 28 cb	 movaps	 xmm1, xmm3
  000dd	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [esi+4]
  000e2	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
  000e7	0f 28 c2	 movaps	 xmm0, xmm2

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000ea	f3 0f 59 e4	 mulss	 xmm4, xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ee	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  000f3	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000f8	f3 0f 59 ed	 mulss	 xmm5, xmm5
  000fc	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00100	f3 0f 59 db	 mulss	 xmm3, xmm3
  00104	f3 0f 58 e1	 addss	 xmm4, xmm1
  00108	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0010c	f3 0f 58 eb	 addss	 xmm5, xmm3
  00110	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00114	f3 0f 58 e0	 addss	 xmm4, xmm0
  00118	f3 0f 58 ea	 addss	 xmm5, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  0011c	0f 2f ec	 comiss	 xmm5, xmm4
; File a:\vs\vc\include\algorithm

; 3035 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  0011f	0f 86 9f 00 00
	00		 jbe	 $LN82@Med3
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00125	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]

; 53   : 	_Left = _Move(_Right);

  00128	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0012b	8b 3a		 mov	 edi, DWORD PTR [edx]
  0012d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0012f	89 02		 mov	 DWORD PTR [edx], eax
; File a:\vs\vc\include\algorithm

; 3038 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00131	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  00134	89 39		 mov	 DWORD PTR [ecx], edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3038 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  0013c	8b 30		 mov	 esi, DWORD PTR [eax]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  0013e	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00143	8b cf		 mov	 ecx, edi
  00145	8b d8		 mov	 ebx, eax
  00147	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0014c	8b ce		 mov	 ecx, esi
  0014e	8b f8		 mov	 edi, eax
  00150	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00155	f3 0f 10 63 30	 movss	 xmm4, DWORD PTR [ebx+48]
  0015a	f3 0f 10 5b 34	 movss	 xmm3, DWORD PTR [ebx+52]
  0015f	0f 28 ec	 movaps	 xmm5, xmm4
  00162	f3 0f 5c 2f	 subss	 xmm5, DWORD PTR [edi]
  00166	f3 0f 5c 20	 subss	 xmm4, DWORD PTR [eax]
  0016a	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  0016f	0f 28 cb	 movaps	 xmm1, xmm3
  00172	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
  00177	f3 0f 5c 4f 04	 subss	 xmm1, DWORD PTR [edi+4]
  0017c	0f 28 c2	 movaps	 xmm0, xmm2

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0017f	f3 0f 59 ed	 mulss	 xmm5, xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00183	f3 0f 5c 47 08	 subss	 xmm0, DWORD PTR [edi+8]
  00188	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0018d	f3 0f 59 db	 mulss	 xmm3, xmm3
  00191	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00195	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00199	f3 0f 58 e9	 addss	 xmm5, xmm1
  0019d	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001a1	f3 0f 58 dc	 addss	 xmm3, xmm4
  001a5	f3 0f 59 d2	 mulss	 xmm2, xmm2
  001a9	f3 0f 58 e8	 addss	 xmm5, xmm0
  001ad	f3 0f 58 da	 addss	 xmm3, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  001b1	0f 2f dd	 comiss	 xmm3, xmm5
; File a:\vs\vc\include\algorithm

; 3038 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  001b4	76 0e		 jbe	 SHORT $LN82@Med3
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  001b6	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]

; 53   : 	_Left = _Move(_Right);

  001b9	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  001bc	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001be	8b 03		 mov	 eax, DWORD PTR [ebx]
  001c0	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  001c2	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN82@Med3:
  001c4	5f		 pop	 edi
  001c5	5e		 pop	 esi
  001c6	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 3041 : 	}

  001c7	5d		 pop	 ebp
  001c8	c3		 ret	 0
??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z PROC ; std::_Move_backward<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi

; 2526 : 	while (_First != _Last)

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	3b f1		 cmp	 esi, ecx
  0000f	74 15		 je	 SHORT $LN5@Move_backw
$LL6@Move_backw:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00011	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00014	83 e9 08	 sub	 ecx, 8
  00017	83 e8 08	 sub	 eax, 8
  0001a	89 10		 mov	 DWORD PTR [eax], edx
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00022	3b ce		 cmp	 ecx, esi
  00024	75 eb		 jne	 SHORT $LL6@Move_backw
$LN5@Move_backw:
  00026	5e		 pop	 esi

; 2549 : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Move_backward@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ENDP ; std::_Move_backward<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z PROC ; std::_Pop_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 2413 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]

; 2395 : 	*_Dest = _Move(*_First);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  0000c	ff 75 10	 push	 DWORD PTR __Pred$[ebp]

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  0000f	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00012	89 45 f8	 mov	 DWORD PTR __Val$1[ebp], eax
  00015	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00018	89 45 fc	 mov	 DWORD PTR __Val$1[ebp+4], eax

; 2395 : 	*_Dest = _Move(*_First);

  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	89 42 f8	 mov	 DWORD PTR [edx-8], eax
  00020	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00023	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00026	2b d1		 sub	 edx, ecx
  00028	8d 45 f8	 lea	 eax, DWORD PTR __Val$1[ebp]
  0002b	83 ea 08	 sub	 edx, 8
  0002e	50		 push	 eax
  0002f	c1 fa 03	 sar	 edx, 3
  00032	52		 push	 edx
  00033	6a 00		 push	 0
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Adjust_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
  0003b	83 c4 14	 add	 esp, 20			; 00000014H

; 2414 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2415 : 		_Val_type(_First));
; 2416 : 	}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Pop_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ENDP ; std::_Pop_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Top$1$ = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z PROC ; std::_Adjust_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>, COMDAT

; 2368 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2369 : 	_Diff _Top = _Hole;
; 2370 : 	_Diff _Idx = 2 * _Hole + 2;
; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00003	8b 55 10	 mov	 edx, DWORD PTR __Bottom$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR __Hole$[ebp]
  0000f	8b df		 mov	 ebx, edi
  00011	89 5d 0c	 mov	 DWORD PTR __Top$1$[ebp], ebx
  00014	8d 04 7d 02 00
	00 00		 lea	 eax, DWORD PTR [edi*2+2]
  0001b	3b c2		 cmp	 eax, edx
  0001d	7d 27		 jge	 SHORT $LN36@Adjust_hea
  0001f	90		 npad	 1
$LL5@Adjust_hea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00020	8b 4c c6 04	 mov	 ecx, DWORD PTR [esi+eax*8+4]
  00024	3b 4c c6 fc	 cmp	 ecx, DWORD PTR [esi+eax*8-4]
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00028	76 01		 jbe	 SHORT $LN2@Adjust_hea

; 2375 : 			--_Idx;

  0002a	48		 dec	 eax
$LN2@Adjust_hea:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0002b	8b 0c c6	 mov	 ecx, DWORD PTR [esi+eax*8]
  0002e	89 0c fe	 mov	 DWORD PTR [esi+edi*8], ecx
  00031	8b 4c c6 04	 mov	 ecx, DWORD PTR [esi+eax*8+4]
  00035	89 4c fe 04	 mov	 DWORD PTR [esi+edi*8+4], ecx

; 2377 : 		_Hole = _Idx;

  00039	8b f8		 mov	 edi, eax
  0003b	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [eax*2+2]
  00042	3b c2		 cmp	 eax, edx
  00044	7c da		 jl	 SHORT $LL5@Adjust_hea
$LN36@Adjust_hea:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  00046	75 12		 jne	 SHORT $LN1@Adjust_hea

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  00048	8b 44 d6 f8	 mov	 eax, DWORD PTR [esi+edx*8-8]
  0004c	89 04 fe	 mov	 DWORD PTR [esi+edi*8], eax
  0004f	8b 44 d6 fc	 mov	 eax, DWORD PTR [esi+edx*8-4]
  00053	89 44 fe 04	 mov	 DWORD PTR [esi+edi*8+4], eax

; 2383 : 		_Hole = _Bottom - 1;

  00057	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
$LN1@Adjust_hea:

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  0005a	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0005d	99		 cdq
  0005e	2b c2		 sub	 eax, edx
  00060	8b c8		 mov	 ecx, eax
  00062	d1 f9		 sar	 ecx, 1

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00064	3b df		 cmp	 ebx, edi
  00066	8b 5d 14	 mov	 ebx, DWORD PTR __Val$[ebp]
  00069	7d 2d		 jge	 SHORT $LN35@Adjust_hea
  0006b	eb 03 8d 49 00	 npad	 5
$LL18@Adjust_hea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00070	8b 44 ce 04	 mov	 eax, DWORD PTR [esi+ecx*8+4]
  00074	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
; File a:\vs\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00077	76 1f		 jbe	 SHORT $LN35@Adjust_hea

; 2317 : 		{	// move _Hole up to parent
; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  00079	8b 04 ce	 mov	 eax, DWORD PTR [esi+ecx*8]
  0007c	89 04 fe	 mov	 DWORD PTR [esi+edi*8], eax
  0007f	8b 44 ce 04	 mov	 eax, DWORD PTR [esi+ecx*8+4]
  00083	89 44 fe 04	 mov	 DWORD PTR [esi+edi*8+4], eax
  00087	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0008a	99		 cdq

; 2319 : 		_Hole = _Idx;

  0008b	8b f9		 mov	 edi, ecx
  0008d	2b c2		 sub	 eax, edx
  0008f	8b c8		 mov	 ecx, eax
  00091	d1 f9		 sar	 ecx, 1
  00093	39 7d 0c	 cmp	 DWORD PTR __Top$1$[ebp], edi
  00096	7c d8		 jl	 SHORT $LL18@Adjust_hea
$LN35@Adjust_hea:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  00098	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009a	89 04 fe	 mov	 DWORD PTR [esi+edi*8], eax
  0009d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000a0	89 44 fe 04	 mov	 DWORD PTR [esi+edi*8+4], eax
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);
; 2386 : 	}

  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ENDP ; std::_Adjust_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z PROC ; std::_Move<CArea::SCRCWithNumber &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAUSCRCWithNumber@CArea@@@std@@YA$$QAUSCRCWithNumber@CArea@@AAU12@@Z ENDP ; std::_Move<CArea::SCRCWithNumber &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAUSCRCWithNumber@CArea@@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUSCRCWithNumber@CArea@@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@@Z PROC ; std::forward<CArea::SCRCWithNumber * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAUSCRCWithNumber@CArea@@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@@Z ENDP ; std::forward<CArea::SCRCWithNumber * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@USCRCWithNumber@CArea@@@std@@YAXAAUSCRCWithNumber@CArea@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@USCRCWithNumber@CArea@@@std@@YAXAAUSCRCWithNumber@CArea@@0@Z PROC ; std::swap<CArea::SCRCWithNumber>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 32		 mov	 esi, DWORD PTR [edx]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00012	89 02		 mov	 DWORD PTR [edx], eax
  00014	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00017	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0001a	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0001d	5f		 pop	 edi
  0001e	89 31		 mov	 DWORD PTR [ecx], esi
  00020	5e		 pop	 esi

; 55   : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??$swap@USCRCWithNumber@CArea@@@std@@YAXAAUSCRCWithNumber@CArea@@0@Z ENDP ; std::swap<CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z PROC ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 3032 : 	{	// sort median of three elements to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
; File a:\vs\vc\include\algorithm

; 3033 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00011	76 13		 jbe	 SHORT $LN10@Med3
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00013	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00015	8b d0		 mov	 edx, eax

; 53   : 	_Left = _Move(_Right);

  00017	8b 07		 mov	 eax, DWORD PTR [edi]
  00019	89 06		 mov	 DWORD PTR [esi], eax
  0001b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00021	89 0f		 mov	 DWORD PTR [edi], ecx
  00023	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN10@Med3:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002c	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
; File a:\vs\vc\include\algorithm

; 3035 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

  0002f	76 29		 jbe	 SHORT $LN34@Med3
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	53		 push	 ebx
  00034	8b d8		 mov	 ebx, eax

; 53   : 	_Left = _Move(_Right);

  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00040	89 16		 mov	 DWORD PTR [esi], edx
  00042	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00045	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
; File a:\vs\vc\include\algorithm

; 3038 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00048	76 0f		 jbe	 SHORT $LN42@Med3
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0004a	8b 07		 mov	 eax, DWORD PTR [edi]
  0004c	89 06		 mov	 DWORD PTR [esi], eax
  0004e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00051	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00054	89 17		 mov	 DWORD PTR [edi], edx
  00056	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN42@Med3:
  00059	5b		 pop	 ebx
$LN34@Med3:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
; File a:\vs\vc\include\algorithm

; 3041 : 	}

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ENDP ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAU?$pair@MJ@std@@U?$less@X@2@U12@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAU?$pair@MJ@std@@U?$less@X@2@U12@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z PROC ; std::_Insertion_sort1<std::pair<float,long> *,std::less<void>,std::pair<float,long> >, COMDAT

; 2999 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3000 : 	if (_First != _Last)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	3b d0		 cmp	 edx, eax
  0000b	0f 84 8d 00 00
	00		 je	 $LN6@Insertion_

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00011	57		 push	 edi
  00012	8d 7a 08	 lea	 edi, DWORD PTR [edx+8]
  00015	3b f8		 cmp	 edi, eax
  00017	0f 84 80 00 00
	00		 je	 $LN85@Insertion_
  0001d	53		 push	 ebx
  0001e	56		 push	 esi
  0001f	90		 npad	 1
$LL7@Insertion_:
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00020	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
; File a:\vs\vc\include\algorithm

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00024	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00027	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
; File a:\vs\vc\include\algorithm

; 3003 : 			_BidIt _Next1 = _Next;

  0002b	8b f7		 mov	 esi, edi
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  0002d	0f 2f c1	 comiss	 xmm0, xmm1

; 157  : 		{	// construct from moved compatible pair

  00030	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00032	77 3d		 ja	 SHORT $LN24@Insertion_
  00034	0f 2f c8	 comiss	 xmm1, xmm0
  00037	77 05		 ja	 SHORT $LN5@Insertion_
  00039	3b 5a 04	 cmp	 ebx, DWORD PTR [edx+4]
  0003c	7c 33		 jl	 SHORT $LN24@Insertion_
$LN5@Insertion_:
; File a:\vs\vc\include\algorithm

; 3013 : 				for (_BidIt _First1 = _Next1;

  0003e	8b cf		 mov	 ecx, edi
$LL3@Insertion_:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00040	f3 0f 10 41 f8	 movss	 xmm0, DWORD PTR [ecx-8]
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00045	83 e9 08	 sub	 ecx, 8
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00048	0f 2f c1	 comiss	 xmm0, xmm1
  0004b	77 0a		 ja	 SHORT $LN55@Insertion_
  0004d	0f 2f c8	 comiss	 xmm1, xmm0
  00050	77 13		 ja	 SHORT $LN54@Insertion_
  00052	3b 59 04	 cmp	 ebx, DWORD PTR [ecx+4]
  00055	7d 0e		 jge	 SHORT $LN54@Insertion_
$LN55@Insertion_:

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00057	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  0005b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005e	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00061	8b f1		 mov	 esi, ecx
  00063	eb db		 jmp	 SHORT $LL3@Insertion_
$LN54@Insertion_:
; File a:\vs\vc\include\utility

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00065	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00068	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1
  0006c	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0006f	eb 23		 jmp	 SHORT $LN67@Insertion_
$LN24@Insertion_:
; File a:\vs\vc\include\xutility

; 2526 : 	while (_First != _Last)

  00071	3b d7		 cmp	 edx, edi
  00073	74 18		 je	 SHORT $LN30@Insertion_
$LL31@Insertion_:
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00075	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
; File a:\vs\vc\include\xutility

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00078	8d 49 f8	 lea	 ecx, DWORD PTR [ecx-8]
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0007b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  0007e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00080	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File a:\vs\vc\include\xutility

; 2526 : 	while (_First != _Last)

  00083	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00086	3b c2		 cmp	 eax, edx
  00088	75 eb		 jne	 SHORT $LL31@Insertion_
  0008a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
$LN30@Insertion_:
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0008d	f3 0f 11 0a	 movss	 DWORD PTR [edx], xmm1

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00091	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
$LN67@Insertion_:
; File a:\vs\vc\include\algorithm

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00094	83 c7 08	 add	 edi, 8
  00097	3b f8		 cmp	 edi, eax
  00099	75 85		 jne	 SHORT $LL7@Insertion_
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
$LN85@Insertion_:
  0009d	5f		 pop	 edi
$LN6@Insertion_:

; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down
; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole
; 3018 : 				}
; 3019 : 			}
; 3020 : 	}

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
??$_Insertion_sort1@PAU?$pair@MJ@std@@U?$less@X@2@U12@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z ENDP ; std::_Insertion_sort1<std::pair<float,long> *,std::less<void>,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__First$ = 8						; size = 4
tv266 = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z PROC ; std::_Sort_heap<std::pair<float,long> *,std::less<void> >, COMDAT

; 2475 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	8b c6		 mov	 eax, esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00010	2b c7		 sub	 eax, edi
  00012	83 e0 f8	 and	 eax, -8			; fffffff8H
  00015	83 f8 08	 cmp	 eax, 8
  00018	7e 59		 jle	 SHORT $LN1@Sort_heap
  0001a	53		 push	 ebx
  0001b	bb fc ff ff ff	 mov	 ebx, -4			; fffffffcH
  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	83 c6 fc	 add	 esi, -4			; fffffffcH
  00028	2b df		 sub	 ebx, edi
  0002a	2b c7		 sub	 eax, edi
  0002c	89 45 0c	 mov	 DWORD PTR tv266[ebp], eax
  0002f	90		 npad	 1
$LL3@Sort_heap:
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	f3 0f 10 46 fc	 movss	 xmm0, DWORD PTR [esi-4]
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  00037	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0003a	89 45 fc	 mov	 DWORD PTR __Val$1[ebp+4], eax

; 158  : 		}
; 159  : 
; 160  : 	template<class _Other1,
; 161  : 		class _Other2>
; 162  : 		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
; 163  : 			_NOEXCEPT_OP((is_nothrow_assignable<_Ty1, _Other1&&>::value
; 164  : 				&& is_nothrow_assignable<_Ty2, _Other2&&>::value))
; 165  : 		{	// assign from moved compatible pair
; 166  : 		first = _STD forward<_Other1>(_Right.first);
; 167  : 		second = _STD forward<_Other2>(_Right.second);
; 168  : 		return (*this);
; 169  : 		}
; 170  : 
; 171  : 	_Myt& operator=(_Myt&& _Right)
; 172  : 		_NOEXCEPT_OP((is_nothrow_move_assignable<_Ty1>::value
; 173  : 			&& is_nothrow_move_assignable<_Ty2>::value))
; 174  : 		{	// assign from moved pair
; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0003d	8b 07		 mov	 eax, DWORD PTR [edi]
  0003f	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00042	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00045	89 06		 mov	 DWORD PTR [esi], eax
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  00047	8d 45 f8	 lea	 eax, DWORD PTR __Val$1[ebp]
  0004a	50		 push	 eax
  0004b	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0004e	f3 0f 11 45 f8	 movss	 DWORD PTR __Val$1[ebp], xmm0
; File a:\vs\vc\include\algorithm

; 2397 : 		_Move(_Val), _Pred);

  00053	c1 f8 03	 sar	 eax, 3
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@HH$$QAU10@U?$less@X@0@@Z ; std::_Adjust_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  0005f	8b 45 0c	 mov	 eax, DWORD PTR tv266[ebp]
  00062	83 ee 08	 sub	 esi, 8
  00065	03 c6		 add	 eax, esi

; 2397 : 		_Move(_Val), _Pred);

  00067	83 c4 14	 add	 esp, 20			; 00000014H

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  0006a	83 e0 f8	 and	 eax, -8			; fffffff8H
  0006d	83 f8 08	 cmp	 eax, 8
  00070	7f be		 jg	 SHORT $LL3@Sort_heap
  00072	5b		 pop	 ebx
$LN1@Sort_heap:
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi

; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}

  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
??$_Sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ENDP ; std::_Sort_heap<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Make_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@PAH0@Z
_TEXT	SEGMENT
tv422 = -4						; size = 4
__Val$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@PAH0@Z PROC ; std::_Make_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >, COMDAT

; 2442 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2443 : 	_Diff _Bottom = _Last - _First;

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000b	2b d9		 sub	 ebx, ecx
  0000d	c1 fb 03	 sar	 ebx, 3

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00010	8b c3		 mov	 eax, ebx
  00012	89 5d 0c	 mov	 DWORD PTR __Last$[ebp], ebx
  00015	99		 cdq
  00016	2b c2		 sub	 eax, edx
  00018	57		 push	 edi
  00019	8b f8		 mov	 edi, eax
  0001b	d1 ff		 sar	 edi, 1
  0001d	85 ff		 test	 edi, edi
  0001f	0f 8e db 00 00
	00		 jle	 $LN1@Make_heap

; 2443 : 	_Diff _Bottom = _Last - _First;

  00025	8d 14 7d 02 00
	00 00		 lea	 edx, DWORD PTR [edi*2+2]
  0002c	56		 push	 esi
  0002d	8d 49 00	 npad	 3
$LL2@Make_heap:
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00030	8b 44 f9 fc	 mov	 eax, DWORD PTR [ecx+edi*8-4]
; File a:\vs\vc\include\algorithm

; 2446 : 		--_Hole;

  00034	4f		 dec	 edi
  00035	83 ea 02	 sub	 edx, 2
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00038	89 45 08	 mov	 DWORD PTR __Val$1$[ebp], eax
; File a:\vs\vc\include\algorithm

; 2446 : 		--_Hole;

  0003b	89 55 fc	 mov	 DWORD PTR tv422[ebp], edx

; 2447 : 		_Ty _Val = _Move(*(_First + _Hole));
; 2448 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2449 : 			_Move(_Val), _Pred);

  0003e	8b f7		 mov	 esi, edi
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00040	f3 0f 10 14 f9	 movss	 xmm2, DWORD PTR [ecx+edi*8]
; File a:\vs\vc\include\algorithm

; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00045	3b d3		 cmp	 edx, ebx
  00047	7d 42		 jge	 SHORT $LN17@Make_heap
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL19@Make_heap:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00050	f3 0f 10 0c d1	 movss	 xmm1, DWORD PTR [ecx+edx*8]
  00055	f3 0f 10 44 d1
	f8		 movss	 xmm0, DWORD PTR [ecx+edx*8-8]
  0005b	0f 2f c1	 comiss	 xmm0, xmm1
  0005e	77 0f		 ja	 SHORT $LN27@Make_heap
  00060	0f 2f c8	 comiss	 xmm1, xmm0
  00063	77 0b		 ja	 SHORT $LN16@Make_heap
  00065	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  00069	3b 44 d1 fc	 cmp	 eax, DWORD PTR [ecx+edx*8-4]
  0006d	7d 01		 jge	 SHORT $LN16@Make_heap
$LN27@Make_heap:
; File a:\vs\vc\include\algorithm

; 2375 : 			--_Idx;

  0006f	4a		 dec	 edx
$LN16@Make_heap:
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00070	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  00073	89 04 f1	 mov	 DWORD PTR [ecx+esi*8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00076	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  0007a	89 44 f1 04	 mov	 DWORD PTR [ecx+esi*8+4], eax
; File a:\vs\vc\include\algorithm

; 2377 : 		_Hole = _Idx;

  0007e	8b f2		 mov	 esi, edx
  00080	8d 14 55 02 00
	00 00		 lea	 edx, DWORD PTR [edx*2+2]
  00087	3b d3		 cmp	 edx, ebx
  00089	7c c5		 jl	 SHORT $LL19@Make_heap
$LN17@Make_heap:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  0008b	3b d3		 cmp	 edx, ebx
  0008d	75 12		 jne	 SHORT $LN15@Make_heap
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  0008f	8b 44 d9 f8	 mov	 eax, DWORD PTR [ecx+ebx*8-8]
  00093	89 04 f1	 mov	 DWORD PTR [ecx+esi*8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  00096	8b 44 d9 fc	 mov	 eax, DWORD PTR [ecx+ebx*8-4]
  0009a	89 44 f1 04	 mov	 DWORD PTR [ecx+esi*8+4], eax
; File a:\vs\vc\include\algorithm

; 2383 : 		_Hole = _Bottom - 1;

  0009e	8d 73 ff	 lea	 esi, DWORD PTR [ebx-1]
$LN15@Make_heap:

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  000a1	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  000a4	99		 cdq
  000a5	2b c2		 sub	 eax, edx
  000a7	8b d0		 mov	 edx, eax
  000a9	d1 fa		 sar	 edx, 1

; 2315 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2316 : 		_Idx = (_Hole - 1) / 2)

  000ab	3b fe		 cmp	 edi, esi
  000ad	7d 39		 jge	 SHORT $LN56@Make_heap
  000af	8b 5d 08	 mov	 ebx, DWORD PTR __Val$1$[ebp]
$LL49@Make_heap:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  000b2	f3 0f 10 04 d1	 movss	 xmm0, DWORD PTR [ecx+edx*8]
  000b7	0f 2f d0	 comiss	 xmm2, xmm0
  000ba	77 0b		 ja	 SHORT $LN57@Make_heap
  000bc	0f 2f c2	 comiss	 xmm0, xmm2
  000bf	77 24		 ja	 SHORT $LN89@Make_heap
  000c1	39 5c d1 04	 cmp	 DWORD PTR [ecx+edx*8+4], ebx
  000c5	7d 1e		 jge	 SHORT $LN89@Make_heap
$LN57@Make_heap:

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  000c7	8b 04 d1	 mov	 eax, DWORD PTR [ecx+edx*8]
  000ca	89 04 f1	 mov	 DWORD PTR [ecx+esi*8], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  000cd	8b 44 d1 04	 mov	 eax, DWORD PTR [ecx+edx*8+4]
  000d1	89 44 f1 04	 mov	 DWORD PTR [ecx+esi*8+4], eax
; File a:\vs\vc\include\algorithm

; 2319 : 		_Hole = _Idx;

  000d5	8b f2		 mov	 esi, edx
  000d7	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000da	99		 cdq
  000db	2b c2		 sub	 eax, edx
  000dd	8b d0		 mov	 edx, eax
  000df	d1 fa		 sar	 edx, 1
  000e1	3b fe		 cmp	 edi, esi
  000e3	7c cd		 jl	 SHORT $LL49@Make_heap
$LN89@Make_heap:
  000e5	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
$LN56@Make_heap:
; File a:\vs\vc\include\utility

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  000e8	8b 45 08	 mov	 eax, DWORD PTR __Val$1$[ebp]
; File a:\vs\vc\include\algorithm

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  000eb	8b 55 fc	 mov	 edx, DWORD PTR tv422[ebp]
; File a:\vs\vc\include\utility

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  000ee	f3 0f 11 14 f1	 movss	 DWORD PTR [ecx+esi*8], xmm2

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  000f3	89 44 f1 04	 mov	 DWORD PTR [ecx+esi*8+4], eax
; File a:\vs\vc\include\algorithm

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  000f7	85 ff		 test	 edi, edi
  000f9	0f 8f 31 ff ff
	ff		 jg	 $LL2@Make_heap
  000ff	5e		 pop	 esi
$LN1@Make_heap:
  00100	5f		 pop	 edi
  00101	5b		 pop	 ebx

; 2450 : 		}
; 2451 : 	}

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
??$_Make_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@PAH0@Z ENDP ; std::_Make_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@PAU?$pair@MJ@std@@@std@@YAPAHPAU?$pair@MJ@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAU?$pair@MJ@std@@@std@@YAPAHPAU?$pair@MJ@0@@Z PROC ; std::_Dist_type<std::pair<float,long> *>, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAU?$pair@MJ@std@@@std@@YAPAHPAU?$pair@MJ@0@@Z ENDP ; std::_Dist_type<std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAPAU?$pair@MJ@std@@AAPAU01@X@?$pair@PAU?$pair@MJ@std@@PAU12@@std@@QAE@AAPAU?$pair@MJ@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$pair@MJ@std@@AAPAU01@X@?$pair@PAU?$pair@MJ@std@@PAU12@@std@@QAE@AAPAU?$pair@MJ@1@0@Z PROC ; std::pair<std::pair<float,long> *,std::pair<float,long> *>::pair<std::pair<float,long> *,std::pair<float,long> *><std::pair<float,long> * &,std::pair<float,long> * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAU?$pair@MJ@std@@AAPAU01@X@?$pair@PAU?$pair@MJ@std@@PAU12@@std@@QAE@AAPAU?$pair@MJ@1@0@Z ENDP ; std::pair<std::pair<float,long> *,std::pair<float,long> *>::pair<std::pair<float,long> *,std::pair<float,long> *><std::pair<float,long> * &,std::pair<float,long> * &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$iter_swap@PAU?$pair@MJ@std@@PAU12@@std@@YAXPAU?$pair@MJ@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAU?$pair@MJ@std@@PAU12@@std@@YAXPAU?$pair@MJ@0@0@Z PROC ; std::iter_swap<std::pair<float,long> *,std::pair<float,long> *>, COMDAT

; 27   : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	}
; 56   : 
; 57   : 		// TEMPLATE FUNCTION _Swap_adl
; 58   : template<class _Ty> inline
; 59   : 	void _Swap_adl(_Ty& _Left, _Ty& _Right)
; 60   : 	{	// exchange values stored at _Left and _Right, using ADL
; 61   : 	swap(_Left, _Right);
; 62   : 	}
; 63   : 
; 64   : 		// STRUCT piecewise_construct_t
; 65   : struct piecewise_construct_t
; 66   : 	{	// tag type for pair tuple arguments
; 67   : 	};
; 68   : 
; 69   : const piecewise_construct_t piecewise_construct =
; 70   : 	piecewise_construct_t();
; 71   : 
; 72   : 		// TEMPLATE STRUCT pair
; 73   : 
; 74   : template<class...>
; 75   : 	class tuple;
; 76   : 
; 77   : 
; 78   : template<class _Ty1,
; 79   : 	class _Ty2>
; 80   : 	struct pair
; 81   : 	{	// store a pair of values
; 82   : 	typedef pair<_Ty1, _Ty2> _Myt;
; 83   : 	typedef _Ty1 first_type;
; 84   : 	typedef _Ty2 second_type;
; 85   : 
; 86   : 	pair()
; 87   : 		: first(), second()
; 88   : 		{	// default construct
; 89   : 		}
; 90   : 
; 91   : 	pair(const _Ty1& _Val1, const _Ty2& _Val2)
; 92   : 		: first(_Val1), second(_Val2)
; 93   : 		{	// construct from specified values
; 94   : 		}
; 95   : 
; 96   : 	template<class _Other1,
; 97   : 		class _Other2,
; 98   : 		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
; 99   : 			&& is_convertible<const _Other2&, _Ty2>::value,
; 100  : 			void>::type>
; 101  : 		pair(const pair<_Other1, _Other2>& _Right)
; 102  : 		: first(_Right.first), second(_Right.second)
; 103  : 		{	// construct from compatible pair
; 104  : 		}
; 105  : 
; 106  : 	template<class _Other1,
; 107  : 		class _Other2>
; 108  : 		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
; 109  : 		{	// assign from compatible pair
; 110  : 		first = _Right.first;
; 111  : 		second = _Right.second;
; 112  : 		return (*this);
; 113  : 		}
; 114  : 
; 115  : 
; 116  : 	template<class _Tuple1,
; 117  : 		class _Tuple2,
; 118  : 		size_t... _Indexes1,
; 119  : 		size_t... _Indexes2> inline
; 120  : 		pair(_Tuple1& _Val1,
; 121  : 			_Tuple2& _Val2,
; 122  : 			_Arg_idx<_Indexes1...>,
; 123  : 			_Arg_idx<_Indexes2...>);
; 124  : 
; 125  : 	template<class... _Types1,
; 126  : 		class... _Types2> inline
; 127  : 		pair(piecewise_construct_t,
; 128  : 			tuple<_Types1...> _Val1,
; 129  : 			tuple<_Types2...> _Val2)
; 130  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Types1&&...>::value
; 131  : 				&& is_nothrow_constructible<_Ty2, _Types2&&...>::value));
; 132  : 
; 133  : 
; 134  : 	template<class _Other1,
; 135  : 		class _Other2,
; 136  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 137  : 			&& is_convertible<_Other2, _Ty2>::value,
; 138  : 			void>::type>
; 139  : 		pair(_Other1&& _Val1, _Other2&& _Val2)
; 140  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 141  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 142  : 		: first(_STD forward<_Other1>(_Val1)),
; 143  : 				second(_STD forward<_Other2>(_Val2))
; 144  : 		{	// construct from moved values
; 145  : 		}
; 146  : 
; 147  : 	template<class _Other1,
; 148  : 		class _Other2,
; 149  : 		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
; 150  : 			&& is_convertible<_Other2, _Ty2>::value,
; 151  : 			void>::type>
; 152  : 		pair(pair<_Other1, _Other2>&& _Right)
; 153  : 			_NOEXCEPT_OP((is_nothrow_constructible<_Ty1, _Other1&&>::value
; 154  : 				&& is_nothrow_constructible<_Ty2, _Other2&&>::value))
; 155  : 		: first(_STD forward<_Other1>(_Right.first)),
; 156  : 			second(_STD forward<_Other2>(_Right.second))
; 157  : 		{	// construct from moved compatible pair
; 158  : 		}
; 159  : 
; 160  : 	template<class _Other1,
; 161  : 		class _Other2>
; 162  : 		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
; 163  : 			_NOEXCEPT_OP((is_nothrow_assignable<_Ty1, _Other1&&>::value
; 164  : 				&& is_nothrow_assignable<_Ty2, _Other2&&>::value))
; 165  : 		{	// assign from moved compatible pair
; 166  : 		first = _STD forward<_Other1>(_Right.first);
; 167  : 		second = _STD forward<_Other2>(_Right.second);
; 168  : 		return (*this);
; 169  : 		}
; 170  : 
; 171  : 	_Myt& operator=(_Myt&& _Right)
; 172  : 		_NOEXCEPT_OP((is_nothrow_move_assignable<_Ty1>::value
; 173  : 			&& is_nothrow_move_assignable<_Ty2>::value))
; 174  : 		{	// assign from moved pair
; 175  : 		first = _STD forward<_Ty1>(_Right.first);
; 176  : 		second = _STD forward<_Ty2>(_Right.second);
; 177  : 		return (*this);
; 178  : 		}
; 179  : 
; 180  : 	void swap(_Myt& _Right)
; 181  : 		_NOEXCEPT_OP(_NOEXCEPT_OP(_Swap_adl(this->first, _Right.first))
; 182  : 			&& _NOEXCEPT_OP(_Swap_adl(this->second, _Right.second)))
; 183  : 		{	// exchange contents with _Right
; 184  : 		if (this != &_Right)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000a	3b d6		 cmp	 edx, esi
  0000c	74 18		 je	 SHORT $LN20@iter_swap

; 53   : 	_Left = _Move(_Right);

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00014	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00016	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);

  0001a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 53   : 	_Left = _Move(_Right);

  0001d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00020	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00023	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN20@iter_swap:
  00026	5e		 pop	 esi

; 28   : 	swap(*_Left, *_Right);
; 29   : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$iter_swap@PAU?$pair@MJ@std@@PAU12@@std@@YAXPAU?$pair@MJ@0@0@Z ENDP ; std::iter_swap<std::pair<float,long> *,std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xstddef
;	COMDAT ??$?RAAU?$pair@MJ@std@@AAU01@@?$less@X@std@@QBE_NAAU?$pair@MJ@1@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RAAU?$pair@MJ@std@@AAU01@@?$less@X@std@@QBE_NAAU?$pair@MJ@1@0@Z PROC ; std::less<void>::operator()<std::pair<float,long> &,std::pair<float,long> &>, COMDAT
; _this$ = ecx

; 263  : 		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0000d	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00011	0f 2f c1	 comiss	 xmm0, xmm1
  00014	77 13		 ja	 SHORT $LN6@operator
  00016	0f 2f c8	 comiss	 xmm1, xmm0
  00019	77 08		 ja	 SHORT $LN5@operator
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00021	7c 06		 jl	 SHORT $LN6@operator
$LN5@operator:
; File a:\vs\vc\include\xstddef

; 268  : 			< static_cast<_Ty2&&>(_Right));

  00023	32 c0		 xor	 al, al

; 269  : 		}

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN6@operator:

; 268  : 			< static_cast<_Ty2&&>(_Right));

  00029	b0 01		 mov	 al, 1

; 269  : 		}

  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
??$?RAAU?$pair@MJ@std@@AAU01@@?$less@X@std@@QBE_NAAU?$pair@MJ@1@0@Z ENDP ; std::less<void>::operator()<std::pair<float,long> &,std::pair<float,long> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?MMJ@std@@YA_NABU?$pair@MJ@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MMJ@std@@YA_NABU?$pair@MJ@0@0@Z PROC		; std::operator<<float,long>, COMDAT

; 232  : 	{	// test if _Left < _Right for pairs

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 	return (_Left.first < _Right.first ||
; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0000d	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00011	0f 2f c1	 comiss	 xmm0, xmm1
  00014	77 11		 ja	 SHORT $LN4@operator
  00016	0f 2f c8	 comiss	 xmm1, xmm0
  00019	77 08		 ja	 SHORT $LN3@operator
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00021	7c 04		 jl	 SHORT $LN4@operator
$LN3@operator:
  00023	32 c0		 xor	 al, al

; 235  : 	}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN4@operator:

; 233  : 	return (_Left.first < _Right.first ||
; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00027	b0 01		 mov	 al, 1

; 235  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$?MMJ@std@@YA_NABU?$pair@MJ@0@0@Z ENDP		; std::operator<<float,long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Median@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Median@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z PROC ; std::_Median<std::pair<float,long> *,std::less<void> >, COMDAT

; 3046 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3047 : 	if (40 < _Last - _First)

  00004	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00007	8b c1		 mov	 eax, ecx
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	2b c3		 sub	 eax, ebx
  0000f	c1 f8 03	 sar	 eax, 3
  00012	83 f8 28	 cmp	 eax, 40			; 00000028H
  00015	7e 70		 jle	 SHORT $LN2@Median

; 3048 : 		{	// median of nine
; 3049 : 		size_t _Step = (_Last - _First + 1) / 8;

  00017	40		 inc	 eax
  00018	99		 cdq
  00019	83 e2 07	 and	 edx, 7
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	56		 push	 esi

; 3050 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00022	8b c8		 mov	 ecx, eax
  00024	57		 push	 edi
  00025	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00028	c1 e1 04	 shl	 ecx, 4
  0002b	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
  00032	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  00035	89 4d fc	 mov	 DWORD PTR tv69[ebp], ecx
  00038	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 ??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Med3<std::pair<float,long> *,std::less<void> >

; 3051 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00043	8b 5d 0c	 mov	 ebx, DWORD PTR __Mid$[ebp]
  00046	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00049	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0004c	50		 push	 eax
  0004d	8b c3		 mov	 eax, ebx
  0004f	2b c7		 sub	 eax, edi
  00051	53		 push	 ebx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Med3<std::pair<float,long> *,std::less<void> >

; 3052 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  00058	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0005b	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0005e	8b f0		 mov	 esi, eax
  00060	50		 push	 eax
  00061	2b 45 fc	 sub	 eax, DWORD PTR tv69[ebp]
  00064	2b f7		 sub	 esi, edi
  00066	56		 push	 esi
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Med3<std::pair<float,long> *,std::less<void> >

; 3053 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  0006d	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00070	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00073	56		 push	 esi
  00074	03 c7		 add	 eax, edi
  00076	53		 push	 ebx
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Med3<std::pair<float,long> *,std::less<void> >
  0007d	83 c4 40	 add	 esp, 64			; 00000040H
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx

; 3057 : 	}

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
$LN2@Median:

; 3054 : 		}
; 3055 : 	else
; 3056 : 		_Med3(_First, _Mid, _Last, _Pred);

  00087	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0008a	51		 push	 ecx
  0008b	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0008e	53		 push	 ebx
  0008f	e8 00 00 00 00	 call	 ??$_Med3@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Med3<std::pair<float,long> *,std::less<void> >
  00094	83 c4 10	 add	 esp, 16			; 00000010H
  00097	5b		 pop	 ebx

; 3057 : 	}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
??$_Median@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ENDP ; std::_Median<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Within_limits@EU?$integral_constant@_N$0A@@std@@@std@@YA_NABEU?$integral_constant@_N$0A@@0@11@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Within_limits@EU?$integral_constant@_N$0A@@std@@@std@@YA_NABEU?$integral_constant@_N$0A@@0@11@Z PROC ; std::_Within_limits<unsigned char,std::integral_constant<bool,0> >, COMDAT

; 2991 : 	{	// unsigned _Elem, unsigned _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2992 : 	return (_Val <= UCHAR_MAX);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	80 c9 ff	 or	 cl, 255			; 000000ffH
  00009	3a 08		 cmp	 cl, BYTE PTR [eax]
  0000b	1b c0		 sbb	 eax, eax
  0000d	40		 inc	 eax

; 2993 : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Within_limits@EU?$integral_constant@_N$0A@@std@@@std@@YA_NABEU?$integral_constant@_N$0A@@0@11@Z ENDP ; std::_Within_limits<unsigned char,std::integral_constant<bool,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory
;	COMDAT ??$get_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YA?AU?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@0@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YA?AU?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@0@H@Z PROC ; std::get_temporary_buffer<CMapOutdoor::TPatchDrawStruct>, COMDAT

; 22   : 	{	// get raw temporary buffer of up to _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 23   : 	_Ty *_Pbuf;
; 24   : 
; 25   : 	if (_Count < 0)

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	79 0f		 jns	 SHORT $LN7@get_tempor
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\xmemory

; 26   : 		_Count = 0;

  0000e	33 f6		 xor	 esi, esi

; 29   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

  00010	33 c9		 xor	 ecx, ecx
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00012	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00015	89 08		 mov	 DWORD PTR [eax], ecx
  00017	5e		 pop	 esi
; File a:\vs\vc\include\xmemory

; 35   : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN7@get_tempor:

; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count))

  0001a	81 fe ff ff ff
	0f		 cmp	 esi, 268435455		; 0fffffffH
  00020	77 3f		 ja	 SHORT $LN23@get_tempor

; 29   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

  00022	33 c9		 xor	 ecx, ecx
  00024	85 f6		 test	 esi, esi
  00026	7e 2e		 jle	 SHORT $LN21@get_tempor
  00028	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL4@get_tempor:

; 30   : 		if ((_Pbuf = (_Ty *)operator new(
; 31   : 			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)

  00030	8b c6		 mov	 eax, esi
  00032	c1 e0 04	 shl	 eax, 4
  00035	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  00040	8b c8		 mov	 ecx, eax
  00042	83 c4 08	 add	 esp, 8
  00045	85 c9		 test	 ecx, ecx
  00047	75 0d		 jne	 SHORT $LN21@get_tempor

; 29   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

  00049	8b c6		 mov	 eax, esi
  0004b	99		 cdq
  0004c	2b c2		 sub	 eax, edx
  0004e	8b f0		 mov	 esi, eax
  00050	d1 fe		 sar	 esi, 1
  00052	85 f6		 test	 esi, esi
  00054	7f da		 jg	 SHORT $LL4@get_tempor
$LN21@get_tempor:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0005c	89 08		 mov	 DWORD PTR [eax], ecx
  0005e	5e		 pop	 esi
; File a:\vs\vc\include\xmemory

; 35   : 	}

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN23@get_tempor:

; 28   : 		_Xbad_alloc();	// report no memory

  00061	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN25@get_tempor:
$LN22@get_tempor:
  00066	cc		 int	 3
??$get_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YA?AU?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@0@H@Z ENDP ; std::get_temporary_buffer<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::allocator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::TPatchDrawStruct>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 16		 je	 SHORT $LN4@Uninit_mov
$LL6@Uninit_mov:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00010	85 c0		 test	 eax, eax
  00012	74 08		 je	 SHORT $LN24@Uninit_mov
  00014	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  00018	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
$LN24@Uninit_mov:
; File a:\vs\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  0001c	83 c1 10	 add	 ecx, 16			; 00000010H
  0001f	83 c0 10	 add	 eax, 16			; 00000010H
  00022	3b ca		 cmp	 ecx, edx
  00024	75 ea		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);
; 451  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::allocator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z PROC ; std::_Val_type<CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z ENDP ; std::_Val_type<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::allocator<std::pair<float,long> >,std::pair<float,long> >, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	3b d7		 cmp	 edx, edi
  0000c	74 22		 je	 SHORT $LN40@Uninit_mov
  0000e	56		 push	 esi
  0000f	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00012	85 f6		 test	 esi, esi
  00014	74 0a		 je	 SHORT $LN24@Uninit_mov
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	89 06		 mov	 DWORD PTR [esi], eax
  0001a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN24@Uninit_mov:
; File a:\vs\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00020	83 c2 08	 add	 edx, 8
  00023	83 c6 08	 add	 esi, 8
  00026	3b d7		 cmp	 edx, edi
  00028	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5f		 pop	 edi

; 451  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN40@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

  00030	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	5f		 pop	 edi

; 451  : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::allocator<std::pair<float,long> >,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z PROC ; std::_Val_type<std::pair<float,long> *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ENDP ; std::_Val_type<std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber>,CArea::SCRCWithNumber>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	3b cf		 cmp	 ecx, edi
  0000c	74 22		 je	 SHORT $LN34@Uninit_mov
  0000e	56		 push	 esi
  0000f	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00012	85 f6		 test	 esi, esi
  00014	74 0a		 je	 SHORT $LN24@Uninit_mov
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	89 06		 mov	 DWORD PTR [esi], eax
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN24@Uninit_mov:
; File a:\vs\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00020	83 c1 08	 add	 ecx, 8
  00023	83 c6 08	 add	 esi, 8
  00026	3b cf		 cmp	 ecx, edi
  00028	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5f		 pop	 edi

; 451  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN34@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

  00030	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	5f		 pop	 edi

; 451  : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber>,CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned char,unsigned char,unsigned char>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	2b f0		 sub	 esi, eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	03 c6		 add	 eax, esi
  0001b	5e		 pop	 esi

; 475  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned char,unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAE@std@@YAPAEPAE@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAE@std@@YAPAEPAE@Z PROC			; std::_Val_type<unsigned char *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAE@std@@YAPAEPAE@Z ENDP			; std::_Val_type<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::destroy<CMapOutdoor::TPatchDrawStruct>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::destroy<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@MJ@std@@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@MJ@std@@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@@Z PROC ; std::allocator_traits<std::allocator<std::pair<float,long> > >::destroy<std::pair<float,long> >, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@U?$pair@MJ@std@@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@@Z ENDP ; std::allocator_traits<std::allocator<std::pair<float,long> > >::destroy<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@USCRCWithNumber@CArea@@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@USCRCWithNumber@CArea@@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@@Z PROC ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::destroy<CArea::SCRCWithNumber>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@USCRCWithNumber@CArea@@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@@Z ENDP ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::destroy<CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 20
$T2 = -32						; size = 20
__Lastn$1$ = -12					; size = 4
__Count2n$1$ = -8					; size = 4
__Firstn$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1n$1$ = 20					; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Buffered_merge<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 2910 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx

; 2911 : 	if (_Count1 == 0 || _Count2 == 0)

  00007	8b 5d 14	 mov	 ebx, DWORD PTR __Count1$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	85 db		 test	 ebx, ebx
  0000e	0f 84 c2 01 00
	00		 je	 $LN11@Buffered_m
  00014	8b 75 18	 mov	 esi, DWORD PTR __Count2$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	0f 84 b7 01 00
	00		 je	 $LN11@Buffered_m

; 2912 : 		;	// do nothing
; 2913 : 	else if (_Count1 + _Count2 == 2)

  0001f	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  00022	83 f8 02	 cmp	 eax, 2
  00025	75 2f		 jne	 SHORT $LN9@Buffered_m

; 2914 : 		{	// order two one-element partitions
; 2915 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

  00027	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0002a	8d 4d 20	 lea	 ecx, DWORD PTR __Pred$[ebp]
  0002d	8b 7d 0c	 mov	 edi, DWORD PTR __Mid$[ebp]
  00030	56		 push	 esi
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
  00037	84 c0		 test	 al, al
  00039	0f 84 97 01 00
	00		 je	 $LN11@Buffered_m
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0003f	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]
  00043	f3 0f 6f 0e	 movdqu	 xmm1, XMMWORD PTR [esi]
  00047	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0

; 54   : 	_Right = _Move(_Tmp);

  0004b	f3 0f 7f 0f	 movdqu	 XMMWORD PTR [edi], xmm1
; File a:\vs\vc\include\algorithm

; 2957 : 	}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN9@Buffered_m:

; 2916 : 			_STD iter_swap(_First, _Mid);
; 2917 : 		}
; 2918 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

  00056	8b 7d 1c	 mov	 edi, DWORD PTR __Tempbuf$[ebp]
  00059	3b de		 cmp	 ebx, esi
  0005b	7f 61		 jg	 SHORT $LN6@Buffered_m
  0005d	8b cf		 mov	 ecx, edi
  0005f	e8 00 00 00 00	 call	 ?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Maxlen
  00064	3b d8		 cmp	 ebx, eax
  00066	7f 56		 jg	 SHORT $LN6@Buffered_m
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  00068	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());

  0006b	83 ec 14	 sub	 esp, 20			; 00000014H
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  0006e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00070	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\algorithm

; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());

  00073	8b cc		 mov	 ecx, esp
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 ??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
  0007b	8b 75 0c	 mov	 esi, DWORD PTR __Mid$[ebp]
  0007e	8d 45 e0	 lea	 eax, DWORD PTR $T2[ebp]
  00081	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  00084	56		 push	 esi
  00085	53		 push	 ebx
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  0008c	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
; File a:\vs\vc\include\algorithm

; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());

  0008f	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  00092	85 c0		 test	 eax, eax
  00094	74 09		 je	 SHORT $LN39@Buffered_m

; 41   : 	operator delete(_Pbuf);

  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009c	83 c4 04	 add	 esp, 4
$LN39@Buffered_m:
; File a:\vs\vc\include\algorithm

; 2922 : 			_Mid, _Last, _First, _Pred);

  0009f	ff 75 20	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xmemory

; 837  : 		return (_Pbuf->_Current);

  000a2	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2922 : 			_Mid, _Last, _First, _Pred);

  000a5	53		 push	 ebx
  000a6	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  000a9	56		 push	 esi
  000aa	ff 70 04	 push	 DWORD PTR [eax+4]
  000ad	ff 30		 push	 DWORD PTR [eax]
  000af	e8 00 00 00 00	 call	 ??$_Merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  000b4	83 c4 18	 add	 esp, 24			; 00000018H

; 2957 : 	}

  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN6@Buffered_m:

; 2923 : 		}
; 2924 : 	else if (_Count2 <= _Tempbuf._Maxlen())

  000be	8b cf		 mov	 ecx, edi
  000c0	e8 00 00 00 00	 call	 ?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Maxlen
  000c5	3b f0		 cmp	 esi, eax
  000c7	7f 56		 jg	 SHORT $LN4@Buffered_m
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  000c9	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000cc	83 ec 14	 sub	 esp, 20			; 00000014H
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  000cf	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d1	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\algorithm

; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000d4	8b cc		 mov	 ecx, esp
  000d6	57		 push	 edi
  000d7	e8 00 00 00 00	 call	 ??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
  000dc	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  000df	8d 45 e0	 lea	 eax, DWORD PTR $T1[ebp]
  000e2	8b 5d 0c	 mov	 ebx, DWORD PTR __Mid$[ebp]
  000e5	56		 push	 esi
  000e6	53		 push	 ebx
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ??$_Move@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YA?AV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@PAUTPatchDrawStruct@CMapOutdoor@@0V10@@Z ; std::_Move<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct> >
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  000ed	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
; File a:\vs\vc\include\algorithm

; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());

  000f0	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  000f3	85 c0		 test	 eax, eax
  000f5	74 09		 je	 SHORT $LN55@Buffered_m

; 41   : 	operator delete(_Pbuf);

  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000fd	83 c4 04	 add	 esp, 4
$LN55@Buffered_m:
; File a:\vs\vc\include\algorithm

; 2928 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);

  00100	ff 75 20	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xmemory

; 837  : 		return (_Pbuf->_Current);

  00103	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 2928 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);

  00106	56		 push	 esi
  00107	ff 70 04	 push	 DWORD PTR [eax+4]
  0010a	ff 30		 push	 DWORD PTR [eax]
  0010c	53		 push	 ebx
  0010d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00110	e8 00 00 00 00	 call	 ??$_Merge_backward@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@PAU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0000UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Merge_backward<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  00115	83 c4 18	 add	 esp, 24			; 00000018H

; 2957 : 	}

  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c3		 ret	 0
$LN4@Buffered_m:

; 2535 : 			_Dist_type(_First))));

  0011f	6a 00		 push	 0
  00121	ff 75 20	 push	 DWORD PTR __Pred$[ebp]

; 2929 : 		}
; 2930 : 	else
; 2931 : 		{	// buffer too small, divide and conquer
; 2932 : 		_BidIt _Firstn, _Lastn;
; 2933 : 		_Diff _Count1n, _Count2n;
; 2934 : 		if (_Count2 < _Count1)

  00124	3b f3		 cmp	 esi, ebx
  00126	7d 35		 jge	 SHORT $LN2@Buffered_m

; 2935 : 			{	// left larger, cut it in half and partition right to match
; 2936 : 			_Count1n = _Count1 / 2, _Count2n = 0;

  00128	8b c3		 mov	 eax, ebx
  0012a	99		 cdq
  0012b	2b c2		 sub	 eax, edx
  0012d	d1 f8		 sar	 eax, 1
  0012f	89 45 14	 mov	 DWORD PTR __Count1n$1$[ebp], eax
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00132	c1 e0 04	 shl	 eax, 4
  00135	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

  00138	50		 push	 eax
  00139	ff 75 10	 push	 DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0013c	89 45 fc	 mov	 DWORD PTR __Firstn$1$[ebp], eax
; File a:\vs\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

  0013f	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00142	e8 00 00 00 00	 call	 ??$_Lower_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ; std::_Lower_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00147	8b f0		 mov	 esi, eax
; File a:\vs\vc\include\algorithm

; 2939 : 			_Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);

  00149	89 45 f4	 mov	 DWORD PTR __Lastn$1$[ebp], eax
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  0014c	2b 75 0c	 sub	 esi, DWORD PTR __Mid$[ebp]
; File a:\vs\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

  0014f	83 c4 14	 add	 esp, 20			; 00000014H

; 2942 : 		else

  00152	8b 45 14	 mov	 eax, DWORD PTR __Count1n$1$[ebp]
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00155	c1 fe 04	 sar	 esi, 4
  00158	89 75 f8	 mov	 DWORD PTR __Count2n$1$[ebp], esi
; File a:\vs\vc\include\algorithm

; 2942 : 		else

  0015b	eb 32		 jmp	 SHORT $LN103@Buffered_m
$LN2@Buffered_m:
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0015d	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
; File a:\vs\vc\include\algorithm

; 2944 : 			_Count1n = 0, _Count2n = _Count2 / 2;

  00160	8b c6		 mov	 eax, esi
  00162	99		 cdq
  00163	2b c2		 sub	 eax, edx
  00165	8b f0		 mov	 esi, eax
  00167	d1 fe		 sar	 esi, 1
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00169	8b c6		 mov	 eax, esi
; File a:\vs\vc\include\algorithm

; 2944 : 			_Count1n = 0, _Count2n = _Count2 / 2;

  0016b	89 75 f8	 mov	 DWORD PTR __Count2n$1$[ebp], esi
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0016e	c1 e0 04	 shl	 eax, 4
  00171	03 c1		 add	 eax, ecx
; File a:\vs\vc\include\algorithm

; 2584 : 			_Dist_type(_First))));

  00173	50		 push	 eax
  00174	51		 push	 ecx
  00175	ff 75 08	 push	 DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00178	89 45 f4	 mov	 DWORD PTR __Lastn$1$[ebp], eax
; File a:\vs\vc\include\algorithm

; 2584 : 			_Dist_type(_First))));

  0017b	e8 00 00 00 00	 call	 ??$_Upper_bound@PAUTPatchDrawStruct@CMapOutdoor@@U12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@0ABU12@UFSortPatchDrawStructWithTerrainNum@2@PAH@Z ; std::_Upper_bound<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>

; 2945 : 			_Lastn = _Mid;
; 2946 : 			_STD advance(_Lastn, _Count2n);
; 2947 : 			_Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);

  00180	89 45 fc	 mov	 DWORD PTR __Firstn$1$[ebp], eax

; 2584 : 			_Dist_type(_First))));

  00183	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00186	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00189	c1 f8 04	 sar	 eax, 4
  0018c	89 45 14	 mov	 DWORD PTR __Count1n$1$[ebp], eax
$LN103@Buffered_m:
; File a:\vs\vc\include\algorithm

; 2951 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

  0018f	57		 push	 edi
  00190	56		 push	 esi
  00191	2b d8		 sub	 ebx, eax
  00193	53		 push	 ebx
  00194	ff 75 f4	 push	 DWORD PTR __Lastn$1$[ebp]
  00197	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0019a	ff 75 fc	 push	 DWORD PTR __Firstn$1$[ebp]
  0019d	e8 00 00 00 00	 call	 ??$_Buffered_rotate@PAUTPatchDrawStruct@CMapOutdoor@@HU12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ; std::_Buffered_rotate<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct>

; 2952 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2953 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

  001a2	ff 75 20	 push	 DWORD PTR __Pred$[ebp]
  001a5	8b f0		 mov	 esi, eax
  001a7	8b 45 14	 mov	 eax, DWORD PTR __Count1n$1$[ebp]
  001aa	57		 push	 edi
  001ab	ff 75 f8	 push	 DWORD PTR __Count2n$1$[ebp]
  001ae	50		 push	 eax
  001af	56		 push	 esi
  001b0	ff 75 fc	 push	 DWORD PTR __Firstn$1$[ebp]
  001b3	ff 75 08	 push	 DWORD PTR __First$[ebp]
  001b6	e8 00 00 00 00	 call	 ??$_Buffered_merge@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Buffered_merge<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>

; 2954 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2955 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

  001bb	ff 75 20	 push	 DWORD PTR __Pred$[ebp]
  001be	8b 45 18	 mov	 eax, DWORD PTR __Count2$[ebp]
  001c1	2b 45 f8	 sub	 eax, DWORD PTR __Count2n$1$[ebp]
  001c4	57		 push	 edi
  001c5	50		 push	 eax
  001c6	53		 push	 ebx
  001c7	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  001ca	ff 75 f4	 push	 DWORD PTR __Lastn$1$[ebp]
  001cd	56		 push	 esi
  001ce	e8 00 00 00 00	 call	 ??$_Buffered_merge@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Buffered_merge<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  001d3	83 c4 50	 add	 esp, 80			; 00000050H
$LN11@Buffered_m:

; 2957 : 	}

  001d6	5f		 pop	 edi
  001d7	5e		 pop	 esi
  001d8	5b		 pop	 ebx
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c3		 ret	 0
??$_Buffered_merge@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Buffered_merge<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Buffered_merge_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 3203 : 	{	// sort using temp buffer for merges, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3204 : 	_BidIt _Mid = _First;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	53		 push	 ebx

; 3205 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0000f	7c 29		 jl	 SHORT $LN4@Buffered_m

; 3204 : 	_BidIt _Mid = _First;

  00011	8b fb		 mov	 edi, ebx
  00013	c1 ef 05	 shr	 edi, 5
  00016	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL6@Buffered_m:

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00020	6a 00		 push	 0
  00022	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00025	8d b0 00 02 00
	00		 lea	 esi, DWORD PTR [eax+512]
; File a:\vs\vc\include\algorithm

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  0002b	56		 push	 esi
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z ; std::_Insertion_sort1<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum,CMapOutdoor::TPatchDrawStruct>
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 3206 : 		{	// sort chunks
; 3207 : 		_BidIt _Midn = _Mid;
; 3208 : 		_STD advance(_Midn, (int)_ISORT_MAX);
; 3209 : 
; 3210 : 		_Insertion_sort(_Mid, _Midn, _Pred);
; 3211 : 		_Mid = _Midn;

  00035	8b c6		 mov	 eax, esi
  00037	4f		 dec	 edi
  00038	75 e6		 jne	 SHORT $LL6@Buffered_m
$LN4@Buffered_m:

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  0003a	6a 00		 push	 0
  0003c	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0003f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z ; std::_Insertion_sort1<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum,CMapOutdoor::TPatchDrawStruct>

; 3212 : 		}
; 3213 : 	_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk
; 3214 : 
; 3215 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

  00048	be 20 00 00 00	 mov	 esi, 32			; 00000020H

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 3212 : 		}
; 3213 : 	_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk
; 3214 : 
; 3215 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

  00050	3b de		 cmp	 ebx, esi
  00052	7e 61		 jle	 SHORT $LN1@Buffered_m
  00054	8b 7d 14	 mov	 edi, DWORD PTR __Tempbuf$[ebp]
$LL3@Buffered_m:

; 3218 : 			_Chunk, _Count, _Pred);

  00057	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  0005a	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 3218 : 			_Chunk, _Count, _Pred);

  0005d	53		 push	 ebx
  0005e	56		 push	 esi
  0005f	83 ec 14	 sub	 esp, 20			; 00000014H
; File a:\vs\vc\include\xmemory

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  00062	8b 01		 mov	 eax, DWORD PTR [ecx]
  00064	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\algorithm

; 3218 : 			_Chunk, _Count, _Pred);

  00067	8b cc		 mov	 ecx, esp
  00069	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0006c	ff 75 08	 push	 DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xmemory

; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  0006f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 759  : 		_Buf._Current = 0;

  00075	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  0007c	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  00083	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 762  : 		*this = _Right;
; 763  : 		}
; 764  : 
; 765  : 	~_Temp_iterator() _NOEXCEPT
; 766  : 		{	// destroy the object
; 767  : 		if (_Buf._Begin != 0)
; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
; 777  : 		{	// assign _Right (share active buffer)
; 778  : 		_Pbuf = _Right._Pbuf;

  0008a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0008d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
; File a:\vs\vc\include\algorithm

; 3218 : 			_Chunk, _Count, _Pred);

  00090	e8 00 00 00 00	 call	 ??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0V?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@HHUFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>

; 3220 : 			_Chunk *= 2, _Count, _Pred);

  00095	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xmemory

; 837  : 		return (_Pbuf->_Current);

  00098	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File a:\vs\vc\include\algorithm

; 3220 : 			_Chunk *= 2, _Count, _Pred);

  0009b	03 f6		 add	 esi, esi
  0009d	53		 push	 ebx
  0009e	56		 push	 esi
  0009f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000a2	ff 70 04	 push	 DWORD PTR [eax+4]
  000a5	ff 30		 push	 DWORD PTR [eax]
  000a7	e8 00 00 00 00	 call	 ??$_Chunked_merge@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@HUFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHUFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Chunked_merge<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  000ac	03 f6		 add	 esi, esi
  000ae	83 c4 40	 add	 esp, 64			; 00000040H
  000b1	3b f3		 cmp	 esi, ebx
  000b3	7c a2		 jl	 SHORT $LL3@Buffered_m
$LN1@Buffered_m:

; 3221 : 		}
; 3222 : 	}

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$_Buffered_merge_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Buffered_merge_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@H@Z PROC ; std::advance<CMapOutdoor::TPatchDrawStruct *,int>, COMDAT

; 696  : 	{	// increment iterator by offset, arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  : 	_Where += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	c1 e1 04	 shl	 ecx, 4
  0000c	01 08		 add	 DWORD PTR [eax], ecx

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$advance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXAAPAUTPatchDrawStruct@CMapOutdoor@@H@Z ENDP ; std::advance<CMapOutdoor::TPatchDrawStruct *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Insertion_sort<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 3025 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z ; std::_Insertion_sort1<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum,CMapOutdoor::TPatchDrawStruct>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 3027 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Insertion_sort@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Insertion_sort<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Distance2@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CMapOutdoor::TPatchDrawStruct *,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	c1 f9 04	 sar	 ecx, 4
  0000f	01 08		 add	 DWORD PTR [eax], ecx

; 751  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Distance2@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CMapOutdoor::TPatchDrawStruct *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::_Iter_cat<CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 405  : 	{	// return category from iterator argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Iter_cat@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::_Iter_cat<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAV1@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z
_TEXT	SEGMENT
tv752 = -20						; size = 4
__First1$1$ = -16					; size = 4
__Next1$1$ = -12					; size = 4
__Next$1$ = -8						; size = 4
__Val$1$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAV1@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z PROC ; std::_Insertion_sort1<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder,CGraphicThingInstance *>, COMDAT

; 2999 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3000 : 	if (_First != _Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	3b f0		 cmp	 esi, eax
  0000f	0f 84 22 02 00
	00		 je	 $LN6@Insertion_

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00015	53		 push	 ebx
  00016	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00019	89 5d f8	 mov	 DWORD PTR __Next$1$[ebp], ebx
  0001c	3b d8		 cmp	 ebx, eax
  0001e	0f 84 12 02 00
	00		 je	 $LN68@Insertion_
  00024	b8 04 00 00 00	 mov	 eax, 4
  00029	2b c6		 sub	 eax, esi
  0002b	89 45 ec	 mov	 DWORD PTR tv752[ebp], eax
  0002e	57		 push	 edi
  0002f	90		 npad	 1
$LL7@Insertion_:

; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);

  00030	8b 3b		 mov	 edi, DWORD PTR [ebx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  00038	8b 36		 mov	 esi, DWORD PTR [esi]
  0003a	89 5d f4	 mov	 DWORD PTR __Next1$1$[ebp], ebx
  0003d	89 7d fc	 mov	 DWORD PTR __Val$1$[ebp], edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00040	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00045	8b cf		 mov	 ecx, edi
  00047	8b d8		 mov	 ebx, eax
  00049	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0004e	8b ce		 mov	 ecx, esi
  00050	8b f8		 mov	 edi, eax
  00052	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00057	f3 0f 10 63 30	 movss	 xmm4, DWORD PTR [ebx+48]
  0005c	f3 0f 10 5b 34	 movss	 xmm3, DWORD PTR [ebx+52]
  00061	0f 28 ec	 movaps	 xmm5, xmm4
  00064	f3 0f 5c 2f	 subss	 xmm5, DWORD PTR [edi]
  00068	f3 0f 5c 20	 subss	 xmm4, DWORD PTR [eax]
  0006c	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  00071	0f 28 cb	 movaps	 xmm1, xmm3
  00074	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
  00079	f3 0f 5c 4f 04	 subss	 xmm1, DWORD PTR [edi+4]
  0007e	0f 28 c2	 movaps	 xmm0, xmm2

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00081	f3 0f 59 ed	 mulss	 xmm5, xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00085	f3 0f 5c 47 08	 subss	 xmm0, DWORD PTR [edi+8]
  0008a	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0008f	f3 0f 59 db	 mulss	 xmm3, xmm3
  00093	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00097	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0009b	f3 0f 58 e9	 addss	 xmm5, xmm1
  0009f	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000a3	f3 0f 58 dc	 addss	 xmm3, xmm4
  000a7	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000ab	f3 0f 58 e8	 addss	 xmm5, xmm0
  000af	f3 0f 58 da	 addss	 xmm3, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  000b3	0f 2f dd	 comiss	 xmm3, xmm5
; File a:\vs\vc\include\algorithm

; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  000b6	76 34		 jbe	 SHORT $LN5@Insertion_
; File a:\vs\vc\include\xutility

; 2536 : 	ptrdiff_t _Count = _Last - _First;

  000b8	8b 45 ec	 mov	 eax, DWORD PTR tv752[ebp]
  000bb	8b 5d f8	 mov	 ebx, DWORD PTR __Next$1$[ebp]
  000be	83 c0 fc	 add	 eax, -4			; fffffffcH

; 2538 : 		_Count * sizeof (*_First));

  000c1	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  000c4	03 c3		 add	 eax, ebx
  000c6	c1 f8 02	 sar	 eax, 2
  000c9	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  000d0	8b c3		 mov	 eax, ebx
  000d2	51		 push	 ecx
  000d3	2b c1		 sub	 eax, ecx
  000d5	83 c0 04	 add	 eax, 4
  000d8	56		 push	 esi
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\algorithm

; 3009 : 				*_First = _Move(_Val);

  000df	8b 4d fc	 mov	 ecx, DWORD PTR __Val$1$[ebp]
; File a:\vs\vc\include\xutility

; 2538 : 		_Count * sizeof (*_First));

  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\algorithm

; 3009 : 				*_First = _Move(_Val);

  000e5	89 0e		 mov	 DWORD PTR [esi], ecx

; 3010 : 				}
; 3011 : 			else

  000e7	e9 3a 01 00 00	 jmp	 $LN4@Insertion_
$LN5@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  000ec	8b 75 f8	 mov	 esi, DWORD PTR __Next$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  000f5	83 c6 fc	 add	 esi, -4			; fffffffcH
  000f8	89 75 f0	 mov	 DWORD PTR __First1$1$[ebp], esi

; 3015 : 					_Next1 = _First1)

  000fb	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  000fd	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00102	8b 4d fc	 mov	 ecx, DWORD PTR __Val$1$[ebp]
  00105	8b d8		 mov	 ebx, eax
  00107	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0010c	8b ce		 mov	 ecx, esi
  0010e	8b f8		 mov	 edi, eax
  00110	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00115	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  0011a	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  0011f	0f 28 cd	 movaps	 xmm1, xmm5
  00122	f3 0f 5c 0f	 subss	 xmm1, DWORD PTR [edi]
  00126	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  0012a	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  0012f	0f 28 dc	 movaps	 xmm3, xmm4
  00132	f3 0f 5c 5f 04	 subss	 xmm3, DWORD PTR [edi+4]
  00137	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  0013c	0f 28 c2	 movaps	 xmm0, xmm2

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0013f	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00143	f3 0f 5c 47 08	 subss	 xmm0, DWORD PTR [edi+8]
  00148	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0014d	f3 0f 59 db	 mulss	 xmm3, xmm3
  00151	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00155	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00159	f3 0f 58 d9	 addss	 xmm3, xmm1
  0015d	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00161	f3 0f 58 e5	 addss	 xmm4, xmm5
  00165	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00169	f3 0f 58 d8	 addss	 xmm3, xmm0
  0016d	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  00171	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00174	0f 86 9e 00 00
	00		 jbe	 $LN1@Insertion_
  0017a	8d 9b 00 00 00
	00		 npad	 6
$LL3@Insertion_:

; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down

  00180	8b 4d f0	 mov	 ecx, DWORD PTR __First1$1$[ebp]
  00183	8b 55 f4	 mov	 edx, DWORD PTR __Next1$1$[ebp]
  00186	89 4d f4	 mov	 DWORD PTR __Next1$1$[ebp], ecx
  00189	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018b	83 e9 04	 sub	 ecx, 4
  0018e	89 02		 mov	 DWORD PTR [edx], eax
  00190	89 4d f0	 mov	 DWORD PTR __First1$1$[ebp], ecx
  00193	8b 31		 mov	 esi, DWORD PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00195	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0019b	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  001a0	8b 4d fc	 mov	 ecx, DWORD PTR __Val$1$[ebp]
  001a3	8b d8		 mov	 ebx, eax
  001a5	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  001aa	8b ce		 mov	 ecx, esi
  001ac	8b f8		 mov	 edi, eax
  001ae	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001b3	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  001b8	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  001bd	0f 28 cd	 movaps	 xmm1, xmm5
  001c0	f3 0f 5c 0f	 subss	 xmm1, DWORD PTR [edi]
  001c4	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  001c8	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  001cd	0f 28 dc	 movaps	 xmm3, xmm4
  001d0	f3 0f 5c 5f 04	 subss	 xmm3, DWORD PTR [edi+4]
  001d5	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  001da	0f 28 c2	 movaps	 xmm0, xmm2

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001dd	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001e1	f3 0f 5c 47 08	 subss	 xmm0, DWORD PTR [edi+8]
  001e6	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001eb	f3 0f 59 db	 mulss	 xmm3, xmm3
  001ef	f3 0f 59 e4	 mulss	 xmm4, xmm4
  001f3	f3 0f 59 ed	 mulss	 xmm5, xmm5
  001f7	f3 0f 58 d9	 addss	 xmm3, xmm1
  001fb	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001ff	f3 0f 58 e5	 addss	 xmm4, xmm5
  00203	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00207	f3 0f 58 d8	 addss	 xmm3, xmm0
  0020b	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  0020f	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00212	0f 87 68 ff ff
	ff		 ja	 $LL3@Insertion_
$LN1@Insertion_:

; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole

  00218	8b 55 f4	 mov	 edx, DWORD PTR __Next1$1$[ebp]
  0021b	8b 45 fc	 mov	 eax, DWORD PTR __Val$1$[ebp]
  0021e	8b 5d f8	 mov	 ebx, DWORD PTR __Next$1$[ebp]
  00221	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00224	89 02		 mov	 DWORD PTR [edx], eax
$LN4@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00226	83 c3 04	 add	 ebx, 4
  00229	89 5d f8	 mov	 DWORD PTR __Next$1$[ebp], ebx
  0022c	3b 5d 0c	 cmp	 ebx, DWORD PTR __Last$[ebp]
  0022f	0f 85 fb fd ff
	ff		 jne	 $LL7@Insertion_
  00235	5f		 pop	 edi
$LN68@Insertion_:
  00236	5b		 pop	 ebx
$LN6@Insertion_:
  00237	5e		 pop	 esi

; 3018 : 				}
; 3019 : 			}
; 3020 : 	}

  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c3		 ret	 0
??$_Insertion_sort1@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAV1@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z ENDP ; std::_Insertion_sort1<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder,CGraphicThingInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Val$1 = 12						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2475 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000b	2b f7		 sub	 esi, edi
  0000d	8b c6		 mov	 eax, esi
  0000f	83 e0 fc	 and	 eax, -4			; fffffffcH
  00012	83 f8 04	 cmp	 eax, 4
  00015	7e 3b		 jle	 SHORT $LN1@Sort_heap
  00017	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL3@Sort_heap:

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00020	8b 44 37 fc	 mov	 eax, DWORD PTR [edi+esi-4]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00024	ff 75 10	 push	 DWORD PTR __Pred$[ebp]

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00027	89 45 0c	 mov	 DWORD PTR __Val$1[ebp], eax

; 2395 : 	*_Dest = _Move(*_First);

  0002a	8b 07		 mov	 eax, DWORD PTR [edi]
  0002c	89 44 37 fc	 mov	 DWORD PTR [edi+esi-4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00030	8d 45 0c	 lea	 eax, DWORD PTR __Val$1[ebp]
  00033	50		 push	 eax
  00034	83 c6 fc	 add	 esi, -4			; fffffffcH
  00037	8b c6		 mov	 eax, esi
  00039	c1 f8 02	 sar	 eax, 2
  0003c	50		 push	 eax
  0003d	6a 00		 push	 0
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Adjust_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  00045	8b c6		 mov	 eax, esi

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00047	83 c4 14	 add	 esp, 20			; 00000014H

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  0004a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0004d	83 f8 04	 cmp	 eax, 4
  00050	7f ce		 jg	 SHORT $LL3@Sort_heap
$LN1@Sort_heap:
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$_Sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Make_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH0@Z
_TEXT	SEGMENT
__Val$1 = -24						; size = 4
__Pred$ = -20						; size = 1
__Hole$1$ = -16						; size = 4
tv483 = -12						; size = 4
__Hole$1$ = -8						; size = 4
__Idx$1$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH0@Z PROC ; std::_Make_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2442 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx

; 2443 : 	_Diff _Bottom = _Last - _First;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000e	2b f3		 sub	 esi, ebx
  00010	c1 fe 02	 sar	 esi, 2

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00013	8b c6		 mov	 eax, esi
  00015	89 75 0c	 mov	 DWORD PTR __Last$[ebp], esi
  00018	99		 cdq
  00019	2b c2		 sub	 eax, edx
  0001b	57		 push	 edi
  0001c	8b f8		 mov	 edi, eax
  0001e	d1 ff		 sar	 edi, 1
  00020	85 ff		 test	 edi, edi
  00022	0f 8e 15 01 00
	00		 jle	 $LN1@Make_heap

; 2443 : 	_Diff _Bottom = _Last - _First;

  00028	8d 0c 7d 02 00
	00 00		 lea	 ecx, DWORD PTR [edi*2+2]
  0002f	90		 npad	 1
$LL2@Make_heap:

; 2445 : 		{	// reheap top half, bottom to top
; 2446 : 		--_Hole;
; 2447 : 		_Ty _Val = _Move(*(_First + _Hole));

  00030	8b 44 bb fc	 mov	 eax, DWORD PTR [ebx+edi*4-4]
  00034	4f		 dec	 edi
  00035	83 e9 02	 sub	 ecx, 2
  00038	89 45 e8	 mov	 DWORD PTR __Val$1[ebp], eax

; 2448 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2449 : 			_Move(_Val), _Pred);

  0003b	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0003e	8b d7		 mov	 edx, edi
  00040	89 7d f0	 mov	 DWORD PTR __Hole$1$[ebp], edi
  00043	89 4d f4	 mov	 DWORD PTR tv483[ebp], ecx
  00046	88 45 ec	 mov	 BYTE PTR __Pred$[ebp], al
  00049	89 55 f8	 mov	 DWORD PTR __Hole$1$[ebp], edx

; 2370 : 	_Diff _Idx = 2 * _Hole + 2;

  0004c	89 4d fc	 mov	 DWORD PTR __Idx$1$[ebp], ecx

; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  0004f	3b ce		 cmp	 ecx, esi
  00051	0f 8d bb 00 00
	00		 jge	 $LN11@Make_heap
  00057	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL13@Make_heap:

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  00060	8b 7c 8b fc	 mov	 edi, DWORD PTR [ebx+ecx*4-4]
  00064	8b 34 8b	 mov	 esi, DWORD PTR [ebx+ecx*4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0006d	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00072	8b ce		 mov	 ecx, esi
  00074	8b d8		 mov	 ebx, eax
  00076	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0007b	8b cf		 mov	 ecx, edi
  0007d	8b f0		 mov	 esi, eax
  0007f	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00084	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  00089	f3 0f 10 5b 34	 movss	 xmm3, DWORD PTR [ebx+52]
  0008e	0f 28 e5	 movaps	 xmm4, xmm5
  00091	f3 0f 5c 26	 subss	 xmm4, DWORD PTR [esi]
  00095	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00099	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  0009e	0f 28 cb	 movaps	 xmm1, xmm3
  000a1	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [esi+4]
  000a6	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
; File a:\vs\vc\include\algorithm

; 2375 : 			--_Idx;

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR __Idx$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ae	0f 28 c2	 movaps	 xmm0, xmm2
  000b1	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  000b6	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 264  : }
; 265  : 
; 266  : D3DXINLINE D3DXVECTOR3
; 267  : D3DXVECTOR3::operator * ( FLOAT f ) const
; 268  : {
; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);
; 270  : }
; 271  : 
; 272  : D3DXINLINE D3DXVECTOR3
; 273  : D3DXVECTOR3::operator / ( FLOAT f ) const
; 274  : {
; 275  :     FLOAT fInv = 1.0f / f;
; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
; 277  : }
; 278  : 
; 279  : 
; 280  : D3DXINLINE D3DXVECTOR3
; 281  : operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
; 282  : {
; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
; 284  : }
; 285  : 
; 286  : 
; 287  : D3DXINLINE BOOL
; 288  : D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
; 289  : {
; 290  :     return x == v.x && y == v.y && z == v.z;
; 291  : }
; 292  : 
; 293  : D3DXINLINE BOOL
; 294  : D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
; 295  : {
; 296  :     return x != v.x || y != v.y || z != v.z;
; 297  : }
; 298  : 
; 299  : 
; 300  : 
; 301  : //--------------------------
; 302  : // 4D Vector
; 303  : //--------------------------
; 304  : D3DXINLINE
; 305  : D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
; 306  : {
; 307  : #ifdef D3DX_DEBUG
; 308  :     if(!pf)
; 309  :         return;
; 310  : #endif
; 311  : 
; 312  :     x = pf[0];
; 313  :     y = pf[1];
; 314  :     z = pf[2];
; 315  :     w = pf[3];
; 316  : }
; 317  : 
; 318  : D3DXINLINE
; 319  : D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 320  : {
; 321  :     x = fx;
; 322  :     y = fy;
; 323  :     z = fz;
; 324  :     w = fw;
; 325  : }
; 326  : 
; 327  : 
; 328  : // casting
; 329  : D3DXINLINE
; 330  : D3DXVECTOR4::operator FLOAT* ()
; 331  : {
; 332  :     return (FLOAT *) &x;
; 333  : }
; 334  : 
; 335  : D3DXINLINE
; 336  : D3DXVECTOR4::operator CONST FLOAT* () const
; 337  : {
; 338  :     return (CONST FLOAT *) &x;
; 339  : }
; 340  : 
; 341  : 
; 342  : // assignment operators
; 343  : D3DXINLINE D3DXVECTOR4&
; 344  : D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
; 345  : {
; 346  :     x += v.x;
; 347  :     y += v.y;
; 348  :     z += v.z;
; 349  :     w += v.w;
; 350  :     return *this;
; 351  : }
; 352  : 
; 353  : D3DXINLINE D3DXVECTOR4&
; 354  : D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
; 355  : {
; 356  :     x -= v.x;
; 357  :     y -= v.y;
; 358  :     z -= v.z;
; 359  :     w -= v.w;
; 360  :     return *this;
; 361  : }
; 362  : 
; 363  : D3DXINLINE D3DXVECTOR4&
; 364  : D3DXVECTOR4::operator *= ( FLOAT f )
; 365  : {
; 366  :     x *= f;
; 367  :     y *= f;
; 368  :     z *= f;
; 369  :     w *= f;
; 370  :     return *this;
; 371  : }
; 372  : 
; 373  : D3DXINLINE D3DXVECTOR4&
; 374  : D3DXVECTOR4::operator /= ( FLOAT f )
; 375  : {
; 376  :     FLOAT fInv = 1.0f / f;
; 377  :     x *= fInv;
; 378  :     y *= fInv;
; 379  :     z *= fInv;
; 380  :     w *= fInv;
; 381  :     return *this;
; 382  : }
; 383  : 
; 384  : 
; 385  : // unary operators
; 386  : D3DXINLINE D3DXVECTOR4
; 387  : D3DXVECTOR4::operator + () const
; 388  : {
; 389  :     return *this;
; 390  : }
; 391  : 
; 392  : D3DXINLINE D3DXVECTOR4
; 393  : D3DXVECTOR4::operator - () const
; 394  : {
; 395  :     return D3DXVECTOR4(-x, -y, -z, -w);
; 396  : }
; 397  : 
; 398  : 
; 399  : // binary operators
; 400  : D3DXINLINE D3DXVECTOR4
; 401  : D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
; 402  : {
; 403  :     return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
; 404  : }
; 405  : 
; 406  : D3DXINLINE D3DXVECTOR4
; 407  : D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
; 408  : {
; 409  :     return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
; 410  : }
; 411  : 
; 412  : D3DXINLINE D3DXVECTOR4
; 413  : D3DXVECTOR4::operator * ( FLOAT f ) const
; 414  : {
; 415  :     return D3DXVECTOR4(x * f, y * f, z * f, w * f);
; 416  : }
; 417  : 
; 418  : D3DXINLINE D3DXVECTOR4
; 419  : D3DXVECTOR4::operator / ( FLOAT f ) const
; 420  : {
; 421  :     FLOAT fInv = 1.0f / f;
; 422  :     return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
; 423  : }
; 424  : 
; 425  : 
; 426  : D3DXINLINE D3DXVECTOR4
; 427  : operator * ( FLOAT f, CONST D3DXVECTOR4& v )
; 428  : {
; 429  :     return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
; 430  : }
; 431  : 
; 432  : 
; 433  : D3DXINLINE BOOL
; 434  : D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
; 435  : {
; 436  :     return x == v.x && y == v.y && z == v.z && w == v.w;
; 437  : }
; 438  : 
; 439  : D3DXINLINE BOOL
; 440  : D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
; 441  : {
; 442  :     return x != v.x || y != v.y || z != v.z || w != v.w;
; 443  : }
; 444  : 
; 445  : 
; 446  : //--------------------------
; 447  : // Matrix
; 448  : //--------------------------
; 449  : D3DXINLINE
; 450  : D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
; 451  : {
; 452  : #ifdef D3DX_DEBUG
; 453  :     if(!pf)
; 454  :         return;
; 455  : #endif
; 456  : 
; 457  :     memcpy(&_11, pf, sizeof(D3DXMATRIX));
; 458  : }
; 459  : 
; 460  : D3DXINLINE
; 461  : D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
; 462  : {
; 463  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));
; 464  : }
; 465  : 
; 466  : D3DXINLINE
; 467  : D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
; 468  :                         FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
; 469  :                         FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
; 470  :                         FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
; 471  : {
; 472  :     _11 = f11; _12 = f12; _13 = f13; _14 = f14;
; 473  :     _21 = f21; _22 = f22; _23 = f23; _24 = f24;
; 474  :     _31 = f31; _32 = f32; _33 = f33; _34 = f34;
; 475  :     _41 = f41; _42 = f42; _43 = f43; _44 = f44;
; 476  : }
; 477  : 
; 478  : 
; 479  : 
; 480  : // access grants
; 481  : D3DXINLINE FLOAT&
; 482  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
; 483  : {
; 484  :     return m[iRow][iCol];
; 485  : }
; 486  : 
; 487  : D3DXINLINE FLOAT
; 488  : D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
; 489  : {
; 490  :     return m[iRow][iCol];
; 491  : }
; 492  : 
; 493  : 
; 494  : // casting operators
; 495  : D3DXINLINE
; 496  : D3DXMATRIX::operator FLOAT* ()
; 497  : {
; 498  :     return (FLOAT *) &_11;
; 499  : }
; 500  : 
; 501  : D3DXINLINE
; 502  : D3DXMATRIX::operator CONST FLOAT* () const
; 503  : {
; 504  :     return (CONST FLOAT *) &_11;
; 505  : }
; 506  : 
; 507  : 
; 508  : // assignment operators
; 509  : D3DXINLINE D3DXMATRIX&
; 510  : D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
; 511  : {
; 512  :     D3DXMatrixMultiply(this, this, &mat);
; 513  :     return *this;
; 514  : }
; 515  : 
; 516  : D3DXINLINE D3DXMATRIX&
; 517  : D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
; 518  : {
; 519  :     _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
; 520  :     _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
; 521  :     _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
; 522  :     _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
; 523  :     return *this;
; 524  : }
; 525  : 
; 526  : D3DXINLINE D3DXMATRIX&
; 527  : D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
; 528  : {
; 529  :     _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
; 530  :     _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
; 531  :     _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
; 532  :     _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
; 533  :     return *this;
; 534  : }
; 535  : 
; 536  : D3DXINLINE D3DXMATRIX&
; 537  : D3DXMATRIX::operator *= ( FLOAT f )
; 538  : {
; 539  :     _11 *= f; _12 *= f; _13 *= f; _14 *= f;
; 540  :     _21 *= f; _22 *= f; _23 *= f; _24 *= f;
; 541  :     _31 *= f; _32 *= f; _33 *= f; _34 *= f;
; 542  :     _41 *= f; _42 *= f; _43 *= f; _44 *= f;
; 543  :     return *this;
; 544  : }
; 545  : 
; 546  : D3DXINLINE D3DXMATRIX&
; 547  : D3DXMATRIX::operator /= ( FLOAT f )
; 548  : {
; 549  :     FLOAT fInv = 1.0f / f;
; 550  :     _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
; 551  :     _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
; 552  :     _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
; 553  :     _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
; 554  :     return *this;
; 555  : }
; 556  : 
; 557  : 
; 558  : // unary operators
; 559  : D3DXINLINE D3DXMATRIX
; 560  : D3DXMATRIX::operator + () const
; 561  : {
; 562  :     return *this;
; 563  : }
; 564  : 
; 565  : D3DXINLINE D3DXMATRIX
; 566  : D3DXMATRIX::operator - () const
; 567  : {
; 568  :     return D3DXMATRIX(-_11, -_12, -_13, -_14,
; 569  :                       -_21, -_22, -_23, -_24,
; 570  :                       -_31, -_32, -_33, -_34,
; 571  :                       -_41, -_42, -_43, -_44);
; 572  : }
; 573  : 
; 574  : 
; 575  : // binary operators
; 576  : D3DXINLINE D3DXMATRIX
; 577  : D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
; 578  : {
; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);
; 581  :     return matT;
; 582  : }
; 583  : 
; 584  : D3DXINLINE D3DXMATRIX
; 585  : D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
; 586  : {
; 587  :     return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
; 588  :                       _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
; 589  :                       _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
; 590  :                       _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
; 591  : }
; 592  : 
; 593  : D3DXINLINE D3DXMATRIX
; 594  : D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
; 595  : {
; 596  :     return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
; 597  :                       _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
; 598  :                       _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
; 599  :                       _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
; 600  : }
; 601  : 
; 602  : D3DXINLINE D3DXMATRIX
; 603  : D3DXMATRIX::operator * ( FLOAT f ) const
; 604  : {
; 605  :     return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
; 606  :                       _21 * f, _22 * f, _23 * f, _24 * f,
; 607  :                       _31 * f, _32 * f, _33 * f, _34 * f,
; 608  :                       _41 * f, _42 * f, _43 * f, _44 * f);
; 609  : }
; 610  : 
; 611  : D3DXINLINE D3DXMATRIX
; 612  : D3DXMATRIX::operator / ( FLOAT f ) const
; 613  : {
; 614  :     FLOAT fInv = 1.0f / f;
; 615  :     return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
; 616  :                       _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
; 617  :                       _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
; 618  :                       _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
; 619  : }
; 620  : 
; 621  : 
; 622  : D3DXINLINE D3DXMATRIX
; 623  : operator * ( FLOAT f, CONST D3DXMATRIX& mat )
; 624  : {
; 625  :     return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
; 626  :                       f * mat._21, f * mat._22, f * mat._23, f * mat._24,
; 627  :                       f * mat._31, f * mat._32, f * mat._33, f * mat._34,
; 628  :                       f * mat._41, f * mat._42, f * mat._43, f * mat._44);
; 629  : }
; 630  : 
; 631  : 
; 632  : D3DXINLINE BOOL
; 633  : D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
; 634  : {
; 635  :     return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
; 636  : }
; 637  : 
; 638  : D3DXINLINE BOOL
; 639  : D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
; 640  : {
; 641  :     return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
; 642  : }
; 643  : 
; 644  : 
; 645  : 
; 646  : //--------------------------
; 647  : // Quaternion
; 648  : //--------------------------
; 649  : 
; 650  : D3DXINLINE
; 651  : D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
; 652  : {
; 653  : #ifdef D3DX_DEBUG
; 654  :     if(!pf)
; 655  :         return;
; 656  : #endif
; 657  : 
; 658  :     x = pf[0];
; 659  :     y = pf[1];
; 660  :     z = pf[2];
; 661  :     w = pf[3];
; 662  : }
; 663  : 
; 664  : D3DXINLINE
; 665  : D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
; 666  : {
; 667  :     x = fx;
; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000bb	f3 0f 59 e4	 mulss	 xmm4, xmm4
  000bf	f3 0f 59 ed	 mulss	 xmm5, xmm5
  000c3	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000c7	f3 0f 59 db	 mulss	 xmm3, xmm3
  000cb	f3 0f 58 e1	 addss	 xmm4, xmm1
  000cf	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000d3	f3 0f 58 eb	 addss	 xmm5, xmm3
  000d7	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000db	f3 0f 58 e0	 addss	 xmm4, xmm0
  000df	f3 0f 58 ea	 addss	 xmm5, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  000e3	0f 2f ec	 comiss	 xmm5, xmm4
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  000e6	76 01		 jbe	 SHORT $LN10@Make_heap

; 2375 : 			--_Idx;

  000e8	49		 dec	 ecx
$LN10@Make_heap:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  000e9	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  000ec	8b 55 f8	 mov	 edx, DWORD PTR __Hole$1$[ebp]
  000ef	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  000f2	8b 04 8b	 mov	 eax, DWORD PTR [ebx+ecx*4]
  000f5	89 04 93	 mov	 DWORD PTR [ebx+edx*4], eax

; 2377 : 		_Hole = _Idx;

  000f8	8b d1		 mov	 edx, ecx
  000fa	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00101	89 55 f8	 mov	 DWORD PTR __Hole$1$[ebp], edx
  00104	89 4d fc	 mov	 DWORD PTR __Idx$1$[ebp], ecx
  00107	3b ce		 cmp	 ecx, esi
  00109	0f 8c 51 ff ff
	ff		 jl	 $LL13@Make_heap
  0010f	8b 7d f0	 mov	 edi, DWORD PTR __Hole$1$[ebp]
$LN11@Make_heap:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  00112	3b ce		 cmp	 ecx, esi
  00114	75 0a		 jne	 SHORT $LN9@Make_heap

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  00116	8b 44 b3 fc	 mov	 eax, DWORD PTR [ebx+esi*4-4]
  0011a	89 04 93	 mov	 DWORD PTR [ebx+edx*4], eax

; 2383 : 		_Hole = _Bottom - 1;

  0011d	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
$LN9@Make_heap:

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  00120	ff 75 ec	 push	 DWORD PTR __Pred$[ebp]
  00123	8d 45 e8	 lea	 eax, DWORD PTR __Val$1[ebp]
  00126	50		 push	 eax
  00127	57		 push	 edi
  00128	52		 push	 edx
  00129	53		 push	 ebx
  0012a	e8 00 00 00 00	 call	 ??$_Push_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@HH$$QAPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Push_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  0012f	8b 4d f4	 mov	 ecx, DWORD PTR tv483[ebp]

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);

  00132	83 c4 14	 add	 esp, 20			; 00000014H

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00135	85 ff		 test	 edi, edi
  00137	0f 8f f3 fe ff
	ff		 jg	 $LL2@Make_heap
$LN1@Make_heap:
  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx

; 2450 : 		}
; 2451 : 	}

  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
??$_Make_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH0@Z ENDP ; std::_Make_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z PROC ; std::_Val_type<CGraphicThingInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CGraphicThingInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@PAPAVCGraphicThingInstance@@@std@@YAPAHPAPAVCGraphicThingInstance@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAPAVCGraphicThingInstance@@@std@@YAPAHPAPAVCGraphicThingInstance@@@Z PROC ; std::_Dist_type<CGraphicThingInstance * *>, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAPAVCGraphicThingInstance@@@std@@YAPAHPAPAVCGraphicThingInstance@@@Z ENDP ; std::_Dist_type<CGraphicThingInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CGraphicThingInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCGraphicThingInstance@@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CGraphicThingInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAPAPAVCGraphicThingInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicThingInstance@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAPAVCGraphicThingInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicThingInstance@@0@Z PROC ; std::pair<CGraphicThingInstance * *,CGraphicThingInstance * *>::pair<CGraphicThingInstance * *,CGraphicThingInstance * *><CGraphicThingInstance * * &,CGraphicThingInstance * * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAPAVCGraphicThingInstance@@AAPAPAV0@X@?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@std@@QAE@AAPAPAVCGraphicThingInstance@@0@Z ENDP ; std::pair<CGraphicThingInstance * *,CGraphicThingInstance * *>::pair<CGraphicThingInstance * *,CGraphicThingInstance * *><CGraphicThingInstance * * &,CGraphicThingInstance * * &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$iter_swap@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAXPAPAVCGraphicThingInstance@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAXPAPAVCGraphicThingInstance@@0@Z PROC ; std::iter_swap<CGraphicThingInstance * *,CGraphicThingInstance * *>, COMDAT

; 27   : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 28   : 	swap(*_Left, *_Right);
; 29   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$iter_swap@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAXPAPAVCGraphicThingInstance@@0@Z ENDP ; std::iter_swap<CGraphicThingInstance * *,CGraphicThingInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Median@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Median@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Median<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 3046 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3047 : 	if (40 < _Last - _First)

  00004	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00007	8b c1		 mov	 eax, ecx
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  0000d	2b c3		 sub	 eax, ebx
  0000f	c1 f8 02	 sar	 eax, 2
  00012	83 f8 28	 cmp	 eax, 40			; 00000028H
  00015	7e 72		 jle	 SHORT $LN2@Median

; 3048 : 		{	// median of nine
; 3049 : 		size_t _Step = (_Last - _First + 1) / 8;

  00017	40		 inc	 eax
  00018	99		 cdq
  00019	83 e2 07	 and	 edx, 7
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	56		 push	 esi
  00022	57		 push	 edi

; 3050 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00023	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00026	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0002d	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00034	89 4d fc	 mov	 DWORD PTR tv69[ebp], ecx
  00037	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0003a	50		 push	 eax
  0003b	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  0003e	52		 push	 edx
  0003f	53		 push	 ebx
  00040	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 3051 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00045	8b 5d 0c	 mov	 ebx, DWORD PTR __Mid$[ebp]
  00048	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0004b	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0004e	50		 push	 eax
  0004f	8b c3		 mov	 eax, ebx
  00051	2b c7		 sub	 eax, edi
  00053	53		 push	 ebx
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 3052 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  0005a	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0005d	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00060	8b f0		 mov	 esi, eax
  00062	50		 push	 eax
  00063	2b 45 fc	 sub	 eax, DWORD PTR tv69[ebp]
  00066	2b f7		 sub	 esi, edi
  00068	56		 push	 esi
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 3053 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  0006f	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00072	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00075	56		 push	 esi
  00076	03 c7		 add	 eax, edi
  00078	53		 push	 ebx
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  0007f	83 c4 40	 add	 esp, 64			; 00000040H
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 3057 : 	}

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN2@Median:

; 3054 : 		}
; 3055 : 	else
; 3056 : 		_Med3(_First, _Mid, _Last, _Pred);

  00089	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0008c	51		 push	 ecx
  0008d	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00090	53		 push	 ebx
  00091	e8 00 00 00 00	 call	 ??$_Med3@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Med3<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  00096	83 c4 10	 add	 esp, 16			; 00000010H
  00099	5b		 pop	 ebx

; 3057 : 	}

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
??$_Median@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Median<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@U12@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z
_TEXT	SEGMENT
__Val$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@U12@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z PROC ; std::_Insertion_sort1<CArea::SCRCWithNumber *,CArea::CRCNumComp,CArea::SCRCWithNumber>, COMDAT

; 2999 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3000 : 	if (_First != _Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000a	3b f8		 cmp	 edi, eax
  0000c	74 6d		 je	 SHORT $LN6@Insertion_

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  0000e	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00011	3b d0		 cmp	 edx, eax
  00013	74 66		 je	 SHORT $LN6@Insertion_
  00015	53		 push	 ebx
  00016	56		 push	 esi
$LL7@Insertion_:

; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);

  00017	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  0001a	8b f2		 mov	 esi, edx
  0001c	8b 02		 mov	 eax, DWORD PTR [edx]
  0001e	89 45 08	 mov	 DWORD PTR __Val$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00021	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
; File a:\vs\vc\include\algorithm

; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

  00024	76 27		 jbe	 SHORT $LN5@Insertion_
; File a:\vs\vc\include\xutility

; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00026	8b c2		 mov	 eax, edx

; 2526 : 	while (_First != _Last)

  00028	3b fa		 cmp	 edi, edx
  0002a	74 17		 je	 SHORT $LN19@Insertion_
  0002c	8d 64 24 00	 npad	 4
$LL20@Insertion_:

; 2527 : 		*--_Dest = _STD move(*--_Last);

  00030	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00033	83 e8 08	 sub	 eax, 8
  00036	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0003f	3b c7		 cmp	 eax, edi
  00041	75 ed		 jne	 SHORT $LL20@Insertion_
$LN19@Insertion_:
; File a:\vs\vc\include\algorithm

; 3009 : 				*_First = _Move(_Val);

  00043	8b 45 08	 mov	 eax, DWORD PTR __Val$1$[ebp]
  00046	89 07		 mov	 DWORD PTR [edi], eax
  00048	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 3010 : 				}
; 3011 : 			else

  0004b	eb 24		 jmp	 SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  0004d	8d 4a f8	 lea	 ecx, DWORD PTR [edx-8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00050	3b 5a fc	 cmp	 ebx, DWORD PTR [edx-4]
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00053	76 17		 jbe	 SHORT $LN1@Insertion_
$LL3@Insertion_:

; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down

  00055	8b 01		 mov	 eax, DWORD PTR [ecx]
  00057	89 06		 mov	 DWORD PTR [esi], eax
  00059	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005f	8b f1		 mov	 esi, ecx
  00061	83 e9 08	 sub	 ecx, 8
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00064	3b 59 04	 cmp	 ebx, DWORD PTR [ecx+4]
; File a:\vs\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

  00067	77 ec		 ja	 SHORT $LL3@Insertion_
  00069	8b 45 08	 mov	 eax, DWORD PTR __Val$1$[ebp]
$LN1@Insertion_:

; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole

  0006c	89 06		 mov	 DWORD PTR [esi], eax
  0006e	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$LN4@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

  00071	83 c2 08	 add	 edx, 8
  00074	3b 55 0c	 cmp	 edx, DWORD PTR __Last$[ebp]
  00077	75 9e		 jne	 SHORT $LL7@Insertion_
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
$LN6@Insertion_:
  0007b	5f		 pop	 edi

; 3018 : 				}
; 3019 : 			}
; 3020 : 	}

  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
??$_Insertion_sort1@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@U12@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z ENDP ; std::_Insertion_sort1<CArea::SCRCWithNumber *,CArea::CRCNumComp,CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__Val$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z PROC ; std::_Sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 2475 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	8b ce		 mov	 ecx, esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00010	2b cf		 sub	 ecx, edi
  00012	8b c1		 mov	 eax, ecx
  00014	83 e0 f8	 and	 eax, -8			; fffffff8H
  00017	83 f8 08	 cmp	 eax, 8
  0001a	7e 48		 jle	 SHORT $LN1@Sort_heap
  0001c	53		 push	 ebx
  0001d	8b 5d 10	 mov	 ebx, DWORD PTR __Pred$[ebp]
  00020	83 c6 f8	 add	 esi, -8			; fffffff8H
$LL3@Sort_heap:

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	89 45 f8	 mov	 DWORD PTR __Val$1[ebp], eax
  00028	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002b	89 45 fc	 mov	 DWORD PTR __Val$1[ebp+4], eax

; 2395 : 	*_Dest = _Move(*_First);

  0002e	8b 07		 mov	 eax, DWORD PTR [edi]
  00030	89 06		 mov	 DWORD PTR [esi], eax
  00032	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00035	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  00038	8d 45 f8	 lea	 eax, DWORD PTR __Val$1[ebp]
  0003b	53		 push	 ebx
  0003c	50		 push	 eax
  0003d	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00040	c1 f8 03	 sar	 eax, 3
  00043	50		 push	 eax
  00044	6a 00		 push	 0
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 ??$_Adjust_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Adjust_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  0004c	83 ee 08	 sub	 esi, 8

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

  0004f	83 c4 14	 add	 esp, 20			; 00000014H

; 2476 : 	for (; 1 < _Last - _First; --_Last)

  00052	8b ce		 mov	 ecx, esi
  00054	2b cf		 sub	 ecx, edi
  00056	83 c1 08	 add	 ecx, 8
  00059	8b c1		 mov	 eax, ecx
  0005b	83 e0 f8	 and	 eax, -8			; fffffff8H
  0005e	83 f8 08	 cmp	 eax, 8
  00061	7f c0		 jg	 SHORT $LL3@Sort_heap
  00063	5b		 pop	 ebx
$LN1@Sort_heap:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi

; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ENDP ; std::_Sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Make_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@PAH0@Z
_TEXT	SEGMENT
tv282 = -16						; size = 4
tv283 = -12						; size = 4
__Val$2$ = -8						; size = 4
__Val$1$ = -4						; size = 4
__Hole$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@PAH0@Z PROC ; std::_Make_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>, COMDAT

; 2442 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 2443 : 	_Diff _Bottom = _Last - _First;

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000e	2b de		 sub	 ebx, esi
  00010	c1 fb 03	 sar	 ebx, 3

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  00013	8b c3		 mov	 eax, ebx
  00015	89 5d 0c	 mov	 DWORD PTR __Last$[ebp], ebx
  00018	99		 cdq
  00019	2b c2		 sub	 eax, edx
  0001b	d1 f8		 sar	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	0f 8e c5 00 00
	00		 jle	 $LN1@Make_heap

; 2443 : 	_Diff _Bottom = _Last - _First;

  00025	8d 14 45 02 00
	00 00		 lea	 edx, DWORD PTR [eax*2+2]
  0002c	8d 0c c6	 lea	 ecx, DWORD PTR [esi+eax*8]
  0002f	57		 push	 edi
$LL2@Make_heap:

; 2447 : 		_Ty _Val = _Move(*(_First + _Hole));

  00030	8b 79 f8	 mov	 edi, DWORD PTR [ecx-8]
  00033	83 e9 08	 sub	 ecx, 8
  00036	48		 dec	 eax
  00037	89 4d f0	 mov	 DWORD PTR tv282[ebp], ecx
  0003a	83 ea 02	 sub	 edx, 2
  0003d	89 7d f8	 mov	 DWORD PTR __Val$2$[ebp], edi
  00040	89 45 08	 mov	 DWORD PTR __Hole$1$[ebp], eax

; 2448 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2449 : 			_Move(_Val), _Pred);

  00043	8b f8		 mov	 edi, eax
  00045	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 2323 : 	}
; 2324 : 
; 2325 : template<class _RanIt,
; 2326 : 	class _Diff,
; 2327 : 	class _Ty,
; 2328 : 	class _Pr> inline
; 2329 : 	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
; 2330 : 	{	// push *_Last onto heap at [_First, _Last), using _Pred
; 2331 : 	_Diff _Count = _Last - _First;
; 2332 : 	if (0 < _Count)
; 2333 : 		{	// worth doing, percolate *_Last
; 2334 : 		_Ty _Val = _Move(*_Last);
; 2335 : 		_Push_heap(_First, _Count, _Diff(0), _Move(_Val), _Pred);
; 2336 : 		}
; 2337 : 	}
; 2338 : 
; 2339 : template<class _RanIt,
; 2340 : 	class _Pr> inline
; 2341 : 	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2342 : 	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using _Pred
; 2343 : 	_DEBUG_RANGE(_First, _Last);
; 2344 : 	_DEBUG_POINTER(_Pred);
; 2345 : 	if (_First != _Last)
; 2346 : 		{	// check and push to nontrivial heap
; 2347 : 		--_Last;
; 2348 : 		_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2349 : 		_Push_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2350 : 			_Dist_type(_First), _Val_type(_First));
; 2351 : 		}
; 2352 : 	}
; 2353 : 
; 2354 : 		// TEMPLATE FUNCTION push_heap
; 2355 : template<class _RanIt> inline
; 2356 : 	void push_heap(_RanIt _First, _RanIt _Last)
; 2357 : 	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using operator<
; 2358 : 	_STD push_heap(_First, _Last, less<>());
; 2359 : 	}
; 2360 : 
; 2361 : 		// TEMPLATE FUNCTION pop_heap WITH PRED
; 2362 : template<class _RanIt,
; 2363 : 	class _Diff,
; 2364 : 	class _Ty,
; 2365 : 	class _Pr> inline
; 2366 : 	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
; 2367 : 		_Ty&& _Val, _Pr _Pred)
; 2368 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred
; 2369 : 	_Diff _Top = _Hole;
; 2370 : 	_Diff _Idx = 2 * _Hole + 2;

  00048	8b c2		 mov	 eax, edx

; 2445 : 		{	// reheap top half, bottom to top
; 2446 : 		--_Hole;

  0004a	89 55 f4	 mov	 DWORD PTR tv283[ebp], edx

; 2447 : 		_Ty _Val = _Move(*(_First + _Hole));

  0004d	89 4d fc	 mov	 DWORD PTR __Val$1$[ebp], ecx

; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

  00050	3b d3		 cmp	 edx, ebx
  00052	7d 26		 jge	 SHORT $LN11@Make_heap
$LL13@Make_heap:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00054	8b 4c c6 04	 mov	 ecx, DWORD PTR [esi+eax*8+4]
  00058	3b 4c c6 fc	 cmp	 ecx, DWORD PTR [esi+eax*8-4]
; File a:\vs\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

  0005c	76 01		 jbe	 SHORT $LN10@Make_heap

; 2375 : 			--_Idx;

  0005e	48		 dec	 eax
$LN10@Make_heap:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  0005f	8b 0c c6	 mov	 ecx, DWORD PTR [esi+eax*8]
  00062	89 0c fe	 mov	 DWORD PTR [esi+edi*8], ecx
  00065	8b 4c c6 04	 mov	 ecx, DWORD PTR [esi+eax*8+4]
  00069	89 4c fe 04	 mov	 DWORD PTR [esi+edi*8+4], ecx

; 2377 : 		_Hole = _Idx;

  0006d	8b f8		 mov	 edi, eax
  0006f	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [eax*2+2]
  00076	3b c3		 cmp	 eax, ebx
  00078	7c da		 jl	 SHORT $LL13@Make_heap
$LN11@Make_heap:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

  0007a	3b c3		 cmp	 eax, ebx
  0007c	75 12		 jne	 SHORT $LN9@Make_heap

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

  0007e	8b 44 de f8	 mov	 eax, DWORD PTR [esi+ebx*8-8]
  00082	89 04 fe	 mov	 DWORD PTR [esi+edi*8], eax
  00085	8b 44 de fc	 mov	 eax, DWORD PTR [esi+ebx*8-4]
  00089	89 44 fe 04	 mov	 DWORD PTR [esi+edi*8+4], eax

; 2383 : 		_Hole = _Bottom - 1;

  0008d	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LN9@Make_heap:

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

  00090	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00093	99		 cdq
  00094	2b c2		 sub	 eax, edx
  00096	8b c8		 mov	 ecx, eax

; 2316 : 		_Idx = (_Hole - 1) / 2)

  00098	8b 45 08	 mov	 eax, DWORD PTR __Hole$1$[ebp]
  0009b	d1 f9		 sar	 ecx, 1
  0009d	3b c7		 cmp	 eax, edi
  0009f	7d 2d		 jge	 SHORT $LN24@Make_heap
  000a1	8b 5d fc	 mov	 ebx, DWORD PTR __Val$1$[ebp]
$LL26@Make_heap:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000a4	39 5c ce 04	 cmp	 DWORD PTR [esi+ecx*8+4], ebx
; File a:\vs\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

  000a8	76 21		 jbe	 SHORT $LN47@Make_heap

; 2317 : 		{	// move _Hole up to parent
; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

  000aa	8b 04 ce	 mov	 eax, DWORD PTR [esi+ecx*8]
  000ad	89 04 fe	 mov	 DWORD PTR [esi+edi*8], eax
  000b0	8b 44 ce 04	 mov	 eax, DWORD PTR [esi+ecx*8+4]
  000b4	89 44 fe 04	 mov	 DWORD PTR [esi+edi*8+4], eax
  000b8	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  000bb	99		 cdq

; 2319 : 		_Hole = _Idx;

  000bc	8b f9		 mov	 edi, ecx
  000be	2b c2		 sub	 eax, edx
  000c0	8b c8		 mov	 ecx, eax
  000c2	8b 45 08	 mov	 eax, DWORD PTR __Hole$1$[ebp]
  000c5	d1 f9		 sar	 ecx, 1
  000c7	3b c7		 cmp	 eax, edi
  000c9	7c d9		 jl	 SHORT $LL26@Make_heap
$LN47@Make_heap:
  000cb	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
$LN24@Make_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  000ce	8b 4d f8	 mov	 ecx, DWORD PTR __Val$2$[ebp]

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  000d1	8b 55 f4	 mov	 edx, DWORD PTR tv283[ebp]

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

  000d4	89 0c fe	 mov	 DWORD PTR [esi+edi*8], ecx
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __Val$1$[ebp]
  000da	89 4c fe 04	 mov	 DWORD PTR [esi+edi*8+4], ecx

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

  000de	8b 4d f0	 mov	 ecx, DWORD PTR tv282[ebp]
  000e1	85 c0		 test	 eax, eax
  000e3	0f 8f 47 ff ff
	ff		 jg	 $LL2@Make_heap
  000e9	5f		 pop	 edi
$LN1@Make_heap:
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx

; 2450 : 		}
; 2451 : 	}

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
??$_Make_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@PAH0@Z ENDP ; std::_Make_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z PROC ; std::_Val_type<CArea::SCRCWithNumber *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z ENDP ; std::_Val_type<CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUSCRCWithNumber@CArea@@@std@@YAPAHPAUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUSCRCWithNumber@CArea@@@std@@YAPAHPAUSCRCWithNumber@CArea@@@Z PROC ; std::_Dist_type<CArea::SCRCWithNumber *>, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAUSCRCWithNumber@CArea@@@std@@YAPAHPAUSCRCWithNumber@CArea@@@Z ENDP ; std::_Dist_type<CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAPAUSCRCWithNumber@CArea@@AAPAU01@X@?$pair@PAUSCRCWithNumber@CArea@@PAU12@@std@@QAE@AAPAUSCRCWithNumber@CArea@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAUSCRCWithNumber@CArea@@AAPAU01@X@?$pair@PAUSCRCWithNumber@CArea@@PAU12@@std@@QAE@AAPAUSCRCWithNumber@CArea@@0@Z PROC ; std::pair<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>::pair<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *><CArea::SCRCWithNumber * &,CArea::SCRCWithNumber * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAUSCRCWithNumber@CArea@@AAPAU01@X@?$pair@PAUSCRCWithNumber@CArea@@PAU12@@std@@QAE@AAPAUSCRCWithNumber@CArea@@0@Z ENDP ; std::pair<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>::pair<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *><CArea::SCRCWithNumber * &,CArea::SCRCWithNumber * &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$iter_swap@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAXPAUSCRCWithNumber@CArea@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAXPAUSCRCWithNumber@CArea@@0@Z PROC ; std::iter_swap<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>, COMDAT

; 27   : 	{	// swap *_Left and *_Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);

  0000b	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00012	89 02		 mov	 DWORD PTR [edx], eax
  00014	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00017	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0001a	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0001d	5f		 pop	 edi
  0001e	89 31		 mov	 DWORD PTR [ecx], esi
  00020	5e		 pop	 esi

; 28   : 	swap(*_Left, *_Right);
; 29   : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??$iter_swap@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAXPAUSCRCWithNumber@CArea@@0@Z ENDP ; std::iter_swap<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Median@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z
_TEXT	SEGMENT
tv73 = -4						; size = 4
tv76 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Median@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z PROC ; std::_Median<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 3046 : 	{	// sort median element to middle

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3047 : 	if (40 < _Last - _First)

  00004	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00007	8b c1		 mov	 eax, ecx
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000d	2b c7		 sub	 eax, edi
  0000f	c1 f8 03	 sar	 eax, 3
  00012	83 f8 28	 cmp	 eax, 40			; 00000028H
  00015	7e 6e		 jle	 SHORT $LN2@Median

; 3048 : 		{	// median of nine
; 3049 : 		size_t _Step = (_Last - _First + 1) / 8;

  00017	40		 inc	 eax
  00018	99		 cdq
  00019	83 e2 07	 and	 edx, 7
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 03	 sar	 eax, 3
  00021	53		 push	 ebx

; 3050 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

  00022	8b c8		 mov	 ecx, eax
  00024	c1 e1 04	 shl	 ecx, 4
  00027	56		 push	 esi
  00028	8b 75 14	 mov	 esi, DWORD PTR __Pred$[ebp]
  0002b	8d 1c c5 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*8]
  00032	56		 push	 esi
  00033	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00036	89 4d 08	 mov	 DWORD PTR tv76[ebp], ecx
  00039	8d 14 3b	 lea	 edx, DWORD PTR [ebx+edi]
  0003c	50		 push	 eax
  0003d	52		 push	 edx
  0003e	57		 push	 edi
  0003f	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  00042	e8 00 00 00 00	 call	 ??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>

; 3051 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00047	8b 7d 0c	 mov	 edi, DWORD PTR __Mid$[ebp]
  0004a	56		 push	 esi
  0004b	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  0004e	50		 push	 eax
  0004f	8b c7		 mov	 eax, edi
  00051	2b c3		 sub	 eax, ebx
  00053	57		 push	 edi
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>

; 3052 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

  0005a	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0005d	8b f0		 mov	 esi, eax
  0005f	2b f3		 sub	 esi, ebx
  00061	8b 5d 14	 mov	 ebx, DWORD PTR __Pred$[ebp]
  00064	53		 push	 ebx
  00065	50		 push	 eax
  00066	2b 45 08	 sub	 eax, DWORD PTR tv76[ebp]
  00069	56		 push	 esi
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>

; 3053 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

  00070	53		 push	 ebx
  00071	56		 push	 esi
  00072	57		 push	 edi
  00073	ff 75 fc	 push	 DWORD PTR tv73[ebp]
  00076	e8 00 00 00 00	 call	 ??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  0007b	83 c4 40	 add	 esp, 64			; 00000040H
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	5f		 pop	 edi

; 3057 : 	}

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN2@Median:

; 3054 : 		}
; 3055 : 	else
; 3056 : 		_Med3(_First, _Mid, _Last, _Pred);

  00085	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00088	51		 push	 ecx
  00089	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0008c	57		 push	 edi
  0008d	e8 00 00 00 00	 call	 ??$_Med3@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  00092	83 c4 10	 add	 esp, 16			; 00000010H
  00095	5f		 pop	 edi

; 3057 : 	}

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
??$_Median@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ENDP ; std::_Median<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z PROC ; std::_Insertion_sort<std::pair<float,long> *,std::less<void> >, COMDAT

; 3025 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAU?$pair@MJ@std@@U?$less@X@2@U12@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z ; std::_Insertion_sort1<std::pair<float,long> *,std::less<void>,std::pair<float,long> >
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 3027 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Insertion_sort@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ENDP ; std::_Insertion_sort<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z PROC ; std::sort_heap<std::pair<float,long> *,std::less<void> >, COMDAT

; 2483 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00003	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::_Sort_heap<std::pair<float,long> *,std::less<void> >
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2488 : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ENDP ; std::sort_heap<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$make_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$make_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z PROC ; std::make_heap<std::pair<float,long> *,std::less<void> >, COMDAT

; 2456 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2457 : 	_DEBUG_RANGE(_First, _Last);
; 2458 : 	_DEBUG_POINTER(_Pred);
; 2459 : 	if (1 < _Last - _First)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000b	2b c2		 sub	 eax, edx
  0000d	83 e0 f8	 and	 eax, -8			; fffffff8H
  00010	83 f8 08	 cmp	 eax, 8
  00013	7e 11		 jle	 SHORT $LN1@make_heap

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Make_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@PAH0@Z ; std::_Make_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
  00023	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@make_heap:

; 2462 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$make_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ENDP ; std::make_heap<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MJ@std@@PAU12@@0@PAU?$pair@MJ@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__Tmp$1$ = -12						; size = 4
$T1 = -8						; size = 4
__Glast$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Unguarded_partition@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MJ@std@@PAU12@@0@PAU?$pair@MJ@0@0U?$less@X@0@@Z PROC ; std::_Unguarded_partition<std::pair<float,long> *,std::less<void> >, COMDAT

; 3063 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3064 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000f	8b c7		 mov	 eax, edi

; 3065 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00011	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00014	2b c1		 sub	 eax, ecx
  00016	c1 f8 03	 sar	 eax, 3
  00019	99		 cdq
  0001a	2b c2		 sub	 eax, edx
  0001c	d1 f8		 sar	 eax, 1
  0001e	8d 34 c1	 lea	 esi, DWORD PTR [ecx+eax*8]
  00021	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  00024	50		 push	 eax
  00025	56		 push	 esi
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$_Median@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@00U?$less@X@0@@Z ; std::_Median<std::pair<float,long> *,std::less<void> >

; 3066 : 	_RanIt _Pfirst = _Mid;
; 3067 : 	_RanIt _Plast = _Pfirst + 1;
; 3068 : 
; 3069 : 	while (_First < _Pfirst
; 3070 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0002c	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  0002f	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	3b d6		 cmp	 edx, esi
  00037	73 3b		 jae	 SHORT $LN315@Unguarded_
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL29@Unguarded_:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00040	f3 0f 10 46 f8	 movss	 xmm0, DWORD PTR [esi-8]
  00045	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00049	0f 2f c8	 comiss	 xmm1, xmm0
  0004c	77 26		 ja	 SHORT $LN315@Unguarded_
  0004e	0f 2f c1	 comiss	 xmm0, xmm1
  00051	77 21		 ja	 SHORT $LN315@Unguarded_
  00053	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00056	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00059	7c 19		 jl	 SHORT $LN315@Unguarded_
  0005b	0f 2f c1	 comiss	 xmm0, xmm1
  0005e	77 14		 ja	 SHORT $LN315@Unguarded_
  00060	0f 2f c8	 comiss	 xmm1, xmm0
  00063	77 08		 ja	 SHORT $LN43@Unguarded_
  00065	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00068	3b 46 fc	 cmp	 eax, DWORD PTR [esi-4]
  0006b	7c 07		 jl	 SHORT $LN315@Unguarded_
$LN43@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3072 : 		--_Pfirst;

  0006d	83 c6 f8	 add	 esi, -8			; fffffff8H
  00070	3b d6		 cmp	 edx, esi
  00072	72 cc		 jb	 SHORT $LL29@Unguarded_
$LN315@Unguarded_:

; 3073 : 	while (_Plast < _Last
; 3074 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  00074	3b df		 cmp	 ebx, edi
  00076	73 37		 jae	 SHORT $LN316@Unguarded_
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00078	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  0007c	8d 64 24 00	 npad	 4
$LL27@Unguarded_:
  00080	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  00084	0f 2f c8	 comiss	 xmm1, xmm0
  00087	77 26		 ja	 SHORT $LN316@Unguarded_
  00089	0f 2f c1	 comiss	 xmm0, xmm1
  0008c	77 21		 ja	 SHORT $LN316@Unguarded_
  0008e	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00091	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00094	7c 19		 jl	 SHORT $LN316@Unguarded_
  00096	0f 2f c1	 comiss	 xmm0, xmm1
  00099	77 14		 ja	 SHORT $LN316@Unguarded_
  0009b	0f 2f c8	 comiss	 xmm1, xmm0
  0009e	77 08		 ja	 SHORT $LN57@Unguarded_
  000a0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a3	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  000a6	7c 07		 jl	 SHORT $LN316@Unguarded_
$LN57@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3076 : 		++_Plast;

  000a8	83 c3 08	 add	 ebx, 8
  000ab	3b df		 cmp	 ebx, edi
  000ad	72 d1		 jb	 SHORT $LL27@Unguarded_
$LN316@Unguarded_:

; 3077 : 
; 3078 : 	_RanIt _Gfirst = _Plast;
; 3079 : 	_RanIt _Glast = _Pfirst;

  000af	8b ce		 mov	 ecx, esi
  000b1	8b d3		 mov	 edx, ebx
  000b3	89 4d fc	 mov	 DWORD PTR __Glast$1$[ebp], ecx
  000b6	eb 08		 jmp	 SHORT $LL25@Unguarded_
$LL322@Unguarded_:
  000b8	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  000bb	eb 03 8d 49 00	 npad	 5
$LL25@Unguarded_:

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  000c0	3b d7		 cmp	 edx, edi
  000c2	73 6d		 jae	 SHORT $LN72@Unguarded_
  000c4	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  000c7	8d 7b f8	 lea	 edi, DWORD PTR [ebx-8]
  000ca	8d 9b 00 00 00
	00		 npad	 6
$LL327@Unguarded_:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  000d0	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  000d4	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
  000d8	0f 2f c8	 comiss	 xmm1, xmm0
  000db	77 4a		 ja	 SHORT $LN22@Unguarded_
  000dd	0f 2f c1	 comiss	 xmm0, xmm1
  000e0	77 4c		 ja	 SHORT $LN317@Unguarded_
  000e2	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e5	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  000e8	7c 3a		 jl	 SHORT $LN321@Unguarded_
  000ea	0f 2f c1	 comiss	 xmm0, xmm1
  000ed	77 3f		 ja	 SHORT $LN317@Unguarded_
  000ef	0f 2f c8	 comiss	 xmm1, xmm0
  000f2	77 08		 ja	 SHORT $LN71@Unguarded_
  000f4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f7	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000fa	7c 32		 jl	 SHORT $LN317@Unguarded_
$LN71@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3088 : 			else if (_Plast++ != _Gfirst)

  000fc	8b c3		 mov	 eax, ebx
  000fe	83 c7 08	 add	 edi, 8
  00101	83 c3 08	 add	 ebx, 8
  00104	3b c2		 cmp	 eax, edx
  00106	74 1c		 je	 SHORT $LN321@Unguarded_
; File a:\vs\vc\include\utility

; 184  : 		if (this != &_Right)

  00108	3b fa		 cmp	 edi, edx
  0010a	74 18		 je	 SHORT $LN321@Unguarded_

; 52   : 	_Ty _Tmp = _Move(_Left);

  0010c	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]

; 53   : 	_Left = _Move(_Right);

  00110	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1

; 54   : 	_Right = _Move(_Tmp);

  00114	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00118	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 53   : 	_Left = _Move(_Right);

  0011b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00121	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN321@Unguarded_:
  00124	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
$LN22@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  00127	83 c2 08	 add	 edx, 8
  0012a	3b d0		 cmp	 edx, eax
  0012c	72 a2		 jb	 SHORT $LL327@Unguarded_
$LN317@Unguarded_:
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR __Glast$1$[ebp]
$LN72@Unguarded_:

; 3090 : 		for (; _First < _Glast; --_Glast)

  00131	8b 7d 0c	 mov	 edi, DWORD PTR __First$[ebp]
  00134	3b cf		 cmp	 ecx, edi
  00136	76 6b		 jbe	 SHORT $LN332@Unguarded_
  00138	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0013b	8d 79 f8	 lea	 edi, DWORD PTR [ecx-8]
  0013e	8b ff		 npad	 2
$LL328@Unguarded_:
; File a:\vs\vc\include\utility

; 234  : 		(!(_Right.first < _Left.first) && _Left.second < _Right.second));

  00140	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]
  00144	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00148	0f 2f c1	 comiss	 xmm0, xmm1
  0014b	77 44		 ja	 SHORT $LN14@Unguarded_
  0014d	0f 2f c8	 comiss	 xmm1, xmm0
  00150	77 4c		 ja	 SHORT $LN318@Unguarded_
  00152	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00155	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00158	7c 34		 jl	 SHORT $LN325@Unguarded_
  0015a	0f 2f c8	 comiss	 xmm1, xmm0
  0015d	77 3f		 ja	 SHORT $LN318@Unguarded_
  0015f	0f 2f c1	 comiss	 xmm0, xmm1
  00162	77 08		 ja	 SHORT $LN112@Unguarded_
  00164	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00167	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  0016a	7c 32		 jl	 SHORT $LN318@Unguarded_
$LN112@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3095 : 			else if (--_Pfirst != _Glast - 1)

  0016c	83 ee 08	 sub	 esi, 8
  0016f	3b f7		 cmp	 esi, edi
  00171	74 1b		 je	 SHORT $LN325@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00173	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]

; 53   : 	_Left = _Move(_Right);

  00177	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1

; 54   : 	_Right = _Move(_Tmp);

  0017b	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  0017f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00182	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00185	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00188	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0018b	8b 4d fc	 mov	 ecx, DWORD PTR __Glast$1$[ebp]
$LN325@Unguarded_:
  0018e	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
$LN14@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3090 : 		for (; _First < _Glast; --_Glast)

  00191	83 e9 08	 sub	 ecx, 8
  00194	83 ef 08	 sub	 edi, 8
  00197	89 4d fc	 mov	 DWORD PTR __Glast$1$[ebp], ecx
  0019a	3b c1		 cmp	 eax, ecx
  0019c	72 a2		 jb	 SHORT $LL328@Unguarded_
$LN318@Unguarded_:
  0019e	8b 7d 0c	 mov	 edi, DWORD PTR __First$[ebp]

; 3096 : 				_STD iter_swap(_Pfirst, _Glast - 1);
; 3097 : 		if (_Glast == _First && _Gfirst == _Last)

  001a1	3b cf		 cmp	 ecx, edi
$LN332@Unguarded_:
  001a3	75 70		 jne	 SHORT $LN6@Unguarded_
  001a5	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  001a8	0f 84 f2 00 00
	00		 je	 $LN291@Unguarded_

; 3098 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
; 3099 : 
; 3100 : 		if (_Glast == _First)
; 3101 : 			{	// no room at bottom, rotate pivot upward
; 3102 : 			if (_Plast != _Gfirst)

  001ae	3b da		 cmp	 ebx, edx
  001b0	74 1f		 je	 SHORT $LN167@Unguarded_
; File a:\vs\vc\include\utility

; 184  : 		if (this != &_Right)

  001b2	3b f3		 cmp	 esi, ebx
  001b4	74 1b		 je	 SHORT $LN167@Unguarded_

; 53   : 	_Left = _Move(_Right);

  001b6	8b 03		 mov	 eax, DWORD PTR [ebx]
  001b8	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  001bc	89 06		 mov	 DWORD PTR [esi], eax

; 54   : 	_Right = _Move(_Tmp);

  001be	f3 0f 11 03	 movss	 DWORD PTR [ebx], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  001c2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  001c5	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  001c8	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  001cb	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR __Glast$1$[ebp]
$LN167@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3105 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  001d1	8b c6		 mov	 eax, esi
  001d3	8b fa		 mov	 edi, edx
  001d5	83 c3 08	 add	 ebx, 8
  001d8	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  001db	83 c6 08	 add	 esi, 8
  001de	83 c2 08	 add	 edx, 8
; File a:\vs\vc\include\utility

; 184  : 		if (this != &_Right)

  001e1	3b c7		 cmp	 eax, edi
  001e3	0f 84 cf fe ff
	ff		 je	 $LL322@Unguarded_

; 52   : 	_Ty _Tmp = _Move(_Left);

  001e9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]

; 53   : 	_Left = _Move(_Right);

  001ed	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  001f0	8b 07		 mov	 eax, DWORD PTR [edi]
  001f2	89 01		 mov	 DWORD PTR [ecx], eax

; 54   : 	_Right = _Move(_Tmp);

  001f4	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  001f8	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 53   : 	_Left = _Move(_Right);

  001fb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001fe	89 4d f4	 mov	 DWORD PTR __Tmp$1$[ebp], ecx
  00201	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00204	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00207	8b 4d f4	 mov	 ecx, DWORD PTR __Tmp$1$[ebp]
  0020a	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 29   : 	}

  0020d	8b 4d fc	 mov	 ecx, DWORD PTR __Glast$1$[ebp]
  00210	e9 a3 fe ff ff	 jmp	 $LL322@Unguarded_
$LN6@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3107 : 		else if (_Gfirst == _Last)

  00215	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]

; 3108 : 			{	// no room at top, rotate pivot downward
; 3109 : 			if (--_Glast != --_Pfirst)

  00218	83 e9 08	 sub	 ecx, 8
  0021b	89 4d fc	 mov	 DWORD PTR __Glast$1$[ebp], ecx
  0021e	3b d7		 cmp	 edx, edi
  00220	75 52		 jne	 SHORT $LN3@Unguarded_
  00222	83 ee 08	 sub	 esi, 8
  00225	3b ce		 cmp	 ecx, esi
  00227	74 20		 je	 SHORT $LN221@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00229	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 53   : 	_Left = _Move(_Right);

  0022d	8b 06		 mov	 eax, DWORD PTR [esi]
  0022f	8b 7d fc	 mov	 edi, DWORD PTR __Glast$1$[ebp]
  00232	89 01		 mov	 DWORD PTR [ecx], eax

; 54   : 	_Right = _Move(_Tmp);

  00234	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00238	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 53   : 	_Left = _Move(_Right);

  0023b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0023e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00241	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00244	8b cf		 mov	 ecx, edi
  00246	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
$LN221@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  00249	83 eb 08	 sub	 ebx, 8
; File a:\vs\vc\include\utility

; 184  : 		if (this != &_Right)

  0024c	3b f3		 cmp	 esi, ebx
  0024e	0f 84 6c fe ff
	ff		 je	 $LL25@Unguarded_

; 53   : 	_Left = _Move(_Right);

  00254	8b 03		 mov	 eax, DWORD PTR [ebx]
  00256	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0025a	89 06		 mov	 DWORD PTR [esi], eax

; 54   : 	_Right = _Move(_Tmp);

  0025c	f3 0f 11 03	 movss	 DWORD PTR [ebx], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00260	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00263	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00266	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00269	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
; File a:\vs\vc\include\algorithm

; 3113 : 		else

  0026c	8b 4d fc	 mov	 ecx, DWORD PTR __Glast$1$[ebp]
  0026f	e9 4c fe ff ff	 jmp	 $LL25@Unguarded_
$LN3@Unguarded_:
; File a:\vs\vc\include\utility

; 184  : 		if (this != &_Right)

  00274	3b d1		 cmp	 edx, ecx
  00276	74 20		 je	 SHORT $LN275@Unguarded_

; 53   : 	_Left = _Move(_Right);

  00278	8b 01		 mov	 eax, DWORD PTR [ecx]
  0027a	8b 7d fc	 mov	 edi, DWORD PTR __Glast$1$[ebp]

; 52   : 	_Ty _Tmp = _Move(_Left);

  0027d	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  00281	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00283	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00287	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 53   : 	_Left = _Move(_Right);

  0028a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0028d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00290	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00293	8b cf		 mov	 ecx, edi
  00295	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
$LN275@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3114 : 			_STD iter_swap(_Gfirst++, --_Glast);

  00298	83 c2 08	 add	 edx, 8

; 3115 : 		}

  0029b	e9 20 fe ff ff	 jmp	 $LL25@Unguarded_
$LN291@Unguarded_:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  002a0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002a3	5f		 pop	 edi
  002a4	89 30		 mov	 DWORD PTR [eax], esi
  002a6	5e		 pop	 esi
  002a7	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  002aa	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 3116 : 	}

  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c3		 ret	 0
??$_Unguarded_partition@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MJ@std@@PAU12@@0@PAU?$pair@MJ@0@0U?$less@X@0@@Z ENDP ; std::_Unguarded_partition<std::pair<float,long> *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Within_limits@PAEE@std@@YA_NPAEABE@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Within_limits@PAEE@std@@YA_NPAEABE@Z PROC		; std::_Within_limits<unsigned char *,unsigned char>, COMDAT

; 2998 : 	{	// check whether _Val is within the limits of _Elem

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2992 : 	return (_Val <= UCHAR_MAX);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	80 c9 ff	 or	 cl, 255			; 000000ffH
  00009	3a 08		 cmp	 cl, BYTE PTR [eax]
  0000b	1b c0		 sbb	 eax, eax
  0000d	40		 inc	 eax

; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Within_limits@PAEE@std@@YA_NPAEABE@Z ENDP		; std::_Within_limits<unsigned char *,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$return_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::return_temporary_buffer<CMapOutdoor::TPatchDrawStruct>, COMDAT

; 41   : 	operator delete(_Pbuf);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
??$return_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::return_temporary_buffer<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::_Destroy<CMapOutdoor::TPatchDrawStruct>, COMDAT

; 55   : 	_Ptr->~_Ty();
; 56   : 	}

  00000	c3		 ret	 0
??$_Destroy@UTPatchDrawStruct@CMapOutdoor@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::_Destroy<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@@std@@YAAAPAUTPatchDrawStruct@CMapOutdoor@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z PROC ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::allocator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::TPatchDrawStruct>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 485  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z ENDP ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z PROC ; std::_Unchecked<CMapOutdoor::TPatchDrawStruct *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@@Z ENDP ; std::_Unchecked<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAU?$pair@MJ@std@@PAU12@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@PAU10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAU?$pair@MJ@std@@PAU12@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@PAU10@@Z PROC ; std::_Rechecked<std::pair<float,long> *,std::pair<float,long> *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAU?$pair@MJ@std@@PAU12@@std@@YAAAPAU?$pair@MJ@0@AAPAU10@PAU10@@Z ENDP ; std::_Rechecked<std::pair<float,long> *,std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z PROC ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::allocator<std::pair<float,long> >,std::pair<float,long> >
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 485  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z ENDP ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z PROC ; std::_Unchecked<std::pair<float,long> *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ENDP ; std::_Unchecked<std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAAAPAUSCRCWithNumber@CArea@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z PROC ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber>,CArea::SCRCWithNumber>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 485  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z ENDP ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z PROC ; std::_Unchecked<CArea::SCRCWithNumber *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUSCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z ENDP ; std::_Unchecked<CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z PROC	; std::_Rechecked<unsigned char *,unsigned char *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ENDP	; std::_Rechecked<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Uninit_move<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	2b f0		 sub	 esi, eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	03 c6		 add	 eax, esi
  0001b	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Uninit_move<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAE@std@@YAPAEPAE@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAE@std@@YAPAEPAE@Z PROC			; std::_Unchecked<unsigned char *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAE@std@@YAPAEPAE@Z ENDP			; std::_Unchecked<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::destroy<CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UTPatchDrawStruct@CMapOutdoor@@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::destroy<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@MJ@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@MJ@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::destroy<std::pair<float,long> >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@MJ@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::destroy<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@USCRCWithNumber@CArea@@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USCRCWithNumber@CArea@@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::destroy<CArea::SCRCWithNumber>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@USCRCWithNumber@CArea@@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::destroy<CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN3@construct:

; 601  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@MJ@std@@U12@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@MJ@std@@U12@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z PROC ; std::allocator<std::pair<float,long> >::construct<std::pair<float,long>,std::pair<float,long> >, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:
; File a:\vs\vc\include\xmemory0

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@MJ@std@@U12@@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z ENDP ; std::allocator<std::pair<float,long> >::construct<std::pair<float,long>,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z PROC ; std::allocator<CArea::SCRCWithNumber>::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z ENDP ; std::allocator<CArea::SCRCWithNumber>::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@EAAE@?$allocator@E@std@@QAEXPAEAAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@EAAE@?$allocator@E@std@@QAEXPAEAAE@Z PROC	; std::allocator<unsigned char>::construct<unsigned char,unsigned char &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@EAAE@?$allocator@E@std@@QAEXPAEAAE@Z ENDP	; std::allocator<unsigned char>::construct<unsigned char,unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__Pair$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Mid$1$ = 16						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 3230 : 	{	// sort preserving order of equivalents, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 3231 : 	if (_Count <= _ISORT_MAX)

  00007	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0000d	7f 18		 jg	 SHORT $LN4@Stable_sor

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  0000f	6a 00		 push	 0
  00011	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAUTPatchDrawStruct@CMapOutdoor@@UFSortPatchDrawStructWithTerrainNum@2@U12@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0UFSortPatchDrawStructWithTerrainNum@2@0@Z ; std::_Insertion_sort1<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::FSortPatchDrawStructWithTerrainNum,CMapOutdoor::TPatchDrawStruct>
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
  00022	5e		 pop	 esi

; 3253 : 		}
; 3254 : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN4@Stable_sor:
  00027	53		 push	 ebx

; 3235 : 		_Diff _Count2 = (_Count + 1) / 2;

  00028	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0002b	99		 cdq
  0002c	2b c2		 sub	 eax, edx
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002e	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00031	57		 push	 edi
; File a:\vs\vc\include\xmemory

; 842  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

  00032	8b 7d 14	 mov	 edi, DWORD PTR __Tempbuf$[ebp]
; File a:\vs\vc\include\algorithm

; 3235 : 		_Diff _Count2 = (_Count + 1) / 2;

  00035	8b d8		 mov	 ebx, eax
  00037	d1 fb		 sar	 ebx, 1
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00039	8b cb		 mov	 ecx, ebx
  0003b	c1 e1 04	 shl	 ecx, 4
; File a:\vs\vc\include\xmemory

; 842  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

  0003e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00041	03 ca		 add	 ecx, edx
  00043	89 4d 10	 mov	 DWORD PTR __Mid$1$[ebp], ecx
; File a:\vs\vc\include\xmemory

; 842  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

  00046	83 38 00	 cmp	 DWORD PTR [eax], 0
  00049	75 37		 jne	 SHORT $LN17@Stable_sor
  0004b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0004e	85 c0		 test	 eax, eax
  00050	7e 30		 jle	 SHORT $LN17@Stable_sor

; 843  : 			{	// allocate buffer on first size query
; 844  : 			pair<_Pty, ptrdiff_t> _Pair =
; 845  : 
; 846  : 				_STD get_temporary_buffer<_Ty>(_Pbuf->_Size);

  00052	50		 push	 eax
  00053	8d 45 f8	 lea	 eax, DWORD PTR __Pair$1[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$get_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YA?AU?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@0@H@Z ; std::get_temporary_buffer<CMapOutdoor::TPatchDrawStruct>

; 847  : 
; 848  : 			_Pbuf->_Begin = _Pair.first;

  0005c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0005f	83 c4 08	 add	 esp, 8
  00062	8b 4d f8	 mov	 ecx, DWORD PTR __Pair$1[ebp]
  00065	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx

; 849  : 			_Pbuf->_Current = _Pair.first;

  0006a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0006d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 850  : 			_Pbuf->_Hiwater = _Pair.first;

  00070	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00073	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 851  : 			_Pbuf->_Size = _Pair.second;

  00076	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00079	8b 45 fc	 mov	 eax, DWORD PTR __Pair$1[ebp+4]
  0007c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0007f	8b 4d 10	 mov	 ecx, DWORD PTR __Mid$1$[ebp]
$LN17@Stable_sor:
; File a:\vs\vc\include\algorithm

; 3241 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

  00082	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00085	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00088	57		 push	 edi
  00089	53		 push	 ebx
  0008a	51		 push	 ecx
  0008b	52		 push	 edx
  0008c	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  0008f	7f 19		 jg	 SHORT $LN2@Stable_sor
  00091	e8 00 00 00 00	 call	 ??$_Buffered_merge_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Buffered_merge_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>

; 3242 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3243 : 				_Tempbuf, _Pred);

  00096	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00099	2b f3		 sub	 esi, ebx
  0009b	57		 push	 edi
  0009c	56		 push	 esi
  0009d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000a0	ff 75 10	 push	 DWORD PTR __Mid$1$[ebp]
  000a3	e8 00 00 00 00	 call	 ??$_Buffered_merge_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Buffered_merge_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>

; 3244 : 			}
; 3245 : 		else

  000a8	eb 17		 jmp	 SHORT $LN20@Stable_sor
$LN2@Stable_sor:

; 3246 : 			{	// temp buffer not big enough, divide and conquer
; 3247 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

  000aa	e8 00 00 00 00	 call	 ??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>

; 3248 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

  000af	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  000b2	2b f3		 sub	 esi, ebx
  000b4	57		 push	 edi
  000b5	56		 push	 esi
  000b6	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000b9	ff 75 10	 push	 DWORD PTR __Mid$1$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
$LN20@Stable_sor:
  000c1	83 c4 28	 add	 esp, 40			; 00000028H

; 3249 : 			}
; 3250 : 
; 3251 : 		_Buffered_merge(_First, _Mid, _Last,
; 3252 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

  000c4	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  000c7	57		 push	 edi
  000c8	56		 push	 esi
  000c9	53		 push	 ebx
  000ca	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000cd	ff 75 10	 push	 DWORD PTR __Mid$1$[ebp]
  000d0	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000d3	e8 00 00 00 00	 call	 ??$_Buffered_merge@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@00HHAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Buffered_merge<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  000d8	83 c4 1c	 add	 esp, 28			; 0000001cH
  000db	5f		 pop	 edi
  000dc	5b		 pop	 ebx
  000dd	5e		 pop	 esi

; 3253 : 		}
; 3254 : 	}

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$1 = -8						; size = 8
?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Maxlen, COMDAT
; _this$ = ecx

; 841  : 		{	// return size of buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 842  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00012	75 34		 jne	 SHORT $LN1@Maxlen
  00014	85 c0		 test	 eax, eax
  00016	7e 2a		 jle	 SHORT $LN5@Maxlen

; 843  : 			{	// allocate buffer on first size query
; 844  : 			pair<_Pty, ptrdiff_t> _Pair =
; 845  : 
; 846  : 				_STD get_temporary_buffer<_Ty>(_Pbuf->_Size);

  00018	50		 push	 eax
  00019	8d 45 f8	 lea	 eax, DWORD PTR __Pair$1[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$get_temporary_buffer@UTPatchDrawStruct@CMapOutdoor@@@std@@YA?AU?$pair@PAUTPatchDrawStruct@CMapOutdoor@@H@0@H@Z ; std::get_temporary_buffer<CMapOutdoor::TPatchDrawStruct>

; 847  : 
; 848  : 			_Pbuf->_Begin = _Pair.first;

  00022	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00025	83 c4 08	 add	 esp, 8
  00028	8b 4d f8	 mov	 ecx, DWORD PTR __Pair$1[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 849  : 			_Pbuf->_Current = _Pair.first;

  0002d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00030	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 850  : 			_Pbuf->_Hiwater = _Pair.first;

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 851  : 			_Pbuf->_Size = _Pair.second;

  00039	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003c	8b 45 fc	 mov	 eax, DWORD PTR __Pair$1[ebp+4]
  0003f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN5@Maxlen:

; 852  : 			}
; 853  : 		return (_Pbuf->_Size);

  00042	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00045	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
$LN1@Maxlen:
  00048	5e		 pop	 esi

; 854  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?_Maxlen@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Maxlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ?_Last@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Last, COMDAT
; _this$ = ecx

; 837  : 		return (_Pbuf->_Current);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 838  : 		}

  00006	c3		 ret	 0
?_Last@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Last
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ?_First@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_First, COMDAT
; _this$ = ecx

; 832  : 		return (_Pbuf->_Begin);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 833  : 		}

  00005	c3		 ret	 0
?_First@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_First
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ?_Init@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Init, COMDAT
; _this$ = ecx

; 826  : 		_Pbuf->_Current = _Pbuf->_Begin;

  00000	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00003	8b 02		 mov	 eax, DWORD PTR [edx]
  00005	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 827  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 828  : 		}

  0000a	c3		 ret	 0
?_Init@?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@H@Z PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator++, COMDAT
; _this$ = ecx

; 821  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 822  : 		}

  00002	c2 04 00	 ret	 4
??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@H@Z ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator++, COMDAT
; _this$ = ecx

; 816  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 817  : 		}

  00002	c3		 ret	 0
??E?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??D?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator*, COMDAT
; _this$ = ecx

; 811  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 812  : 		}

  00002	c3		 ret	 0
??D?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@$$QAUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@$$QAUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator=, COMDAT
; _this$ = ecx

; 796  : 		{	// move or construct value into active buffer, and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 797  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

  00005	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00008	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0000e	73 18		 jae	 SHORT $LN2@operator

; 798  : 			*_Pbuf->_Current++ =
; 799  : 				_STD forward<_Ty>(_Val);	// below high water mark, move

  00010	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00017	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  0001b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001e	83 40 04 10	 add	 DWORD PTR [eax+4], 16	; 00000010H

; 805  : 			}
; 806  : 		return (*this);

  00022	8b c2		 mov	 eax, edx

; 807  : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN2@operator:
; File a:\vs\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00028	85 c9		 test	 ecx, ecx
  0002a	74 0b		 je	 SHORT $LN11@operator
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0002f	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00033	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN11@operator:
; File a:\vs\vc\include\xmemory

; 804  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

  00037	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0003a	83 41 04 10	 add	 DWORD PTR [ecx+4], 16	; 00000010H
  0003e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00041	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00044	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 805  : 			}
; 806  : 		return (*this);

  00047	8b c2		 mov	 eax, edx

; 807  : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@$$QAUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator=, COMDAT
; _this$ = ecx

; 777  : 		{	// assign _Right (share active buffer)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 778  : 		_Pbuf = _Right._Pbuf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00009	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 779  : 		return (*this);

  0000c	8b c1		 mov	 eax, ecx

; 780  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??4?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??1?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::~_Temp_iterator<CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 767  : 		if (_Buf._Begin != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 07		 je	 SHORT $LN9@Temp_itera

; 41   : 	operator delete(_Pbuf);

  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
$LN9@Temp_itera:

; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}

  0000d	c3		 ret	 0
??1?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::~_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 756  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 764  : 
; 765  : 	~_Temp_iterator() _NOEXCEPT
; 766  : 		{	// destroy the object
; 767  : 		if (_Buf._Begin != 0)
; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
; 777  : 		{	// assign _Right (share active buffer)
; 778  : 		_Pbuf = _Right._Pbuf;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 757  : 		{	// construct from _Right (share active buffer)
; 758  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 759  : 		_Buf._Current = 0;

  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 760  : 		_Buf._Hiwater = 0;

  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 761  : 		_Buf._Size = 0;

  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 764  : 
; 765  : 	~_Temp_iterator() _NOEXCEPT
; 766  : 		{	// destroy the object
; 767  : 		if (_Buf._Begin != 0)
; 768  : 			{	// destroy any constructed elements in buffer
; 769  : 			for (_Pty _Next = _Buf._Begin;
; 770  : 				_Next != _Buf._Hiwater; ++_Next)
; 771  : 				_Destroy(&*_Next);
; 772  : 			_STD return_temporary_buffer(_Buf._Begin);
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
; 777  : 		{	// assign _Right (share active buffer)
; 778  : 		_Pbuf = _Right._Pbuf;

  00021	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00024	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 762  : 		*this = _Right;
; 763  : 		}

  00027	8b c1		 mov	 eax, ecx
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 747  : 	_Temp_iterator(ptrdiff_t _Count = 0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 748  : 		{	// construct from desired temporary buffer size
; 749  : 		_Buf._Begin = 0;
; 750  : 		_Buf._Current = 0;
; 751  : 		_Buf._Hiwater = 0;
; 752  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 753  : 		_Pbuf = &_Buf;
; 754  : 		}

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00011	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00018	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001f	89 49 10	 mov	 DWORD PTR [ecx+16], ecx
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Distance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAH@Z PROC ; std::_Distance<CMapOutdoor::TPatchDrawStruct *,int>, COMDAT

; 765  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	c1 f9 04	 sar	 ecx, 4
  0000f	01 08		 add	 DWORD PTR [eax], ecx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Distance@PAUTPatchDrawStruct@CMapOutdoor@@H@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAH@Z ENDP ; std::_Distance<CMapOutdoor::TPatchDrawStruct *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Insertion_sort<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 3025 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAV1@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z ; std::_Insertion_sort1<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder,CGraphicThingInstance *>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 3027 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Insertion_sort@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Insertion_sort<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2483 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00003	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2488 : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$make_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$make_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::make_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 2456 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2457 : 	_DEBUG_RANGE(_First, _Last);
; 2458 : 	_DEBUG_POINTER(_Pred);
; 2459 : 	if (1 < _Last - _First)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000b	2b c2		 sub	 eax, edx
  0000d	83 e0 fc	 and	 eax, -4			; fffffffcH
  00010	83 f8 04	 cmp	 eax, 4
  00013	7e 11		 jle	 SHORT $LN1@make_heap

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Make_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH0@Z ; std::_Make_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  00023	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@make_heap:

; 2462 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$make_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::make_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@0@PAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
tv2478 = -20						; size = 4
tv2470 = -20						; size = 4
__Gfirst$1$ = -16					; size = 4
__Glast$1$ = -12					; size = 4
__Plast$1$ = -8						; size = 4
__Pfirst$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Unguarded_partition@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@0@PAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Unguarded_partition<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 3063 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3064 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00008	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	57		 push	 edi
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR __First$[ebp]
  00011	2b c7		 sub	 eax, edi

; 3065 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  00013	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00016	c1 f8 02	 sar	 eax, 2
  00019	99		 cdq
  0001a	2b c2		 sub	 eax, edx
  0001c	d1 f8		 sar	 eax, 1
  0001e	8d 1c 87	 lea	 ebx, DWORD PTR [edi+eax*4]
  00021	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00024	89 5d fc	 mov	 DWORD PTR __Pfirst$1$[ebp], ebx
  00027	50		 push	 eax
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	e8 00 00 00 00	 call	 ??$_Median@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@00UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Median<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  0002f	83 c4 10	 add	 esp, 16			; 00000010H

; 3066 : 	_RanIt _Pfirst = _Mid;
; 3067 : 	_RanIt _Plast = _Pfirst + 1;

  00032	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  00035	89 55 f8	 mov	 DWORD PTR __Plast$1$[ebp], edx

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00038	3b fb		 cmp	 edi, ebx
  0003a	0f 83 2e 01 00
	00		 jae	 $LN254@Unguarded_
$LL29@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00046	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  00049	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0004b	8b 30		 mov	 esi, DWORD PTR [eax]
  0004d	89 45 ec	 mov	 DWORD PTR tv2478[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00050	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00055	8b ce		 mov	 ecx, esi
  00057	8b d8		 mov	 ebx, eax
  00059	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0005e	8b cf		 mov	 ecx, edi
  00060	8b f0		 mov	 esi, eax
  00062	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00067	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  0006c	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  00071	0f 28 cd	 movaps	 xmm1, xmm5
  00074	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  00078	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  0007c	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  00081	0f 28 dc	 movaps	 xmm3, xmm4
  00084	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  00089	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  0008e	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00091	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00095	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  0009a	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0009f	f3 0f 59 db	 mulss	 xmm3, xmm3
  000a3	f3 0f 59 e4	 mulss	 xmm4, xmm4
  000a7	f3 0f 59 ed	 mulss	 xmm5, xmm5
  000ab	f3 0f 58 d9	 addss	 xmm3, xmm1
  000af	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000b3	f3 0f 58 e5	 addss	 xmm4, xmm5
  000b7	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000bb	f3 0f 58 d8	 addss	 xmm3, xmm0
  000bf	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  000c3	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  000c6	0f 87 99 00 00
	00		 ja	 $LN281@Unguarded_
  000cc	8b 4d fc	 mov	 ecx, DWORD PTR __Pfirst$1$[ebp]
  000cf	8b 7d ec	 mov	 edi, DWORD PTR tv2478[ebp]
  000d2	8b 31		 mov	 esi, DWORD PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  000da	8b 3f		 mov	 edi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  000dc	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  000e1	8b ce		 mov	 ecx, esi
  000e3	8b d8		 mov	 ebx, eax
  000e5	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  000ea	8b cf		 mov	 ecx, edi
  000ec	8b f0		 mov	 esi, eax
  000ee	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000f3	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  000f8	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  000fd	0f 28 cd	 movaps	 xmm1, xmm5
  00100	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  00104	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00108	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  0010d	0f 28 dc	 movaps	 xmm3, xmm4
  00110	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  00115	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  0011a	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0011d	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00121	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  00126	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0012b	f3 0f 59 db	 mulss	 xmm3, xmm3
  0012f	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00133	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00137	f3 0f 58 d9	 addss	 xmm3, xmm1
  0013b	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0013f	f3 0f 58 e5	 addss	 xmm4, xmm5
  00143	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00147	f3 0f 58 d8	 addss	 xmm3, xmm0
  0014b	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  0014f	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00152	77 11		 ja	 SHORT $LN281@Unguarded_

; 3072 : 		--_Pfirst;

  00154	8b 5d ec	 mov	 ebx, DWORD PTR tv2478[ebp]
  00157	89 5d fc	 mov	 DWORD PTR __Pfirst$1$[ebp], ebx
  0015a	39 5d 0c	 cmp	 DWORD PTR __First$[ebp], ebx
  0015d	0f 82 dd fe ff
	ff		 jb	 $LL29@Unguarded_

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00163	eb 03		 jmp	 SHORT $LN276@Unguarded_
$LN281@Unguarded_:
  00165	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
$LN276@Unguarded_:
  00168	8b 55 f8	 mov	 edx, DWORD PTR __Plast$1$[ebp]
  0016b	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
$LN254@Unguarded_:

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  0016e	3b d6		 cmp	 edx, esi
  00170	0f 83 2d 01 00
	00		 jae	 $LN277@Unguarded_
$LL27@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00176	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  0017c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0017e	8b 32		 mov	 esi, DWORD PTR [edx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00180	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00185	8b ce		 mov	 ecx, esi
  00187	8b d8		 mov	 ebx, eax
  00189	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0018e	8b cf		 mov	 ecx, edi
  00190	8b f0		 mov	 esi, eax
  00192	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00197	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  0019c	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  001a1	0f 28 cd	 movaps	 xmm1, xmm5
  001a4	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  001a8	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  001ac	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  001b1	0f 28 dc	 movaps	 xmm3, xmm4
  001b4	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  001b9	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  001be	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001c1	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001c5	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  001ca	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001cf	f3 0f 59 db	 mulss	 xmm3, xmm3
  001d3	f3 0f 59 e4	 mulss	 xmm4, xmm4
  001d7	f3 0f 59 ed	 mulss	 xmm5, xmm5
  001db	f3 0f 58 d9	 addss	 xmm3, xmm1
  001df	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001e3	f3 0f 58 e5	 addss	 xmm4, xmm5
  001e7	f3 0f 59 d2	 mulss	 xmm2, xmm2
  001eb	f3 0f 58 d8	 addss	 xmm3, xmm0
  001ef	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  001f3	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  001f6	0f 87 a1 00 00
	00		 ja	 $LN286@Unguarded_
  001fc	8b 4d f8	 mov	 ecx, DWORD PTR __Plast$1$[ebp]
  001ff	8b 39		 mov	 edi, DWORD PTR [ecx]
  00201	8b 4d fc	 mov	 ecx, DWORD PTR __Pfirst$1$[ebp]
  00204	8b 31		 mov	 esi, DWORD PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00206	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0020c	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00211	8b ce		 mov	 ecx, esi
  00213	8b d8		 mov	 ebx, eax
  00215	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0021a	8b cf		 mov	 ecx, edi
  0021c	8b f0		 mov	 esi, eax
  0021e	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00223	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  00228	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  0022d	0f 28 cd	 movaps	 xmm1, xmm5
  00230	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  00234	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00238	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  0023d	0f 28 dc	 movaps	 xmm3, xmm4
  00240	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  00245	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
; File a:\vs\vc\include\algorithm

; 3076 : 		++_Plast;

  0024a	8b 55 f8	 mov	 edx, DWORD PTR __Plast$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0024d	0f 28 c2	 movaps	 xmm0, xmm2
  00250	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  00255	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  0025a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0025d	f3 0f 59 db	 mulss	 xmm3, xmm3
  00261	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00265	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00269	f3 0f 59 ed	 mulss	 xmm5, xmm5
  0026d	f3 0f 58 d9	 addss	 xmm3, xmm1
  00271	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00275	f3 0f 58 e5	 addss	 xmm4, xmm5
  00279	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0027d	f3 0f 58 d8	 addss	 xmm3, xmm0
  00281	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  00285	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  00288	77 19		 ja	 SHORT $LN277@Unguarded_
  0028a	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]

; 3076 : 		++_Plast;

  0028d	83 c2 04	 add	 edx, 4
  00290	89 55 f8	 mov	 DWORD PTR __Plast$1$[ebp], edx
  00293	3b d6		 cmp	 edx, esi
  00295	0f 82 db fe ff
	ff		 jb	 $LL27@Unguarded_

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  0029b	eb 06		 jmp	 SHORT $LN277@Unguarded_
$LN286@Unguarded_:
  0029d	8b 55 f8	 mov	 edx, DWORD PTR __Plast$1$[ebp]
  002a0	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
$LN277@Unguarded_:

; 3079 : 	_RanIt _Glast = _Pfirst;

  002a3	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
  002a6	8b fa		 mov	 edi, edx
  002a8	8b d3		 mov	 edx, ebx
  002aa	89 55 f4	 mov	 DWORD PTR __Glast$1$[ebp], edx
$LN289@Unguarded_:

; 3077 : 
; 3078 : 	_RanIt _Gfirst = _Plast;

  002ad	89 7d f0	 mov	 DWORD PTR __Gfirst$1$[ebp], edi
$LL25@Unguarded_:

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  002b0	3b fe		 cmp	 edi, esi
  002b2	0f 83 4f 01 00
	00		 jae	 $LN258@Unguarded_
  002b8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL23@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  002c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3084 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  002c6	8b 3f		 mov	 edi, DWORD PTR [edi]
  002c8	8b 33		 mov	 esi, DWORD PTR [ebx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  002ca	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  002cf	8b ce		 mov	 ecx, esi
  002d1	8b d8		 mov	 ebx, eax
  002d3	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  002d8	8b cf		 mov	 ecx, edi
  002da	8b f0		 mov	 esi, eax
  002dc	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002e1	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  002e6	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  002eb	0f 28 cd	 movaps	 xmm1, xmm5
  002ee	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  002f2	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  002f6	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  002fb	0f 28 dc	 movaps	 xmm3, xmm4
  002fe	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  00303	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  00308	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0030b	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0030f	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  00314	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00319	f3 0f 59 db	 mulss	 xmm3, xmm3
  0031d	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00321	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00325	f3 0f 58 d9	 addss	 xmm3, xmm1
  00329	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0032d	f3 0f 58 e5	 addss	 xmm4, xmm5
  00331	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00335	f3 0f 58 d8	 addss	 xmm3, xmm0
  00339	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  0033d	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3084 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  00340	0f 87 a6 00 00
	00		 ja	 $LN284@Unguarded_

; 3086 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  00346	8b 4d fc	 mov	 ecx, DWORD PTR __Pfirst$1$[ebp]
  00349	8b 75 f0	 mov	 esi, DWORD PTR __Gfirst$1$[ebp]
  0034c	8b 39		 mov	 edi, DWORD PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  0034e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3086 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  00354	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00356	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  0035b	8b ce		 mov	 ecx, esi
  0035d	8b d8		 mov	 ebx, eax
  0035f	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  00364	8b cf		 mov	 ecx, edi
  00366	8b f0		 mov	 esi, eax
  00368	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0036d	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  00372	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  00377	0f 28 cd	 movaps	 xmm1, xmm5
  0037a	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  0037e	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00382	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  00387	0f 28 dc	 movaps	 xmm3, xmm4
  0038a	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  0038f	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  00394	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00397	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0039b	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  003a0	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  003a5	f3 0f 59 db	 mulss	 xmm3, xmm3
  003a9	f3 0f 59 e4	 mulss	 xmm4, xmm4
  003ad	f3 0f 59 ed	 mulss	 xmm5, xmm5
  003b1	f3 0f 58 d9	 addss	 xmm3, xmm1
  003b5	f3 0f 59 c0	 mulss	 xmm0, xmm0
  003b9	f3 0f 58 e5	 addss	 xmm4, xmm5
  003bd	f3 0f 59 d2	 mulss	 xmm2, xmm2
  003c1	f3 0f 58 d8	 addss	 xmm3, xmm0
  003c5	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  003c9	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3086 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  003cc	77 33		 ja	 SHORT $LN278@Unguarded_

; 3087 : 				break;
; 3088 : 			else if (_Plast++ != _Gfirst)

  003ce	8b 55 f8	 mov	 edx, DWORD PTR __Plast$1$[ebp]
  003d1	8b c2		 mov	 eax, edx
  003d3	8b 7d f0	 mov	 edi, DWORD PTR __Gfirst$1$[ebp]
  003d6	83 c2 04	 add	 edx, 4
  003d9	89 55 f8	 mov	 DWORD PTR __Plast$1$[ebp], edx
  003dc	3b c7		 cmp	 eax, edi
  003de	74 0f		 je	 SHORT $LN22@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  003e0	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]

; 53   : 	_Left = _Move(_Right);

  003e3	8b 07		 mov	 eax, DWORD PTR [edi]
  003e5	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 54   : 	_Right = _Move(_Tmp);

  003e8	89 0f		 mov	 DWORD PTR [edi], ecx
  003ea	eb 03		 jmp	 SHORT $LN22@Unguarded_
$LN284@Unguarded_:
  003ec	8b 7d f0	 mov	 edi, DWORD PTR __Gfirst$1$[ebp]
$LN22@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  003ef	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
  003f2	83 c7 04	 add	 edi, 4
  003f5	89 7d f0	 mov	 DWORD PTR __Gfirst$1$[ebp], edi
  003f8	3b 7d 10	 cmp	 edi, DWORD PTR __Last$[ebp]
  003fb	0f 82 bf fe ff
	ff		 jb	 $LL23@Unguarded_
$LN278@Unguarded_:
  00401	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
  00404	8b 55 f4	 mov	 edx, DWORD PTR __Glast$1$[ebp]
$LN258@Unguarded_:

; 3090 : 		for (; _First < _Glast; --_Glast)

  00407	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0040a	3b d0		 cmp	 edx, eax
  0040c	0f 86 60 01 00
	00		 jbe	 $LN288@Unguarded_
  00412	8d 72 fc	 lea	 esi, DWORD PTR [edx-4]
  00415	89 75 ec	 mov	 DWORD PTR tv2470[ebp], esi
  00418	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL15@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00420	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3091 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  00426	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00428	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  0042a	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  0042f	8b ce		 mov	 ecx, esi
  00431	8b d8		 mov	 ebx, eax
  00433	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  00438	8b cf		 mov	 ecx, edi
  0043a	8b f0		 mov	 esi, eax
  0043c	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00441	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  00446	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  0044b	0f 28 cd	 movaps	 xmm1, xmm5
  0044e	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  00452	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00456	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  0045b	0f 28 dc	 movaps	 xmm3, xmm4
  0045e	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  00463	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  00468	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0046b	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0046f	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  00474	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00479	f3 0f 59 db	 mulss	 xmm3, xmm3
  0047d	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00481	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00485	f3 0f 58 d9	 addss	 xmm3, xmm1
  00489	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0048d	f3 0f 58 e5	 addss	 xmm4, xmm5
  00491	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00495	f3 0f 58 d8	 addss	 xmm3, xmm0
  00499	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  0049d	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3091 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  004a0	0f 87 a2 00 00
	00		 ja	 $LN283@Unguarded_

; 3093 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  004a6	8b 45 fc	 mov	 eax, DWORD PTR __Pfirst$1$[ebp]
  004a9	8b 7d ec	 mov	 edi, DWORD PTR tv2470[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  004ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3093 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  004b2	8b 30		 mov	 esi, DWORD PTR [eax]
  004b4	8b 3f		 mov	 edi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  004b6	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  004bb	8b ce		 mov	 ecx, esi
  004bd	8b d8		 mov	 ebx, eax
  004bf	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  004c4	8b cf		 mov	 ecx, edi
  004c6	8b f0		 mov	 esi, eax
  004c8	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  004cd	f3 0f 10 6b 30	 movss	 xmm5, DWORD PTR [ebx+48]
  004d2	f3 0f 10 63 34	 movss	 xmm4, DWORD PTR [ebx+52]
  004d7	0f 28 cd	 movaps	 xmm1, xmm5
  004da	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]
  004de	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  004e2	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  004e7	0f 28 dc	 movaps	 xmm3, xmm4
  004ea	f3 0f 5c 5e 04	 subss	 xmm3, DWORD PTR [esi+4]
  004ef	f3 0f 5c 60 04	 subss	 xmm4, DWORD PTR [eax+4]
  004f4	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  004f7	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  004fb	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]
  00500	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00505	f3 0f 59 db	 mulss	 xmm3, xmm3
  00509	f3 0f 59 e4	 mulss	 xmm4, xmm4
  0050d	f3 0f 59 ed	 mulss	 xmm5, xmm5
  00511	f3 0f 58 d9	 addss	 xmm3, xmm1
  00515	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00519	f3 0f 58 e5	 addss	 xmm4, xmm5
  0051d	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00521	f3 0f 58 d8	 addss	 xmm3, xmm0
  00525	f3 0f 58 e2	 addss	 xmm4, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  00529	0f 2f e3	 comiss	 xmm4, xmm3
; File a:\vs\vc\include\algorithm

; 3093 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  0052c	77 3c		 ja	 SHORT $LN287@Unguarded_

; 3094 : 				break;
; 3095 : 			else if (--_Pfirst != _Glast - 1)

  0052e	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
  00531	8b 75 ec	 mov	 esi, DWORD PTR tv2470[ebp]
  00534	83 eb 04	 sub	 ebx, 4
  00537	89 5d fc	 mov	 DWORD PTR __Pfirst$1$[ebp], ebx
  0053a	3b de		 cmp	 ebx, esi
  0053c	74 10		 je	 SHORT $LN14@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0053e	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 53   : 	_Left = _Move(_Right);

  00540	8b 06		 mov	 eax, DWORD PTR [esi]
  00542	89 03		 mov	 DWORD PTR [ebx], eax

; 54   : 	_Right = _Move(_Tmp);

  00544	89 0e		 mov	 DWORD PTR [esi], ecx
  00546	eb 06		 jmp	 SHORT $LN14@Unguarded_
$LN283@Unguarded_:
  00548	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
  0054b	8b 75 ec	 mov	 esi, DWORD PTR tv2470[ebp]
$LN14@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3090 : 		for (; _First < _Glast; --_Glast)

  0054e	8b 55 f4	 mov	 edx, DWORD PTR __Glast$1$[ebp]
  00551	83 ee 04	 sub	 esi, 4
  00554	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00557	83 ea 04	 sub	 edx, 4
  0055a	89 55 f4	 mov	 DWORD PTR __Glast$1$[ebp], edx
  0055d	89 75 ec	 mov	 DWORD PTR tv2470[ebp], esi
  00560	3b c2		 cmp	 eax, edx
  00562	0f 82 b8 fe ff
	ff		 jb	 $LL15@Unguarded_
  00568	eb 06		 jmp	 SHORT $LN279@Unguarded_
$LN287@Unguarded_:
  0056a	8b 55 f4	 mov	 edx, DWORD PTR __Glast$1$[ebp]
  0056d	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
$LN279@Unguarded_:

; 3096 : 				_STD iter_swap(_Pfirst, _Glast - 1);
; 3097 : 		if (_Glast == _First && _Gfirst == _Last)

  00570	3b d0		 cmp	 edx, eax
$LN288@Unguarded_:
  00572	8b 7d f0	 mov	 edi, DWORD PTR __Gfirst$1$[ebp]
  00575	75 41		 jne	 SHORT $LN6@Unguarded_
  00577	3b 7d 10	 cmp	 edi, DWORD PTR __Last$[ebp]
  0057a	0f 84 83 00 00
	00		 je	 $LN260@Unguarded_

; 3102 : 			if (_Plast != _Gfirst)

  00580	8b 55 f8	 mov	 edx, DWORD PTR __Plast$1$[ebp]
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00583	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
; File a:\vs\vc\include\algorithm

; 3102 : 			if (_Plast != _Gfirst)

  00586	3b d7		 cmp	 edx, edi
  00588	74 08		 je	 SHORT $LN204@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0058a	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 53   : 	_Left = _Move(_Right);

  0058c	8b 02		 mov	 eax, DWORD PTR [edx]
  0058e	89 03		 mov	 DWORD PTR [ebx], eax

; 54   : 	_Right = _Move(_Tmp);

  00590	89 0a		 mov	 DWORD PTR [edx], ecx
$LN204@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3104 : 			++_Plast;

  00592	83 c2 04	 add	 edx, 4

; 3105 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  00595	8b f7		 mov	 esi, edi
  00597	89 55 f8	 mov	 DWORD PTR __Plast$1$[ebp], edx
  0059a	8b d3		 mov	 edx, ebx
  0059c	83 c3 04	 add	 ebx, 4
  0059f	83 c7 04	 add	 edi, 4
  005a2	89 5d fc	 mov	 DWORD PTR __Pfirst$1$[ebp], ebx
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  005a5	8b 06		 mov	 eax, DWORD PTR [esi]
  005a7	8b 0a		 mov	 ecx, DWORD PTR [edx]
  005a9	89 02		 mov	 DWORD PTR [edx], eax

; 29   : 	}

  005ab	8b 55 f4	 mov	 edx, DWORD PTR __Glast$1$[ebp]

; 54   : 	_Right = _Move(_Tmp);

  005ae	89 0e		 mov	 DWORD PTR [esi], ecx

; 29   : 	}

  005b0	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  005b3	e9 f5 fc ff ff	 jmp	 $LN289@Unguarded_
$LN6@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3107 : 		else if (_Gfirst == _Last)

  005b8	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]

; 3108 : 			{	// no room at top, rotate pivot downward
; 3109 : 			if (--_Glast != --_Pfirst)

  005bb	83 ea 04	 sub	 edx, 4
  005be	8b 5d fc	 mov	 ebx, DWORD PTR __Pfirst$1$[ebp]
  005c1	89 55 f4	 mov	 DWORD PTR __Glast$1$[ebp], edx
  005c4	3b fe		 cmp	 edi, esi
  005c6	75 2b		 jne	 SHORT $LN3@Unguarded_
  005c8	83 eb 04	 sub	 ebx, 4
  005cb	89 5d fc	 mov	 DWORD PTR __Pfirst$1$[ebp], ebx
  005ce	3b d3		 cmp	 edx, ebx
  005d0	74 08		 je	 SHORT $LN224@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  005d2	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  005d4	8b 03		 mov	 eax, DWORD PTR [ebx]
  005d6	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  005d8	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN224@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  005da	8b 55 f8	 mov	 edx, DWORD PTR __Plast$1$[ebp]
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  005dd	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  005df	83 ea 04	 sub	 edx, 4
  005e2	89 55 f8	 mov	 DWORD PTR __Plast$1$[ebp], edx
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  005e5	8b 02		 mov	 eax, DWORD PTR [edx]
  005e7	89 03		 mov	 DWORD PTR [ebx], eax

; 54   : 	_Right = _Move(_Tmp);

  005e9	89 0a		 mov	 DWORD PTR [edx], ecx
; File a:\vs\vc\include\algorithm

; 3113 : 		else

  005eb	8b 55 f4	 mov	 edx, DWORD PTR __Glast$1$[ebp]
  005ee	e9 bd fc ff ff	 jmp	 $LL25@Unguarded_
$LN3@Unguarded_:
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  005f3	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 53   : 	_Left = _Move(_Right);

  005f5	8b 02		 mov	 eax, DWORD PTR [edx]
  005f7	89 07		 mov	 DWORD PTR [edi], eax
; File a:\vs\vc\include\algorithm

; 3114 : 			_STD iter_swap(_Gfirst++, --_Glast);

  005f9	83 c7 04	 add	 edi, 4
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  005fc	89 0a		 mov	 DWORD PTR [edx], ecx
; File a:\vs\vc\include\algorithm

; 3115 : 		}

  005fe	e9 aa fc ff ff	 jmp	 $LN289@Unguarded_
$LN260@Unguarded_:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00603	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00606	8b 4d fc	 mov	 ecx, DWORD PTR __Pfirst$1$[ebp]
  00609	5f		 pop	 edi
  0060a	5e		 pop	 esi
  0060b	89 08		 mov	 DWORD PTR [eax], ecx
  0060d	8b 4d f8	 mov	 ecx, DWORD PTR __Plast$1$[ebp]
  00610	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00613	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 3116 : 	}

  00614	8b e5		 mov	 esp, ebp
  00616	5d		 pop	 ebp
  00617	c3		 ret	 0
??$_Unguarded_partition@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@0@PAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Unguarded_partition<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z PROC ; std::_Insertion_sort<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 3025 : 	{	// insertion sort [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00003	6a 00		 push	 0
  00005	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00008	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@U12@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z ; std::_Insertion_sort1<CArea::SCRCWithNumber *,CArea::CRCNumComp,CArea::SCRCWithNumber>
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 3027 : 	}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Insertion_sort@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ENDP ; std::_Insertion_sort<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z PROC ; std::sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 2483 : 	{	// order heap by repeatedly popping, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  00003	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2488 : 	}

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ENDP ; std::sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$make_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$make_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z PROC ; std::make_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 2456 : 	{	// make [_First, _Last) into a heap, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2457 : 	_DEBUG_RANGE(_First, _Last);
; 2458 : 	_DEBUG_POINTER(_Pred);
; 2459 : 	if (1 < _Last - _First)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000b	2b c2		 sub	 eax, edx
  0000d	83 e0 f8	 and	 eax, -8			; fffffff8H
  00010	83 f8 08	 cmp	 eax, 8
  00013	7e 11		 jle	 SHORT $LN1@make_heap

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Make_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@PAH0@Z ; std::_Make_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
  00023	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@make_heap:

; 2462 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$make_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ENDP ; std::make_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z
_TEXT	SEGMENT
__Gfirst$1$ = -12					; size = 4
__Glast$1$ = -8						; size = 4
__Plast$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Unguarded_partition@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z PROC ; std::_Unguarded_partition<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 3063 : 	{	// partition [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3064 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

  00006	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	53		 push	 ebx
  0000c	8b 5d 0c	 mov	 ebx, DWORD PTR __First$[ebp]
  0000f	2b c3		 sub	 eax, ebx
  00011	c1 f8 03	 sar	 eax, 3
  00014	99		 cdq
  00015	56		 push	 esi
  00016	2b c2		 sub	 eax, edx
  00018	d1 f8		 sar	 eax, 1
  0001a	57		 push	 edi

; 3065 : 	_Median(_First, _Mid, _Last - 1, _Pred);

  0001b	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0001e	8d 34 c3	 lea	 esi, DWORD PTR [ebx+eax*8]
  00021	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00024	50		 push	 eax
  00025	56		 push	 esi
  00026	53		 push	 ebx
  00027	e8 00 00 00 00	 call	 ??$_Median@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Median<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 3066 : 	_RanIt _Pfirst = _Mid;
; 3067 : 	_RanIt _Plast = _Pfirst + 1;

  0002f	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00032	89 4d fc	 mov	 DWORD PTR __Plast$1$[ebp], ecx

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00035	3b de		 cmp	 ebx, esi
  00037	73 1c		 jae	 SHORT $LN148@Unguarded_
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL29@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00040	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00043	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00046	3b c2		 cmp	 eax, edx
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  00048	77 0b		 ja	 SHORT $LN148@Unguarded_
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  0004a	3b d0		 cmp	 edx, eax
; File a:\vs\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

  0004c	77 07		 ja	 SHORT $LN148@Unguarded_

; 3072 : 		--_Pfirst;

  0004e	83 ee 08	 sub	 esi, 8
  00051	3b de		 cmp	 ebx, esi
  00053	72 eb		 jb	 SHORT $LL29@Unguarded_
$LN148@Unguarded_:

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  00055	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00058	3b c8		 cmp	 ecx, eax
  0005a	73 19		 jae	 SHORT $LN26@Unguarded_
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  0005c	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0005f	90		 npad	 1
$LL27@Unguarded_:
  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b d7		 cmp	 edx, edi
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  00065	77 0b		 ja	 SHORT $LN149@Unguarded_
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00067	3b fa		 cmp	 edi, edx
; File a:\vs\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

  00069	77 07		 ja	 SHORT $LN149@Unguarded_

; 3076 : 		++_Plast;

  0006b	83 c1 08	 add	 ecx, 8
  0006e	3b c8		 cmp	 ecx, eax
  00070	72 ee		 jb	 SHORT $LL27@Unguarded_
$LN149@Unguarded_:
  00072	89 4d fc	 mov	 DWORD PTR __Plast$1$[ebp], ecx
$LN26@Unguarded_:

; 3079 : 	_RanIt _Glast = _Pfirst;

  00075	8b fe		 mov	 edi, esi
  00077	8b d9		 mov	 ebx, ecx
  00079	89 7d f8	 mov	 DWORD PTR __Glast$1$[ebp], edi
$LN153@Unguarded_:

; 3077 : 
; 3078 : 	_RanIt _Gfirst = _Plast;

  0007c	89 5d f4	 mov	 DWORD PTR __Gfirst$1$[ebp], ebx
  0007f	90		 npad	 1
$LL25@Unguarded_:

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  00080	3b d8		 cmp	 ebx, eax
  00082	73 45		 jae	 SHORT $LN130@Unguarded_
  00084	8d 79 f8	 lea	 edi, DWORD PTR [ecx-8]
$LL23@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00087	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008a	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0008d	3b c2		 cmp	 eax, edx
; File a:\vs\vc\include\algorithm

; 3084 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

  0008f	77 2a		 ja	 SHORT $LN22@Unguarded_
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00091	3b d0		 cmp	 edx, eax
; File a:\vs\vc\include\algorithm

; 3086 : 			else if (_Pred(*_Gfirst, *_Pfirst))

  00093	77 2e		 ja	 SHORT $LN150@Unguarded_

; 3087 : 				break;
; 3088 : 			else if (_Plast++ != _Gfirst)

  00095	8b c1		 mov	 eax, ecx
  00097	83 c7 08	 add	 edi, 8
  0009a	83 c1 08	 add	 ecx, 8
  0009d	89 4d fc	 mov	 DWORD PTR __Plast$1$[ebp], ecx
  000a0	3b c3		 cmp	 eax, ebx
  000a2	74 17		 je	 SHORT $LN22@Unguarded_
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  000a4	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 53   : 	_Left = _Move(_Right);

  000a6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a8	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000ab	89 07		 mov	 DWORD PTR [edi], eax
  000ad	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000b0	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  000b3	89 0b		 mov	 DWORD PTR [ebx], ecx
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __Plast$1$[ebp]
  000b8	89 53 04	 mov	 DWORD PTR [ebx+4], edx
$LN22@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

  000bb	83 c3 08	 add	 ebx, 8
  000be	3b 5d 10	 cmp	 ebx, DWORD PTR __Last$[ebp]
  000c1	72 c4		 jb	 SHORT $LL23@Unguarded_
$LN150@Unguarded_:
  000c3	8b 7d f8	 mov	 edi, DWORD PTR __Glast$1$[ebp]
  000c6	89 5d f4	 mov	 DWORD PTR __Gfirst$1$[ebp], ebx
$LN130@Unguarded_:

; 3090 : 		for (; _First < _Glast; --_Glast)

  000c9	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  000cc	3b fa		 cmp	 edi, edx
  000ce	76 3c		 jbe	 SHORT $LN152@Unguarded_
$LL15@Unguarded_:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000d0	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  000d3	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d6	3b c1		 cmp	 eax, ecx
; File a:\vs\vc\include\algorithm

; 3091 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

  000d8	77 26		 ja	 SHORT $LN14@Unguarded_
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000da	3b c8		 cmp	 ecx, eax
; File a:\vs\vc\include\algorithm

; 3093 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

  000dc	77 29		 ja	 SHORT $LN151@Unguarded_

; 3094 : 				break;
; 3095 : 			else if (--_Pfirst != _Glast - 1)

  000de	83 ee 08	 sub	 esi, 8
  000e1	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  000e4	3b f0		 cmp	 esi, eax
  000e6	74 18		 je	 SHORT $LN14@Unguarded_
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  000e8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ea	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ec	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000ef	89 06		 mov	 DWORD PTR [esi], eax
  000f1	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  000f4	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  000f7	89 57 fc	 mov	 DWORD PTR [edi-4], edx
  000fa	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  000fd	89 4f f8	 mov	 DWORD PTR [edi-8], ecx
$LN14@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3090 : 		for (; _First < _Glast; --_Glast)

  00100	83 ef 08	 sub	 edi, 8
  00103	3b d7		 cmp	 edx, edi
  00105	72 c9		 jb	 SHORT $LL15@Unguarded_
$LN151@Unguarded_:
  00107	89 7d f8	 mov	 DWORD PTR __Glast$1$[ebp], edi

; 3096 : 				_STD iter_swap(_Pfirst, _Glast - 1);
; 3097 : 		if (_Glast == _First && _Gfirst == _Last)

  0010a	3b fa		 cmp	 edi, edx
$LN152@Unguarded_:
  0010c	75 58		 jne	 SHORT $LN6@Unguarded_
  0010e	3b 5d 10	 cmp	 ebx, DWORD PTR __Last$[ebp]
  00111	0f 84 c4 00 00
	00		 je	 $LN132@Unguarded_

; 3098 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
; 3099 : 
; 3100 : 		if (_Glast == _First)
; 3101 : 			{	// no room at bottom, rotate pivot upward
; 3102 : 			if (_Plast != _Gfirst)

  00117	8b 7d fc	 mov	 edi, DWORD PTR __Plast$1$[ebp]
  0011a	3b fb		 cmp	 edi, ebx
  0011c	74 14		 je	 SHORT $LN76@Unguarded_
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0011e	8b 07		 mov	 eax, DWORD PTR [edi]
  00120	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00122	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00125	89 06		 mov	 DWORD PTR [esi], eax
  00127	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0012a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  0012d	89 0f		 mov	 DWORD PTR [edi], ecx
  0012f	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN76@Unguarded_:

; 53   : 	_Left = _Move(_Right);

  00132	8b 03		 mov	 eax, DWORD PTR [ebx]
; File a:\vs\vc\include\algorithm

; 3104 : 			++_Plast;

  00134	83 c7 08	 add	 edi, 8
  00137	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi

; 3105 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

  0013a	8b fe		 mov	 edi, esi
  0013c	83 c6 08	 add	 esi, 8
  0013f	83 45 f4 08	 add	 DWORD PTR __Gfirst$1$[ebp], 8
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00143	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00145	8b 57 04	 mov	 edx, DWORD PTR [edi+4]

; 53   : 	_Left = _Move(_Right);

  00148	89 07		 mov	 DWORD PTR [edi], eax
  0014a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0014d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 29   : 	}

  00150	8b 7d f8	 mov	 edi, DWORD PTR __Glast$1$[ebp]
  00153	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]

; 54   : 	_Right = _Move(_Tmp);

  00156	89 0b		 mov	 DWORD PTR [ebx], ecx

; 29   : 	}

  00158	8b 4d fc	 mov	 ecx, DWORD PTR __Plast$1$[ebp]

; 54   : 	_Right = _Move(_Tmp);

  0015b	89 53 04	 mov	 DWORD PTR [ebx+4], edx

; 29   : 	}

  0015e	8b 5d f4	 mov	 ebx, DWORD PTR __Gfirst$1$[ebp]
  00161	e9 1a ff ff ff	 jmp	 $LL25@Unguarded_
$LN6@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3109 : 			if (--_Glast != --_Pfirst)

  00166	83 ef 08	 sub	 edi, 8
  00169	89 7d f8	 mov	 DWORD PTR __Glast$1$[ebp], edi
  0016c	3b 5d 10	 cmp	 ebx, DWORD PTR __Last$[ebp]
  0016f	75 48		 jne	 SHORT $LN3@Unguarded_
  00171	83 ee 08	 sub	 esi, 8
  00174	3b fe		 cmp	 edi, esi
  00176	74 14		 je	 SHORT $LN96@Unguarded_
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00178	8b 06		 mov	 eax, DWORD PTR [esi]
  0017a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0017c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0017f	89 07		 mov	 DWORD PTR [edi], eax
  00181	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00184	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00187	89 0e		 mov	 DWORD PTR [esi], ecx
  00189	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN96@Unguarded_:
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  0018c	8b 45 fc	 mov	 eax, DWORD PTR __Plast$1$[ebp]
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  0018f	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  00191	83 e8 08	 sub	 eax, 8
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  00194	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
; File a:\vs\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

  00197	89 45 fc	 mov	 DWORD PTR __Plast$1$[ebp], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0019a	8b 00		 mov	 eax, DWORD PTR [eax]
  0019c	89 06		 mov	 DWORD PTR [esi], eax
  0019e	8b 45 fc	 mov	 eax, DWORD PTR __Plast$1$[ebp]
  001a1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a4	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  001a7	8b 45 fc	 mov	 eax, DWORD PTR __Plast$1$[ebp]
  001aa	89 08		 mov	 DWORD PTR [eax], ecx
  001ac	8b c8		 mov	 ecx, eax
; File a:\vs\vc\include\algorithm

; 3113 : 		else

  001ae	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  001b1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File a:\vs\vc\include\algorithm

; 3113 : 		else

  001b4	e9 c7 fe ff ff	 jmp	 $LL25@Unguarded_
$LN3@Unguarded_:
; File a:\vs\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

  001b9	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 53   : 	_Left = _Move(_Right);

  001bb	8b 07		 mov	 eax, DWORD PTR [edi]
  001bd	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  001c0	89 03		 mov	 DWORD PTR [ebx], eax
  001c2	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001c5	89 43 04	 mov	 DWORD PTR [ebx+4], eax
; File a:\vs\vc\include\algorithm

; 3114 : 			_STD iter_swap(_Gfirst++, --_Glast);

  001c8	83 c3 08	 add	 ebx, 8

; 3115 : 		}

  001cb	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  001ce	89 0f		 mov	 DWORD PTR [edi], ecx
; File a:\vs\vc\include\algorithm

; 3115 : 		}

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR __Plast$1$[ebp]
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  001d3	89 57 04	 mov	 DWORD PTR [edi+4], edx
; File a:\vs\vc\include\algorithm

; 3115 : 		}

  001d6	e9 a1 fe ff ff	 jmp	 $LN153@Unguarded_
$LN132@Unguarded_:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  001db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001de	8b 4d fc	 mov	 ecx, DWORD PTR __Plast$1$[ebp]
  001e1	5f		 pop	 edi
  001e2	89 30		 mov	 DWORD PTR [eax], esi
  001e4	5e		 pop	 esi
  001e5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001e8	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 3116 : 	}

  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c3		 ret	 0
??$_Unguarded_partition@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z ENDP ; std::_Unguarded_partition<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z PROC ; std::_Sort<std::pair<float,long> *,int,std::less<void> >, COMDAT

; 3122 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3123 : 	_Diff _Count;
; 3124 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00011	2b c7		 sub	 eax, edi
  00013	c1 f8 03	 sar	 eax, 3
  00016	83 f8 20	 cmp	 eax, 32			; 00000020H
  00019	7e 72		 jle	 SHORT $LN3@Sort
  0001b	8b 5d 10	 mov	 ebx, DWORD PTR __Ideal$[ebp]
  0001e	8b ff		 npad	 2
$LL7@Sort:
  00020	85 db		 test	 ebx, ebx
  00022	0f 8e 80 00 00
	00		 jle	 $LN6@Sort

; 3125 : 		{	// divide and conquer by quicksort
; 3126 : 		pair<_RanIt, _RanIt> _Mid =
; 3127 : 			_Unguarded_partition(_First, _Last, _Pred);

  00028	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0002b	8d 45 f8	 lea	 eax, DWORD PTR __Mid$1[ebp]
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YA?AU?$pair@PAU?$pair@MJ@std@@PAU12@@0@PAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::_Unguarded_partition<std::pair<float,long> *,std::less<void> >

; 3128 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

  00036	8b c3		 mov	 eax, ebx
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	99		 cdq

; 3129 : 
; 3130 : 		if (_Mid.first - _First < _Last - _Mid.second)

  0003c	8b ce		 mov	 ecx, esi
  0003e	2b c2		 sub	 eax, edx
  00040	8b d8		 mov	 ebx, eax

; 3131 : 			{	// loop on second half
; 3132 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  00042	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00045	d1 fb		 sar	 ebx, 1
  00047	8b c3		 mov	 eax, ebx
  00049	99		 cdq
  0004a	2b c2		 sub	 eax, edx
  0004c	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1[ebp+4]
  0004f	d1 f8		 sar	 eax, 1
  00051	2b ca		 sub	 ecx, edx
  00053	03 d8		 add	 ebx, eax
  00055	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00058	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0005b	2b c7		 sub	 eax, edi
  0005d	83 e0 f8	 and	 eax, -8			; fffffff8H
  00060	53		 push	 ebx
  00061	3b c1		 cmp	 eax, ecx
  00063	7d 0f		 jge	 SHORT $LN5@Sort
  00065	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  00068	50		 push	 eax
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z ; std::_Sort<std::pair<float,long> *,int,std::less<void> >

; 3133 : 			_First = _Mid.second;

  0006f	8b 7d fc	 mov	 edi, DWORD PTR __Mid$1[ebp+4]

; 3134 : 			}
; 3135 : 		else

  00072	eb 0a		 jmp	 SHORT $LN34@Sort
$LN5@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  00074	56		 push	 esi
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 ??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z ; std::_Sort<std::pair<float,long> *,int,std::less<void> >

; 3138 : 			_Last = _Mid.first;

  0007b	8b 75 f8	 mov	 esi, DWORD PTR __Mid$1[ebp]
$LN34@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0007e	8b c6		 mov	 eax, esi
  00080	83 c4 10	 add	 esp, 16			; 00000010H
  00083	2b c7		 sub	 eax, edi
  00085	c1 f8 03	 sar	 eax, 3
  00088	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008b	7f 93		 jg	 SHORT $LL7@Sort
$LN3@Sort:

; 3143 : 		{	// heap sort if too many divisions
; 3144 : 		_STD make_heap(_First, _Last, _Pred);
; 3145 : 		_STD sort_heap(_First, _Last, _Pred);
; 3146 : 		}
; 3147 : 	else if (1 < _Count)

  0008d	83 f8 01	 cmp	 eax, 1
  00090	7e 0f		 jle	 SHORT $LN27@Sort

; 2488 : 	}
; 2489 : 
; 2490 : 		// TEMPLATE FUNCTION sort_heap
; 2491 : template<class _RanIt> inline
; 2492 : 	void sort_heap(_RanIt _First, _RanIt _Last)
; 2493 : 	{	// order heap by repeatedly popping, using operator<
; 2494 : 	_STD sort_heap(_First, _Last, less<>());
; 2495 : 	}
; 2496 : 
; 2497 : 		// TEMPLATE FUNCTION lower_bound WITH PRED
; 2498 : template<class _FwdIt,
; 2499 : 	class _Ty,
; 2500 : 	class _Diff,
; 2501 : 	class _Pr> inline
; 2502 : 	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
; 2503 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2504 : 	{	// find first element not before _Val, using _Pred
; 2505 : 	_Diff _Count = 0;
; 2506 : 	_Distance(_First, _Last, _Count);
; 2507 : 
; 2508 : 	while (0 < _Count)
; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;
; 2511 : 		_FwdIt _Mid = _First;
; 2512 : 		_STD advance(_Mid, _Count2);
; 2513 : 
; 2514 : 		if (_Pred(*_Mid, _Val))
; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;
; 2519 : 			}
; 2520 : 		else
; 2521 : 			_Count = _Count2;
; 2522 : 		}
; 2523 : 	return (_First);
; 2524 : 	}
; 2525 : 
; 2526 : template<class _FwdIt,
; 2527 : 	class _Ty,
; 2528 : 	class _Pr> inline
; 2529 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
; 2530 : 		const _Ty& _Val, _Pr _Pred)
; 2531 : 	{	// find first element not before _Val, using _Pred
; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));
; 2536 : 	}
; 2537 : 
; 2538 : 		// TEMPLATE FUNCTION lower_bound
; 2539 : template<class _FwdIt,
; 2540 : 	class _Ty> inline
; 2541 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2542 : 	{	// find first element not before _Val, using operator<
; 2543 : 	return (_STD lower_bound(_First, _Last, _Val, less<>()));
; 2544 : 	}
; 2545 : 
; 2546 : 		// TEMPLATE FUNCTION upper_bound WITH PRED
; 2547 : template<class _FwdIt,
; 2548 : 	class _Ty,
; 2549 : 	class _Diff,
; 2550 : 	class _Pr> inline
; 2551 : 	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
; 2552 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2553 : 	{	// find first element that _Val is before, using _Pred
; 2554 : 	_Diff _Count = 0;
; 2555 : 	_Distance(_First, _Last, _Count);
; 2556 : 
; 2557 : 	while (0 < _Count)
; 2558 : 		{	// divide and conquer, find half that contains answer
; 2559 : 		_Diff _Count2 = _Count / 2;
; 2560 : 		_FwdIt _Mid = _First;
; 2561 : 		_STD advance(_Mid, _Count2);
; 2562 : 
; 2563 : 		if (!_Pred(_Val, *_Mid))
; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;
; 2567 : 			_Count -= _Count2 + 1;
; 2568 : 			}
; 2569 : 		else
; 2570 : 			_Count = _Count2;
; 2571 : 		}
; 2572 : 	return (_First);
; 2573 : 	}
; 2574 : 
; 2575 : template<class _FwdIt,
; 2576 : 	class _Ty,
; 2577 : 	class _Pr> inline
; 2578 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
; 2579 : 		const _Ty& _Val, _Pr _Pred)
; 2580 : 	{	// find first element that _Val is before, using _Pred
; 2581 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2582 : 	return (_Rechecked(_First,
; 2583 : 		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2584 : 			_Dist_type(_First))));
; 2585 : 	}
; 2586 : 
; 2587 : 		// TEMPLATE FUNCTION upper_bound
; 2588 : template<class _FwdIt,
; 2589 : 	class _Ty> inline
; 2590 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2591 : 	{	// find first element that _Val is before, using operator<
; 2592 : 	return (_STD upper_bound(_First, _Last, _Val, less<>()));
; 2593 : 	}
; 2594 : 
; 2595 : 		// TEMPLATE FUNCTION equal_range WITH PRED
; 2596 : template<class _FwdIt,
; 2597 : 	class _Ty,
; 2598 : 	class _Diff,
; 2599 : 	class _Pr> inline
; 2600 : 	pair<_FwdIt, _FwdIt>
; 2601 : 		_Equal_range(_FwdIt _First, _FwdIt _Last,
; 2602 : 			const _Ty& _Val, _Pr _Pred, _Diff *)
; 2603 : 	{	// find range equivalent to _Val, using _Pred
; 2604 : 	_Diff _Count = 0;
; 2605 : 	_Distance(_First, _Last, _Count);
; 2606 : 
; 2607 : 	while (0 < _Count)
; 2608 : 		{	// divide and conquer, check midpoint
; 2609 : 		_Diff _Count2 = _Count / 2;
; 2610 : 		_FwdIt _Mid = _First;
; 2611 : 		_STD advance(_Mid, _Count2);
; 2612 : 
; 2613 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2614 : 			{	// range begins above _Mid, loop
; 2615 : 			_First = ++_Mid;
; 2616 : 			_Count -= _Count2 + 1;
; 2617 : 			}
; 2618 : 		else if (_Pred(_Val, *_Mid))
; 2619 : 			_Count = _Count2;	// range in first half, loop
; 2620 : 		else
; 2621 : 			{	// range straddles _Mid, find each end and return
; 2622 : 			_FwdIt _First2 = _STD lower_bound(_First, _Mid, _Val, _Pred);
; 2623 : 			_STD advance(_First, _Count);
; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);
; 2625 : 			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
; 2626 : 			}
; 2627 : 		}
; 2628 : 
; 2629 : 	return (pair<_FwdIt, _FwdIt>(_First, _First));	// empty range
; 2630 : 	}
; 2631 : 
; 2632 : template<class _FwdIt,
; 2633 : 	class _Ty,
; 2634 : 	class _Pr> inline
; 2635 : 	pair<_FwdIt, _FwdIt>
; 2636 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2637 : 			const _Ty& _Val, _Pr _Pred)
; 2638 : 	{	// find range equivalent to _Val, using _Pred
; 2639 : 	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2640 : 	pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
; 2641 : 		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
; 2642 : 			_Val, _Pred, _Dist_type(_First)));
; 2643 : 	return (pair<_FwdIt, _FwdIt>(
; 2644 : 		_Rechecked(_First, _Ans.first),
; 2645 : 		_Rechecked(_Last, _Ans.second)));
; 2646 : 	}
; 2647 : 
; 2648 : 		// TEMPLATE FUNCTION equal_range
; 2649 : template<class _FwdIt,
; 2650 : 	class _Ty> inline
; 2651 : 	pair<_FwdIt, _FwdIt>
; 2652 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2653 : 			const _Ty& _Val)
; 2654 : 	{	// find range equivalent to _Val, using operator<
; 2655 : 	return (_STD equal_range(_First, _Last, _Val, less<>()));
; 2656 : 	}
; 2657 : 
; 2658 : 		// TEMPLATE FUNCTION binary_search WITH PRED
; 2659 : template<class _FwdIt,
; 2660 : 	class _Ty,
; 2661 : 	class _Pr> inline
; 2662 : 	bool binary_search(_FwdIt _First, _FwdIt _Last,
; 2663 : 		const _Ty& _Val, _Pr _Pred)
; 2664 : 	{	// test if _Val equivalent to some element, using _Pred
; 2665 : 	_First = _STD lower_bound(_First, _Last, _Val, _Pred);
; 2666 : 	return (_First != _Last && !_Pred(_Val, *_First));
; 2667 : 	}
; 2668 : 
; 2669 : 		// TEMPLATE FUNCTION binary_search
; 2670 : template<class _FwdIt,
; 2671 : 	class _Ty> inline
; 2672 : 	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2673 : 	{	// test if _Val equivalent to some element, using operator<
; 2674 : 	return (_STD binary_search(_First, _Last, _Val, less<>()));
; 2675 : 	}
; 2676 : 
; 2677 : 		// TEMPLATE FUNCTION merge WITH PRED
; 2678 : template<class _InIt1,
; 2679 : 	class _InIt2,
; 2680 : 	class _OutIt,
; 2681 : 	class _Pr> inline
; 2682 : 	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
; 2683 : 		_InIt2 _First2, _InIt2 _Last2,
; 2684 : 		_OutIt _Dest, _Pr _Pred)
; 2685 : 	{	// copy merging ranges, both using _Pred
; 2686 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2687 : 		for (; ; )
; 2688 : 			{	// merge either first or second
; 2689 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2690 : 				{	// merge first
; 2691 : 				*_Dest++ = *_First2++;
; 2692 : 				if (_First2 == _Last2)
; 2693 : 					break;
; 2694 : 				}
; 2695 : 			else
; 2696 : 				{	// merge second
; 2697 : 				*_Dest++ = *_First1++;
; 2698 : 				if (_First1 == _Last1)
; 2699 : 					break;
; 2700 : 				}
; 2701 : 			}
; 2702 : 
; 2703 : 	_Dest = _Copy_impl(_First1, _Last1, _Dest);	// copy any tail
; 2704 : 	return (_Copy_impl(_First2, _Last2, _Dest));
; 2705 : 	}
; 2706 : 
; 2707 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2708 : template<class _InIt1,
; 2709 : 	class _InIt2,
; 2710 : 	class _OutIt,
; 2711 : 	class _Pr> inline
; 2712 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2713 : 		_InIt2 _First2, _InIt2 _Last2,
; 2714 : 		_OutIt _Dest, _Pr _Pred)
; 2715 : 	{	// copy merging ranges, both using _Pred
; 2716 : 	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
; 2717 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2718 : 		_Dest, _Pred));
; 2719 : 	}
; 2720 : 
; 2721 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2722 : template<class _InIt1,
; 2723 : 	class _InIt2,
; 2724 : 	class _OutIt,
; 2725 : 	class _Pr> inline
; 2726 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2727 : 		_InIt2 _First2, _InIt2 _Last2,
; 2728 : 		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
; 2729 : 		input_iterator_tag, _Mutable_iterator_tag)
; 2730 : 	{	// copy merging ranges, both using _Pred, arbitrary iterators
; 2731 : 	return (_Merge0(_First1, _Last1,
; 2732 : 		_First2, _Last2,
; 2733 : 		_Dest, _Pred));
; 2734 : 	}
; 2735 : 
; 2736 : template<class _InIt1,
; 2737 : 	class _InIt2,
; 2738 : 	class _OutIt,
; 2739 : 	class _Pr> inline
; 2740 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2741 : 		_InIt2 _First2, _InIt2 _Last2,
; 2742 : 		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
; 2743 : 		random_access_iterator_tag, random_access_iterator_tag)
; 2744 : 	{	// copy merging ranges, both using _Pred, random-access iterators
; 2745 : 	_OutIt _Ans = _Dest + (_Last1 - _First1)
; 2746 : 		+ (_Last2 - _First2);	// also checks range
; 2747 : 	_Merge0(_First1, _Last1,
; 2748 : 		_First2, _Last2,
; 2749 : 		_Dest, _Pred);
; 2750 : 	return (_Ans);
; 2751 : 	}
; 2752 : 
; 2753 : template<class _InIt1,
; 2754 : 	class _InIt2,
; 2755 : 	class _OutIt,
; 2756 : 	class _Pr> inline
; 2757 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2758 : 		_InIt2 _First2, _InIt2 _Last2,
; 2759 : 		_OutIt _Dest, _Pr _Pred, true_type)
; 2760 : 	{	// copy merging ranges, both using _Pred, checked dest
; 2761 : 	return (_Merge2(_First1, _Last1,
; 2762 : 		_First2, _Last2,
; 2763 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2764 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2765 : 	}
; 2766 : 
; 2767 : template<class _InIt1,
; 2768 : 	class _InIt2,
; 2769 : 	class _OutIt,
; 2770 : 	class _Pr> inline
; 2771 : _SCL_INSECURE_DEPRECATE
; 2772 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2773 : 		_InIt2 _First2, _InIt2 _Last2,
; 2774 : 		_OutIt _Dest, _Pr _Pred, false_type)
; 2775 : 	{	// copy merging ranges, both using _Pred, unchecked dest
; 2776 : 	return (_Merge2(_First1, _Last1,
; 2777 : 		_First2, _Last2,
; 2778 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2779 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2780 : 	}
; 2781 : 
; 2782 : template<class _InIt1,
; 2783 : 	class _InIt2,
; 2784 : 	class _OutIt,
; 2785 : 	class _Pr> inline
; 2786 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2787 : 		_InIt2 _First2, _InIt2 _Last2,
; 2788 : 		_OutIt _Dest, _Pr _Pred)
; 2789 : 	{	// copy merging ranges, both using _Pred
; 2790 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2791 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2792 : 	_DEBUG_POINTER(_Dest);
; 2793 : 	_DEBUG_POINTER(_Pred);
; 2794 : 	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
; 2795 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2796 : 		_Dest, _Pred, _Is_checked(_Dest)));
; 2797 : 	}
; 2798 : 
; 2799 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2800 : template<class _InIt1,
; 2801 : 	class _InIt2,
; 2802 : 	class _OutTy,
; 2803 : 	size_t _OutSize,
; 2804 : 	class _Pr> inline
; 2805 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InIt2 _First2, _InIt2 _Last2,
; 2807 : 		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
; 2808 : 	{	// copy merging ranges, both using _Pred, array dest
; 2809 : 	return (_Unchecked(
; 2810 : 		_STD merge(_First1, _Last1,
; 2811 : 			_First2, _Last2,
; 2812 : 			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
; 2813 : 	}
; 2814 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2815 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2816 : 
; 2817 : 		// TEMPLATE FUNCTION merge
; 2818 : template<class _InIt1,
; 2819 : 	class _InIt2,
; 2820 : 	class _OutIt> inline
; 2821 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2822 : 		_InIt2 _First2, _InIt2 _Last2,
; 2823 : 		_OutIt _Dest)
; 2824 : 	{	// copy merging ranges, both using operator<
; 2825 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2826 : 		less<>()));
; 2827 : 	}
; 2828 : 
; 2829 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2830 : template<class _InIt1,
; 2831 : 	class _InIt2,
; 2832 : 	class _OutTy,
; 2833 : 	size_t _OutSize> inline
; 2834 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2835 : 		_InIt2 _First2, _InIt2 _Last2,
; 2836 : 		_OutTy (&_Dest)[_OutSize])
; 2837 : 	{	// copy merging ranges, both using operator<, array dest
; 2838 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2839 : 		less<>()));
; 2840 : 	}
; 2841 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2842 : 
; 2843 : 		// TEMPLATE FUNCTION inplace_merge WITH PRED
; 2844 : template<class _BidIt1,
; 2845 : 	class _BidIt2,
; 2846 : 	class _BidIt3,
; 2847 : 	class _Pr> inline
; 2848 : 	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
; 2849 : 		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
; 2850 : 	{	// merge backwards to _Dest, using _Pred
; 2851 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2852 : 		for (; ; )
; 2853 : 			{	// merge either first or second
; 2854 : 			if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))
; 2855 : 				{	// merge first
; 2856 : 				*--_Dest = _Move(*_Last1);
; 2857 : 				++_Last2;
; 2858 : 				if (_First1 == _Last1)
; 2859 : 					break;
; 2860 : 				}
; 2861 : 			else
; 2862 : 				{	// merge second
; 2863 : 				*--_Dest = _Move(*_Last2);
; 2864 : 				++_Last1;
; 2865 : 				if (_First2 == _Last2)
; 2866 : 					break;
; 2867 : 				}
; 2868 : 			}
; 2869 : 
; 2870 : 	_Dest = _Move_backward(_First2, _Last2, _Dest);	// move any tail
; 2871 : 	return (_Move_backward(_First1, _Last1, _Dest));
; 2872 : 	}
; 2873 : 
; 2874 : template<class _InIt1,
; 2875 : 	class _InIt2,
; 2876 : 	class _OutIt,
; 2877 : 	class _Pr> inline
; 2878 : 	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
; 2879 : 		_InIt2 _First2, _InIt2 _Last2,
; 2880 : 		_OutIt _Dest, _Pr _Pred)
; 2881 : 	{	// move merging ranges, both using _Pred
; 2882 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2883 : 		for (; ; )
; 2884 : 			{	// merge either first or second
; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2886 : 				{	// merge first
; 2887 : 				*_Dest++ = _Move(*_First2++);
; 2888 : 				if (_First2 == _Last2)
; 2889 : 					break;
; 2890 : 				}
; 2891 : 			else
; 2892 : 				{	// merge second
; 2893 : 				*_Dest++ = _Move(*_First1++);
; 2894 : 				if (_First1 == _Last1)
; 2895 : 					break;
; 2896 : 				}
; 2897 : 			}
; 2898 : 
; 2899 : 	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail
; 2900 : 	return (_Move(_First2, _Last2, _Dest));
; 2901 : 	}
; 2902 : 
; 2903 : template<class _BidIt,
; 2904 : 	class _Diff,
; 2905 : 	class _Ty,
; 2906 : 	class _Pr> inline
; 2907 : 	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
; 2908 : 		_Diff _Count1, _Diff _Count2,
; 2909 : 			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
; 2910 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2911 : 	if (_Count1 == 0 || _Count2 == 0)
; 2912 : 		;	// do nothing
; 2913 : 	else if (_Count1 + _Count2 == 2)
; 2914 : 		{	// order two one-element partitions
; 2915 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 2916 : 			_STD iter_swap(_First, _Mid);
; 2917 : 		}
; 2918 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
; 2919 : 		{	// buffer left partition, then merge
; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());
; 2921 : 		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2922 : 			_Mid, _Last, _First, _Pred);
; 2923 : 		}
; 2924 : 	else if (_Count2 <= _Tempbuf._Maxlen())
; 2925 : 		{	// buffer right partition, then merge
; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());
; 2927 : 		_Merge_backward(_First, _Mid,
; 2928 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
; 2929 : 		}
; 2930 : 	else
; 2931 : 		{	// buffer too small, divide and conquer
; 2932 : 		_BidIt _Firstn, _Lastn;
; 2933 : 		_Diff _Count1n, _Count2n;
; 2934 : 		if (_Count2 < _Count1)
; 2935 : 			{	// left larger, cut it in half and partition right to match
; 2936 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2937 : 			_Firstn = _First;
; 2938 : 			_STD advance(_Firstn, _Count1n);
; 2939 : 			_Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);
; 2940 : 			_Distance(_Mid, _Lastn, _Count2n);
; 2941 : 			}
; 2942 : 		else
; 2943 : 			{	// right larger, cut it in half and partition left to match
; 2944 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2945 : 			_Lastn = _Mid;
; 2946 : 			_STD advance(_Lastn, _Count2n);
; 2947 : 			_Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);
; 2948 : 			_Distance(_First, _Firstn, _Count1n);
; 2949 : 			}
; 2950 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2951 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle
; 2952 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2953 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part
; 2954 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2955 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
; 2956 : 		}
; 2957 : 	}
; 2958 : 
; 2959 : template<class _BidIt,
; 2960 : 	class _Diff,
; 2961 : 	class _Ty,
; 2962 : 	class _Pr> inline
; 2963 : 	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
; 2964 : 		_Diff *, _Ty *)
; 2965 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2966 : 	_Diff _Count1 = 0;
; 2967 : 	_Distance(_First, _Mid, _Count1);
; 2968 : 	_Diff _Count2 = 0;
; 2969 : 	_Distance(_Mid, _Last, _Count2);
; 2970 : 	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
; 2971 : 	_Buffered_merge(_First, _Mid, _Last,
; 2972 : 		_Count1, _Count2, _Tempbuf, _Pred);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _BidIt,
; 2976 : 	class _Pr> inline
; 2977 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
; 2978 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2979 : 	_DEBUG_ORDER_PRED(_First, _Mid, _Pred);
; 2980 : 	_DEBUG_ORDER_PRED(_Mid, _Last, _Pred);
; 2981 : 	if (_First != _Mid && _Mid != _Last)
; 2982 : 		_Inplace_merge(
; 2983 : 			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
; 2984 : 			_Dist_type(_First), _Val_type(_First));
; 2985 : 	}
; 2986 : 
; 2987 : 		// TEMPLATE FUNCTION inplace_merge
; 2988 : template<class _BidIt> inline
; 2989 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
; 2990 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
; 2991 : 	_STD inplace_merge(_First, _Mid, _Last, less<>());
; 2992 : 	}
; 2993 : 
; 2994 : 		// TEMPLATE FUNCTION sort WITH PRED
; 2995 : template<class _BidIt,
; 2996 : 	class _Pr,
; 2997 : 	class _Ty> inline
; 2998 : 	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
; 2999 : 	{	// insertion sort [_First, _Last), using _Pred
; 3000 : 	if (_First != _Last)
; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )
; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);
; 3005 : 
; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))
; 3007 : 				{	// found new earliest element, move to front
; 3008 : 				_Move_backward(_First, _Next, ++_Next1);
; 3009 : 				*_First = _Move(_Val);
; 3010 : 				}
; 3011 : 			else
; 3012 : 				{	// look for insertion point after first
; 3013 : 				for (_BidIt _First1 = _Next1;
; 3014 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3015 : 					_Next1 = _First1)
; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down
; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole
; 3018 : 				}
; 3019 : 			}
; 3020 : 	}
; 3021 : 
; 3022 : template<class _BidIt,
; 3023 : 	class _Pr> inline
; 3024 : 	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
; 3025 : 	{	// insertion sort [_First, _Last), using _Pred
; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00092	6a 00		 push	 0
  00094	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAU?$pair@MJ@std@@U?$less@X@2@U12@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@0@Z ; std::_Insertion_sort1<std::pair<float,long> *,std::less<void>,std::pair<float,long> >
  0009e	83 c4 10	 add	 esp, 16			; 00000010H
$LN27@Sort:
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN6@Sort:

; 3139 : 			}
; 3140 : 		}
; 3141 : 
; 3142 : 	if (_ISORT_MAX < _Count)

  000a8	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ab	7e e0		 jle	 SHORT $LN3@Sort

; 2459 : 	if (1 < _Last - _First)

  000ad	8b c6		 mov	 eax, esi
  000af	2b c7		 sub	 eax, edi
  000b1	83 e0 f8	 and	 eax, -8			; fffffff8H
  000b4	83 f8 08	 cmp	 eax, 8
  000b7	7e 11		 jle	 SHORT $LN10@Sort

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c0	56		 push	 esi
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 ??$_Make_heap@PAU?$pair@MJ@std@@HU12@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@PAH0@Z ; std::_Make_heap<std::pair<float,long> *,int,std::pair<float,long>,std::less<void> >
  000c7	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@Sort:

; 2462 : 	}
; 2463 : 
; 2464 : 		// TEMPLATE FUNCTION make_heap
; 2465 : template<class _RanIt> inline
; 2466 : 	void make_heap(_RanIt _First, _RanIt _Last)
; 2467 : 	{	// make [_First, _Last) into a heap, using operator<
; 2468 : 	_STD make_heap(_First, _Last, less<>());
; 2469 : 	}
; 2470 : 
; 2471 : 		// TEMPLATE FUNCTION sort_heap WITH PRED
; 2472 : template<class _RanIt,
; 2473 : 	class _Pr> inline
; 2474 : 	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2475 : 	{	// order heap by repeatedly popping, using _Pred
; 2476 : 	for (; 1 < _Last - _First; --_Last)
; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}
; 2479 : 
; 2480 : template<class _RanIt,
; 2481 : 	class _Pr> inline
; 2482 : 	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2483 : 	{	// order heap by repeatedly popping, using _Pred
; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  000ca	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000cd	56		 push	 esi
  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 ??$_Sort_heap@PAU?$pair@MJ@std@@U?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0U?$less@X@0@@Z ; std::_Sort_heap<std::pair<float,long> *,std::less<void> >
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z ENDP ; std::_Sort<std::pair<float,long> *,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@YAPAU?$pair@MJ@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@YAPAU?$pair@MJ@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@YAPAU?$pair@MJ@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAEE@std@@YAPAEPAE0ABEU?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find@PAEE@std@@YAPAEPAE0ABEU?$integral_constant@_N$00@0@@Z PROC ; std::_Find<unsigned char *,unsigned char>, COMDAT

; 3013 : 	{	// find first byte matching integral _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2992 : 	return (_Val <= UCHAR_MAX);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]
  00008	3c ff		 cmp	 al, 255			; 000000ffH

; 3014 : 	if (!_Within_limits(_First, _Val))

  0000a	76 05		 jbe	 SHORT $LN1@Find

; 3015 : 		return (_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 3019 : 	}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN1@Find:

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  00011	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00019	8b cf		 mov	 ecx, edi
  0001b	2b ca		 sub	 ecx, edx
  0001d	0f b6 f0	 movzx	 esi, al
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00020	51		 push	 ecx
  00021	56		 push	 esi
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _memchr
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  0002b	85 c0		 test	 eax, eax
  0002d	0f 45 f8	 cmovne	 edi, eax
  00030	8b c7		 mov	 eax, edi
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 3019 : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Find@PAEE@std@@YAPAEPAE0ABEU?$integral_constant@_N$00@0@@Z ENDP ; std::_Find<unsigned char *,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::allocator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::TPatchDrawStruct>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::pair<float,long> *,std::pair<float,long> *,std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::allocator<std::pair<float,long> >,std::pair<float,long> >
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAU?$pair@MJ@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::pair<float,long> *,std::pair<float,long> *,std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber>,CArea::SCRCWithNumber>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@PAU12@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	2b f0		 sub	 esi, eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	03 c6		 add	 eax, esi
  0001b	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTPatchDrawStruct@CMapOutdoor@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTPatchDrawStruct@CMapOutdoor@@0@Z PROC ; std::_Ptr_cat<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UTPatchDrawStruct@CMapOutdoor@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUTPatchDrawStruct@CMapOutdoor@@0@Z ENDP ; std::_Ptr_cat<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@U?$pair@MJ@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@MJ@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U?$pair@MJ@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@MJ@0@0@Z PROC ; std::_Ptr_cat<std::pair<float,long>,std::pair<float,long> >, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@U?$pair@MJ@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@MJ@0@0@Z ENDP ; std::_Ptr_cat<std::pair<float,long>,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@USCRCWithNumber@CArea@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSCRCWithNumber@CArea@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@USCRCWithNumber@CArea@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSCRCWithNumber@CArea@@0@Z PROC ; std::_Ptr_cat<CArea::SCRCWithNumber,CArea::SCRCWithNumber>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@USCRCWithNumber@CArea@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSCRCWithNumber@CArea@@0@Z ENDP ; std::_Ptr_cat<CArea::SCRCWithNumber,CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGraphicThingInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicThingInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGraphicThingInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicThingInstance@@0@Z PROC ; std::_Ptr_cat<CGraphicThingInstance *,CGraphicThingInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGraphicThingInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicThingInstance@@0@Z ENDP ; std::_Ptr_cat<CGraphicThingInstance *,CGraphicThingInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned char> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z PROC ; std::_Ptr_cat<unsigned char,unsigned char>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z ENDP ; std::_Ptr_cat<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABUTPatchDrawStruct@CMapOutdoor@@@std@@YAABUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUTPatchDrawStruct@CMapOutdoor@@@std@@YAABUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z PROC ; std::forward<CMapOutdoor::TPatchDrawStruct const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUTPatchDrawStruct@CMapOutdoor@@@std@@YAABUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z ENDP ; std::forward<CMapOutdoor::TPatchDrawStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@AAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@AAU34@@Z PROC ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAXAAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@1@PAUTPatchDrawStruct@CMapOutdoor@@AAU34@@Z ENDP ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z PROC ; std::forward<CMapOutdoor::TPatchDrawStruct &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUTPatchDrawStruct@CMapOutdoor@@@std@@YAAAUTPatchDrawStruct@CMapOutdoor@@AAU12@@Z ENDP ; std::forward<CMapOutdoor::TPatchDrawStruct &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@MJ@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@MJ@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::pair<float,long> > >::construct<std::pair<float,long>,std::pair<float,long> >, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:
; File a:\vs\vc\include\xmemory0

; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U?$pair@MJ@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@MJ@std@@@1@PAU?$pair@MJ@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::pair<float,long> > >::construct<std::pair<float,long>,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@ABU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@ABU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USCRCWithNumber@CArea@@ABU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@USCRCWithNumber@CArea@@ABU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABUSCRCWithNumber@CArea@@@std@@YAABUSCRCWithNumber@CArea@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUSCRCWithNumber@CArea@@@std@@YAABUSCRCWithNumber@CArea@@ABU12@@Z PROC ; std::forward<CArea::SCRCWithNumber const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUSCRCWithNumber@CArea@@@std@@YAABUSCRCWithNumber@CArea@@ABU12@@Z ENDP ; std::forward<CArea::SCRCWithNumber const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@AAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@AAU34@@Z PROC ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@USCRCWithNumber@CArea@@AAU12@@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAXAAV?$allocator@USCRCWithNumber@CArea@@@1@PAUSCRCWithNumber@CArea@@AAU34@@Z ENDP ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAUSCRCWithNumber@CArea@@@std@@YAAAUSCRCWithNumber@CArea@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUSCRCWithNumber@CArea@@@std@@YAAAUSCRCWithNumber@CArea@@AAU12@@Z PROC ; std::forward<CArea::SCRCWithNumber &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUSCRCWithNumber@CArea@@@std@@YAAAUSCRCWithNumber@CArea@@AAU12@@Z ENDP ; std::forward<CArea::SCRCWithNumber &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@EABE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEABE@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@EABE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEABE@Z PROC ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@EABE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEABE@Z ENDP ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABE@std@@YAABEABE@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABE@std@@YAABEABE@Z PROC			; std::forward<unsigned char const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABE@std@@YAABEABE@Z ENDP			; std::forward<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@EAAE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEAAE@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@EAAE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEAAE@Z PROC ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@EAAE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAEAAE@Z ENDP ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAE@std@@YAAAEAAE@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAE@std@@YAAAEAAE@Z PROC			; std::forward<unsigned char &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAE@std@@YAAAEAAE@Z ENDP			; std::forward<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z PROC ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 3261 : 	{	// sort preserving order of equivalents, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  0002b	c1 f9 04	 sar	 ecx, 4
; File a:\vs\vc\include\xmemory

; 749  : 		_Buf._Begin = 0;

  0002e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Tempbuf$[ebp], 0

; 750  : 		_Buf._Current = 0;

  00035	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Tempbuf$[ebp+4], 0

; 751  : 		_Buf._Hiwater = 0;

  0003c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Tempbuf$[ebp+8], 0
; File a:\vs\vc\include\algorithm

; 3264 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

  00043	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00046	99		 cdq
  00047	2b c2		 sub	 eax, edx
  00049	d1 f8		 sar	 eax, 1
; File a:\vs\vc\include\xmemory

; 752  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

  0004b	89 45 ec	 mov	 DWORD PTR __Tempbuf$[ebp+12], eax

; 753  : 		_Pbuf = &_Buf;

  0004e	8d 45 e0	 lea	 eax, DWORD PTR __Tempbuf$[ebp]
  00051	89 45 f0	 mov	 DWORD PTR __Tempbuf$[ebp+16], eax
; File a:\vs\vc\include\algorithm

; 3265 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

  00054	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005e	50		 push	 eax
  0005f	51		 push	 ecx
  00060	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00063	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0HAAV?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@0@UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  0006b	8b 45 e0	 mov	 eax, DWORD PTR __Tempbuf$[ebp]
; File a:\vs\vc\include\algorithm

; 3265 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

  0006e	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\xmemory

; 767  : 		if (_Buf._Begin != 0)

  00071	85 c0		 test	 eax, eax
  00073	74 09		 je	 SHORT $LN20@Stable_sor

; 41   : 	operator delete(_Pbuf);

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007b	83 c4 04	 add	 esp, 4
$LN20@Stable_sor:
; File a:\vs\vc\include\algorithm

; 3266 : 	}

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Tempbuf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Temp_iterator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ ; std::_Temp_iterator<CMapOutdoor::TPatchDrawStruct>::~_Temp_iterator<CMapOutdoor::TPatchDrawStruct>
__ehhandler$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z ENDP ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > > >, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > > >, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUFRenderPCBlocker@@@std@@YA$$QAUFRenderPCBlocker@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUFRenderPCBlocker@@@std@@YA$$QAUFRenderPCBlocker@@AAU1@@Z PROC ; std::move<FRenderPCBlocker &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUFRenderPCBlocker@@@std@@YA$$QAUFRenderPCBlocker@@AAU1@@Z ENDP ; std::move<FRenderPCBlocker &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicObjectInstance@@UFRenderPCBlocker@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFRenderPCBlocker@@@Z
_TEXT	SEGMENT
tv176 = 8						; size = 4
__First$ = 8						; size = 4
_pInstance$1$ = 12					; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicObjectInstance@@UFRenderPCBlocker@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFRenderPCBlocker@@@Z PROC ; std::_For_each<CGraphicObjectInstance * *,FRenderPCBlocker>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	2b cf		 sub	 ecx, edi
  00011	83 c1 03	 add	 ecx, 3
  00014	c1 e9 02	 shr	 ecx, 2
  00017	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  0001a	0f 47 ca	 cmova	 ecx, edx
  0001d	89 4d 08	 mov	 DWORD PTR tv176[ebp], ecx

; 23   : 	for (; _First != _Last; ++_First)

  00020	85 c9		 test	 ecx, ecx
  00022	74 72		 je	 SHORT $LN1@For_each
  00024	53		 push	 ebx
$LL3@For_each:

; 24   : 		_Func(*_First);

  00025	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 321  : 		pInstance->Show();

  00027	8b cb		 mov	 ecx, ebx
; File a:\vs\vc\include\algorithm

; 24   : 		_Func(*_First);

  00029	89 5d 0c	 mov	 DWORD PTR _pInstance$1$[ebp], ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 321  : 		pInstance->Show();

  0002c	e8 00 00 00 00	 call	 ?Show@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Show

; 322  : 		CGraphicThingInstance* pThingInstance = dynamic_cast <CGraphicThingInstance*> (pInstance);

  00031	6a 00		 push	 0
  00033	68 00 00 00 00	 push	 OFFSET ??_R0?AVCGraphicThingInstance@@@8
  00038	68 00 00 00 00	 push	 OFFSET ??_R0?AVCGraphicObjectInstance@@@8
  0003d	6a 00		 push	 0
  0003f	53		 push	 ebx
  00040	e8 00 00 00 00	 call	 ___RTDynamicCast
  00045	8b d8		 mov	 ebx, eax
  00047	83 c4 14	 add	 esp, 20			; 00000014H

; 323  : 		if (pThingInstance != NULL)

  0004a	85 db		 test	 ebx, ebx
  0004c	74 25		 je	 SHORT $LN6@For_each

; 324  : 		{
; 325  : 			if (pThingInstance->HaveBlendThing())

  0004e	8b cb		 mov	 ecx, ebx
  00050	e8 00 00 00 00	 call	 ?HaveBlendThing@CGraphicThingInstance@@QAE_NXZ ; CGraphicThingInstance::HaveBlendThing
  00055	84 c0		 test	 al, al
  00057	74 1a		 je	 SHORT $LN6@For_each

; 326  : 			{
; 327  : 				STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  00059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005f	6a 01		 push	 1
  00061	6a 04		 push	 4
  00063	6a 01		 push	 1
  00065	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 328  : 				pThingInstance->BlendRender();

  0006a	8b cb		 mov	 ecx, ebx
  0006c	e8 00 00 00 00	 call	 ?BlendRender@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::BlendRender

; 329  : 				return;

  00071	eb 19		 jmp	 SHORT $LN2@For_each
$LN6@For_each:

; 330  : 			}
; 331  : 		}
; 332  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00079	6a 02		 push	 2
  0007b	6a 04		 push	 4
  0007d	6a 01		 push	 1
  0007f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 333  : 
; 334  : 		pInstance->RenderPCBlocker();

  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _pInstance$1$[ebp]
  00087	e8 00 00 00 00	 call	 ?RenderPCBlocker@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RenderPCBlocker
$LN2@For_each:
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  0008c	46		 inc	 esi
  0008d	83 c7 04	 add	 edi, 4
  00090	3b 75 08	 cmp	 esi, DWORD PTR tv176[ebp]
  00093	75 90		 jne	 SHORT $LL3@For_each
  00095	5b		 pop	 ebx
$LN1@For_each:
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi

; 25   : 	}

  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
??$_For_each@PAPAVCGraphicObjectInstance@@UFRenderPCBlocker@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFRenderPCBlocker@@@Z ENDP ; std::_For_each<CGraphicObjectInstance * *,FRenderPCBlocker>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUCMapOutdoor_FBlendThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FBlendThingInstanceRender@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCMapOutdoor_FBlendThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FBlendThingInstanceRender@@AAU1@@Z PROC ; std::move<CMapOutdoor_FBlendThingInstanceRender &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUCMapOutdoor_FBlendThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FBlendThingInstanceRender@@AAU1@@Z ENDP ; std::move<CMapOutdoor_FBlendThingInstanceRender &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FBlendThingInstanceRender@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FBlendThingInstanceRender@@@Z PROC ; std::_For_each<CGraphicThingInstance * *,CMapOutdoor_FBlendThingInstanceRender>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 0f		 je	 SHORT $LN1@For_each
$LL3@For_each:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 377  : 		pkThingInst->BlendRender();

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	e8 00 00 00 00	 call	 ?BlendRender@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::BlendRender
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	3b fb		 cmp	 edi, ebx
  0002f	75 f1		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 24   : 		_Func(*_First);
; 25   : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FBlendThingInstanceRender@@@Z ENDP ; std::_For_each<CGraphicThingInstance * *,CMapOutdoor_FBlendThingInstanceRender>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YA$$QAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YA$$QAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@AAV10@@Z PROC ; std::move<std::void_mem_fun_t<CGraphicObjectInstance> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YA$$QAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@AAV10@@Z ENDP ; std::move<std::void_mem_fun_t<CGraphicObjectInstance> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicObjectInstance@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicObjectInstance@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@@Z PROC ; std::_For_each<CGraphicObjectInstance * *,std::void_mem_fun_t<CGraphicObjectInstance> >, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 11		 je	 SHORT $LN1@For_each
$LL3@For_each:
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h

; 41   : 		{((_P->*_Ptr)()); }

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	3b fb		 cmp	 edi, ebx
  00031	75 ef		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 24   : 		_Func(*_First);
; 25   : 	}

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$_For_each@PAPAVCGraphicObjectInstance@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@@Z ENDP ; std::_For_each<CGraphicObjectInstance * *,std::void_mem_fun_t<CGraphicObjectInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FOpaqueThingInstanceRender@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FOpaqueThingInstanceRender@@AAU1@@Z PROC ; std::move<CMapOutdoor_FOpaqueThingInstanceRender &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA$$QAUCMapOutdoor_FOpaqueThingInstanceRender@@AAU1@@Z ENDP ; std::move<CMapOutdoor_FOpaqueThingInstanceRender &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FOpaqueThingInstanceRender@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FOpaqueThingInstanceRender@@@Z PROC ; std::_For_each<CGraphicThingInstance * *,CMapOutdoor_FOpaqueThingInstanceRender>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 0f		 je	 SHORT $LN1@For_each
$LL3@For_each:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 370  : 		pkThingInst->Render();

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	3b fb		 cmp	 edi, ebx
  0002f	75 f1		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 24   : 		_Func(*_First);
; 25   : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_For_each@PAPAVCGraphicThingInstance@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YAXPAPAVCGraphicThingInstance@@0AAUCMapOutdoor_FOpaqueThingInstanceRender@@@Z ENDP ; std::_For_each<CGraphicThingInstance * *,CMapOutdoor_FOpaqueThingInstanceRender>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__Mid$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 3122 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3123 : 	_Diff _Count;
; 3124 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00011	2b c7		 sub	 eax, edi
  00013	c1 f8 02	 sar	 eax, 2
  00016	83 f8 20	 cmp	 eax, 32			; 00000020H
  00019	7e 72		 jle	 SHORT $LN3@Sort
  0001b	8b 5d 10	 mov	 ebx, DWORD PTR __Ideal$[ebp]
  0001e	8b ff		 npad	 2
$LL7@Sort:
  00020	85 db		 test	 ebx, ebx
  00022	0f 8e 80 00 00
	00		 jle	 $LN6@Sort

; 3125 : 		{	// divide and conquer by quicksort
; 3126 : 		pair<_RanIt, _RanIt> _Mid =
; 3127 : 			_Unguarded_partition(_First, _Last, _Pred);

  00028	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0002b	8d 45 f8	 lea	 eax, DWORD PTR __Mid$1[ebp]
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCGraphicThingInstance@@PAPAV1@@0@PAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Unguarded_partition<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 3128 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

  00036	8b c3		 mov	 eax, ebx
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	99		 cdq

; 3129 : 
; 3130 : 		if (_Mid.first - _First < _Last - _Mid.second)

  0003c	8b ce		 mov	 ecx, esi
  0003e	2b c2		 sub	 eax, edx
  00040	8b d8		 mov	 ebx, eax

; 3131 : 			{	// loop on second half
; 3132 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  00042	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00045	d1 fb		 sar	 ebx, 1
  00047	8b c3		 mov	 eax, ebx
  00049	99		 cdq
  0004a	2b c2		 sub	 eax, edx
  0004c	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1[ebp+4]
  0004f	d1 f8		 sar	 eax, 1
  00051	2b ca		 sub	 ecx, edx
  00053	03 d8		 add	 ebx, eax
  00055	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00058	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0005b	2b c7		 sub	 eax, edi
  0005d	83 e0 fc	 and	 eax, -4			; fffffffcH
  00060	53		 push	 ebx
  00061	3b c1		 cmp	 eax, ecx
  00063	7d 0f		 jge	 SHORT $LN5@Sort
  00065	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  00068	50		 push	 eax
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 3133 : 			_First = _Mid.second;

  0006f	8b 7d fc	 mov	 edi, DWORD PTR __Mid$1[ebp+4]

; 3134 : 			}
; 3135 : 		else

  00072	eb 0a		 jmp	 SHORT $LN34@Sort
$LN5@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  00074	56		 push	 esi
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 3138 : 			_Last = _Mid.first;

  0007b	8b 75 f8	 mov	 esi, DWORD PTR __Mid$1[ebp]
$LN34@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0007e	8b c6		 mov	 eax, esi
  00080	83 c4 10	 add	 esp, 16			; 00000010H
  00083	2b c7		 sub	 eax, edi
  00085	c1 f8 02	 sar	 eax, 2
  00088	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008b	7f 93		 jg	 SHORT $LL7@Sort
$LN3@Sort:

; 3143 : 		{	// heap sort if too many divisions
; 3144 : 		_STD make_heap(_First, _Last, _Pred);
; 3145 : 		_STD sort_heap(_First, _Last, _Pred);
; 3146 : 		}
; 3147 : 	else if (1 < _Count)

  0008d	83 f8 01	 cmp	 eax, 1
  00090	7e 0f		 jle	 SHORT $LN27@Sort

; 2488 : 	}
; 2489 : 
; 2490 : 		// TEMPLATE FUNCTION sort_heap
; 2491 : template<class _RanIt> inline
; 2492 : 	void sort_heap(_RanIt _First, _RanIt _Last)
; 2493 : 	{	// order heap by repeatedly popping, using operator<
; 2494 : 	_STD sort_heap(_First, _Last, less<>());
; 2495 : 	}
; 2496 : 
; 2497 : 		// TEMPLATE FUNCTION lower_bound WITH PRED
; 2498 : template<class _FwdIt,
; 2499 : 	class _Ty,
; 2500 : 	class _Diff,
; 2501 : 	class _Pr> inline
; 2502 : 	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
; 2503 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2504 : 	{	// find first element not before _Val, using _Pred
; 2505 : 	_Diff _Count = 0;
; 2506 : 	_Distance(_First, _Last, _Count);
; 2507 : 
; 2508 : 	while (0 < _Count)
; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;
; 2511 : 		_FwdIt _Mid = _First;
; 2512 : 		_STD advance(_Mid, _Count2);
; 2513 : 
; 2514 : 		if (_Pred(*_Mid, _Val))
; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;
; 2519 : 			}
; 2520 : 		else
; 2521 : 			_Count = _Count2;
; 2522 : 		}
; 2523 : 	return (_First);
; 2524 : 	}
; 2525 : 
; 2526 : template<class _FwdIt,
; 2527 : 	class _Ty,
; 2528 : 	class _Pr> inline
; 2529 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
; 2530 : 		const _Ty& _Val, _Pr _Pred)
; 2531 : 	{	// find first element not before _Val, using _Pred
; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));
; 2536 : 	}
; 2537 : 
; 2538 : 		// TEMPLATE FUNCTION lower_bound
; 2539 : template<class _FwdIt,
; 2540 : 	class _Ty> inline
; 2541 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2542 : 	{	// find first element not before _Val, using operator<
; 2543 : 	return (_STD lower_bound(_First, _Last, _Val, less<>()));
; 2544 : 	}
; 2545 : 
; 2546 : 		// TEMPLATE FUNCTION upper_bound WITH PRED
; 2547 : template<class _FwdIt,
; 2548 : 	class _Ty,
; 2549 : 	class _Diff,
; 2550 : 	class _Pr> inline
; 2551 : 	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
; 2552 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2553 : 	{	// find first element that _Val is before, using _Pred
; 2554 : 	_Diff _Count = 0;
; 2555 : 	_Distance(_First, _Last, _Count);
; 2556 : 
; 2557 : 	while (0 < _Count)
; 2558 : 		{	// divide and conquer, find half that contains answer
; 2559 : 		_Diff _Count2 = _Count / 2;
; 2560 : 		_FwdIt _Mid = _First;
; 2561 : 		_STD advance(_Mid, _Count2);
; 2562 : 
; 2563 : 		if (!_Pred(_Val, *_Mid))
; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;
; 2567 : 			_Count -= _Count2 + 1;
; 2568 : 			}
; 2569 : 		else
; 2570 : 			_Count = _Count2;
; 2571 : 		}
; 2572 : 	return (_First);
; 2573 : 	}
; 2574 : 
; 2575 : template<class _FwdIt,
; 2576 : 	class _Ty,
; 2577 : 	class _Pr> inline
; 2578 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
; 2579 : 		const _Ty& _Val, _Pr _Pred)
; 2580 : 	{	// find first element that _Val is before, using _Pred
; 2581 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2582 : 	return (_Rechecked(_First,
; 2583 : 		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2584 : 			_Dist_type(_First))));
; 2585 : 	}
; 2586 : 
; 2587 : 		// TEMPLATE FUNCTION upper_bound
; 2588 : template<class _FwdIt,
; 2589 : 	class _Ty> inline
; 2590 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2591 : 	{	// find first element that _Val is before, using operator<
; 2592 : 	return (_STD upper_bound(_First, _Last, _Val, less<>()));
; 2593 : 	}
; 2594 : 
; 2595 : 		// TEMPLATE FUNCTION equal_range WITH PRED
; 2596 : template<class _FwdIt,
; 2597 : 	class _Ty,
; 2598 : 	class _Diff,
; 2599 : 	class _Pr> inline
; 2600 : 	pair<_FwdIt, _FwdIt>
; 2601 : 		_Equal_range(_FwdIt _First, _FwdIt _Last,
; 2602 : 			const _Ty& _Val, _Pr _Pred, _Diff *)
; 2603 : 	{	// find range equivalent to _Val, using _Pred
; 2604 : 	_Diff _Count = 0;
; 2605 : 	_Distance(_First, _Last, _Count);
; 2606 : 
; 2607 : 	while (0 < _Count)
; 2608 : 		{	// divide and conquer, check midpoint
; 2609 : 		_Diff _Count2 = _Count / 2;
; 2610 : 		_FwdIt _Mid = _First;
; 2611 : 		_STD advance(_Mid, _Count2);
; 2612 : 
; 2613 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2614 : 			{	// range begins above _Mid, loop
; 2615 : 			_First = ++_Mid;
; 2616 : 			_Count -= _Count2 + 1;
; 2617 : 			}
; 2618 : 		else if (_Pred(_Val, *_Mid))
; 2619 : 			_Count = _Count2;	// range in first half, loop
; 2620 : 		else
; 2621 : 			{	// range straddles _Mid, find each end and return
; 2622 : 			_FwdIt _First2 = _STD lower_bound(_First, _Mid, _Val, _Pred);
; 2623 : 			_STD advance(_First, _Count);
; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);
; 2625 : 			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
; 2626 : 			}
; 2627 : 		}
; 2628 : 
; 2629 : 	return (pair<_FwdIt, _FwdIt>(_First, _First));	// empty range
; 2630 : 	}
; 2631 : 
; 2632 : template<class _FwdIt,
; 2633 : 	class _Ty,
; 2634 : 	class _Pr> inline
; 2635 : 	pair<_FwdIt, _FwdIt>
; 2636 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2637 : 			const _Ty& _Val, _Pr _Pred)
; 2638 : 	{	// find range equivalent to _Val, using _Pred
; 2639 : 	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2640 : 	pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
; 2641 : 		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
; 2642 : 			_Val, _Pred, _Dist_type(_First)));
; 2643 : 	return (pair<_FwdIt, _FwdIt>(
; 2644 : 		_Rechecked(_First, _Ans.first),
; 2645 : 		_Rechecked(_Last, _Ans.second)));
; 2646 : 	}
; 2647 : 
; 2648 : 		// TEMPLATE FUNCTION equal_range
; 2649 : template<class _FwdIt,
; 2650 : 	class _Ty> inline
; 2651 : 	pair<_FwdIt, _FwdIt>
; 2652 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2653 : 			const _Ty& _Val)
; 2654 : 	{	// find range equivalent to _Val, using operator<
; 2655 : 	return (_STD equal_range(_First, _Last, _Val, less<>()));
; 2656 : 	}
; 2657 : 
; 2658 : 		// TEMPLATE FUNCTION binary_search WITH PRED
; 2659 : template<class _FwdIt,
; 2660 : 	class _Ty,
; 2661 : 	class _Pr> inline
; 2662 : 	bool binary_search(_FwdIt _First, _FwdIt _Last,
; 2663 : 		const _Ty& _Val, _Pr _Pred)
; 2664 : 	{	// test if _Val equivalent to some element, using _Pred
; 2665 : 	_First = _STD lower_bound(_First, _Last, _Val, _Pred);
; 2666 : 	return (_First != _Last && !_Pred(_Val, *_First));
; 2667 : 	}
; 2668 : 
; 2669 : 		// TEMPLATE FUNCTION binary_search
; 2670 : template<class _FwdIt,
; 2671 : 	class _Ty> inline
; 2672 : 	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2673 : 	{	// test if _Val equivalent to some element, using operator<
; 2674 : 	return (_STD binary_search(_First, _Last, _Val, less<>()));
; 2675 : 	}
; 2676 : 
; 2677 : 		// TEMPLATE FUNCTION merge WITH PRED
; 2678 : template<class _InIt1,
; 2679 : 	class _InIt2,
; 2680 : 	class _OutIt,
; 2681 : 	class _Pr> inline
; 2682 : 	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
; 2683 : 		_InIt2 _First2, _InIt2 _Last2,
; 2684 : 		_OutIt _Dest, _Pr _Pred)
; 2685 : 	{	// copy merging ranges, both using _Pred
; 2686 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2687 : 		for (; ; )
; 2688 : 			{	// merge either first or second
; 2689 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2690 : 				{	// merge first
; 2691 : 				*_Dest++ = *_First2++;
; 2692 : 				if (_First2 == _Last2)
; 2693 : 					break;
; 2694 : 				}
; 2695 : 			else
; 2696 : 				{	// merge second
; 2697 : 				*_Dest++ = *_First1++;
; 2698 : 				if (_First1 == _Last1)
; 2699 : 					break;
; 2700 : 				}
; 2701 : 			}
; 2702 : 
; 2703 : 	_Dest = _Copy_impl(_First1, _Last1, _Dest);	// copy any tail
; 2704 : 	return (_Copy_impl(_First2, _Last2, _Dest));
; 2705 : 	}
; 2706 : 
; 2707 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2708 : template<class _InIt1,
; 2709 : 	class _InIt2,
; 2710 : 	class _OutIt,
; 2711 : 	class _Pr> inline
; 2712 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2713 : 		_InIt2 _First2, _InIt2 _Last2,
; 2714 : 		_OutIt _Dest, _Pr _Pred)
; 2715 : 	{	// copy merging ranges, both using _Pred
; 2716 : 	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
; 2717 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2718 : 		_Dest, _Pred));
; 2719 : 	}
; 2720 : 
; 2721 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2722 : template<class _InIt1,
; 2723 : 	class _InIt2,
; 2724 : 	class _OutIt,
; 2725 : 	class _Pr> inline
; 2726 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2727 : 		_InIt2 _First2, _InIt2 _Last2,
; 2728 : 		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
; 2729 : 		input_iterator_tag, _Mutable_iterator_tag)
; 2730 : 	{	// copy merging ranges, both using _Pred, arbitrary iterators
; 2731 : 	return (_Merge0(_First1, _Last1,
; 2732 : 		_First2, _Last2,
; 2733 : 		_Dest, _Pred));
; 2734 : 	}
; 2735 : 
; 2736 : template<class _InIt1,
; 2737 : 	class _InIt2,
; 2738 : 	class _OutIt,
; 2739 : 	class _Pr> inline
; 2740 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2741 : 		_InIt2 _First2, _InIt2 _Last2,
; 2742 : 		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
; 2743 : 		random_access_iterator_tag, random_access_iterator_tag)
; 2744 : 	{	// copy merging ranges, both using _Pred, random-access iterators
; 2745 : 	_OutIt _Ans = _Dest + (_Last1 - _First1)
; 2746 : 		+ (_Last2 - _First2);	// also checks range
; 2747 : 	_Merge0(_First1, _Last1,
; 2748 : 		_First2, _Last2,
; 2749 : 		_Dest, _Pred);
; 2750 : 	return (_Ans);
; 2751 : 	}
; 2752 : 
; 2753 : template<class _InIt1,
; 2754 : 	class _InIt2,
; 2755 : 	class _OutIt,
; 2756 : 	class _Pr> inline
; 2757 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2758 : 		_InIt2 _First2, _InIt2 _Last2,
; 2759 : 		_OutIt _Dest, _Pr _Pred, true_type)
; 2760 : 	{	// copy merging ranges, both using _Pred, checked dest
; 2761 : 	return (_Merge2(_First1, _Last1,
; 2762 : 		_First2, _Last2,
; 2763 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2764 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2765 : 	}
; 2766 : 
; 2767 : template<class _InIt1,
; 2768 : 	class _InIt2,
; 2769 : 	class _OutIt,
; 2770 : 	class _Pr> inline
; 2771 : _SCL_INSECURE_DEPRECATE
; 2772 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2773 : 		_InIt2 _First2, _InIt2 _Last2,
; 2774 : 		_OutIt _Dest, _Pr _Pred, false_type)
; 2775 : 	{	// copy merging ranges, both using _Pred, unchecked dest
; 2776 : 	return (_Merge2(_First1, _Last1,
; 2777 : 		_First2, _Last2,
; 2778 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2779 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2780 : 	}
; 2781 : 
; 2782 : template<class _InIt1,
; 2783 : 	class _InIt2,
; 2784 : 	class _OutIt,
; 2785 : 	class _Pr> inline
; 2786 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2787 : 		_InIt2 _First2, _InIt2 _Last2,
; 2788 : 		_OutIt _Dest, _Pr _Pred)
; 2789 : 	{	// copy merging ranges, both using _Pred
; 2790 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2791 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2792 : 	_DEBUG_POINTER(_Dest);
; 2793 : 	_DEBUG_POINTER(_Pred);
; 2794 : 	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
; 2795 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2796 : 		_Dest, _Pred, _Is_checked(_Dest)));
; 2797 : 	}
; 2798 : 
; 2799 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2800 : template<class _InIt1,
; 2801 : 	class _InIt2,
; 2802 : 	class _OutTy,
; 2803 : 	size_t _OutSize,
; 2804 : 	class _Pr> inline
; 2805 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InIt2 _First2, _InIt2 _Last2,
; 2807 : 		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
; 2808 : 	{	// copy merging ranges, both using _Pred, array dest
; 2809 : 	return (_Unchecked(
; 2810 : 		_STD merge(_First1, _Last1,
; 2811 : 			_First2, _Last2,
; 2812 : 			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
; 2813 : 	}
; 2814 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2815 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2816 : 
; 2817 : 		// TEMPLATE FUNCTION merge
; 2818 : template<class _InIt1,
; 2819 : 	class _InIt2,
; 2820 : 	class _OutIt> inline
; 2821 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2822 : 		_InIt2 _First2, _InIt2 _Last2,
; 2823 : 		_OutIt _Dest)
; 2824 : 	{	// copy merging ranges, both using operator<
; 2825 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2826 : 		less<>()));
; 2827 : 	}
; 2828 : 
; 2829 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2830 : template<class _InIt1,
; 2831 : 	class _InIt2,
; 2832 : 	class _OutTy,
; 2833 : 	size_t _OutSize> inline
; 2834 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2835 : 		_InIt2 _First2, _InIt2 _Last2,
; 2836 : 		_OutTy (&_Dest)[_OutSize])
; 2837 : 	{	// copy merging ranges, both using operator<, array dest
; 2838 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2839 : 		less<>()));
; 2840 : 	}
; 2841 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2842 : 
; 2843 : 		// TEMPLATE FUNCTION inplace_merge WITH PRED
; 2844 : template<class _BidIt1,
; 2845 : 	class _BidIt2,
; 2846 : 	class _BidIt3,
; 2847 : 	class _Pr> inline
; 2848 : 	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
; 2849 : 		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
; 2850 : 	{	// merge backwards to _Dest, using _Pred
; 2851 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2852 : 		for (; ; )
; 2853 : 			{	// merge either first or second
; 2854 : 			if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))
; 2855 : 				{	// merge first
; 2856 : 				*--_Dest = _Move(*_Last1);
; 2857 : 				++_Last2;
; 2858 : 				if (_First1 == _Last1)
; 2859 : 					break;
; 2860 : 				}
; 2861 : 			else
; 2862 : 				{	// merge second
; 2863 : 				*--_Dest = _Move(*_Last2);
; 2864 : 				++_Last1;
; 2865 : 				if (_First2 == _Last2)
; 2866 : 					break;
; 2867 : 				}
; 2868 : 			}
; 2869 : 
; 2870 : 	_Dest = _Move_backward(_First2, _Last2, _Dest);	// move any tail
; 2871 : 	return (_Move_backward(_First1, _Last1, _Dest));
; 2872 : 	}
; 2873 : 
; 2874 : template<class _InIt1,
; 2875 : 	class _InIt2,
; 2876 : 	class _OutIt,
; 2877 : 	class _Pr> inline
; 2878 : 	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
; 2879 : 		_InIt2 _First2, _InIt2 _Last2,
; 2880 : 		_OutIt _Dest, _Pr _Pred)
; 2881 : 	{	// move merging ranges, both using _Pred
; 2882 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2883 : 		for (; ; )
; 2884 : 			{	// merge either first or second
; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2886 : 				{	// merge first
; 2887 : 				*_Dest++ = _Move(*_First2++);
; 2888 : 				if (_First2 == _Last2)
; 2889 : 					break;
; 2890 : 				}
; 2891 : 			else
; 2892 : 				{	// merge second
; 2893 : 				*_Dest++ = _Move(*_First1++);
; 2894 : 				if (_First1 == _Last1)
; 2895 : 					break;
; 2896 : 				}
; 2897 : 			}
; 2898 : 
; 2899 : 	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail
; 2900 : 	return (_Move(_First2, _Last2, _Dest));
; 2901 : 	}
; 2902 : 
; 2903 : template<class _BidIt,
; 2904 : 	class _Diff,
; 2905 : 	class _Ty,
; 2906 : 	class _Pr> inline
; 2907 : 	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
; 2908 : 		_Diff _Count1, _Diff _Count2,
; 2909 : 			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
; 2910 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2911 : 	if (_Count1 == 0 || _Count2 == 0)
; 2912 : 		;	// do nothing
; 2913 : 	else if (_Count1 + _Count2 == 2)
; 2914 : 		{	// order two one-element partitions
; 2915 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 2916 : 			_STD iter_swap(_First, _Mid);
; 2917 : 		}
; 2918 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
; 2919 : 		{	// buffer left partition, then merge
; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());
; 2921 : 		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2922 : 			_Mid, _Last, _First, _Pred);
; 2923 : 		}
; 2924 : 	else if (_Count2 <= _Tempbuf._Maxlen())
; 2925 : 		{	// buffer right partition, then merge
; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());
; 2927 : 		_Merge_backward(_First, _Mid,
; 2928 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
; 2929 : 		}
; 2930 : 	else
; 2931 : 		{	// buffer too small, divide and conquer
; 2932 : 		_BidIt _Firstn, _Lastn;
; 2933 : 		_Diff _Count1n, _Count2n;
; 2934 : 		if (_Count2 < _Count1)
; 2935 : 			{	// left larger, cut it in half and partition right to match
; 2936 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2937 : 			_Firstn = _First;
; 2938 : 			_STD advance(_Firstn, _Count1n);
; 2939 : 			_Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);
; 2940 : 			_Distance(_Mid, _Lastn, _Count2n);
; 2941 : 			}
; 2942 : 		else
; 2943 : 			{	// right larger, cut it in half and partition left to match
; 2944 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2945 : 			_Lastn = _Mid;
; 2946 : 			_STD advance(_Lastn, _Count2n);
; 2947 : 			_Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);
; 2948 : 			_Distance(_First, _Firstn, _Count1n);
; 2949 : 			}
; 2950 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2951 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle
; 2952 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2953 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part
; 2954 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2955 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
; 2956 : 		}
; 2957 : 	}
; 2958 : 
; 2959 : template<class _BidIt,
; 2960 : 	class _Diff,
; 2961 : 	class _Ty,
; 2962 : 	class _Pr> inline
; 2963 : 	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
; 2964 : 		_Diff *, _Ty *)
; 2965 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2966 : 	_Diff _Count1 = 0;
; 2967 : 	_Distance(_First, _Mid, _Count1);
; 2968 : 	_Diff _Count2 = 0;
; 2969 : 	_Distance(_Mid, _Last, _Count2);
; 2970 : 	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
; 2971 : 	_Buffered_merge(_First, _Mid, _Last,
; 2972 : 		_Count1, _Count2, _Tempbuf, _Pred);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _BidIt,
; 2976 : 	class _Pr> inline
; 2977 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
; 2978 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2979 : 	_DEBUG_ORDER_PRED(_First, _Mid, _Pred);
; 2980 : 	_DEBUG_ORDER_PRED(_Mid, _Last, _Pred);
; 2981 : 	if (_First != _Mid && _Mid != _Last)
; 2982 : 		_Inplace_merge(
; 2983 : 			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
; 2984 : 			_Dist_type(_First), _Val_type(_First));
; 2985 : 	}
; 2986 : 
; 2987 : 		// TEMPLATE FUNCTION inplace_merge
; 2988 : template<class _BidIt> inline
; 2989 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
; 2990 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
; 2991 : 	_STD inplace_merge(_First, _Mid, _Last, less<>());
; 2992 : 	}
; 2993 : 
; 2994 : 		// TEMPLATE FUNCTION sort WITH PRED
; 2995 : template<class _BidIt,
; 2996 : 	class _Pr,
; 2997 : 	class _Ty> inline
; 2998 : 	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
; 2999 : 	{	// insertion sort [_First, _Last), using _Pred
; 3000 : 	if (_First != _Last)
; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )
; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);
; 3005 : 
; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))
; 3007 : 				{	// found new earliest element, move to front
; 3008 : 				_Move_backward(_First, _Next, ++_Next1);
; 3009 : 				*_First = _Move(_Val);
; 3010 : 				}
; 3011 : 			else
; 3012 : 				{	// look for insertion point after first
; 3013 : 				for (_BidIt _First1 = _Next1;
; 3014 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3015 : 					_Next1 = _First1)
; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down
; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole
; 3018 : 				}
; 3019 : 			}
; 3020 : 	}
; 3021 : 
; 3022 : template<class _BidIt,
; 3023 : 	class _Pr> inline
; 3024 : 	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
; 3025 : 	{	// insertion sort [_First, _Last), using _Pred
; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00092	6a 00		 push	 0
  00094	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAV1@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@0@Z ; std::_Insertion_sort1<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder,CGraphicThingInstance *>
  0009e	83 c4 10	 add	 esp, 16			; 00000010H
$LN27@Sort:
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN6@Sort:

; 3139 : 			}
; 3140 : 		}
; 3141 : 
; 3142 : 	if (_ISORT_MAX < _Count)

  000a8	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ab	7e e0		 jle	 SHORT $LN3@Sort

; 2459 : 	if (1 < _Last - _First)

  000ad	8b c6		 mov	 eax, esi
  000af	2b c7		 sub	 eax, edi
  000b1	83 e0 fc	 and	 eax, -4			; fffffffcH
  000b4	83 f8 04	 cmp	 eax, 4
  000b7	7e 11		 jle	 SHORT $LN10@Sort

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c0	56		 push	 esi
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 ??$_Make_heap@PAPAVCGraphicThingInstance@@HPAV1@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@PAH0@Z ; std::_Make_heap<CGraphicThingInstance * *,int,CGraphicThingInstance *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  000c7	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@Sort:

; 2462 : 	}
; 2463 : 
; 2464 : 		// TEMPLATE FUNCTION make_heap
; 2465 : template<class _RanIt> inline
; 2466 : 	void make_heap(_RanIt _First, _RanIt _Last)
; 2467 : 	{	// make [_First, _Last) into a heap, using operator<
; 2468 : 	_STD make_heap(_First, _Last, less<>());
; 2469 : 	}
; 2470 : 
; 2471 : 		// TEMPLATE FUNCTION sort_heap WITH PRED
; 2472 : template<class _RanIt,
; 2473 : 	class _Pr> inline
; 2474 : 	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2475 : 	{	// order heap by repeatedly popping, using _Pred
; 2476 : 	for (; 1 < _Last - _First; --_Last)
; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}
; 2479 : 
; 2480 : template<class _RanIt,
; 2481 : 	class _Pr> inline
; 2482 : 	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2483 : 	{	// order heap by repeatedly popping, using _Pred
; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  000ca	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000cd	56		 push	 esi
  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 ??$_Sort_heap@PAPAVCGraphicThingInstance@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort_heap<CGraphicThingInstance * *,CMapOutdoor_LessThingInstancePtrRenderOrder>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAPAPAVCGraphicThingInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAPAPAVCGraphicThingInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAPAPAVCGraphicThingInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Sort@PAUSCRCWithNumber@CArea@@HUCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z
_TEXT	SEGMENT
__Mid$1 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort@PAUSCRCWithNumber@CArea@@HUCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z PROC ; std::_Sort<CArea::SCRCWithNumber *,int,CArea::CRCNumComp>, COMDAT

; 3122 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3123 : 	_Diff _Count;
; 3124 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00011	2b c7		 sub	 eax, edi
  00013	c1 f8 03	 sar	 eax, 3
  00016	83 f8 20	 cmp	 eax, 32			; 00000020H
  00019	7e 72		 jle	 SHORT $LN3@Sort
  0001b	8b 5d 10	 mov	 ebx, DWORD PTR __Ideal$[ebp]
  0001e	8b ff		 npad	 2
$LL7@Sort:
  00020	85 db		 test	 ebx, ebx
  00022	0f 8e 80 00 00
	00		 jle	 $LN6@Sort

; 3125 : 		{	// divide and conquer by quicksort
; 3126 : 		pair<_RanIt, _RanIt> _Mid =
; 3127 : 			_Unguarded_partition(_First, _Last, _Pred);

  00028	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0002b	8d 45 f8	 lea	 eax, DWORD PTR __Mid$1[ebp]
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Unguarded_partition@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z ; std::_Unguarded_partition<CArea::SCRCWithNumber *,CArea::CRCNumComp>

; 3128 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

  00036	8b c3		 mov	 eax, ebx
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	99		 cdq

; 3129 : 
; 3130 : 		if (_Mid.first - _First < _Last - _Mid.second)

  0003c	8b ce		 mov	 ecx, esi
  0003e	2b c2		 sub	 eax, edx
  00040	8b d8		 mov	 ebx, eax

; 3131 : 			{	// loop on second half
; 3132 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

  00042	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00045	d1 fb		 sar	 ebx, 1
  00047	8b c3		 mov	 eax, ebx
  00049	99		 cdq
  0004a	2b c2		 sub	 eax, edx
  0004c	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1[ebp+4]
  0004f	d1 f8		 sar	 eax, 1
  00051	2b ca		 sub	 ecx, edx
  00053	03 d8		 add	 ebx, eax
  00055	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00058	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0005b	2b c7		 sub	 eax, edi
  0005d	83 e0 f8	 and	 eax, -8			; fffffff8H
  00060	53		 push	 ebx
  00061	3b c1		 cmp	 eax, ecx
  00063	7d 0f		 jge	 SHORT $LN5@Sort
  00065	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp]
  00068	50		 push	 eax
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ??$_Sort@PAUSCRCWithNumber@CArea@@HUCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort<CArea::SCRCWithNumber *,int,CArea::CRCNumComp>

; 3133 : 			_First = _Mid.second;

  0006f	8b 7d fc	 mov	 edi, DWORD PTR __Mid$1[ebp+4]

; 3134 : 			}
; 3135 : 		else

  00072	eb 0a		 jmp	 SHORT $LN34@Sort
$LN5@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  00074	56		 push	 esi
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 ??$_Sort@PAUSCRCWithNumber@CArea@@HUCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort<CArea::SCRCWithNumber *,int,CArea::CRCNumComp>

; 3138 : 			_Last = _Mid.first;

  0007b	8b 75 f8	 mov	 esi, DWORD PTR __Mid$1[ebp]
$LN34@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

  0007e	8b c6		 mov	 eax, esi
  00080	83 c4 10	 add	 esp, 16			; 00000010H
  00083	2b c7		 sub	 eax, edi
  00085	c1 f8 03	 sar	 eax, 3
  00088	83 f8 20	 cmp	 eax, 32			; 00000020H
  0008b	7f 93		 jg	 SHORT $LL7@Sort
$LN3@Sort:

; 3143 : 		{	// heap sort if too many divisions
; 3144 : 		_STD make_heap(_First, _Last, _Pred);
; 3145 : 		_STD sort_heap(_First, _Last, _Pred);
; 3146 : 		}
; 3147 : 	else if (1 < _Count)

  0008d	83 f8 01	 cmp	 eax, 1
  00090	7e 0f		 jle	 SHORT $LN27@Sort

; 2488 : 	}
; 2489 : 
; 2490 : 		// TEMPLATE FUNCTION sort_heap
; 2491 : template<class _RanIt> inline
; 2492 : 	void sort_heap(_RanIt _First, _RanIt _Last)
; 2493 : 	{	// order heap by repeatedly popping, using operator<
; 2494 : 	_STD sort_heap(_First, _Last, less<>());
; 2495 : 	}
; 2496 : 
; 2497 : 		// TEMPLATE FUNCTION lower_bound WITH PRED
; 2498 : template<class _FwdIt,
; 2499 : 	class _Ty,
; 2500 : 	class _Diff,
; 2501 : 	class _Pr> inline
; 2502 : 	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
; 2503 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2504 : 	{	// find first element not before _Val, using _Pred
; 2505 : 	_Diff _Count = 0;
; 2506 : 	_Distance(_First, _Last, _Count);
; 2507 : 
; 2508 : 	while (0 < _Count)
; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;
; 2511 : 		_FwdIt _Mid = _First;
; 2512 : 		_STD advance(_Mid, _Count2);
; 2513 : 
; 2514 : 		if (_Pred(*_Mid, _Val))
; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;
; 2519 : 			}
; 2520 : 		else
; 2521 : 			_Count = _Count2;
; 2522 : 		}
; 2523 : 	return (_First);
; 2524 : 	}
; 2525 : 
; 2526 : template<class _FwdIt,
; 2527 : 	class _Ty,
; 2528 : 	class _Pr> inline
; 2529 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
; 2530 : 		const _Ty& _Val, _Pr _Pred)
; 2531 : 	{	// find first element not before _Val, using _Pred
; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));
; 2536 : 	}
; 2537 : 
; 2538 : 		// TEMPLATE FUNCTION lower_bound
; 2539 : template<class _FwdIt,
; 2540 : 	class _Ty> inline
; 2541 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2542 : 	{	// find first element not before _Val, using operator<
; 2543 : 	return (_STD lower_bound(_First, _Last, _Val, less<>()));
; 2544 : 	}
; 2545 : 
; 2546 : 		// TEMPLATE FUNCTION upper_bound WITH PRED
; 2547 : template<class _FwdIt,
; 2548 : 	class _Ty,
; 2549 : 	class _Diff,
; 2550 : 	class _Pr> inline
; 2551 : 	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
; 2552 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2553 : 	{	// find first element that _Val is before, using _Pred
; 2554 : 	_Diff _Count = 0;
; 2555 : 	_Distance(_First, _Last, _Count);
; 2556 : 
; 2557 : 	while (0 < _Count)
; 2558 : 		{	// divide and conquer, find half that contains answer
; 2559 : 		_Diff _Count2 = _Count / 2;
; 2560 : 		_FwdIt _Mid = _First;
; 2561 : 		_STD advance(_Mid, _Count2);
; 2562 : 
; 2563 : 		if (!_Pred(_Val, *_Mid))
; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;
; 2567 : 			_Count -= _Count2 + 1;
; 2568 : 			}
; 2569 : 		else
; 2570 : 			_Count = _Count2;
; 2571 : 		}
; 2572 : 	return (_First);
; 2573 : 	}
; 2574 : 
; 2575 : template<class _FwdIt,
; 2576 : 	class _Ty,
; 2577 : 	class _Pr> inline
; 2578 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
; 2579 : 		const _Ty& _Val, _Pr _Pred)
; 2580 : 	{	// find first element that _Val is before, using _Pred
; 2581 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2582 : 	return (_Rechecked(_First,
; 2583 : 		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2584 : 			_Dist_type(_First))));
; 2585 : 	}
; 2586 : 
; 2587 : 		// TEMPLATE FUNCTION upper_bound
; 2588 : template<class _FwdIt,
; 2589 : 	class _Ty> inline
; 2590 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2591 : 	{	// find first element that _Val is before, using operator<
; 2592 : 	return (_STD upper_bound(_First, _Last, _Val, less<>()));
; 2593 : 	}
; 2594 : 
; 2595 : 		// TEMPLATE FUNCTION equal_range WITH PRED
; 2596 : template<class _FwdIt,
; 2597 : 	class _Ty,
; 2598 : 	class _Diff,
; 2599 : 	class _Pr> inline
; 2600 : 	pair<_FwdIt, _FwdIt>
; 2601 : 		_Equal_range(_FwdIt _First, _FwdIt _Last,
; 2602 : 			const _Ty& _Val, _Pr _Pred, _Diff *)
; 2603 : 	{	// find range equivalent to _Val, using _Pred
; 2604 : 	_Diff _Count = 0;
; 2605 : 	_Distance(_First, _Last, _Count);
; 2606 : 
; 2607 : 	while (0 < _Count)
; 2608 : 		{	// divide and conquer, check midpoint
; 2609 : 		_Diff _Count2 = _Count / 2;
; 2610 : 		_FwdIt _Mid = _First;
; 2611 : 		_STD advance(_Mid, _Count2);
; 2612 : 
; 2613 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2614 : 			{	// range begins above _Mid, loop
; 2615 : 			_First = ++_Mid;
; 2616 : 			_Count -= _Count2 + 1;
; 2617 : 			}
; 2618 : 		else if (_Pred(_Val, *_Mid))
; 2619 : 			_Count = _Count2;	// range in first half, loop
; 2620 : 		else
; 2621 : 			{	// range straddles _Mid, find each end and return
; 2622 : 			_FwdIt _First2 = _STD lower_bound(_First, _Mid, _Val, _Pred);
; 2623 : 			_STD advance(_First, _Count);
; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);
; 2625 : 			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
; 2626 : 			}
; 2627 : 		}
; 2628 : 
; 2629 : 	return (pair<_FwdIt, _FwdIt>(_First, _First));	// empty range
; 2630 : 	}
; 2631 : 
; 2632 : template<class _FwdIt,
; 2633 : 	class _Ty,
; 2634 : 	class _Pr> inline
; 2635 : 	pair<_FwdIt, _FwdIt>
; 2636 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2637 : 			const _Ty& _Val, _Pr _Pred)
; 2638 : 	{	// find range equivalent to _Val, using _Pred
; 2639 : 	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2640 : 	pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
; 2641 : 		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
; 2642 : 			_Val, _Pred, _Dist_type(_First)));
; 2643 : 	return (pair<_FwdIt, _FwdIt>(
; 2644 : 		_Rechecked(_First, _Ans.first),
; 2645 : 		_Rechecked(_Last, _Ans.second)));
; 2646 : 	}
; 2647 : 
; 2648 : 		// TEMPLATE FUNCTION equal_range
; 2649 : template<class _FwdIt,
; 2650 : 	class _Ty> inline
; 2651 : 	pair<_FwdIt, _FwdIt>
; 2652 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2653 : 			const _Ty& _Val)
; 2654 : 	{	// find range equivalent to _Val, using operator<
; 2655 : 	return (_STD equal_range(_First, _Last, _Val, less<>()));
; 2656 : 	}
; 2657 : 
; 2658 : 		// TEMPLATE FUNCTION binary_search WITH PRED
; 2659 : template<class _FwdIt,
; 2660 : 	class _Ty,
; 2661 : 	class _Pr> inline
; 2662 : 	bool binary_search(_FwdIt _First, _FwdIt _Last,
; 2663 : 		const _Ty& _Val, _Pr _Pred)
; 2664 : 	{	// test if _Val equivalent to some element, using _Pred
; 2665 : 	_First = _STD lower_bound(_First, _Last, _Val, _Pred);
; 2666 : 	return (_First != _Last && !_Pred(_Val, *_First));
; 2667 : 	}
; 2668 : 
; 2669 : 		// TEMPLATE FUNCTION binary_search
; 2670 : template<class _FwdIt,
; 2671 : 	class _Ty> inline
; 2672 : 	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2673 : 	{	// test if _Val equivalent to some element, using operator<
; 2674 : 	return (_STD binary_search(_First, _Last, _Val, less<>()));
; 2675 : 	}
; 2676 : 
; 2677 : 		// TEMPLATE FUNCTION merge WITH PRED
; 2678 : template<class _InIt1,
; 2679 : 	class _InIt2,
; 2680 : 	class _OutIt,
; 2681 : 	class _Pr> inline
; 2682 : 	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
; 2683 : 		_InIt2 _First2, _InIt2 _Last2,
; 2684 : 		_OutIt _Dest, _Pr _Pred)
; 2685 : 	{	// copy merging ranges, both using _Pred
; 2686 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2687 : 		for (; ; )
; 2688 : 			{	// merge either first or second
; 2689 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2690 : 				{	// merge first
; 2691 : 				*_Dest++ = *_First2++;
; 2692 : 				if (_First2 == _Last2)
; 2693 : 					break;
; 2694 : 				}
; 2695 : 			else
; 2696 : 				{	// merge second
; 2697 : 				*_Dest++ = *_First1++;
; 2698 : 				if (_First1 == _Last1)
; 2699 : 					break;
; 2700 : 				}
; 2701 : 			}
; 2702 : 
; 2703 : 	_Dest = _Copy_impl(_First1, _Last1, _Dest);	// copy any tail
; 2704 : 	return (_Copy_impl(_First2, _Last2, _Dest));
; 2705 : 	}
; 2706 : 
; 2707 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2708 : template<class _InIt1,
; 2709 : 	class _InIt2,
; 2710 : 	class _OutIt,
; 2711 : 	class _Pr> inline
; 2712 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2713 : 		_InIt2 _First2, _InIt2 _Last2,
; 2714 : 		_OutIt _Dest, _Pr _Pred)
; 2715 : 	{	// copy merging ranges, both using _Pred
; 2716 : 	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
; 2717 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2718 : 		_Dest, _Pred));
; 2719 : 	}
; 2720 : 
; 2721 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2722 : template<class _InIt1,
; 2723 : 	class _InIt2,
; 2724 : 	class _OutIt,
; 2725 : 	class _Pr> inline
; 2726 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2727 : 		_InIt2 _First2, _InIt2 _Last2,
; 2728 : 		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
; 2729 : 		input_iterator_tag, _Mutable_iterator_tag)
; 2730 : 	{	// copy merging ranges, both using _Pred, arbitrary iterators
; 2731 : 	return (_Merge0(_First1, _Last1,
; 2732 : 		_First2, _Last2,
; 2733 : 		_Dest, _Pred));
; 2734 : 	}
; 2735 : 
; 2736 : template<class _InIt1,
; 2737 : 	class _InIt2,
; 2738 : 	class _OutIt,
; 2739 : 	class _Pr> inline
; 2740 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2741 : 		_InIt2 _First2, _InIt2 _Last2,
; 2742 : 		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
; 2743 : 		random_access_iterator_tag, random_access_iterator_tag)
; 2744 : 	{	// copy merging ranges, both using _Pred, random-access iterators
; 2745 : 	_OutIt _Ans = _Dest + (_Last1 - _First1)
; 2746 : 		+ (_Last2 - _First2);	// also checks range
; 2747 : 	_Merge0(_First1, _Last1,
; 2748 : 		_First2, _Last2,
; 2749 : 		_Dest, _Pred);
; 2750 : 	return (_Ans);
; 2751 : 	}
; 2752 : 
; 2753 : template<class _InIt1,
; 2754 : 	class _InIt2,
; 2755 : 	class _OutIt,
; 2756 : 	class _Pr> inline
; 2757 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2758 : 		_InIt2 _First2, _InIt2 _Last2,
; 2759 : 		_OutIt _Dest, _Pr _Pred, true_type)
; 2760 : 	{	// copy merging ranges, both using _Pred, checked dest
; 2761 : 	return (_Merge2(_First1, _Last1,
; 2762 : 		_First2, _Last2,
; 2763 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2764 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2765 : 	}
; 2766 : 
; 2767 : template<class _InIt1,
; 2768 : 	class _InIt2,
; 2769 : 	class _OutIt,
; 2770 : 	class _Pr> inline
; 2771 : _SCL_INSECURE_DEPRECATE
; 2772 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2773 : 		_InIt2 _First2, _InIt2 _Last2,
; 2774 : 		_OutIt _Dest, _Pr _Pred, false_type)
; 2775 : 	{	// copy merging ranges, both using _Pred, unchecked dest
; 2776 : 	return (_Merge2(_First1, _Last1,
; 2777 : 		_First2, _Last2,
; 2778 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2779 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2780 : 	}
; 2781 : 
; 2782 : template<class _InIt1,
; 2783 : 	class _InIt2,
; 2784 : 	class _OutIt,
; 2785 : 	class _Pr> inline
; 2786 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2787 : 		_InIt2 _First2, _InIt2 _Last2,
; 2788 : 		_OutIt _Dest, _Pr _Pred)
; 2789 : 	{	// copy merging ranges, both using _Pred
; 2790 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2791 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2792 : 	_DEBUG_POINTER(_Dest);
; 2793 : 	_DEBUG_POINTER(_Pred);
; 2794 : 	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
; 2795 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2796 : 		_Dest, _Pred, _Is_checked(_Dest)));
; 2797 : 	}
; 2798 : 
; 2799 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2800 : template<class _InIt1,
; 2801 : 	class _InIt2,
; 2802 : 	class _OutTy,
; 2803 : 	size_t _OutSize,
; 2804 : 	class _Pr> inline
; 2805 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InIt2 _First2, _InIt2 _Last2,
; 2807 : 		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
; 2808 : 	{	// copy merging ranges, both using _Pred, array dest
; 2809 : 	return (_Unchecked(
; 2810 : 		_STD merge(_First1, _Last1,
; 2811 : 			_First2, _Last2,
; 2812 : 			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
; 2813 : 	}
; 2814 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2815 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2816 : 
; 2817 : 		// TEMPLATE FUNCTION merge
; 2818 : template<class _InIt1,
; 2819 : 	class _InIt2,
; 2820 : 	class _OutIt> inline
; 2821 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2822 : 		_InIt2 _First2, _InIt2 _Last2,
; 2823 : 		_OutIt _Dest)
; 2824 : 	{	// copy merging ranges, both using operator<
; 2825 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2826 : 		less<>()));
; 2827 : 	}
; 2828 : 
; 2829 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2830 : template<class _InIt1,
; 2831 : 	class _InIt2,
; 2832 : 	class _OutTy,
; 2833 : 	size_t _OutSize> inline
; 2834 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2835 : 		_InIt2 _First2, _InIt2 _Last2,
; 2836 : 		_OutTy (&_Dest)[_OutSize])
; 2837 : 	{	// copy merging ranges, both using operator<, array dest
; 2838 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2839 : 		less<>()));
; 2840 : 	}
; 2841 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2842 : 
; 2843 : 		// TEMPLATE FUNCTION inplace_merge WITH PRED
; 2844 : template<class _BidIt1,
; 2845 : 	class _BidIt2,
; 2846 : 	class _BidIt3,
; 2847 : 	class _Pr> inline
; 2848 : 	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
; 2849 : 		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
; 2850 : 	{	// merge backwards to _Dest, using _Pred
; 2851 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2852 : 		for (; ; )
; 2853 : 			{	// merge either first or second
; 2854 : 			if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))
; 2855 : 				{	// merge first
; 2856 : 				*--_Dest = _Move(*_Last1);
; 2857 : 				++_Last2;
; 2858 : 				if (_First1 == _Last1)
; 2859 : 					break;
; 2860 : 				}
; 2861 : 			else
; 2862 : 				{	// merge second
; 2863 : 				*--_Dest = _Move(*_Last2);
; 2864 : 				++_Last1;
; 2865 : 				if (_First2 == _Last2)
; 2866 : 					break;
; 2867 : 				}
; 2868 : 			}
; 2869 : 
; 2870 : 	_Dest = _Move_backward(_First2, _Last2, _Dest);	// move any tail
; 2871 : 	return (_Move_backward(_First1, _Last1, _Dest));
; 2872 : 	}
; 2873 : 
; 2874 : template<class _InIt1,
; 2875 : 	class _InIt2,
; 2876 : 	class _OutIt,
; 2877 : 	class _Pr> inline
; 2878 : 	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
; 2879 : 		_InIt2 _First2, _InIt2 _Last2,
; 2880 : 		_OutIt _Dest, _Pr _Pred)
; 2881 : 	{	// move merging ranges, both using _Pred
; 2882 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2883 : 		for (; ; )
; 2884 : 			{	// merge either first or second
; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2886 : 				{	// merge first
; 2887 : 				*_Dest++ = _Move(*_First2++);
; 2888 : 				if (_First2 == _Last2)
; 2889 : 					break;
; 2890 : 				}
; 2891 : 			else
; 2892 : 				{	// merge second
; 2893 : 				*_Dest++ = _Move(*_First1++);
; 2894 : 				if (_First1 == _Last1)
; 2895 : 					break;
; 2896 : 				}
; 2897 : 			}
; 2898 : 
; 2899 : 	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail
; 2900 : 	return (_Move(_First2, _Last2, _Dest));
; 2901 : 	}
; 2902 : 
; 2903 : template<class _BidIt,
; 2904 : 	class _Diff,
; 2905 : 	class _Ty,
; 2906 : 	class _Pr> inline
; 2907 : 	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
; 2908 : 		_Diff _Count1, _Diff _Count2,
; 2909 : 			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
; 2910 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2911 : 	if (_Count1 == 0 || _Count2 == 0)
; 2912 : 		;	// do nothing
; 2913 : 	else if (_Count1 + _Count2 == 2)
; 2914 : 		{	// order two one-element partitions
; 2915 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 2916 : 			_STD iter_swap(_First, _Mid);
; 2917 : 		}
; 2918 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
; 2919 : 		{	// buffer left partition, then merge
; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());
; 2921 : 		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2922 : 			_Mid, _Last, _First, _Pred);
; 2923 : 		}
; 2924 : 	else if (_Count2 <= _Tempbuf._Maxlen())
; 2925 : 		{	// buffer right partition, then merge
; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());
; 2927 : 		_Merge_backward(_First, _Mid,
; 2928 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
; 2929 : 		}
; 2930 : 	else
; 2931 : 		{	// buffer too small, divide and conquer
; 2932 : 		_BidIt _Firstn, _Lastn;
; 2933 : 		_Diff _Count1n, _Count2n;
; 2934 : 		if (_Count2 < _Count1)
; 2935 : 			{	// left larger, cut it in half and partition right to match
; 2936 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2937 : 			_Firstn = _First;
; 2938 : 			_STD advance(_Firstn, _Count1n);
; 2939 : 			_Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);
; 2940 : 			_Distance(_Mid, _Lastn, _Count2n);
; 2941 : 			}
; 2942 : 		else
; 2943 : 			{	// right larger, cut it in half and partition left to match
; 2944 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2945 : 			_Lastn = _Mid;
; 2946 : 			_STD advance(_Lastn, _Count2n);
; 2947 : 			_Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);
; 2948 : 			_Distance(_First, _Firstn, _Count1n);
; 2949 : 			}
; 2950 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2951 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle
; 2952 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2953 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part
; 2954 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2955 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
; 2956 : 		}
; 2957 : 	}
; 2958 : 
; 2959 : template<class _BidIt,
; 2960 : 	class _Diff,
; 2961 : 	class _Ty,
; 2962 : 	class _Pr> inline
; 2963 : 	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
; 2964 : 		_Diff *, _Ty *)
; 2965 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2966 : 	_Diff _Count1 = 0;
; 2967 : 	_Distance(_First, _Mid, _Count1);
; 2968 : 	_Diff _Count2 = 0;
; 2969 : 	_Distance(_Mid, _Last, _Count2);
; 2970 : 	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
; 2971 : 	_Buffered_merge(_First, _Mid, _Last,
; 2972 : 		_Count1, _Count2, _Tempbuf, _Pred);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _BidIt,
; 2976 : 	class _Pr> inline
; 2977 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
; 2978 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2979 : 	_DEBUG_ORDER_PRED(_First, _Mid, _Pred);
; 2980 : 	_DEBUG_ORDER_PRED(_Mid, _Last, _Pred);
; 2981 : 	if (_First != _Mid && _Mid != _Last)
; 2982 : 		_Inplace_merge(
; 2983 : 			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
; 2984 : 			_Dist_type(_First), _Val_type(_First));
; 2985 : 	}
; 2986 : 
; 2987 : 		// TEMPLATE FUNCTION inplace_merge
; 2988 : template<class _BidIt> inline
; 2989 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
; 2990 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
; 2991 : 	_STD inplace_merge(_First, _Mid, _Last, less<>());
; 2992 : 	}
; 2993 : 
; 2994 : 		// TEMPLATE FUNCTION sort WITH PRED
; 2995 : template<class _BidIt,
; 2996 : 	class _Pr,
; 2997 : 	class _Ty> inline
; 2998 : 	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
; 2999 : 	{	// insertion sort [_First, _Last), using _Pred
; 3000 : 	if (_First != _Last)
; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )
; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);
; 3005 : 
; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))
; 3007 : 				{	// found new earliest element, move to front
; 3008 : 				_Move_backward(_First, _Next, ++_Next1);
; 3009 : 				*_First = _Move(_Val);
; 3010 : 				}
; 3011 : 			else
; 3012 : 				{	// look for insertion point after first
; 3013 : 				for (_BidIt _First1 = _Next1;
; 3014 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3015 : 					_Next1 = _First1)
; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down
; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole
; 3018 : 				}
; 3019 : 			}
; 3020 : 	}
; 3021 : 
; 3022 : template<class _BidIt,
; 3023 : 	class _Pr> inline
; 3024 : 	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
; 3025 : 	{	// insertion sort [_First, _Last), using _Pred
; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

  00092	6a 00		 push	 0
  00094	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	e8 00 00 00 00	 call	 ??$_Insertion_sort1@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@U12@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@0@Z ; std::_Insertion_sort1<CArea::SCRCWithNumber *,CArea::CRCNumComp,CArea::SCRCWithNumber>
  0009e	83 c4 10	 add	 esp, 16			; 00000010H
$LN27@Sort:
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN6@Sort:

; 3139 : 			}
; 3140 : 		}
; 3141 : 
; 3142 : 	if (_ISORT_MAX < _Count)

  000a8	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ab	7e e0		 jle	 SHORT $LN3@Sort

; 2459 : 	if (1 < _Last - _First)

  000ad	8b c6		 mov	 eax, esi
  000af	2b c7		 sub	 eax, edi
  000b1	83 e0 f8	 and	 eax, -8			; fffffff8H
  000b4	83 f8 08	 cmp	 eax, 8
  000b7	7e 11		 jle	 SHORT $LN10@Sort

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c0	56		 push	 esi
  000c1	57		 push	 edi
  000c2	e8 00 00 00 00	 call	 ??$_Make_heap@PAUSCRCWithNumber@CArea@@HU12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@PAH0@Z ; std::_Make_heap<CArea::SCRCWithNumber *,int,CArea::SCRCWithNumber,CArea::CRCNumComp>
  000c7	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@Sort:

; 2462 : 	}
; 2463 : 
; 2464 : 		// TEMPLATE FUNCTION make_heap
; 2465 : template<class _RanIt> inline
; 2466 : 	void make_heap(_RanIt _First, _RanIt _Last)
; 2467 : 	{	// make [_First, _Last) into a heap, using operator<
; 2468 : 	_STD make_heap(_First, _Last, less<>());
; 2469 : 	}
; 2470 : 
; 2471 : 		// TEMPLATE FUNCTION sort_heap WITH PRED
; 2472 : template<class _RanIt,
; 2473 : 	class _Pr> inline
; 2474 : 	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2475 : 	{	// order heap by repeatedly popping, using _Pred
; 2476 : 	for (; 1 < _Last - _First; --_Last)
; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}
; 2479 : 
; 2480 : template<class _RanIt,
; 2481 : 	class _Pr> inline
; 2482 : 	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2483 : 	{	// order heap by repeatedly popping, using _Pred
; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

  000ca	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000cd	56		 push	 esi
  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 ??$_Sort_heap@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Sort_heap<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
??$_Sort@PAUSCRCWithNumber@CArea@@HUCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ENDP ; std::_Sort<CArea::SCRCWithNumber *,int,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@AAV10@PAUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@AAV10@PAUSCRCWithNumber@CArea@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >, COMDAT

; 404  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@AAV10@PAUSCRCWithNumber@CArea@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Find_if@PAUSCRCWithNumber@CArea@@UFFindIfCRC@2@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@0UFFindIfCRC@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Find_if@PAUSCRCWithNumber@CArea@@UFFindIfCRC@2@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@0UFFindIfCRC@2@@Z PROC ; std::_Find_if<CArea::SCRCWithNumber *,CArea::FFindIfCRC>, COMDAT

; 42   : 	{	// find first satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 	for (; _First != _Last; ++_First)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 0e		 je	 SHORT $LN16@Find_if
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Pred$[ebp]
$LL4@Find_if:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 178  : 				if (rCRCWithNumber.dwCRC == m_dwCRC)

  00010	39 08		 cmp	 DWORD PTR [eax], ecx
  00012	74 07		 je	 SHORT $LN16@Find_if
; File a:\vs\vc\include\algorithm

; 43   : 	for (; _First != _Last; ++_First)

  00014	83 c0 08	 add	 eax, 8
  00017	3b c2		 cmp	 eax, edx
  00019	75 f5		 jne	 SHORT $LL4@Find_if
$LN16@Find_if:

; 44   : 		if (_Pred(*_First))
; 45   : 			break;
; 46   : 	return (_First);
; 47   : 	}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Find_if@PAUSCRCWithNumber@CArea@@UFFindIfCRC@2@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@0UFFindIfCRC@2@@Z ENDP ; std::_Find_if<CArea::SCRCWithNumber *,CArea::FFindIfCRC>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUFAreaRenderShadow@@@std@@YA$$QAUFAreaRenderShadow@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUFAreaRenderShadow@@@std@@YA$$QAUFAreaRenderShadow@@AAU1@@Z PROC ; std::move<FAreaRenderShadow &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUFAreaRenderShadow@@@std@@YA$$QAUFAreaRenderShadow@@AAU1@@Z ENDP ; std::move<FAreaRenderShadow &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicObjectInstance@@UFAreaRenderShadow@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFAreaRenderShadow@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv141 = 12						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicObjectInstance@@UFAreaRenderShadow@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFAreaRenderShadow@@@Z PROC ; std::_For_each<CGraphicObjectInstance * *,FAreaRenderShadow>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	33 db		 xor	 ebx, ebx
  0000f	2b ce		 sub	 ecx, esi
  00011	83 c1 03	 add	 ecx, 3
  00014	c1 e9 02	 shr	 ecx, 2
  00017	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001a	0f 47 ca	 cmova	 ecx, edx
  0001d	89 4d 0c	 mov	 DWORD PTR tv141[ebp], ecx

; 23   : 	for (; _First != _Last; ++_First)

  00020	85 c9		 test	 ecx, ecx
  00022	74 1b		 je	 SHORT $LN1@For_each
  00024	57		 push	 edi
$LL3@For_each:

; 24   : 		_Func(*_First);

  00025	8b 3e		 mov	 edi, DWORD PTR [esi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 304  : 		pInstance->RenderShadow();

  00027	8b cf		 mov	 ecx, edi
  00029	e8 00 00 00 00	 call	 ?RenderShadow@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RenderShadow

; 305  : 		pInstance->Hide();

  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00035	43		 inc	 ebx
  00036	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00039	3b 5d 0c	 cmp	 ebx, DWORD PTR tv141[ebp]
  0003c	75 e7		 jne	 SHORT $LL3@For_each
  0003e	5f		 pop	 edi
$LN1@For_each:
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx

; 25   : 	}

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??$_For_each@PAPAVCGraphicObjectInstance@@UFAreaRenderShadow@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFAreaRenderShadow@@@Z ENDP ; std::_For_each<CGraphicObjectInstance * *,FAreaRenderShadow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAUFPCBlockerHide@@@std@@YA$$QAUFPCBlockerHide@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUFPCBlockerHide@@@std@@YA$$QAUFPCBlockerHide@@AAU1@@Z PROC ; std::move<FPCBlockerHide &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUFPCBlockerHide@@@std@@YA$$QAUFPCBlockerHide@@AAU1@@Z ENDP ; std::move<FPCBlockerHide &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicObjectInstance@@UFPCBlockerHide@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFPCBlockerHide@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicObjectInstance@@UFPCBlockerHide@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFPCBlockerHide@@@Z PROC ; std::_For_each<CGraphicObjectInstance * *,FPCBlockerHide>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 0f		 je	 SHORT $LN1@For_each
$LL3@For_each:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 313  : 		pInstance->Hide();

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	3b fb		 cmp	 edi, ebx
  0002f	75 f1		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 24   : 		_Func(*_First);
; 25   : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_For_each@PAPAVCGraphicObjectInstance@@UFPCBlockerHide@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFPCBlockerHide@@@Z ENDP ; std::_For_each<CGraphicObjectInstance * *,FPCBlockerHide>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@YAPAPAVCGraphicObjectInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAMAAJX@?$pair@MJ@std@@QAE@AAMAAJ@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAMAAJX@?$pair@MJ@std@@QAE@AAMAAJ@Z PROC		; std::pair<float,long>::pair<float,long><float &,long &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAMAAJX@?$pair@MJ@std@@QAE@AAMAAJ@Z ENDP		; std::pair<float,long>::pair<float,long><float &,long &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAJ@std@@YAAAJAAJ@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAJ@std@@YAAAJAAJ@Z PROC			; std::forward<long &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAJ@std@@YAAAJAAJ@Z ENDP			; std::forward<long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAM@std@@YAAAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAM@std@@YAAAMAAM@Z PROC			; std::forward<float &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAM@std@@YAAAMAAM@Z ENDP			; std::forward<float &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0U?$less@X@0@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::less<void> >, COMDAT

; 3154 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	2b d0		 sub	 edx, eax
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  0000d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00010	c1 fa 03	 sar	 edx, 3
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00013	52		 push	 edx
  00014	51		 push	 ecx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z ; std::_Sort<std::pair<float,long> *,int,std::less<void> >
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3158 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$less@X@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0U?$less@X@0@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AAV10@PAE@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AAV10@PAE@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 404  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@AAV10@PAE@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Find@PAEE@std@@YAPAEPAE0ABE@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find@PAEE@std@@YAPAEPAE0ABE@Z PROC			; std::_Find<unsigned char *,unsigned char>, COMDAT

; 3034 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2992 : 	return (_Val <= UCHAR_MAX);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]
  00008	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  0000a	76 05		 jbe	 SHORT $LN3@Find

; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 3046 : 	}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN3@Find:

; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00018	0f b6 d0	 movzx	 edx, al
  0001b	8b c6		 mov	 eax, esi
  0001d	2b c1		 sub	 eax, ecx
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  0001f	50		 push	 eax
  00020	52		 push	 edx
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _memchr
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  0002a	85 c0		 test	 eax, eax
  0002c	0f 45 f0	 cmovne	 esi, eax

; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 3046 : 	}

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Find@PAEE@std@@YAPAEPAE0ABE@Z ENDP			; std::_Find<unsigned char *,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAEV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAEV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPAEV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@UTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@IPAU12@@Z PROC ; std::_Allocate<CMapOutdoor::TPatchDrawStruct>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 04	 shl	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@UTPatchDrawStruct@CMapOutdoor@@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@IPAU12@@Z ENDP ; std::_Allocate<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@IPAU10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<float,long> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@USCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@IPAU12@@Z PROC ; std::_Allocate<CArea::SCRCWithNumber>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@USCRCWithNumber@CArea@@@std@@YAPAUSCRCWithNumber@CArea@@IPAU12@@Z ENDP ; std::_Allocate<CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@E@std@@YAPAEIPAE@Z PROC			; std::_Allocate<unsigned char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	77 0f		 ja	 SHORT $LN1@Allocate
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	8b c8		 mov	 ecx, eax
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c9		 test	 ecx, ecx
  0001e	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00020	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  00025	8b c1		 mov	 eax, ecx

; 32   : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Allocate@E@std@@YAPAEIPAE@Z ENDP			; std::_Allocate<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAUTPatchDrawStruct@CMapOutdoor@@@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEPAUTPatchDrawStruct@CMapOutdoor@@PAU23@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUTPatchDrawStruct@CMapOutdoor@@@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEPAUTPatchDrawStruct@CMapOutdoor@@PAU23@00@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Umove<CMapOutdoor::TPatchDrawStruct *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::allocator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::TPatchDrawStruct>
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1649 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUTPatchDrawStruct@CMapOutdoor@@@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEPAUTPatchDrawStruct@CMapOutdoor@@PAU23@00@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Umove<CMapOutdoor::TPatchDrawStruct *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAU?$pair@MJ@std@@@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEPAU?$pair@MJ@1@PAU21@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAU?$pair@MJ@std@@@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEPAU?$pair@MJ@1@PAU21@00@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Umove<std::pair<float,long> *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::allocator<std::pair<float,long> >,std::pair<float,long> >
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1649 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAU?$pair@MJ@std@@@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEPAU?$pair@MJ@1@PAU21@00@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Umove<std::pair<float,long> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEPAUSCRCWithNumber@CArea@@PAU23@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEPAUSCRCWithNumber@CArea@@PAU23@00@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Umove<CArea::SCRCWithNumber *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber>,CArea::SCRCWithNumber>
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1649 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEPAUSCRCWithNumber@CArea@@PAU23@00@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Umove<CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	2b f0		 sub	 esi, eax

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	03 c6		 add	 eax, esi
  0001b	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@@std@@YAXPAU?$pair@MJ@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@0AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned char> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$construct@UTPatchDrawStruct@CMapOutdoor@@ABU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$construct@UTPatchDrawStruct@CMapOutdoor@@AAU12@@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@AAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::construct<CMapOutdoor::TPatchDrawStruct,CMapOutdoor::TPatchDrawStruct &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUTPatchDrawStruct@CMapOutdoor@@@std@@YAPBUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUTPatchDrawStruct@CMapOutdoor@@@std@@YAPBUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z PROC ; std::addressof<CMapOutdoor::TPatchDrawStruct const >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUTPatchDrawStruct@CMapOutdoor@@@std@@YAPBUTPatchDrawStruct@CMapOutdoor@@ABU12@@Z ENDP ; std::addressof<CMapOutdoor::TPatchDrawStruct const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@MJ@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@MJ@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::construct<std::pair<float,long>,std::pair<float,long> >, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:
; File a:\vs\vc\include\xmemory0

; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@MJ@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::construct<std::pair<float,long>,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z PROC ; std::forward<std::pair<float,long> >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@MJ@std@@@std@@YA$$QAU?$pair@MJ@0@AAU10@@Z ENDP ; std::forward<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z PROC ; std::addressof<std::pair<float,long> >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@AAU10@@Z ENDP ; std::addressof<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@ABU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USCRCWithNumber@CArea@@ABU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@USCRCWithNumber@CArea@@ABU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USCRCWithNumber@CArea@@AAU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USCRCWithNumber@CArea@@AAU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@USCRCWithNumber@CArea@@AAU12@@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@AAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::construct<CArea::SCRCWithNumber,CArea::SCRCWithNumber &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUSCRCWithNumber@CArea@@@std@@YAPBUSCRCWithNumber@CArea@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUSCRCWithNumber@CArea@@@std@@YAPBUSCRCWithNumber@CArea@@ABU12@@Z PROC ; std::addressof<CArea::SCRCWithNumber const >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUSCRCWithNumber@CArea@@@std@@YAPBUSCRCWithNumber@CArea@@ABU12@@Z ENDP ; std::addressof<CArea::SCRCWithNumber const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@EABE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEABE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@EABE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEABE@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@EABE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEABE@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@EAAE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEAAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@EAAE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEAAE@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@EAAE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEAAE@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@$$CBE@std@@YAPBEABE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBE@std@@YAPBEABE@Z PROC			; std::addressof<unsigned char const >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBE@std@@YAPBEABE@Z ENDP			; std::addressof<unsigned char const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@0UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@0UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@Z PROC ; std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>, COMDAT

; 3271 : 	{	// sort preserving order of equivalents, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	3b c1		 cmp	 eax, ecx
; File a:\vs\vc\include\algorithm

; 3274 : 	if (_First != _Last)

  0000b	74 11		 je	 SHORT $LN1@stable_sor

; 3275 : 		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
; 3276 : 			_Dist_type(_First), _Val_type(_First), _Pred);

  0000d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	51		 push	 ecx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  0001b	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@stable_sor:

; 3277 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$stable_sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@0@0UFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEPAUTPatchDrawStruct@CMapOutdoor@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUTPatchDrawStruct@CMapOutdoor@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0MJX@?$pair@MJ@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0MJX@?$pair@MJ@std@@QAE@$$QAU01@@Z PROC		; std::pair<float,long>::pair<float,long><float,long,void>, COMDAT
; _this$ = ecx

; 157  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 158  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??$?0MJX@?$pair@MJ@std@@QAE@$$QAU01@@Z ENDP		; std::pair<float,long>::pair<float,long><float,long,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFRenderPCBlocker@@@std@@YA?AUFRenderPCBlocker@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 1
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFRenderPCBlocker@@@std@@YA?AUFRenderPCBlocker@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FRenderPCBlocker>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Func$[ebp]
  00006	50		 push	 eax
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_For_each@PAPAVCGraphicObjectInstance@@UFRenderPCBlocker@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFRenderPCBlocker@@@Z ; std::_For_each<CGraphicObjectInstance * *,FRenderPCBlocker>

; 34   : 
; 35   : 	return (_STD move(_Func));

  00012	8a 45 10	 mov	 al, BYTE PTR __Func$[ebp]
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 36   : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFRenderPCBlocker@@@std@@YA?AUFRenderPCBlocker@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FRenderPCBlocker>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YA?AUCMapOutdoor_FBlendThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 1
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YA?AUCMapOutdoor_FBlendThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_FBlendThingInstanceRender>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 0f		 je	 SHORT $LN24@for_each
$LL13@for_each:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 377  : 		pkThingInst->BlendRender();

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	e8 00 00 00 00	 call	 ?BlendRender@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::BlendRender
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	3b fb		 cmp	 edi, ebx
  0002f	75 f1		 jne	 SHORT $LL13@for_each
$LN24@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00031	8a 45 10	 mov	 al, BYTE PTR __Func$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 36   : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FBlendThingInstanceRender@@@std@@YA?AUCMapOutdoor_FBlendThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_FBlendThingInstanceRender>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??__Fs_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
??__Fs_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@YAXXZ PROC ; `CMapOutdoor::RenderBlendArea'::`4'::`dynamic atexit destructor for 's_kVct_pkBlendThingInstSort'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  00009	85 c0		 test	 eax, eax
  0000b	74 45		 je	 SHORT $LN5@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0000d	ff 35 04 00 00
	00		 push	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXPAPAVCGraphicThingInstance@@0@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy

; 642  : 		return (_Alty());

  0001e	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00026	ff 35 00 00 00
	00		 push	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A, 0

; 1630 : 			this->_Mylast = pointer();

  0003e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4, 0

; 1631 : 			this->_Myend = pointer();

  00048	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+8, 0
$LN5@dynamic:
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??__Fs_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@YAXXZ ENDP ; `CMapOutdoor::RenderBlendArea'::`4'::`dynamic atexit destructor for 's_kVct_pkBlendThingInstSort''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@2@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@2@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0V10@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,std::void_mem_fun_t<CGraphicObjectInstance> >, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 10	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 0d		 je	 SHORT $LN24@for_each
$LL13@for_each:
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h

; 41   : 		{((_P->*_Ptr)()); }

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	ff 55 14	 call	 DWORD PTR __Func$[ebp]
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	3b fb		 cmp	 edi, ebx
  0002d	75 f3		 jne	 SHORT $LL13@for_each
$LN24@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  0002f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	89 08		 mov	 DWORD PTR [eax], ecx
  00039	5b		 pop	 ebx

; 36   : 	}

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@V?$void_mem_fun_t@VCGraphicObjectInstance@@@2@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0V10@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,std::void_mem_fun_t<CGraphicObjectInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
;	COMDAT ??R?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QBEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
__P$ = 8						; size = 4
??R?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QBEXPAVCGraphicObjectInstance@@@Z PROC ; std::void_mem_fun_t<CGraphicObjectInstance>::operator(), COMDAT
; _this$ = ecx

; 41   : 		{((_P->*_Ptr)()); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __P$[ebp]
  00008	ff d0		 call	 eax
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??R?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QBEXPAVCGraphicObjectInstance@@@Z ENDP ; std::void_mem_fun_t<CGraphicObjectInstance>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
;	COMDAT ??0?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QAE@P8CGraphicObjectInstance@@AEXXZ@Z
_TEXT	SEGMENT
__Pm$ = 8						; size = 4
??0?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QAE@P8CGraphicObjectInstance@@AEXXZ@Z PROC ; std::void_mem_fun_t<CGraphicObjectInstance>::void_mem_fun_t<CGraphicObjectInstance>, COMDAT
; _this$ = ecx

; 38   : 		explicit void_mem_fun_t(void (_Ty::*_Pm)())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pm$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$void_mem_fun_t@VCGraphicObjectInstance@@@std@@QAE@P8CGraphicObjectInstance@@AEXXZ@Z ENDP ; std::void_mem_fun_t<CGraphicObjectInstance>::void_mem_fun_t<CGraphicObjectInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
;	COMDAT ??$void_mem_fun@VCGraphicObjectInstance@@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@P8CGraphicObjectInstance@@AEXXZ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Pm$ = 12						; size = 4
??$void_mem_fun@VCGraphicObjectInstance@@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@P8CGraphicObjectInstance@@AEXXZ@Z PROC ; std::void_mem_fun<CGraphicObjectInstance>, COMDAT

; 47   : 	{return (void_mem_fun_t<_Ty>(_Pm)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 		explicit void_mem_fun_t(void (_Ty::*_Pm)())

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Pm$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 47   : 	{return (void_mem_fun_t<_Ty>(_Pm)); }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$void_mem_fun@VCGraphicObjectInstance@@@std@@YA?AV?$void_mem_fun_t@VCGraphicObjectInstance@@@0@P8CGraphicObjectInstance@@AEXXZ@Z ENDP ; std::void_mem_fun<CGraphicObjectInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA?AUCMapOutdoor_FOpaqueThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 1
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA?AUCMapOutdoor_FOpaqueThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_FOpaqueThingInstanceRender>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 0f		 je	 SHORT $LN24@for_each
$LL13@for_each:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 370  : 		pkThingInst->Render();

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	3b fb		 cmp	 edi, ebx
  0002f	75 f1		 jne	 SHORT $LL13@for_each
$LN24@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00031	8a 45 10	 mov	 al, BYTE PTR __Func$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 36   : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_FOpaqueThingInstanceRender@@@std@@YA?AUCMapOutdoor_FOpaqueThingInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_FOpaqueThingInstanceRender>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_LessThingInstancePtrRenderOrder>, COMDAT

; 3154 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	2b d0		 sub	 edx, eax
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  0000d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00010	c1 fa 02	 sar	 edx, 2
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00013	52		 push	 edx
  00014	51		 push	 ecx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3158 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@UCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@0@0UCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >,CMapOutdoor_LessThingInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 382  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 02	 sar	 eax, 2

; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicThingInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicThingInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicThingInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 192  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 02	 sar	 eax, 2

; 195  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??__Fs_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
??__Fs_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@YAXXZ PROC ; `CMapOutdoor::RenderArea'::`33'::`dynamic atexit destructor for 's_kVct_pkOpaqueThingInstSort'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  00009	85 c0		 test	 eax, eax
  0000b	74 45		 je	 SHORT $LN5@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0000d	ff 35 04 00 00
	00		 push	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXPAPAVCGraphicThingInstance@@0@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy

; 642  : 		return (_Alty());

  0001e	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00026	ff 35 00 00 00
	00		 push	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A, 0

; 1630 : 			this->_Mylast = pointer();

  0003e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4, 0

; 1631 : 			this->_Myend = pointer();

  00048	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+8, 0
$LN5@dynamic:
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??__Fs_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@YAXXZ ENDP ; `CMapOutdoor::RenderArea'::`33'::`dynamic atexit destructor for 's_kVct_pkOpaqueThingInstSort''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UCRCNumComp@CArea@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@0UCRCNumComp@CArea@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UCRCNumComp@CArea@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@0UCRCNumComp@CArea@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::CRCNumComp>, COMDAT

; 3154 : 	{	// order [_First, _Last), using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	2b d0		 sub	 edx, eax
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  0000d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00010	c1 fa 03	 sar	 edx, 3
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00013	52		 push	 edx
  00014	51		 push	 ecx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Sort@PAUSCRCWithNumber@CArea@@HUCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort<CArea::SCRCWithNumber *,int,CArea::CRCNumComp>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 3158 : 	}

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UCRCNumComp@CArea@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@0UCRCNumComp@CArea@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@0UFFindIfCRC@CArea@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@0UFFindIfCRC@CArea@@@Z PROC ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::FFindIfCRC>, COMDAT

; 52   : 	{	// find first satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : 	_DEBUG_RANGE(_First, _Last);
; 54   : 	_DEBUG_POINTER(_Pred);
; 55   : 	return (_Rechecked(_First,
; 56   : 		_Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]

; 43   : 	for (; _First != _Last; ++_First)

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	3b d0		 cmp	 edx, eax
  0000b	74 0e		 je	 SHORT $LN32@find_if
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
$LL14@find_if:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h

; 178  : 				if (rCRCWithNumber.dwCRC == m_dwCRC)

  00010	39 0a		 cmp	 DWORD PTR [edx], ecx
  00012	74 07		 je	 SHORT $LN32@find_if
; File a:\vs\vc\include\algorithm

; 43   : 	for (; _First != _Last; ++_First)

  00014	83 c2 08	 add	 edx, 8
  00017	3b d0		 cmp	 edx, eax
  00019	75 f5		 jne	 SHORT $LL14@find_if
$LN32@find_if:

; 53   : 	_DEBUG_RANGE(_First, _Last);
; 54   : 	_DEBUG_POINTER(_Pred);
; 55   : 	return (_Rechecked(_First,
; 56   : 		_Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));

  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	89 10		 mov	 DWORD PTR [eax], edx

; 57   : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@0UFFindIfCRC@CArea@@@Z ENDP ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::FFindIfCRC>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator-, COMDAT
; _this$ = ecx

; 382  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 03	 sar	 eax, 3

; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++, COMDAT
; _this$ = ecx

; 339  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 340  : 		_Myiter _Tmp = *this;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 112  : 		++this->_Ptr;

  0000a	83 c2 08	 add	 edx, 8
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 08	 add	 DWORD PTR [ecx], 8

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEAAUSCRCWithNumber@CArea@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEAAUSCRCWithNumber@CArea@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEAAUSCRCWithNumber@CArea@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEPAUSCRCWithNumber@CArea@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEPAUSCRCWithNumber@CArea@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEPAUSCRCWithNumber@CArea@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV12@PAUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV12@PAUSCRCWithNumber@CArea@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Rechecked, COMDAT
; _this$ = ecx

; 312  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 315  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV12@PAUSCRCWithNumber@CArea@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator-, COMDAT
; _this$ = ecx

; 192  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 03	 sar	 eax, 3

; 195  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 08	 add	 DWORD PTR [ecx], 8

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEABUSCRCWithNumber@CArea@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEABUSCRCWithNumber@CArea@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBEABUSCRCWithNumber@CArea@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@PAUSCRCWithNumber@CArea@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFAreaRenderShadow@@@std@@YA?AUFAreaRenderShadow@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
tv154 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 1
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFAreaRenderShadow@@@std@@YA?AUFAreaRenderShadow@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FAreaRenderShadow>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	53		 push	 ebx
  0000a	57		 push	 edi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 db		 xor	 ebx, ebx
  00010	2b cf		 sub	 ecx, edi
  00012	83 c1 03	 add	 ecx, 3
  00015	c1 e9 02	 shr	 ecx, 2
  00018	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  0001b	0f 47 ca	 cmova	 ecx, edx
  0001e	89 4d fc	 mov	 DWORD PTR tv154[ebp], ecx

; 23   : 	for (; _First != _Last; ++_First)

  00021	85 c9		 test	 ecx, ecx
  00023	74 1b		 je	 SHORT $LN24@for_each
  00025	56		 push	 esi
$LL13@for_each:

; 24   : 		_Func(*_First);

  00026	8b 37		 mov	 esi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 304  : 		pInstance->RenderShadow();

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?RenderShadow@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RenderShadow

; 305  : 		pInstance->Hide();

  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00036	43		 inc	 ebx
  00037	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  0003a	3b 5d fc	 cmp	 ebx, DWORD PTR tv154[ebp]
  0003d	75 e7		 jne	 SHORT $LL13@for_each
  0003f	5e		 pop	 esi
$LN24@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00040	8a 45 10	 mov	 al, BYTE PTR __Func$[ebp]
  00043	5f		 pop	 edi
  00044	5b		 pop	 ebx

; 36   : 	}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFAreaRenderShadow@@@std@@YA?AUFAreaRenderShadow@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FAreaRenderShadow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerHide@@@std@@YA?AUFPCBlockerHide@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 1
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerHide@@@std@@YA?AUFPCBlockerHide@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FPCBlockerHide>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 0f		 je	 SHORT $LN24@for_each
$LL13@for_each:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 313  : 		pInstance->Hide();

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00029	47		 inc	 edi
  0002a	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002d	3b fb		 cmp	 edi, ebx
  0002f	75 f1		 jne	 SHORT $LL13@for_each
$LN24@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00031	8a 45 10	 mov	 al, BYTE PTR __Func$[ebp]
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 36   : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFPCBlockerHide@@@std@@YA?AUFPCBlockerHide@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FPCBlockerHide>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??RCMapOutdoor_FBlendThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z
_TEXT	SEGMENT
_pkThingInst$ = 8					; size = 4
??RCMapOutdoor_FBlendThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z PROC ; CMapOutdoor_FBlendThingInstanceRender::operator(), COMDAT
; _this$ = ecx

; 376  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  : 		pkThingInst->BlendRender();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkThingInst$[ebp]
  00006	e8 00 00 00 00	 call	 ?BlendRender@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::BlendRender

; 378  : 	}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??RCMapOutdoor_FBlendThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z ENDP ; CMapOutdoor_FBlendThingInstanceRender::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??RCMapOutdoor_FOpaqueThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z
_TEXT	SEGMENT
_pkThingInst$ = 8					; size = 4
??RCMapOutdoor_FOpaqueThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z PROC ; CMapOutdoor_FOpaqueThingInstanceRender::operator(), COMDAT
; _this$ = ecx

; 369  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 370  : 		pkThingInst->Render();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkThingInst$[ebp]
  00006	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render

; 371  : 	}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??RCMapOutdoor_FOpaqueThingInstanceRender@@QAEXPAVCGraphicThingInstance@@@Z ENDP ; CMapOutdoor_FOpaqueThingInstanceRender::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??RCMapOutdoor_LessThingInstancePtrRenderOrder@@QAE_NPAVCGraphicThingInstance@@0@Z
_TEXT	SEGMENT
_pkLeft$ = 8						; size = 4
_pkRight$ = 12						; size = 4
??RCMapOutdoor_LessThingInstancePtrRenderOrder@@QAE_NPAVCGraphicThingInstance@@0@Z PROC ; CMapOutdoor_LessThingInstancePtrRenderOrder::operator(), COMDAT
; _this$ = ecx

; 355  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  : 		//TODO : Camera 
; 357  : 		CCamera * pCurrentCamera = CCameraManager::Instance().GetCurrentCamera();

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 358  : 		const D3DXVECTOR3 & c_rv3CameraPos = pCurrentCamera->GetEye();
; 359  : 		const D3DXVECTOR3 & c_v3LeftPos  = pkLeft->GetPosition();

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  00013	8b f8		 mov	 edi, eax
  00015	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 360  : 		const D3DXVECTOR3 & c_v3RightPos = pkRight->GetPosition();

  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _pkRight$[ebp]
  0001d	8b f0		 mov	 esi, eax
  0001f	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 6f 30	 movss	 xmm5, DWORD PTR [edi+48]
  00029	f3 0f 10 5f 34	 movss	 xmm3, DWORD PTR [edi+52]
  0002e	0f 28 e5	 movaps	 xmm4, xmm5
  00031	f3 0f 5c 26	 subss	 xmm4, DWORD PTR [esi]
  00035	f3 0f 5c 28	 subss	 xmm5, DWORD PTR [eax]
  00039	f3 0f 10 57 38	 movss	 xmm2, DWORD PTR [edi+56]
  0003e	0f 28 cb	 movaps	 xmm1, xmm3
  00041	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
  00046	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [esi+4]
  0004b	0f 28 c2	 movaps	 xmm0, xmm2

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0004e	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00052	5f		 pop	 edi

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00053	f3 0f 5c 50 08	 subss	 xmm2, DWORD PTR [eax+8]
  00058	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0005d	f3 0f 59 ed	 mulss	 xmm5, xmm5
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  00061	33 c0		 xor	 eax, eax
  00063	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00064	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00068	f3 0f 59 db	 mulss	 xmm3, xmm3
  0006c	f3 0f 58 e1	 addss	 xmm4, xmm1
  00070	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00074	f3 0f 58 eb	 addss	 xmm5, xmm3
  00078	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0007c	f3 0f 58 e0	 addss	 xmm4, xmm0
  00080	f3 0f 58 ea	 addss	 xmm5, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 362  : 		return D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3LeftPos)) < D3DXVec3LengthSq(&D3DXVECTOR3(c_rv3CameraPos - c_v3RightPos) );	

  00084	0f 2f ec	 comiss	 xmm5, xmm4
  00087	0f 97 c0	 seta	 al

; 363  : 	}

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
??RCMapOutdoor_LessThingInstancePtrRenderOrder@@QAE_NPAVCGraphicThingInstance@@0@Z ENDP ; CMapOutdoor_LessThingInstancePtrRenderOrder::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??RFRenderPCBlocker@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pInstance$ = 8						; size = 4
??RFRenderPCBlocker@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; FRenderPCBlocker::operator(), COMDAT
; _this$ = ecx

; 320  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 321  : 		pInstance->Show();

  00005	8b 7d 08	 mov	 edi, DWORD PTR _pInstance$[ebp]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 ?Show@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Show

; 322  : 		CGraphicThingInstance* pThingInstance = dynamic_cast <CGraphicThingInstance*> (pInstance);

  0000f	6a 00		 push	 0
  00011	68 00 00 00 00	 push	 OFFSET ??_R0?AVCGraphicThingInstance@@@8
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVCGraphicObjectInstance@@@8
  0001b	6a 00		 push	 0
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ___RTDynamicCast
  00023	8b f0		 mov	 esi, eax
  00025	83 c4 14	 add	 esp, 20			; 00000014H

; 323  : 		if (pThingInstance != NULL)

  00028	85 f6		 test	 esi, esi
  0002a	74 29		 je	 SHORT $LN1@operator

; 324  : 		{
; 325  : 			if (pThingInstance->HaveBlendThing())

  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?HaveBlendThing@CGraphicThingInstance@@QAE_NXZ ; CGraphicThingInstance::HaveBlendThing
  00033	84 c0		 test	 al, al
  00035	74 1e		 je	 SHORT $LN1@operator

; 326  : 			{
; 327  : 				STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0003d	6a 01		 push	 1
  0003f	6a 04		 push	 4
  00041	6a 01		 push	 1
  00043	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 328  : 				pThingInstance->BlendRender();

  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?BlendRender@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::BlendRender
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 335  : 	}

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN1@operator:

; 329  : 				return;
; 330  : 			}
; 331  : 		}
; 332  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005b	6a 02		 push	 2
  0005d	6a 04		 push	 4
  0005f	6a 01		 push	 1
  00061	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 333  : 
; 334  : 		pInstance->RenderPCBlocker();

  00066	8b cf		 mov	 ecx, edi
  00068	e8 00 00 00 00	 call	 ?RenderPCBlocker@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RenderPCBlocker
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 335  : 	}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
??RFRenderPCBlocker@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; FRenderPCBlocker::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??RFPCBlockerHide@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pInstance$ = 8						; size = 4
??RFPCBlockerHide@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; FPCBlockerHide::operator(), COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		pInstance->Hide();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  00006	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide

; 314  : 	}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??RFPCBlockerHide@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; FPCBlockerHide::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??RFAreaRenderShadow@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_pInstance$ = 8						; size = 4
??RFAreaRenderShadow@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; FAreaRenderShadow::operator(), COMDAT
; _this$ = ecx

; 303  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  : 		pInstance->RenderShadow();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  00006	e8 00 00 00 00	 call	 ?RenderShadow@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RenderShadow

; 305  : 		pInstance->Hide();

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  0000e	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide

; 306  : 	}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??RFAreaRenderShadow@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; FAreaRenderShadow::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ?swap@?$pair@MJ@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$pair@MJ@std@@QAEXAAU12@@Z PROC			; std::pair<float,long>::swap, COMDAT
; _this$ = ecx

; 183  : 		{	// exchange contents with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 184  : 		if (this != &_Right)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	8b d1		 mov	 edx, ecx
  00009	3b d6		 cmp	 edx, esi
  0000b	74 18		 je	 SHORT $LN16@swap

; 53   : 	_Left = _Move(_Right);

  0000d	8b 06		 mov	 eax, DWORD PTR [esi]
  0000f	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00013	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00015	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0

; 52   : 	_Ty _Tmp = _Move(_Left);

  00019	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 53   : 	_Left = _Move(_Right);

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00022	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN16@swap:
  00025	5e		 pop	 esi

; 185  : 			{	// different, worth swapping
; 186  : 			_Swap_adl(first, _Right.first);
; 187  : 			_Swap_adl(second, _Right.second);
; 188  : 			}
; 189  : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?swap@?$pair@MJ@std@@QAEXAAU12@@Z ENDP			; std::pair<float,long>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??4?$pair@MJ@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$pair@MJ@std@@QAEAAU01@$$QAU01@@Z PROC		; std::pair<float,long>::operator=, COMDAT
; _this$ = ecx

; 174  : 		{	// assign from moved pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 175  : 		first = _STD forward<_Ty1>(_Right.first);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 176  : 		second = _STD forward<_Ty2>(_Right.second);

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 177  : 		return (*this);

  00010	8b c1		 mov	 eax, ecx

; 178  : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??4?$pair@MJ@std@@QAEAAU01@$$QAU01@@Z ENDP		; std::pair<float,long>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$make_pair@AAMAAJ@std@@YA?AU?$pair@MJ@0@AAMAAJ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@AAMAAJ@std@@YA?AU?$pair@MJ@0@AAMAAJ@Z PROC	; std::make_pair<float &,long &>, COMDAT

; 268  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 144  : 		{	// construct from moved values

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 269  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 270  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 271  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),
; 272  : 		_STD forward<_Ty2>(_Val2)));
; 273  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@AAMAAJ@std@@YA?AU?$pair@MJ@0@AAMAAJ@Z ENDP	; std::make_pair<float &,long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > > >, COMDAT

; 3163 : 	{	// order [_First, _Last), using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00007	8b d1		 mov	 edx, ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	2b d0		 sub	 edx, eax
; File a:\vs\vc\include\algorithm

; 3164 : 	_STD sort(_First, _Last, less<>());

  0000e	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00012	ff 75 fc	 push	 DWORD PTR $T1[ebp]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00015	c1 fa 03	 sar	 edx, 3
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00018	52		 push	 edx
  00019	51		 push	 ecx
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z ; std::_Sort<std::pair<float,long> *,int,std::less<void> >
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 3165 : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator-, COMDAT
; _this$ = ecx

; 382  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 03	 sar	 eax, 3

; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 08	 add	 DWORD PTR [ecx], 8

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEAAU?$pair@MJ@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@2@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@2@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEPAU?$pair@MJ@2@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 301  : 		{	// construct with null vector pointer
; 302  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator-, COMDAT
; _this$ = ecx

; 192  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	c1 f8 03	 sar	 eax, 3

; 195  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 08	 add	 DWORD PTR [ecx], 8

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QBEABU?$pair@MJ@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 43   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??__F?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
??__F?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00009	85 c0		 test	 eax, eax
  0000b	74 45		 je	 SHORT $LN5@m_TerrainN

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0000d	ff 35 04 00 00
	00		 push	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 642  : 		return (_Alty());

  0001e	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00026	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A, 0

; 1630 : 			this->_Mylast = pointer();

  0003e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4, 0

; 1631 : 			this->_Myend = pointer();

  00048	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+8, 0
$LN5@m_TerrainN:
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??__F?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??__E?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector'', COMDAT

; 15   : CMapOutdoor::TTerrainNumVector CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector''
text$di	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??__Fm_dwRenderedCRCWithNumberVector@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
??__Fm_dwRenderedCRCWithNumberVector@@YAXXZ PROC	; `dynamic atexit destructor for 'm_dwRenderedCRCWithNumberVector'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A
  00009	85 c0		 test	 eax, eax
  0000b	74 45		 je	 SHORT $LN5@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0000d	ff 35 04 00 00
	00		 push	 DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A+4
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A ; m_dwRenderedCRCWithNumberVector
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXPAUSCRCWithNumber@CArea@@0@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy

; 642  : 		return (_Alty());

  0001e	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00021	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00026	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00034	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A, 0

; 1630 : 			this->_Mylast = pointer();

  0003e	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A+4, 0

; 1631 : 			this->_Myend = pointer();

  00048	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A+8, 0
$LN5@dynamic:
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??__Fm_dwRenderedCRCWithNumberVector@@YAXXZ ENDP	; `dynamic atexit destructor for 'm_dwRenderedCRCWithNumberVector''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ??__Em_dwRenderedCRCWithNumberVector@@YAXXZ
text$di	SEGMENT
??__Em_dwRenderedCRCWithNumberVector@@YAXXZ PROC	; `dynamic initializer for 'm_dwRenderedCRCWithNumberVector'', COMDAT

; 13   : CArea::TCRCWithNumberVector m_dwRenderedCRCWithNumberVector;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fm_dwRenderedCRCWithNumberVector@@YAXXZ ; `dynamic atexit destructor for 'm_dwRenderedCRCWithNumberVector''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Em_dwRenderedCRCWithNumberVector@@YAXXZ ENDP	; `dynamic initializer for 'm_dwRenderedCRCWithNumberVector''
text$di	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ PROC ; CSingleton<CStateManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ENDP ; CSingleton<CStateManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ PROC ; CSingleton<CCameraManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ENDP ; CSingleton<CCameraManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetInverseViewMatrix@CCamera@@QBEABUD3DXMATRIX@@XZ
_TEXT	SEGMENT
?GetInverseViewMatrix@CCamera@@QBEABUD3DXMATRIX@@XZ PROC ; CCamera::GetInverseViewMatrix, COMDAT
; _this$ = ecx

; 175  : 		const D3DXMATRIX & GetInverseViewMatrix() const	{ return m_matInverseView; }

  00000	8d 81 ac 00 00
	00		 lea	 eax, DWORD PTR [ecx+172]
  00006	c3		 ret	 0
?GetInverseViewMatrix@CCamera@@QBEABUD3DXMATRIX@@XZ ENDP ; CCamera::GetInverseViewMatrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetTarget, COMDAT
; _this$ = ecx

; 169  : 		const D3DXVECTOR3 & GetTarget() const	{ return m_v3Target; }

  00000	8d 41 3c	 lea	 eax, DWORD PTR [ecx+60]
  00003	c3		 ret	 0
?GetTarget@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetTarget
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetEye, COMDAT
; _this$ = ecx

; 168  : 		const D3DXVECTOR3 & GetEye() const		{ return m_v3Eye; }

  00000	8d 41 30	 lea	 eax, DWORD PTR [ecx+48]
  00003	c3		 ret	 0
?GetEye@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetEye
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@E@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@0ABE@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@E@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@0ABE@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char>, COMDAT

; 3051 : 	{	// find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2992 : 	return (_Val <= UCHAR_MAX);

  00003	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  00007	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  0000a	8a 00		 mov	 al, BYTE PTR [eax]
  0000c	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  0000e	77 1a		 ja	 SHORT $LN26@find

; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  00010	0f b6 d0	 movzx	 edx, al
  00013	8b ce		 mov	 ecx, esi
  00015	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00018	2b c8		 sub	 ecx, eax
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  0001a	51		 push	 ecx
  0001b	52		 push	 edx
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _memchr
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  00025	85 c0		 test	 eax, eax
  00027	0f 45 f0	 cmovne	 esi, eax
$LN26@find:

; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));

  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	89 30		 mov	 DWORD PTR [eax], esi
  0002f	5e		 pop	 esi

; 3055 : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@E@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@V10@0ABE@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator-, COMDAT
; _this$ = ecx

; 382  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPAEXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV12@PAE@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV12@PAE@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Rechecked, COMDAT
; _this$ = ecx

; 312  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 315  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV12@PAE@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator-, COMDAT
; _this$ = ecx

; 192  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 195  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?__RenderTerrain_AppendPatch@CMapOutdoor@@IAEXABUD3DXVECTOR3@@MJ@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_c_rv3Center$ = 8					; size = 4
_fDistance$ = 12					; size = 4
_lPatchNum$ = 16					; size = 4
?__RenderTerrain_AppendPatch@CMapOutdoor@@IAEXABUD3DXVECTOR3@@MJ@Z PROC ; CMapOutdoor::__RenderTerrain_AppendPatch, COMDAT
; _this$ = ecx

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 123  : 	if (!m_pTerrainPatchProxyList[lPatchNum].isUsed())

  00007	8b 75 10	 mov	 esi, DWORD PTR _lPatchNum$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 14 f5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*8]
  00014	2b d6		 sub	 edx, esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  00016	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 123  : 	if (!m_pTerrainPatchProxyList[lPatchNum].isUsed())

  00019	80 7c 90 04 00	 cmp	 BYTE PTR [eax+edx*4+4], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  0001e	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 123  : 	if (!m_pTerrainPatchProxyList[lPatchNum].isUsed())

  00021	74 24		 je	 SHORT $LN2@RenderTerr

; 124  : 		return;
; 125  : 
; 126  : 	m_pTerrainPatchProxyList[lPatchNum].SetCenterPosition(c_rv3Center);

  00023	ff 75 08	 push	 DWORD PTR _c_rv3Center$[ebp]
  00026	e8 00 00 00 00	 call	 ?SetCenterPosition@CTerrainPatchProxy@@QAEXABUD3DXVECTOR3@@@Z ; CTerrainPatchProxy::SetCenterPosition
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0002b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 127  : 	m_PatchVector.push_back(std::make_pair(fDistance, lPatchNum));

  00030	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00033	50		 push	 eax
  00034	8d 8f 18 01 00
	00		 lea	 ecx, DWORD PTR [edi+280]
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0003a	f3 0f 11 45 f8	 movss	 DWORD PTR $T1[ebp], xmm0
  0003f	89 75 fc	 mov	 DWORD PTR $T1[ebp+4], esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 127  : 	m_PatchVector.push_back(std::make_pair(fDistance, lPatchNum));

  00042	e8 00 00 00 00	 call	 ?push_back@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEX$$QAU?$pair@MJ@2@@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::push_back
$LN2@RenderTerr:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 128  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 0c 00	 ret	 12			; 0000000cH
?__RenderTerrain_AppendPatch@CMapOutdoor@@IAEXABUD3DXVECTOR3@@MJ@Z ENDP ; CMapOutdoor::__RenderTerrain_AppendPatch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle@CMapOutdoor@@IAEHABUD3DXVECTOR3@@ABM@Z
_TEXT	SEGMENT
_distance$ = -28					; size = 24
_center$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_c_v3Center$ = 8					; size = 4
_c_fRadius$ = 12					; size = 4
?__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle@CMapOutdoor@@IAEHABUD3DXVECTOR3@@ABM@Z PROC ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 96   : 	const int count = 6;
; 97   : 
; 98   : 	D3DXVECTOR3 center = c_v3Center;

  00010	8b 45 08	 mov	 eax, DWORD PTR _c_v3Center$[ebp]

; 99   : 	center.y = -center.y;
; 100  : 
; 101  : 	int i;
; 102  : 
; 103  : 	float distance[count];
; 104  : 	for(i = 0; i < count; ++i)

  00013	33 d2		 xor	 edx, edx
  00015	81 c1 24 02 00
	00		 add	 ecx, 548		; 00000224H
  0001b	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0001f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00022	89 45 f8	 mov	 DWORD PTR _center$[ebp+8], eax

; 107  : 		if (distance[i] <= -c_fRadius) 

  00025	8b 45 0c	 mov	 eax, DWORD PTR _c_fRadius$[ebp]
  00028	f3 0f 10 6d f8	 movss	 xmm5, DWORD PTR _center$[ebp+8]
  0002d	66 0f d6 45 f0	 movq	 QWORD PTR _center$[ebp], xmm0
  00032	f3 0f 10 5d f4	 movss	 xmm3, DWORD PTR _center$[ebp+4]
  00037	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0003b	0f 57 1d 00 00
	00 00		 xorps	 xmm3, DWORD PTR __xmm@80000000800000008000000080000000
  00042	0f 28 e2	 movaps	 xmm4, xmm2
  00045	0f 57 25 00 00
	00 00		 xorps	 xmm4, DWORD PTR __xmm@80000000800000008000000080000000
  0004c	f3 0f 10 75 f0	 movss	 xmm6, DWORD PTR _center$[ebp]
$LL8@RenderTerr:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00051	f3 0f 10 41 fc	 movss	 xmm0, DWORD PTR [ecx-4]
  00056	f3 0f 10 49 f8	 movss	 xmm1, DWORD PTR [ecx-8]
  0005b	f3 0f 59 ce	 mulss	 xmm1, xmm6
  0005f	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00063	f3 0f 58 c8	 addss	 xmm1, xmm0
  00067	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0006b	f3 0f 59 c5	 mulss	 xmm0, xmm5
  0006f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00073	f3 0f 58 49 04	 addss	 xmm1, DWORD PTR [ecx+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 107  : 		if (distance[i] <= -c_fRadius) 

  00078	0f 2f e1	 comiss	 xmm4, xmm1
  0007b	f3 0f 11 4c 95
	e4		 movss	 DWORD PTR _distance$[ebp+edx*4], xmm1
  00081	73 44		 jae	 SHORT $LN15@RenderTerr

; 99   : 	center.y = -center.y;
; 100  : 
; 101  : 	int i;
; 102  : 
; 103  : 	float distance[count];
; 104  : 	for(i = 0; i < count; ++i)

  00083	42		 inc	 edx
  00084	83 c1 10	 add	 ecx, 16			; 00000010H
  00087	83 fa 06	 cmp	 edx, 6
  0008a	7c c5		 jl	 SHORT $LL8@RenderTerr

; 108  : 			return VIEW_NONE;
; 109  : 	}
; 110  : 
; 111  : 	for(i = 0; i < count;++i)

  0008c	33 c0		 xor	 eax, eax
  0008e	8b ff		 npad	 2
$LL4@RenderTerr:

; 112  : 	{
; 113  : 		if (distance[i] <= c_fRadius) 

  00090	0f 2f 54 85 e4	 comiss	 xmm2, DWORD PTR _distance$[ebp+eax*4]
  00095	73 1b		 jae	 SHORT $LN16@RenderTerr

; 108  : 			return VIEW_NONE;
; 109  : 	}
; 110  : 
; 111  : 	for(i = 0; i < count;++i)

  00097	40		 inc	 eax
  00098	83 f8 06	 cmp	 eax, 6
  0009b	7c f3		 jl	 SHORT $LL4@RenderTerr

; 115  : 	}
; 116  : 	
; 117  : 	return VIEW_ALL;

  0009d	b8 02 00 00 00	 mov	 eax, 2

; 118  : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
$LN16@RenderTerr:

; 114  : 			return VIEW_PART;

  000b2	b8 01 00 00 00	 mov	 eax, 1

; 118  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 08 00	 ret	 8
$LN15@RenderTerr:
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	33 c0		 xor	 eax, eax
  000cc	33 cd		 xor	 ecx, ebp
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 08 00	 ret	 8
?__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle@CMapOutdoor@@IAEHABUD3DXVECTOR3@@ABM@Z ENDP ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z
_TEXT	SEGMENT
_fDistance$1 = -20					; size = 4
_v3Center$2 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_Node$ = 8						; size = 4
_bCullCheckNeed$ = 12					; size = 1
?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z PROC ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _Node$[ebp]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx
$LL23@RenderTerr:

; 57   : 	if (bCullCheckNeed)

  00017	80 7d 0c 00	 cmp	 BYTE PTR _bCullCheckNeed$[ebp], 0
  0001b	74 20		 je	 SHORT $LN10@RenderTerr

; 58   : 	{
; 59   : 		switch (__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle(Node->center, Node->radius))

  0001d	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  00020	8b cf		 mov	 ecx, edi
  00022	50		 push	 eax
  00023	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle@CMapOutdoor@@IAEHABUD3DXVECTOR3@@ABM@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle
  0002c	83 e8 00	 sub	 eax, 0
  0002f	0f 84 d7 00 00
	00		 je	 $LN1@RenderTerr
  00035	83 e8 02	 sub	 eax, 2
  00038	75 03		 jne	 SHORT $LN10@RenderTerr

; 60   : 		{
; 61   : 			case VIEW_ALL:
; 62   : 				// all child nodes need not cull check
; 63   : 				bCullCheckNeed = false;

  0003a	88 45 0c	 mov	 BYTE PTR _bCullCheckNeed$[ebp], al
$LN10@RenderTerr:

; 64   : 				break;
; 65   : 			case VIEW_PART:
; 66   : 				break;
; 67   : 			case VIEW_NONE:
; 68   : 				// no need to render
; 69   : 				return;
; 70   : 		}
; 71   : 		// if no need cull check more
; 72   : 		// -> bCullCheckNeed = false;
; 73   : 	}
; 74   : 	
; 75   : 	if (Node->Size == 1)

  0003d	83 7e 24 01	 cmp	 DWORD PTR [esi+36], 1
  00041	74 4f		 je	 SHORT $LN25@RenderTerr

; 80   : 	}
; 81   : 	else
; 82   : 	{
; 83   : 		if (Node->NW_Node != NULL)

  00043	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00046	85 c0		 test	 eax, eax
  00048	74 0b		 je	 SHORT $LN4@RenderTerr

; 84   : 			__RenderTerrain_RecurseRenderQuadTree(Node->NW_Node, bCullCheckNeed);

  0004a	ff 75 0c	 push	 DWORD PTR _bCullCheckNeed$[ebp]
  0004d	8b cf		 mov	 ecx, edi
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree
$LN4@RenderTerr:

; 85   : 		if (Node->NE_Node != NULL)

  00055	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00058	85 c0		 test	 eax, eax
  0005a	74 0b		 je	 SHORT $LN3@RenderTerr

; 86   : 			__RenderTerrain_RecurseRenderQuadTree(Node->NE_Node, bCullCheckNeed);

  0005c	ff 75 0c	 push	 DWORD PTR _bCullCheckNeed$[ebp]
  0005f	8b cf		 mov	 ecx, edi
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree
$LN3@RenderTerr:

; 87   : 		if (Node->SW_Node != NULL)

  00067	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0006a	85 c0		 test	 eax, eax
  0006c	74 0b		 je	 SHORT $LN2@RenderTerr

; 88   : 			__RenderTerrain_RecurseRenderQuadTree(Node->SW_Node, bCullCheckNeed);

  0006e	ff 75 0c	 push	 DWORD PTR _bCullCheckNeed$[ebp]
  00071	8b cf		 mov	 ecx, edi
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree
$LN2@RenderTerr:

; 89   : 		if (Node->SE_Node != NULL)

  00079	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  0007c	85 f6		 test	 esi, esi
  0007e	75 97		 jne	 SHORT $LL23@RenderTerr
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi

; 90   : 			__RenderTerrain_RecurseRenderQuadTree(Node->SE_Node, bCullCheckNeed);
; 91   : 	}
; 92   : }

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	33 cd		 xor	 ecx, ebp
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
$LN25@RenderTerr:

; 76   : 	{
; 77   : 		D3DXVECTOR3 v3Center = Node->center;

  00092	f3 0f 7e 46 2c	 movq	 xmm0, QWORD PTR [esi+44]

; 78   : 		float fDistance = fMAX(fabs(v3Center.x + m_fXforDistanceCaculation), fabs(-v3Center.y + m_fYforDistanceCaculation));

  00097	83 ec 08	 sub	 esp, 8
  0009a	66 0f d6 45 f0	 movq	 QWORD PTR _v3Center$2[ebp], xmm0
  0009f	f3 0f 10 87 14
	09 00 00	 movss	 xmm0, DWORD PTR [edi+2324]
  000a7	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _v3Center$2[ebp+4]
  000ac	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000af	89 45 f8	 mov	 DWORD PTR _v3Center$2[ebp+8], eax
; File a:\vs\vc\include\math.h

; 687  :     return (float)fabs(_X);

  000b2	0f 5a c0	 cvtps2pd xmm0, xmm0
  000b5	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  000bd	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 78   : 		float fDistance = fMAX(fabs(v3Center.x + m_fXforDistanceCaculation), fabs(-v3Center.y + m_fYforDistanceCaculation));

  000c1	f3 0f 10 87 10
	09 00 00	 movss	 xmm0, DWORD PTR [edi+2320]
  000c9	f3 0f 58 45 f0	 addss	 xmm0, DWORD PTR _v3Center$2[ebp]
  000ce	f3 0f 11 54 24
	04		 movss	 DWORD PTR [esp+4], xmm2
; File a:\vs\vc\include\math.h

; 687  :     return (float)fabs(_X);

  000d4	0f 5a c0	 cvtps2pd xmm0, xmm0
  000d7	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  000df	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 78   : 		float fDistance = fMAX(fabs(v3Center.x + m_fXforDistanceCaculation), fabs(-v3Center.y + m_fYforDistanceCaculation));

  000e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e8	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  000ed	83 c4 08	 add	 esp, 8

; 79   : 		__RenderTerrain_AppendPatch(v3Center, fDistance, Node->PatchNum);

  000f0	8d 45 f0	 lea	 eax, DWORD PTR _v3Center$2[ebp]
  000f3	d9 5d ec	 fstp	 DWORD PTR _fDistance$1[ebp]
  000f6	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fDistance$1[ebp]
  000fb	ff 76 28	 push	 DWORD PTR [esi+40]
  000fe	51		 push	 ecx
  000ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00104	8b cf		 mov	 ecx, edi
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ?__RenderTerrain_AppendPatch@CMapOutdoor@@IAEXABUD3DXVECTOR3@@MJ@Z ; CMapOutdoor::__RenderTerrain_AppendPatch
$LN1@RenderTerr:

; 90   : 			__RenderTerrain_RecurseRenderQuadTree(Node->SE_Node, bCullCheckNeed);
; 91   : 	}
; 92   : }

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010f	5f		 pop	 edi
  00110	33 cd		 xor	 ecx, ebp
  00112	5e		 pop	 esi
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 08 00	 ret	 8
?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z ENDP ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?__GetFogDistance@CMapOutdoor@@IAEMXZ
_TEXT	SEGMENT
tv132 = -4						; size = 4
?__GetFogDistance@CMapOutdoor@@IAEMXZ PROC		; CMapOutdoor::__GetFogDistance, COMDAT
; _this$ = ecx

; 741  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 742  : 	return (float)(CTerrainImpl::CELLSCALE * m_lViewRadius) * 0.75f;

  00004	69 41 68 c8 00
	00 00		 imul	 eax, DWORD PTR [ecx+104], 200
  0000b	66 0f 6e c0	 movd	 xmm0, eax
  0000f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00012	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f400000
  0001a	f3 0f 11 45 fc	 movss	 DWORD PTR tv132[ebp], xmm0
  0001f	d9 45 fc	 fld	 DWORD PTR tv132[ebp]

; 743  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?__GetFogDistance@CMapOutdoor@@IAEMXZ ENDP		; CMapOutdoor::__GetFogDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?__GetNoFogDistance@CMapOutdoor@@IAEMXZ
_TEXT	SEGMENT
tv132 = -4						; size = 4
?__GetNoFogDistance@CMapOutdoor@@IAEMXZ PROC		; CMapOutdoor::__GetNoFogDistance, COMDAT
; _this$ = ecx

; 736  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 737  : 	return (float)(CTerrainImpl::CELLSCALE * m_lViewRadius) * 0.5f;

  00004	69 41 68 c8 00
	00 00		 imul	 eax, DWORD PTR [ecx+104], 200
  0000b	66 0f 6e c0	 movd	 xmm0, eax
  0000f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00012	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0001a	f3 0f 11 45 fc	 movss	 DWORD PTR tv132[ebp], xmm0
  0001f	d9 45 fc	 fld	 DWORD PTR tv132[ebp]

; 738  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?__GetNoFogDistance@CMapOutdoor@@IAEMXZ ENDP		; CMapOutdoor::__GetNoFogDistance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z
_TEXT	SEGMENT
_ePart$ = 8						; size = 4
?IsVisiblePart@CMapOutdoor@@IAE_NH@Z PROC		; CMapOutdoor::IsVisiblePart, COMDAT
; _this$ = ecx

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 160  : 	DWORD dwMask=(1<<ePart);

  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _ePart$[ebp]
  0000d	d3 e0		 shl	 eax, cl

; 161  : 	if (dwMask & m_dwVisiblePartFlags)

  0000f	85 82 80 09 00
	00		 test	 eax, DWORD PTR [edx+2432]
  00015	0f 95 c0	 setne	 al

; 162  : 		return true;
; 163  : 
; 164  : 	return false;
; 165  : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ENDP		; CMapOutdoor::IsVisiblePart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?InitializeVisibleParts@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
?InitializeVisibleParts@CMapOutdoor@@IAEXXZ PROC	; CMapOutdoor::InitializeVisibleParts, COMDAT
; _this$ = ecx

; 139  : 	m_dwVisiblePartFlags=0xffffffff;

  00000	c7 81 80 09 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+2432], -1

; 140  : }

  0000a	c3		 ret	 0
?InitializeVisibleParts@CMapOutdoor@@IAEXXZ ENDP	; CMapOutdoor::InitializeVisibleParts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
_byLODLevel$ = 8					; size = 1
_pwPrimitiveCount$ = 12					; size = 4
_pePrimitiveType$ = 16					; size = 4
?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::SelectIndexBuffer, COMDAT
; _this$ = ecx

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 659  : #ifdef WORLD_EDITOR
; 660  : 	*pwPrimitiveCount = m_wNumIndices - 2;
; 661  : 	*pePrimitiveType = D3DPT_TRIANGLESTRIP;
; 662  : 	STATEMANAGER.SetIndices(m_IndexBuffer.GetD3DIndexBuffer(), 0);
; 663  : #else
; 664  : 	if (0 == byLODLevel)

  00004	8a 5d 08	 mov	 bl, BYTE PTR _byLODLevel$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	84 db		 test	 bl, bl
  0000d	75 1c		 jne	 SHORT $LN2@SelectInde

; 665  : 	{
; 666  : 		*pwPrimitiveCount = m_wNumIndices[byLODLevel] - 2;

  0000f	66 8b 97 d8 00
	00 00		 mov	 dx, WORD PTR [edi+216]
  00016	8b 45 0c	 mov	 eax, DWORD PTR _pwPrimitiveCount$[ebp]
  00019	66 83 ea 02	 sub	 dx, 2
  0001d	66 89 10	 mov	 WORD PTR [eax], dx

; 667  : 		*pePrimitiveType = D3DPT_TRIANGLESTRIP;

  00020	8b 45 10	 mov	 eax, DWORD PTR _pePrimitiveType$[ebp]
  00023	c7 00 05 00 00
	00		 mov	 DWORD PTR [eax], 5

; 668  : 	}
; 669  : 	else

  00029	eb 28		 jmp	 SHORT $LN1@SelectInde
$LN2@SelectInde:

; 670  : 	{
; 671  : 		*pwPrimitiveCount =  m_wNumIndices[byLODLevel]/3;

  0002b	0f b6 c3	 movzx	 eax, bl
  0002e	0f b7 8c 47 d8
	00 00 00	 movzx	 ecx, WORD PTR [edi+eax*2+216]
  00036	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0003b	f7 e9		 imul	 ecx
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _pwPrimitiveCount$[ebp]
  00040	8b ca		 mov	 ecx, edx
  00042	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00045	03 ca		 add	 ecx, edx
  00047	66 89 08	 mov	 WORD PTR [eax], cx

; 672  : 		*pePrimitiveType = D3DPT_TRIANGLELIST;

  0004a	8b 45 10	 mov	 eax, DWORD PTR _pePrimitiveType$[ebp]
  0004d	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], 4
$LN1@SelectInde:
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  00053	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 674  : 	STATEMANAGER.SetIndices(m_IndexBuffer[byLODLevel].GetD3DIndexBuffer(), 0);

  00059	0f b6 c3	 movzx	 eax, bl
  0005c	6a 00		 push	 0
  0005e	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00061	8d 40 27	 lea	 eax, DWORD PTR [eax+39]
  00064	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  00067	e8 00 00 00 00	 call	 ?GetD3DIndexBuffer@CGraphicIndexBuffer@@QBEPAUIDirect3DIndexBuffer8@@XZ ; CGraphicIndexBuffer::GetD3DIndexBuffer
  0006c	50		 push	 eax
  0006d	8b ce		 mov	 ecx, esi
  0006f	e8 00 00 00 00	 call	 ?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z ; CStateManager::SetIndices
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 675  : #endif
; 676  : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::SelectIndexBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
_patchnum$ = 8						; size = 4
_wPrimitiveCount$ = 12					; size = 2
_ePrimitiveType$ = 16					; size = 4
?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::DrawWireFrame, COMDAT
; _this$ = ecx

; 781  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::DrawWireFrame");
; 783  : 
; 784  : 	CTerrainPatchProxy * pTerrainPatchProxy= &m_pTerrainPatchProxyList[patchnum];

  00003	8b 45 08	 mov	 eax, DWORD PTR _patchnum$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00010	2b d0		 sub	 edx, eax
  00012	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]

; 785  : 
; 786  : 	if (!pTerrainPatchProxy->isUsed())

  00015	80 7c 90 04 00	 cmp	 BYTE PTR [eax+edx*4+4], 0
  0001a	0f 84 05 01 00
	00		 je	 $LN4@DrawWireFr

; 787  : 		return;
; 788  : 
; 789  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();
; 790  : 	if (sPatchNum < 0)

  00020	66 83 7c 90 06
	00		 cmp	 WORD PTR [eax+edx*4+6], 0
  00026	0f 8c f9 00 00
	00		 jl	 $LN4@DrawWireFr

; 791  : 		return;
; 792  : 	BYTE ucTerrainNum = pTerrainPatchProxy->GetTerrainNum();
; 793  : 	if (0xFF == ucTerrainNum)

  0002c	80 7c 90 08 ff	 cmp	 BYTE PTR [eax+edx*4+8], 255 ; 000000ffH
  00031	0f 84 ee 00 00
	00		 je	 $LN4@DrawWireFr

; 794  : 		return;
; 795  : 
; 796  : 	DWORD dwFillMode = STATEMANAGER.GetRenderState(D3DRS_FILLMODE);

  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0003d	56		 push	 esi
  0003e	57		 push	 edi
  0003f	6a 08		 push	 8
  00041	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 797  : 	STATEMANAGER.SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);

  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004c	8b f8		 mov	 edi, eax
  0004e	6a 02		 push	 2
  00050	6a 08		 push	 8
  00052	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 798  : 
; 799  : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005d	6a 1c		 push	 28			; 0000001cH
  0005f	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 800  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006a	8b f0		 mov	 esi, eax
  0006c	6a 00		 push	 0
  0006e	6a 1c		 push	 28			; 0000001cH
  00070	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 801  : 	
; 802  : 	STATEMANAGER.SetTexture(0, NULL);

  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007b	6a 00		 push	 0
  0007d	6a 00		 push	 0
  0007f	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 803  : 	STATEMANAGER.SetTexture(1, NULL);

  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008a	6a 00		 push	 0
  0008c	6a 01		 push	 1
  0008e	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 804  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);

  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00099	6a 01		 push	 1
  0009b	6a 01		 push	 1
  0009d	6a 00		 push	 0
  0009f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 805  : 
; 806  : 	STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  000a4	8b 45 0c	 mov	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ad	0f b7 c0	 movzx	 eax, ax
  000b0	50		 push	 eax
  000b1	6a 00		 push	 0
  000b3	ff b3 a0 09 00
	00		 push	 DWORD PTR [ebx+2464]
  000b9	6a 00		 push	 0
  000bb	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  000be	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 807  : 
; 808  : 	STATEMANAGER.SetRenderState(D3DRS_FILLMODE, dwFillMode);

  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000c9	57		 push	 edi
  000ca	6a 08		 push	 8
  000cc	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 809  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d7	56		 push	 esi
  000d8	6a 1c		 push	 28			; 0000001cH
  000da	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 810  : 
; 811  :  	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e5	6a 02		 push	 2
  000e7	6a 02		 push	 2
  000e9	6a 00		 push	 0
  000eb	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 812  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  000f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f6	6a 01		 push	 1
  000f8	6a 03		 push	 3
  000fa	6a 00		 push	 0
  000fc	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx

; 813  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);	

  00104	c7 45 10 04 00
	00 00		 mov	 DWORD PTR _ePrimitiveType$[ebp], 4
  0010b	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _wPrimitiveCount$[ebp], 1
  00112	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _patchnum$[ebp], 0
  00119	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 814  : }

  0011f	5d		 pop	 ebp

; 813  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);	

  00120	e9 00 00 00 00	 jmp	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
$LN4@DrawWireFr:
  00125	5b		 pop	 ebx

; 814  : }

  00126	5d		 pop	 ebp
  00127	c2 0c 00	 ret	 12			; 0000000cH
?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::DrawWireFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?NEW_DrawWireFrame@CMapOutdoor@@IAEXPAVCTerrainPatchProxy@@GW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
_pTerrainPatchProxy$ = 8				; size = 4
_wPrimitiveCount$ = 12					; size = 2
_ePrimitiveType$ = 16					; size = 4
?NEW_DrawWireFrame@CMapOutdoor@@IAEXPAVCTerrainPatchProxy@@GW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::NEW_DrawWireFrame, COMDAT
; _this$ = ecx

; 759  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 760  : 	DWORD dwFillMode = STATEMANAGER.GetRenderState(D3DRS_FILLMODE);

  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0000e	6a 08		 push	 8
  00010	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 761  : 	STATEMANAGER.SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);

  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0001b	8b d8		 mov	 ebx, eax
  0001d	6a 02		 push	 2
  0001f	6a 08		 push	 8
  00021	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 762  : 	
; 763  : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0002c	6a 1c		 push	 28			; 0000001cH
  0002e	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 764  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00039	8b f0		 mov	 esi, eax
  0003b	6a 00		 push	 0
  0003d	6a 1c		 push	 28			; 0000001cH
  0003f	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 765  : 	
; 766  : 	STATEMANAGER.SetTexture(0, NULL);

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 767  : 	STATEMANAGER.SetTexture(1, NULL);

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00059	6a 00		 push	 0
  0005b	6a 01		 push	 1
  0005d	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 768  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00068	6a 01		 push	 1
  0006a	6a 01		 push	 1
  0006c	6a 00		 push	 0
  0006e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 769  : 	
; 770  : 	STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  00073	8b 45 0c	 mov	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007c	0f b7 c0	 movzx	 eax, ax
  0007f	50		 push	 eax
  00080	6a 00		 push	 0
  00082	ff b7 a0 09 00
	00		 push	 DWORD PTR [edi+2464]
  00088	6a 00		 push	 0
  0008a	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0008d	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 771  : 	
; 772  : 	STATEMANAGER.SetRenderState(D3DRS_FILLMODE, dwFillMode);

  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00098	53		 push	 ebx
  00099	6a 08		 push	 8
  0009b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 773  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000a6	56		 push	 esi
  000a7	6a 1c		 push	 28			; 0000001cH
  000a9	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 774  : 	
; 775  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000b4	6a 02		 push	 2
  000b6	6a 02		 push	 2
  000b8	6a 00		 push	 0
  000ba	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 776  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  000bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000c5	6a 01		 push	 1
  000c7	6a 03		 push	 3
  000c9	6a 00		 push	 0
  000cb	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx

; 777  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);	

  000d3	c7 45 10 04 00
	00 00		 mov	 DWORD PTR _ePrimitiveType$[ebp], 4
  000da	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR _wPrimitiveCount$[ebp], 1
  000e1	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _pTerrainPatchProxy$[ebp], 0
  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 778  : }

  000ee	5d		 pop	 ebp

; 777  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);	

  000ef	e9 00 00 00 00	 jmp	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
?NEW_DrawWireFrame@CMapOutdoor@@IAEXPAVCTerrainPatchProxy@@GW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::NEW_DrawWireFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?SetPatchDrawVector@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_aPatchDrawStruct$ = -44				; size = 16
_adistancePatchPair$1 = -28				; size = 8
$T2 = -20						; size = 1
_pTerrain$3 = -20					; size = 4
_pTerrainPatchProxy$1$ = -16				; size = 4
_lPatchNum$1$ = -12					; size = 4
_byTerrainNum$4 = -8					; size = 1
_this$1$ = -4						; size = 4
?SetPatchDrawVector@CMapOutdoor@@IAEXXZ PROC		; CMapOutdoor::SetPatchDrawVector, COMDAT
; _this$ = ecx

; 679  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	8b d1		 mov	 edx, ecx
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00008	8b 82 24 01 00
	00		 mov	 eax, DWORD PTR [edx+292]
  0000e	56		 push	 esi
  0000f	57		 push	 edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 682  : 	m_PatchDrawStructVector.clear();

  00010	8d ba 24 01 00
	00		 lea	 edi, DWORD PTR [edx+292]
  00016	89 55 fc	 mov	 DWORD PTR _this$1$[ebp], edx
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00019	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 688  : 	aDistancePatchVectorIterator = m_PatchVector.begin();

  0001c	8b b2 18 01 00
	00		 mov	 esi, DWORD PTR [edx+280]
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00022	3b b2 1c 01 00
	00		 cmp	 esi, DWORD PTR [edx+284]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 689  : 	while(aDistancePatchVectorIterator != m_PatchVector.end())

  00028	0f 84 dc 00 00
	00		 je	 $LN5@SetPatchDr
  0002e	53		 push	 ebx
  0002f	90		 npad	 1
$LL6@SetPatchDr:

; 690  : 	{
; 691  : 		std::pair<float, long> adistancePatchPair = *aDistancePatchVectorIterator;

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	89 45 e4	 mov	 DWORD PTR _adistancePatchPair$1[ebp], eax
  00035	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 692  : 
; 693  : 		CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[adistancePatchPair.second];

  00038	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0003f	2b c8		 sub	 ecx, eax
  00041	8b 42 64	 mov	 eax, DWORD PTR [edx+100]

; 694  : 
; 695  : 		if (!pTerrainPatchProxy->isUsed())

  00044	80 7c 88 04 00	 cmp	 BYTE PTR [eax+ecx*4+4], 0
  00049	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0004c	89 45 f0	 mov	 DWORD PTR _pTerrainPatchProxy$1$[ebp], eax
  0004f	0f 84 a5 00 00
	00		 je	 $LN173@SetPatchDr

; 696  : 		{
; 697  : 			++aDistancePatchVectorIterator;
; 698  : 			continue;
; 699  : 		}
; 700  : 
; 701  : 		long lPatchNum = pTerrainPatchProxy->GetPatchNum();

  00055	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00059	89 4d f4	 mov	 DWORD PTR _lPatchNum$1$[ebp], ecx

; 702  : 		if (lPatchNum < 0)

  0005c	85 c9		 test	 ecx, ecx
  0005e	0f 88 96 00 00
	00		 js	 $LN173@SetPatchDr
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  00064	8a 58 08	 mov	 bl, BYTE PTR [eax+8]
  00067	88 5d f8	 mov	 BYTE PTR _byTerrainNum$4[ebp], bl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 709  : 		if (0xFF == byTerrainNum)

  0006a	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0006d	0f 84 87 00 00
	00		 je	 $LN173@SetPatchDr

; 710  : 		{
; 711  : 			++aDistancePatchVectorIterator;
; 712  : 			continue;
; 713  : 		}
; 714  : 
; 715  : 		CTerrain * pTerrain;
; 716  : 		if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  00073	8d 45 ec	 lea	 eax, DWORD PTR _pTerrain$3[ebp]
  00076	8b ca		 mov	 ecx, edx
  00078	50		 push	 eax
  00079	ff 75 f8	 push	 DWORD PTR _byTerrainNum$4[ebp]
  0007c	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00081	85 c0		 test	 eax, eax
  00083	74 72		 je	 SHORT $LN66@SetPatchDr

; 724  : 		aPatchDrawStruct.lPatchNum				= lPatchNum;

  00085	8b 45 f4	 mov	 eax, DWORD PTR _lPatchNum$1$[ebp]
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00088	8d 4d d4	 lea	 ecx, DWORD PTR _aPatchDrawStruct$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 722  : 		aPatchDrawStruct.fDistance				= adistancePatchPair.first;

  0008b	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _adistancePatchPair$1[ebp]

; 724  : 		aPatchDrawStruct.lPatchNum				= lPatchNum;

  00090	89 45 dc	 mov	 DWORD PTR _aPatchDrawStruct$[ebp+8], eax

; 725  : 		aPatchDrawStruct.pTerrainPatchProxy		= pTerrainPatchProxy;

  00093	8b 45 f0	 mov	 eax, DWORD PTR _pTerrainPatchProxy$1$[ebp]
  00096	89 45 e0	 mov	 DWORD PTR _aPatchDrawStruct$[ebp+12], eax
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00099	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 722  : 		aPatchDrawStruct.fDistance				= adistancePatchPair.first;

  0009c	f3 0f 11 45 d4	 movss	 DWORD PTR _aPatchDrawStruct$[ebp], xmm0

; 723  : 		aPatchDrawStruct.byTerrainNum			= byTerrainNum;

  000a1	88 5d d8	 mov	 BYTE PTR _aPatchDrawStruct$[ebp+4], bl
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  000a4	3b c8		 cmp	 ecx, eax
  000a6	73 2d		 jae	 SHORT $LN68@SetPatchDr
  000a8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000aa	8d 55 d4	 lea	 edx, DWORD PTR _aPatchDrawStruct$[ebp]
  000ad	3b ca		 cmp	 ecx, edx
  000af	77 24		 ja	 SHORT $LN68@SetPatchDr

; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);
; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  000b1	8b da		 mov	 ebx, edx
  000b3	2b d9		 sub	 ebx, ecx

; 1247 : 			if (this->_Mylast == this->_Myend)

  000b5	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  000b8	75 09		 jne	 SHORT $LN67@SetPatchDr

; 1248 : 				_Reserve(1);

  000ba	6a 01		 push	 1
  000bc	8b cf		 mov	 ecx, edi
  000be	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reserve
$LN67@SetPatchDr:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  000c3	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File a:\vs\vc\include\vector

; 1251 : 				this->_Myfirst[_Idx]);

  000c6	83 e3 f0	 and	 ebx, -16		; fffffff0H
  000c9	03 1f		 add	 ebx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  000cb	85 c0		 test	 eax, eax
  000cd	74 24		 je	 SHORT $LN113@SetPatchDr
  000cf	f3 0f 6f 03	 movdqu	 xmm0, XMMWORD PTR [ebx]
; File a:\vs\vc\include\vector

; 1254 : 		else

  000d3	eb 1a		 jmp	 SHORT $LN174@SetPatchDr
$LN68@SetPatchDr:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  000d5	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  000d8	75 09		 jne	 SHORT $LN65@SetPatchDr

; 1257 : 				_Reserve(1);

  000da	6a 01		 push	 1
  000dc	8b cf		 mov	 ecx, edi
  000de	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reserve
$LN65@SetPatchDr:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  000e3	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000e6	85 c0		 test	 eax, eax
  000e8	74 09		 je	 SHORT $LN113@SetPatchDr
  000ea	f3 0f 6f 45 d4	 movdqu	 xmm0, XMMWORD PTR _aPatchDrawStruct$[ebp]
$LN174@SetPatchDr:
  000ef	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
$LN113@SetPatchDr:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  000f3	83 47 04 10	 add	 DWORD PTR [edi+4], 16	; 00000010H
$LN66@SetPatchDr:
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN173@SetPatchDr:

; 112  : 		++this->_Ptr;

  000fa	83 c6 08	 add	 esi, 8

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000fd	3b b2 1c 01 00
	00		 cmp	 esi, DWORD PTR [edx+284]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 689  : 	while(aDistancePatchVectorIterator != m_PatchVector.end())

  00103	0f 85 27 ff ff
	ff		 jne	 $LL6@SetPatchDr
  00109	5b		 pop	 ebx
$LN5@SetPatchDr:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  0010f	a3 04 00 00 00	 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 732  : 	std::stable_sort(m_PatchDrawStructVector.begin(), m_PatchDrawStructVector.end(), FSortPatchDrawStructWithTerrainNum());

  00114	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00116	8b 82 28 01 00
	00		 mov	 eax, DWORD PTR [edx+296]
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0011e	3b c8		 cmp	 ecx, eax
; File a:\vs\vc\include\algorithm

; 3274 : 	if (_First != _Last)

  00120	74 11		 je	 SHORT $LN143@SetPatchDr

; 3275 : 		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
; 3276 : 			_Dist_type(_First), _Val_type(_First), _Pred);

  00122	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00125	6a 00		 push	 0
  00127	6a 00		 push	 0
  00129	50		 push	 eax
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ??$_Stable_sort@PAUTPatchDrawStruct@CMapOutdoor@@HU12@UFSortPatchDrawStructWithTerrainNum@2@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@0PAH0UFSortPatchDrawStructWithTerrainNum@2@@Z ; std::_Stable_sort<CMapOutdoor::TPatchDrawStruct *,int,CMapOutdoor::TPatchDrawStruct,CMapOutdoor::FSortPatchDrawStructWithTerrainNum>
  00130	83 c4 14	 add	 esp, 20			; 00000014H
$LN143@SetPatchDr:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 733  : }

  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
?SetPatchDrawVector@CMapOutdoor@@IAEXXZ ENDP		; CMapOutdoor::SetPatchDrawVector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXXZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEXXZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 04	 sar	 eax, 4

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 0f	 mov	 ebx, 268435455		; 0fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 04	 sar	 esi, 4

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 04	 sar	 edx, 4

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
__Ptr$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$3 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$4 = 11						; size = 1
?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e8	 mov	 DWORD PTR _this$1$[ebp], ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00030	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  00033	33 ff		 xor	 edi, edi
  00035	89 7d ec	 mov	 DWORD PTR __Ptr$2[ebp], edi
  00038	85 f6		 test	 esi, esi
  0003a	74 24		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0003c	81 fe ff ff ff
	0f		 cmp	 esi, 268435455		; 0fffffffH
  00042	77 17		 ja	 SHORT $LN15@Reallocate
  00044	8b c6		 mov	 eax, esi
  00046	c1 e0 04	 shl	 eax, 4
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004f	8b f8		 mov	 edi, eax
  00051	83 c4 04	 add	 esp, 4
  00054	89 7d ec	 mov	 DWORD PTR __Ptr$2[ebp], edi
  00057	85 ff		 test	 edi, edi
  00059	75 05		 jne	 SHORT $LN16@Reallocate
$LN15@Reallocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0005b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN60@Reallocate:
$LN16@Reallocate:
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00060	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  00063	8d 45 0b	 lea	 eax, DWORD PTR __Alval$4[ebp]
; File a:\vs\vc\include\vector

; 1590 : 		_TRY_BEGIN

  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0006d	6a 00		 push	 0
  0006f	50		 push	 eax
  00070	57		 push	 edi
  00071	ff 73 04	 push	 DWORD PTR [ebx+4]
  00074	ff 33		 push	 DWORD PTR [ebx]
  00076	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUTPatchDrawStruct@CMapOutdoor@@PAU12@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@U12@@std@@YAPAUTPatchDrawStruct@CMapOutdoor@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CMapOutdoor::TPatchDrawStruct *,CMapOutdoor::TPatchDrawStruct *,std::allocator<CMapOutdoor::TPatchDrawStruct>,CMapOutdoor::TPatchDrawStruct>
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007b	8b 03		 mov	 eax, DWORD PTR [ebx]
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0007d	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00080	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00083	2b d8		 sub	 ebx, eax

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN54@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008f	83 c4 04	 add	 esp, 4
$LN54@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  00092	8b 45 e8	 mov	 eax, DWORD PTR _this$1$[ebp]

; 1607 : 		this->_Mylast = _Ptr + _Size;

  00095	83 e3 f0	 and	 ebx, -16		; fffffff0H
  00098	c1 e6 04	 shl	 esi, 4
  0009b	03 f7		 add	 esi, edi
  0009d	03 df		 add	 ebx, edi
  0009f	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000a2	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 1608 : 		this->_Myfirst = _Ptr;

  000a5	89 38		 mov	 DWORD PTR [eax], edi

; 1609 : 		}

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000bb	ff 75 ec	 push	 DWORD PTR __Ptr$2[ebp]
  000be	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c3	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1594 : 		_RERAISE;

  000c6	6a 00		 push	 0
  000c8	6a 00		 push	 0
  000ca	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN61@Reallocate:
$LN59@Reallocate:
  000cf	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reallocate
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBE_NPBUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBE_NPBUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBE_NPBUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEII@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 04	 sar	 edx, 4

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IBEII@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXPAUTPatchDrawStruct@CMapOutdoor@@0@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXXZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXXZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXABUTPatchDrawStruct@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXABUTPatchDrawStruct@CMapOutdoor@@@Z PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 1d		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 17		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)

  00017	2b f9		 sub	 edi, ecx
  00019	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001c	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  0001e	6a 01		 push	 1
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

  00027	83 e7 f0	 and	 edi, -16		; fffffff0H
  0002a	03 3e		 add	 edi, DWORD PTR [esi]

; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else

  0002c	eb 0e		 jmp	 SHORT $LN1@push_back
$LN4@push_back:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  0002e	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00031	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00033	6a 01		 push	 1
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@IAEXI@Z ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0003c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003f	85 c0		 test	 eax, eax
  00041	74 08		 je	 SHORT $LN49@push_back
  00043	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]
  00047	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0004b	83 46 04 10	 add	 DWORD PTR [esi+4], 16	; 00000010H
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?push_back@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXABUTPatchDrawStruct@CMapOutdoor@@@Z ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 04	 sar	 eax, 4

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@2@XZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 04	 sar	 eax, 4

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 04	 sar	 eax, 4

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 04	 shl	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Wrap_alloc<std::allocator<CMapOutdoor::TPatchDrawStruct> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAIABV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAIABV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@2@@Z PROC ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@SAIABV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CMapOutdoor::TPatchDrawStruct> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEIXZ PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QBEIXZ ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0b		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
$LN3@construct:

; 594  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?construct@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@ABU34@@Z ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 04	 shl	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEPAUTPatchDrawStruct@CMapOutdoor@@I@Z ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAEXPAUTPatchDrawStruct@CMapOutdoor@@I@Z ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ PROC ; std::allocator<CMapOutdoor::TPatchDrawStruct>::allocator<CMapOutdoor::TPatchDrawStruct>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@QAE@XZ ENDP ; std::allocator<CMapOutdoor::TPatchDrawStruct>::allocator<CMapOutdoor::TPatchDrawStruct>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXPAU?$pair@MJ@2@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXPAU?$pair@MJ@2@0@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXPAU?$pair@MJ@2@0@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 03	 sar	 eax, 3

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 03	 sar	 esi, 3

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 03	 sar	 edx, 3

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Ptr$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$1$ = 8						; size = 4
__Cat$3 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$4 = 11						; size = 1
?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	33 f6		 xor	 esi, esi
  00032	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00035	85 db		 test	 ebx, ebx
  00037	74 26		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00039	81 fb ff ff ff
	1f		 cmp	 ebx, 536870911		; 1fffffffH
  0003f	77 19		 ja	 SHORT $LN15@Reallocate
  00041	8d 04 dd 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*8]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004e	8b f0		 mov	 esi, eax
  00050	83 c4 04	 add	 esp, 4
  00053	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00056	85 f6		 test	 esi, esi
  00058	75 05		 jne	 SHORT $LN16@Reallocate
$LN15@Reallocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0005a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN60@Reallocate:
$LN16@Reallocate:
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0005f	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  00062	8d 45 0b	 lea	 eax, DWORD PTR __Alval$4[ebp]
; File a:\vs\vc\include\vector

; 1590 : 		_TRY_BEGIN

  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0006c	6a 00		 push	 0
  0006e	50		 push	 eax
  0006f	56		 push	 esi
  00070	ff 77 04	 push	 DWORD PTR [edi+4]
  00073	ff 37		 push	 DWORD PTR [edi]
  00075	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU?$pair@MJ@std@@PAU12@V?$allocator@U?$pair@MJ@std@@@2@U12@@std@@YAPAU?$pair@MJ@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<float,long> *,std::pair<float,long> *,std::allocator<std::pair<float,long> >,std::pair<float,long> >
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007a	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0007c	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00082	2b c1		 sub	 eax, ecx
  00084	c1 f8 03	 sar	 eax, 3
  00087	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0008a	85 c9		 test	 ecx, ecx
  0008c	74 09		 je	 SHORT $LN54@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00094	83 c4 04	 add	 esp, 4
$LN54@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  00097	8d 04 de	 lea	 eax, DWORD PTR [esi+ebx*8]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  0009a	89 37		 mov	 DWORD PTR [edi], esi
  0009c	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0009f	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  000a2	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  000a5	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1609 : 		}

  000a8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b2	59		 pop	 ecx
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000bc	ff 75 ec	 push	 DWORD PTR __Ptr$2[ebp]
  000bf	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c4	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1594 : 		_RERAISE;

  000c7	6a 00		 push	 0
  000c9	6a 00		 push	 0
  000cb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN61@Reallocate:
$LN59@Reallocate:
  000d0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reallocate
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBE_NPBU?$pair@MJ@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBE_NPBU?$pair@MJ@2@@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBE_NPBU?$pair@MJ@2@@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEII@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 03	 sar	 edx, 3

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IBEII@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXPAU?$pair@MJ@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXPAU?$pair@MJ@2@0@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXPAU?$pair@MJ@2@0@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 03	 sar	 eax, 3

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEX$$QAU?$pair@MJ@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEX$$QAU?$pair@MJ@2@@Z PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::push_back, COMDAT
; _this$ = ecx

; 865  : 		{	// insert by moving into element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 38		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 32		 ja	 SHORT $LN4@push_back

; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 869  : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 870  : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\vector

; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

  0002d	8b 16		 mov	 edx, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002f	85 c9		 test	 ecx, ecx
  00031	74 35		 je	 SHORT $LN59@push_back
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00033	8b 04 fa	 mov	 eax, DWORD PTR [edx+edi*8]
  00036	89 01		 mov	 DWORD PTR [ecx], eax
  00038	8b 44 fa 04	 mov	 eax, DWORD PTR [edx+edi*8+4]
  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File a:\vs\vc\include\vector

; 883  : 			++this->_Mylast;

  0003f	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 884  : 			}
; 885  : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN4@push_back:

; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

  00049	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004c	75 09		 jne	 SHORT $LN1@push_back

; 879  : 				_Reserve(1);

  0004e	6a 01		 push	 1
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00057	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005a	85 c9		 test	 ecx, ecx
  0005c	74 0a		 je	 SHORT $LN59@push_back
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0005e	8b 07		 mov	 eax, DWORD PTR [edi]
  00060	89 01		 mov	 DWORD PTR [ecx], eax
  00062	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00065	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN59@push_back:
; File a:\vs\vc\include\vector

; 883  : 			++this->_Mylast;

  00068	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 884  : 			}
; 885  : 		}

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?push_back@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEX$$QAU?$pair@MJ@2@@Z ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<float,long>,std::allocator<std::pair<float,long> > > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<float,long>,std::allocator<std::pair<float,long> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEPAU?$pair@MJ@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEPAU?$pair@MJ@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAEPAU?$pair@MJ@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::_Wrap_alloc<std::allocator<std::pair<float,long> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$pair@MJ@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::pair<float,long> > >::_Wrap_alloc<std::allocator<std::pair<float,long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAIABV?$allocator@U?$pair@MJ@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAIABV?$allocator@U?$pair@MJ@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::pair<float,long> > >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$pair@MJ@std@@@std@@@std@@SAIABV?$allocator@U?$pair@MJ@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::pair<float,long> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$pair@MJ@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@MJ@std@@@std@@QBEIXZ PROC	; std::allocator<std::pair<float,long> >::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@MJ@std@@@std@@QBEIXZ ENDP	; std::allocator<std::pair<float,long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$pair@MJ@std@@@std@@QAEPAU?$pair@MJ@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$pair@MJ@std@@@std@@QAEPAU?$pair@MJ@2@I@Z PROC ; std::allocator<std::pair<float,long> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@U?$pair@MJ@std@@@std@@QAEPAU?$pair@MJ@2@I@Z ENDP ; std::allocator<std::pair<float,long> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z PROC ; std::allocator<std::pair<float,long> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$pair@MJ@std@@@std@@QAEXPAU?$pair@MJ@2@I@Z ENDP ; std::allocator<std::pair<float,long> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@MJ@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@MJ@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<float,long> >::allocator<std::pair<float,long> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$pair@MJ@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<float,long> >::allocator<std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\string.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
;	COMDAT ??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z
_TEXT	SEGMENT
__Val$1$ = -8						; size = 4
_blhsOrderFound$1$ = -1					; size = 1
$T1 = 8							; size = 4
_lhs$ = 8						; size = 4
__Val$1$ = 12						; size = 4
_rhs$ = 12						; size = 4
??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z PROC ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator(), COMDAT
; _this$ = ecx

; 359  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 364  : 				TTerrainNumVector::iterator lhsIterator = std::find(m_TerrainNumVector.begin(), m_TerrainNumVector.end(), lhs.byTerrainNum);

  00006	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
; File a:\vs\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 364  : 				TTerrainNumVector::iterator lhsIterator = std::find(m_TerrainNumVector.begin(), m_TerrainNumVector.end(), lhs.byTerrainNum);

  0000f	83 c0 04	 add	 eax, 4
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	89 45 f8	 mov	 DWORD PTR __Val$1$[ebp], eax
  00017	33 f6		 xor	 esi, esi
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  00019	8a 00		 mov	 al, BYTE PTR [eax]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 361  : 				bool blhsOrderFound = false;

  0001b	c6 45 ff 00	 mov	 BYTE PTR _blhsOrderFound$1$[ebp], 0
  0001f	57		 push	 edi
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  00020	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  00026	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  00028	76 05		 jbe	 SHORT $LN37@operator

; 3015 : 		return (_Last);

  0002a	89 7d 08	 mov	 DWORD PTR $T1[ebp], edi
  0002d	eb 28		 jmp	 SHORT $LN38@operator
$LN37@operator:

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  0002f	0f b6 c8	 movzx	 ecx, al
  00032	8b c7		 mov	 eax, edi
  00034	2b c2		 sub	 eax, edx
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00036	50		 push	 eax
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  0003e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  00047	8b cf		 mov	 ecx, edi
  00049	85 c0		 test	 eax, eax
  0004b	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  00051	0f 45 c8	 cmovne	 ecx, eax
  00054	89 4d 08	 mov	 DWORD PTR $T1[ebp], ecx
$LN38@operator:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 365  : 				TTerrainNumVector::iterator rhsIterator = std::find(m_TerrainNumVector.begin(), m_TerrainNumVector.end(), rhs.byTerrainNum);

  00057	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  0005a	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  0005d	8a 01		 mov	 al, BYTE PTR [ecx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 365  : 				TTerrainNumVector::iterator rhsIterator = std::find(m_TerrainNumVector.begin(), m_TerrainNumVector.end(), rhs.byTerrainNum);

  0005f	89 4d 0c	 mov	 DWORD PTR __Val$1$[ebp], ecx
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  00062	3c ff		 cmp	 al, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  00064	76 04		 jbe	 SHORT $LN78@operator

; 3015 : 		return (_Last);

  00066	8b df		 mov	 ebx, edi
  00068	eb 28		 jmp	 SHORT $LN79@operator
$LN78@operator:

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  0006a	0f b6 c8	 movzx	 ecx, al
  0006d	8b c7		 mov	 eax, edi
  0006f	2b c2		 sub	 eax, edx
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00071	50		 push	 eax
  00072	51		 push	 ecx
  00073	52		 push	 edx
  00074	e8 00 00 00 00	 call	 _memchr
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  00079	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$1$[ebp]
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  00085	8b df		 mov	 ebx, edi
  00087	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  0008d	85 c0		 test	 eax, eax
  0008f	0f 45 d8	 cmovne	 ebx, eax
$LN79@operator:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00092	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  00095	3b c7		 cmp	 eax, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 367  : 				if (lhsIterator != m_TerrainNumVector.end())

  00097	74 08		 je	 SHORT $LN6@operator
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  00099	8b f0		 mov	 esi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 369  : 					blhsOrderFound = true;

  0009b	c6 45 ff 01	 mov	 BYTE PTR _blhsOrderFound$1$[ebp], 1
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  0009f	2b f2		 sub	 esi, edx
$LN6@operator:

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000a1	3b df		 cmp	 ebx, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 372  : 				if (rhsIterator != m_TerrainNumVector.end())

  000a3	74 04		 je	 SHORT $LN220@operator
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000a5	2b da		 sub	 ebx, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 377  : 				if (!brhsOrderFound)

  000a7	eb 1c		 jmp	 SHORT $LN4@operator
$LN220@operator:

; 378  : 				{
; 379  : 					m_TerrainNumVector.push_back(rhs.byTerrainNum);

  000a9	51		 push	 ecx
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  000af	e8 00 00 00 00	 call	 ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEXABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back

; 380  : 					rhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  000b4	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  000ba	8b df		 mov	 ebx, edi
  000bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  000c2	2b da		 sub	 ebx, edx
  000c4	4b		 dec	 ebx
$LN4@operator:

; 381  : 				}
; 382  : 				if (!blhsOrderFound)

  000c5	80 7d ff 00	 cmp	 BYTE PTR _blhsOrderFound$1$[ebp], 0
  000c9	75 59		 jne	 SHORT $LN1@operator
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  000cb	8b 45 f8	 mov	 eax, DWORD PTR __Val$1$[ebp]
; File a:\vs\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

  000ce	8b f7		 mov	 esi, edi
; File a:\vs\vc\include\xutility

; 2992 : 	return (_Val <= UCHAR_MAX);

  000d0	8a 08		 mov	 cl, BYTE PTR [eax]
  000d2	80 f9 ff	 cmp	 cl, 255			; 000000ffH

; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))

  000d5	77 35		 ja	 SHORT $LN221@operator

; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));

  000d7	2b fa		 sub	 edi, edx
  000d9	0f b6 c1	 movzx	 eax, cl
; File a:\vs\vc\include\string.h

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  000dc	57		 push	 edi
  000dd	50		 push	 eax
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 _memchr
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xutility

; 3018 : 	return (_First ? _First : _Last);

  000e7	85 c0		 test	 eax, eax
  000e9	0f 45 f0	 cmovne	 esi, eax
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000ec	3b 35 04 00 00
	00		 cmp	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 385  : 					if (lhsIterator != m_TerrainNumVector.end())

  000f2	74 15		 je	 SHORT $LN222@operator
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000f4	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 397  : 				return lhsTerrainNumOrder < rhsTerrainNumOrder;

  000fa	3b f3		 cmp	 esi, ebx
  000fc	5f		 pop	 edi
  000fd	1b c0		 sbb	 eax, eax
  000ff	5e		 pop	 esi
  00100	f7 d8		 neg	 eax
  00102	5b		 pop	 ebx

; 398  : 			}

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 08 00	 ret	 8
$LN222@operator:
  00109	8b 45 f8	 mov	 eax, DWORD PTR __Val$1$[ebp]
$LN221@operator:

; 386  : 					{
; 387  : 						blhsOrderFound = true;
; 388  : 						lhsTerrainNumOrder = lhsIterator - m_TerrainNumVector.begin();
; 389  : 					}
; 390  : 					if (!blhsOrderFound)
; 391  : 					{
; 392  : 						m_TerrainNumVector.push_back(lhs.byTerrainNum);

  0010c	50		 push	 eax
  0010d	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::m_TerrainNumVector
  00112	e8 00 00 00 00	 call	 ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEXABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back

; 393  : 						lhsTerrainNumOrder = m_TerrainNumVector.size() -1;

  00117	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4
  0011d	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00123	4e		 dec	 esi
$LN1@operator:

; 397  : 				return lhsTerrainNumOrder < rhsTerrainNumOrder;

  00124	3b f3		 cmp	 esi, ebx
  00126	5f		 pop	 edi
  00127	1b c0		 sbb	 eax, eax
  00129	5e		 pop	 esi
  0012a	f7 d8		 neg	 eax
  0012c	5b		 pop	 ebx

; 398  : 			}

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 08 00	 ret	 8
??RFSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE_NABUTPatchDrawStruct@1@0@Z ENDP ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h
;	COMDAT ??0FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE@XZ
_TEXT	SEGMENT
??0FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE@XZ PROC ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::FSortPatchDrawStructWithTerrainNum, COMDAT
; _this$ = ecx
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A
  00005	a3 04 00 00 00	 mov	 DWORD PTR ?m_TerrainNumVector@FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@2V?$vector@EV?$allocator@E@std@@@std@@A+4, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoor.h

; 356  : 			}

  0000a	8b c1		 mov	 eax, ecx
  0000c	c3		 ret	 0
??0FSortPatchDrawStructWithTerrainNum@CMapOutdoor@@QAE@XZ ENDP ; CMapOutdoor::FSortPatchDrawStructWithTerrainNum::FSortPatchDrawStructWithTerrainNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderTree@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
?RenderTree@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::RenderTree, COMDAT
; _this$ = ecx

; 238  : 	if (IsVisiblePart(PART_TREE))

  00000	6a 04		 push	 4
  00002	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  00007	84 c0		 test	 al, al
  00009	74 0d		 je	 SHORT $LN1@RenderTree

; 239  : 		CSpeedTreeForestDirectX8::Instance().Render();

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00011	6a 0f		 push	 15			; 0000000fH
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	ff 50 08	 call	 DWORD PTR [eax+8]
$LN1@RenderTree:

; 240  : }

  00018	c3		 ret	 0
?RenderTree@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::RenderTree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderPCBlocker@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
__Func$ = -4						; size = 1
?RenderPCBlocker@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::RenderPCBlocker, COMDAT
; _this$ = ecx

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00007	8b 87 1c 0a 00
	00		 mov	 eax, DWORD PTR [edi+2588]
  0000d	2b 87 18 0a 00
	00		 sub	 eax, DWORD PTR [edi+2584]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 615  : 	if (m_PCBlockerVector.size() != 0)

  00013	a9 fc ff ff ff	 test	 eax, -4			; fffffffcH
  00018	0f 84 19 02 00
	00		 je	 $LN1@RenderPCBl

; 616  : 	{
; 617  : 		STATEMANAGER.SetTexture(0, NULL);

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00024	56		 push	 esi
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 618  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00034	6a 02		 push	 2
  00036	6a 02		 push	 2
  00038	6a 00		 push	 0
  0003a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 619  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2,	D3DTA_CURRENT);

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00045	6a 01		 push	 1
  00047	6a 03		 push	 3
  00049	6a 00		 push	 0
  0004b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 620  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_MODULATE);

  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00056	6a 04		 push	 4
  00058	6a 01		 push	 1
  0005a	6a 00		 push	 0
  0005c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 621  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00067	6a 02		 push	 2
  00069	6a 05		 push	 5
  0006b	6a 00		 push	 0
  0006d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 622  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,	D3DTOP_SELECTARG1);

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00078	6a 02		 push	 2
  0007a	6a 04		 push	 4
  0007c	6a 00		 push	 0
  0007e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 623  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,	D3DTOP_SELECTARG1);

  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00089	6a 02		 push	 2
  0008b	6a 01		 push	 1
  0008d	6a 01		 push	 1
  0008f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 624  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,	D3DTOP_DISABLE);

  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0009a	6a 01		 push	 1
  0009c	6a 04		 push	 4
  0009e	6a 01		 push	 1
  000a0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 625  : 
; 626  : 		STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  000a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ab	6a 01		 push	 1
  000ad	6a 1b		 push	 27			; 0000001bH
  000af	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 627  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ba	68 00 00 02 00	 push	 131072			; 00020000H
  000bf	6a 0b		 push	 11			; 0000000bH
  000c1	6a 01		 push	 1
  000c3	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 628  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ce	6a 02		 push	 2
  000d0	6a 18		 push	 24			; 00000018H
  000d2	6a 01		 push	 1
  000d4	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 629  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000df	6a 01		 push	 1
  000e1	6a 02		 push	 2
  000e3	6a 01		 push	 1
  000e5	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 630  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f0	6a 02		 push	 2
  000f2	6a 01		 push	 1
  000f4	6a 01		 push	 1
  000f6	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 631  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00101	6a 02		 push	 2
  00103	6a 05		 push	 5
  00105	6a 01		 push	 1
  00107	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 632  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  0010c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00112	6a 02		 push	 2
  00114	6a 04		 push	 4
  00116	6a 01		 push	 1
  00118	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 633  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00123	6a 03		 push	 3
  00125	6a 0d		 push	 13			; 0000000dH
  00127	6a 01		 push	 1
  00129	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 634  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);	

  0012e	6a 03		 push	 3
  00130	6a 0e		 push	 14			; 0000000eH
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00138	6a 01		 push	 1
  0013a	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 635  : 
; 636  : 		STATEMANAGER.SaveTransform(D3DTS_TEXTURE1, &m_matBuildingTransparent);

  0013f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00145	8d 87 2c 0e 00
	00		 lea	 eax, DWORD PTR [edi+3628]
  0014b	50		 push	 eax
  0014c	6a 11		 push	 17			; 00000011H
  0014e	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  00153	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 637  : 		STATEMANAGER.SetTexture(1, m_BuildingTransparentImageInstance.GetTexturePointer()->GetD3DTexture());

  00159	8d 8f 0c 0e 00
	00		 lea	 ecx, DWORD PTR [edi+3596]
  0015f	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00164	8b c8		 mov	 ecx, eax
  00166	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0016b	50		 push	 eax
  0016c	6a 01		 push	 1
  0016e	8b ce		 mov	 ecx, esi
  00170	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00175	8d 45 fc	 lea	 eax, DWORD PTR __Func$[ebp]
  00178	50		 push	 eax
  00179	ff b7 1c 0a 00
	00		 push	 DWORD PTR [edi+2588]
  0017f	ff b7 18 0a 00
	00		 push	 DWORD PTR [edi+2584]
  00185	e8 00 00 00 00	 call	 ??$_For_each@PAPAVCGraphicObjectInstance@@UFRenderPCBlocker@@@std@@YAXPAPAVCGraphicObjectInstance@@0AAUFRenderPCBlocker@@@Z ; std::_For_each<CGraphicObjectInstance * *,FRenderPCBlocker>
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 641  : 		STATEMANAGER.SetTexture(1, NULL);

  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00190	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 641  : 		STATEMANAGER.SetTexture(1, NULL);

  00193	6a 00		 push	 0
  00195	6a 01		 push	 1
  00197	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 642  : 		STATEMANAGER.RestoreTransform(D3DTS_TEXTURE1);

  0019c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a2	6a 11		 push	 17			; 00000011H
  001a4	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 643  : 
; 644  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXCOORDINDEX);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001af	6a 0b		 push	 11			; 0000000bH
  001b1	6a 01		 push	 1
  001b3	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 645  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS);

  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001be	6a 18		 push	 24			; 00000018H
  001c0	6a 01		 push	 1
  001c2	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 646  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  001c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001cd	6a 02		 push	 2
  001cf	6a 02		 push	 2
  001d1	6a 01		 push	 1
  001d3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 647  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001de	6a 01		 push	 1
  001e0	6a 01		 push	 1
  001e2	6a 01		 push	 1
  001e4	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 648  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  001e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ef	6a 02		 push	 2
  001f1	6a 05		 push	 5
  001f3	6a 01		 push	 1
  001f5	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 649  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00200	6a 01		 push	 1
  00202	6a 04		 push	 4
  00204	6a 01		 push	 1
  00206	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 650  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSU);

  0020b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00211	6a 0d		 push	 13			; 0000000dH
  00213	6a 01		 push	 1
  00215	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 651  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSV);

  0021a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00220	6a 0e		 push	 14			; 0000000eH
  00222	6a 01		 push	 1
  00224	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 652  : 		STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  00229	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0022f	6a 1b		 push	 27			; 0000001bH
  00231	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState
  00236	5e		 pop	 esi
$LN1@RenderPCBl:
  00237	5f		 pop	 edi

; 653  : 	}
; 654  : #endif
; 655  : }

  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c3		 ret	 0
?RenderPCBlocker@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::RenderPCBlocker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderEffect@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_pArea$1 = -4						; size = 4
?RenderEffect@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::RenderEffect, COMDAT
; _this$ = ecx

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 340  : 	if (!IsVisiblePart(PART_OBJECT))

  00005	6a 01		 push	 1
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  0000e	84 c0		 test	 al, al
  00010	74 22		 je	 SHORT $LN2@RenderEffe

; 341  : 		return;
; 342  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00012	56		 push	 esi
  00013	33 f6		 xor	 esi, esi
$LL4@RenderEffe:

; 343  : 	{
; 344  : 		CArea * pArea;
; 345  : 		if (GetAreaPointer(i, &pArea))

  00015	8d 45 fc	 lea	 eax, DWORD PTR _pArea$1[ebp]
  00018	8b cf		 mov	 ecx, edi
  0001a	50		 push	 eax
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  00021	85 c0		 test	 eax, eax
  00023	74 08		 je	 SHORT $LN3@RenderEffe

; 346  : 		{
; 347  : 			pArea->RenderEffect();

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pArea$1[ebp]
  00028	e8 00 00 00 00	 call	 ?RenderEffect@CArea@@QAEXXZ ; CArea::RenderEffect
$LN3@RenderEffe:

; 341  : 		return;
; 342  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  0002d	46		 inc	 esi
  0002e	83 fe 09	 cmp	 esi, 9
  00031	7c e2		 jl	 SHORT $LL4@RenderEffe
  00033	5e		 pop	 esi
$LN2@RenderEffe:
  00034	5f		 pop	 edi

; 348  : 		}
; 349  : 	}
; 350  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?RenderEffect@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::RenderEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderDungeon@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_pArea$1 = -4						; size = 4
?RenderDungeon@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::RenderDungeon, COMDAT
; _this$ = ecx

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 602  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00008	33 f6		 xor	 esi, esi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@RenderDung:

; 603  : 	{
; 604  : 		CArea * pArea;
; 605  : 		if (!GetAreaPointer(i, &pArea))

  00010	8d 45 fc	 lea	 eax, DWORD PTR _pArea$1[ebp]
  00013	8b cf		 mov	 ecx, edi
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  0001c	85 c0		 test	 eax, eax
  0001e	74 08		 je	 SHORT $LN3@RenderDung

; 606  : 			continue;
; 607  : 		pArea->RenderDungeon();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _pArea$1[ebp]
  00023	e8 00 00 00 00	 call	 ?RenderDungeon@CArea@@QAEXXZ ; CArea::RenderDungeon
$LN3@RenderDung:

; 602  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00028	46		 inc	 esi
  00029	83 fe 09	 cmp	 esi, 9
  0002c	7c e2		 jl	 SHORT $LL4@RenderDung
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 608  : 	}
; 609  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?RenderDungeon@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::RenderDungeon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderBlendArea@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
_pArea$2 = -4						; size = 4
?RenderBlendArea@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::RenderBlendArea, COMDAT
; _this$ = ecx

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 528  : 	if (!IsVisiblePart(PART_OBJECT))

  00005	6a 01		 push	 1
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  0000e	84 c0		 test	 al, al
  00010	0f 84 cf 01 00
	00		 je	 $LN1@RenderBlen

; 531  : 	static std::vector<CGraphicThingInstance*> s_kVct_pkBlendThingInstSort;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S2@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4IA
  0001b	a8 01		 test	 al, 1
  0001d	75 33		 jne	 SHORT $LN6@RenderBlen
  0001f	83 c8 01	 or	 eax, 1
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00022	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A, 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 531  : 	static std::vector<CGraphicThingInstance*> s_kVct_pkBlendThingInstSort;

  0002c	68 00 00 00 00	 push	 OFFSET ??__Fs_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@YAXXZ ; `CMapOutdoor::RenderBlendArea'::`4'::`dynamic atexit destructor for 's_kVct_pkBlendThingInstSort''
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?$S2@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4IA, eax
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  00036	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4, 0

; 484  : 		_Myend = pointer();

  00040	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+8, 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 531  : 	static std::vector<CGraphicThingInstance*> s_kVct_pkBlendThingInstSort;

  0004a	e8 00 00 00 00	 call	 _atexit
  0004f	83 c4 04	 add	 esp, 4
$LN6@RenderBlen:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  00057	56		 push	 esi
  00058	a3 04 00 00 00	 mov	 DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 534  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  0005d	33 f6		 xor	 esi, esi
  0005f	90		 npad	 1
$LL5@RenderBlen:

; 535  : 	{
; 536  : 		CArea * pArea;
; 537  : 		if (GetAreaPointer(i, &pArea))

  00060	8d 45 fc	 lea	 eax, DWORD PTR _pArea$2[ebp]
  00063	8b cf		 mov	 ecx, edi
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  0006c	85 c0		 test	 eax, eax
  0006e	74 0d		 je	 SHORT $LN4@RenderBlen

; 538  : 		{
; 539  : 			pArea->CollectBlendRenderingObject(s_kVct_pkBlendThingInstSort);

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _pArea$2[ebp]
  00073	68 00 00 00 00	 push	 OFFSET ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  00078	e8 00 00 00 00	 call	 ?CollectBlendRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z ; CArea::CollectBlendRenderingObject
$LN4@RenderBlen:

; 534  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  0007d	46		 inc	 esi
  0007e	83 fe 09	 cmp	 esi, 9
  00081	7c dd		 jl	 SHORT $LL5@RenderBlen
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00083	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4
  00089	8b c1		 mov	 eax, ecx
  0008b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  00091	2b c2		 sub	 eax, edx
  00093	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 543  : 	if (s_kVct_pkBlendThingInstSort.size() != 0)

  00096	85 c0		 test	 eax, eax
  00098	0f 84 46 01 00
	00		 je	 $LN132@RenderBlen

; 544  : 	{
; 545  : 
; 546  : 		
; 547  : 		//STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
; 548  : 		//STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
; 549  : 		//STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
; 550  : 		//STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
; 551  : 		//STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);
; 552  : 		//STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);
; 553  : 
; 554  : 		//// Transform
; 555  : 		//STATEMANAGER.SaveTransform(D3DTS_TEXTURE1, &m_matDynamicShadow);
; 556  : 		//STATEMANAGER.SetTexture(1, m_lpCharacterShadowMapTexture);
; 557  : 
; 558  : 		//STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
; 559  : 		//STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);
; 560  : 		//STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_MODULATE);
; 561  : 		//STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);
; 562  : 		//STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER);
; 563  : 		//STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER);
; 564  : 		//STATEMANAGER.SaveTextureStageState(1, D3DTSS_BORDERCOLOR, 0xFFFFFFFF);
; 565  : 
; 566  : 		////std::for_each(m_ShadowReceiverVector.begin(), m_ShadowReceiverVector.end(), FAreaRenderShadow());
; 567  : 
; 568  : 		//STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXCOORDINDEX);
; 569  : 		//STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS);
; 570  : 		//STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSU);
; 571  : 		//STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSV);
; 572  : 		//STATEMANAGER.RestoreTextureStageState(1, D3DTSS_BORDERCOLOR);
; 573  : 
; 574  : 		//STATEMANAGER.RestoreTransform(D3DTS_TEXTURE1);
; 575  : 
; 576  : 
; 577  : 		std::sort(s_kVct_pkBlendThingInstSort.begin(), s_kVct_pkBlendThingInstSort.end(), CMapOutdoor_LessThingInstancePtrRenderOrder());

  0009e	53		 push	 ebx
  0009f	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  000a3	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  000a6	50		 push	 eax
  000a7	51		 push	 ecx
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 579  : 		STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, TRUE);

  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  000b4	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 579  : 		STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, TRUE);

  000b7	6a 01		 push	 1
  000b9	6a 0e		 push	 14			; 0000000eH
  000bb	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 580  : 		STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000c6	6a 01		 push	 1
  000c8	6a 1b		 push	 27			; 0000001bH
  000ca	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 581  : 		STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d5	6a 05		 push	 5
  000d7	6a 13		 push	 19			; 00000013H
  000d9	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 582  : 		STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e4	6a 06		 push	 6
  000e6	6a 14		 push	 20			; 00000014H
  000e8	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 583  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  000ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f3	6a 02		 push	 2
  000f5	6a 05		 push	 5
  000f7	6a 00		 push	 0
  000f9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 584  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00104	6a 02		 push	 2
  00106	6a 04		 push	 4
  00108	6a 00		 push	 0
  0010a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 585  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00115	6a 02		 push	 2
  00117	6a 02		 push	 2
  00119	6a 00		 push	 0
  0011b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 586  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00126	6a 00		 push	 0
  00128	6a 03		 push	 3
  0012a	6a 00		 push	 0
  0012c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 587  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00137	6a 02		 push	 2
  00139	6a 02		 push	 2
  0013b	6a 01		 push	 1
  0013d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 588  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00148	6a 01		 push	 1
  0014a	6a 03		 push	 3
  0014c	6a 01		 push	 1
  0014e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 589  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00159	6a 02		 push	 2
  0015b	6a 01		 push	 1
  0015d	6a 01		 push	 1
  0015f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 590  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0016a	6a 01		 push	 1
  0016c	6a 04		 push	 4
  0016e	6a 01		 push	 1
  00170	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00175	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  0017b	33 c9		 xor	 ecx, ecx
  0017d	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4
  00183	33 ff		 xor	 edi, edi
  00185	2b de		 sub	 ebx, esi
  00187	83 c3 03	 add	 ebx, 3
  0018a	c1 eb 02	 shr	 ebx, 2
  0018d	3b 35 04 00 00
	00		 cmp	 esi, DWORD PTR ?s_kVct_pkBlendThingInstSort@?3??RenderBlendArea@CMapOutdoor@@QAEXXZ@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4
  00193	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  00196	85 db		 test	 ebx, ebx
  00198	74 15		 je	 SHORT $LN107@RenderBlen
  0019a	8d 9b 00 00 00
	00		 npad	 6
$LL109@RenderBlen:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 377  : 		pkThingInst->BlendRender();

  001a0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001a2	e8 00 00 00 00	 call	 ?BlendRender@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::BlendRender
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  001a7	47		 inc	 edi
  001a8	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  001ab	3b fb		 cmp	 edi, ebx
  001ad	75 f1		 jne	 SHORT $LL109@RenderBlen
$LN107@RenderBlen:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 594  : 		STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  001af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b5	6a 1b		 push	 27			; 0000001bH
  001b7	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 595  : 		STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);

  001bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c2	6a 13		 push	 19			; 00000013H
  001c4	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 596  : 		STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001cf	6a 14		 push	 20			; 00000014H
  001d1	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 597  : 		STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);

  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001dc	6a 0e		 push	 14			; 0000000eH
  001de	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState
  001e3	5b		 pop	 ebx
$LN132@RenderBlen:
  001e4	5e		 pop	 esi
$LN1@RenderBlen:
  001e5	5f		 pop	 edi

; 598  : 	}
; 599  : }

  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c3		 ret	 0
?RenderBlendArea@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::RenderBlendArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderArea@CMapOutdoor@@QAEX_N@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
tv1857 = -4						; size = 4
tv1856 = -4						; size = 4
_dwR$1$ = -4						; size = 4
$T1 = -4						; size = 1
$T2 = -4						; size = 1
_pArea$3 = -4						; size = 4
_pArea$4 = -4						; size = 4
_bRenderAmbience$ = 8					; size = 1
?RenderArea@CMapOutdoor@@QAEX_N@Z PROC			; CMapOutdoor::RenderArea, COMDAT
; _this$ = ecx

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 383  : 	if (!IsVisiblePart(PART_OBJECT))

  00009	6a 01		 push	 1
  0000b	89 75 f8	 mov	 DWORD PTR _this$1$[ebp], esi
  0000e	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  00013	84 c0		 test	 al, al
  00015	0f 84 7d 04 00
	00		 je	 $LN515@RenderArea

; 384  : 		return;
; 385  : 
; 386  : 	m_dwRenderedCRCNum = 0;

  0001b	c7 86 b0 09 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2480], 0

; 387  : 	m_dwRenderedGraphicThingInstanceNum = 0;

  00025	c7 86 b4 09 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2484], 0
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A
  00034	57		 push	 edi
  00035	a3 04 00 00 00	 mov	 DWORD PTR ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A+4, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 391  : 	for (int j = 0; j < AROUND_AREA_NUM; ++j)

  0003a	33 ff		 xor	 edi, edi
  0003c	8d 64 24 00	 npad	 4
$LL23@RenderArea:

; 392  : 	{
; 393  : 		CArea * pArea;
; 394  : 		if (GetAreaPointer(j, &pArea))

  00040	8d 45 fc	 lea	 eax, DWORD PTR _pArea$4[ebp]
  00043	8b ce		 mov	 ecx, esi
  00045	50		 push	 eax
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  0004c	85 c0		 test	 eax, eax
  0004e	74 08		 je	 SHORT $LN22@RenderArea

; 395  : 		{
; 396  : 			pArea->RenderDungeon();

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _pArea$4[ebp]
  00053	e8 00 00 00 00	 call	 ?RenderDungeon@CArea@@QAEXXZ ; CArea::RenderDungeon
$LN22@RenderArea:

; 391  : 	for (int j = 0; j < AROUND_AREA_NUM; ++j)

  00058	47		 inc	 edi
  00059	83 ff 09	 cmp	 edi, 9
  0005c	7c e2		 jl	 SHORT $LL23@RenderArea
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0005e	8b 86 1c 0a 00
	00		 mov	 eax, DWORD PTR [esi+2588]
  00064	33 d2		 xor	 edx, edx
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00066	8b be 18 0a 00
	00		 mov	 edi, DWORD PTR [esi+2584]
  0006c	8b c8		 mov	 ecx, eax
  0006e	2b cf		 sub	 ecx, edi
  00070	83 c1 03	 add	 ecx, 3
  00073	c1 e9 02	 shr	 ecx, 2
  00076	53		 push	 ebx
  00077	33 db		 xor	 ebx, ebx
  00079	3b f8		 cmp	 edi, eax
  0007b	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  0007e	85 c9		 test	 ecx, ecx
  00080	74 14		 je	 SHORT $LN58@RenderArea
  00082	8b f1		 mov	 esi, ecx
$LL60@RenderArea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 313  : 		pInstance->Hide();

  00084	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00086	e8 00 00 00 00	 call	 ?Hide@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Hide
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  0008b	43		 inc	 ebx
  0008c	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  0008f	3b de		 cmp	 ebx, esi
  00091	75 f1		 jne	 SHORT $LL60@RenderArea
  00093	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN58@RenderArea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 405  : 	if (m_bDrawShadow && m_bDrawChrShadow)

  00096	80 be 31 01 00
	00 00		 cmp	 BYTE PTR [esi+305], 0
  0009d	0f 84 ca 02 00
	00		 je	 $LN17@RenderArea
  000a3	80 be 32 01 00
	00 00		 cmp	 BYTE PTR [esi+306], 0
  000aa	0f 84 bd 02 00
	00		 je	 $LN17@RenderArea

; 406  : 	{
; 407  : 		if (mc_pEnvironmentData != NULL)

  000b0	83 7e 3c 00	 cmp	 DWORD PTR [esi+60], 0
  000b4	74 0f		 je	 SHORT $LN18@RenderArea

; 408  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, 0xFFFFFFFF);

  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000bc	6a ff		 push	 -1
  000be	6a 22		 push	 34			; 00000022H
  000c0	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN18@RenderArea:

; 409  : 
; 410  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000cb	6a 02		 push	 2
  000cd	6a 02		 push	 2
  000cf	6a 00		 push	 0
  000d1	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 411  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  000d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000dc	6a 00		 push	 0
  000de	6a 03		 push	 3
  000e0	6a 00		 push	 0
  000e2	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 412  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ed	6a 04		 push	 4
  000ef	6a 01		 push	 1
  000f1	6a 00		 push	 0
  000f3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 413  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000fe	6a 01		 push	 1
  00100	6a 04		 push	 4
  00102	6a 00		 push	 0
  00104	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 414  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0010f	68 00 00 02 00	 push	 131072			; 00020000H
  00114	6a 0b		 push	 11			; 0000000bH
  00116	6a 01		 push	 1
  00118	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 415  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00123	6a 02		 push	 2
  00125	6a 18		 push	 24			; 00000018H
  00127	6a 01		 push	 1
  00129	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 416  : 
; 417  : 		// Transform
; 418  : 		STATEMANAGER.SaveTransform(D3DTS_TEXTURE1, &m_matDynamicShadow);

  0012e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00134	8d 86 48 08 00
	00		 lea	 eax, DWORD PTR [esi+2120]
  0013a	50		 push	 eax
  0013b	6a 11		 push	 17			; 00000011H
  0013d	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 419  : 		STATEMANAGER.SetTexture(1, m_lpCharacterShadowMapTexture);

  00142	ff b6 d4 01 00
	00		 push	 DWORD PTR [esi+468]
  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0014e	6a 01		 push	 1
  00150	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 420  : 
; 421  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0015b	6a 02		 push	 2
  0015d	6a 02		 push	 2
  0015f	6a 01		 push	 1
  00161	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 422  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0016c	6a 01		 push	 1
  0016e	6a 03		 push	 3
  00170	6a 01		 push	 1
  00172	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 423  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00177	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0017d	6a 04		 push	 4
  0017f	6a 01		 push	 1
  00181	6a 01		 push	 1
  00183	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 424  : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0018e	6a 01		 push	 1
  00190	6a 04		 push	 4
  00192	6a 01		 push	 1
  00194	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 425  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER);

  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0019f	6a 04		 push	 4
  001a1	6a 0d		 push	 13			; 0000000dH
  001a3	6a 01		 push	 1
  001a5	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 426  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER);

  001aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b0	6a 04		 push	 4
  001b2	6a 0e		 push	 14			; 0000000eH
  001b4	6a 01		 push	 1
  001b6	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 427  : 		STATEMANAGER.SaveTextureStageState(1, D3DTSS_BORDERCOLOR, 0xFFFFFFFF);

  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c1	6a ff		 push	 -1
  001c3	6a 0f		 push	 15			; 0000000fH
  001c5	6a 01		 push	 1
  001c7	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 428  : 
; 429  : 		std::for_each(m_ShadowReceiverVector.begin(), m_ShadowReceiverVector.end(), FAreaRenderShadow());

  001cc	c6 45 fc 00	 mov	 BYTE PTR $T2[ebp], 0
  001d0	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  001d3	ff b6 10 0a 00
	00		 push	 DWORD PTR [esi+2576]
  001d9	ff b6 0c 0a 00
	00		 push	 DWORD PTR [esi+2572]
  001df	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@UFAreaRenderShadow@@@std@@YA?AUFAreaRenderShadow@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >,FAreaRenderShadow>
  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 430  : 
; 431  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXCOORDINDEX);

  001e7	6a 0b		 push	 11			; 0000000bH
  001e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ef	6a 01		 push	 1
  001f1	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 432  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS);

  001f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001fc	6a 18		 push	 24			; 00000018H
  001fe	6a 01		 push	 1
  00200	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 433  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSU);

  00205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020b	6a 0d		 push	 13			; 0000000dH
  0020d	6a 01		 push	 1
  0020f	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 434  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSV);

  00214	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0021a	6a 0e		 push	 14			; 0000000eH
  0021c	6a 01		 push	 1
  0021e	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 435  : 		STATEMANAGER.RestoreTextureStageState(1, D3DTSS_BORDERCOLOR);

  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00229	6a 0f		 push	 15			; 0000000fH
  0022b	6a 01		 push	 1
  0022d	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 436  : 
; 437  : 		STATEMANAGER.RestoreTransform(D3DTS_TEXTURE1);

  00232	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00238	6a 11		 push	 17			; 00000011H
  0023a	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 438  : 
; 439  : 		if (mc_pEnvironmentData != NULL)

  0023f	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  00242	85 ff		 test	 edi, edi
  00244	0f 84 23 01 00
	00		 je	 $LN17@RenderArea
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0024a	f3 0f 10 87 2c
	01 00 00	 movss	 xmm0, DWORD PTR [edi+300]
  00252	0f 57 c9	 xorps	 xmm1, xmm1
  00255	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0025c	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00264	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  0026c	72 09		 jb	 SHORT $LN131@RenderArea
  0026e	c7 45 fc ff 00
	00 00		 mov	 DWORD PTR _dwR$1$[ebp], 255 ; 000000ffH
  00275	eb 31		 jmp	 SHORT $LN130@RenderArea
$LN131@RenderArea:
  00277	0f 2f c8	 comiss	 xmm1, xmm0
  0027a	72 09		 jb	 SHORT $LN129@RenderArea
  0027c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwR$1$[ebp], 0
  00283	eb 23		 jmp	 SHORT $LN130@RenderArea
$LN129@RenderArea:
  00285	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00289	f3 0f 58 c4	 addss	 xmm0, xmm4
  0028d	e8 00 00 00 00	 call	 __ftoui3
  00292	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  0029a	0f 57 c9	 xorps	 xmm1, xmm1
  0029d	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  002a5	89 45 fc	 mov	 DWORD PTR _dwR$1$[ebp], eax
$LN130@RenderArea:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  002a8	f3 0f 10 87 30
	01 00 00	 movss	 xmm0, DWORD PTR [edi+304]
  002b0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  002b7	72 07		 jb	 SHORT $LN135@RenderArea
  002b9	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  002be	eb 18		 jmp	 SHORT $LN134@RenderArea
$LN135@RenderArea:
  002c0	0f 2f c8	 comiss	 xmm1, xmm0
  002c3	72 04		 jb	 SHORT $LN133@RenderArea
  002c5	33 db		 xor	 ebx, ebx
  002c7	eb 0f		 jmp	 SHORT $LN134@RenderArea
$LN133@RenderArea:
  002c9	f3 0f 59 c3	 mulss	 xmm0, xmm3
  002cd	f3 0f 58 c4	 addss	 xmm0, xmm4
  002d1	e8 00 00 00 00	 call	 __ftoui3
  002d6	8b d8		 mov	 ebx, eax
$LN134@RenderArea:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  002d8	f3 0f 10 87 34
	01 00 00	 movss	 xmm0, DWORD PTR [edi+308]
  002e0	0f 57 c9	 xorps	 xmm1, xmm1
  002e3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  002ea	72 07		 jb	 SHORT $LN139@RenderArea
  002ec	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  002f1	eb 23		 jmp	 SHORT $LN138@RenderArea
$LN139@RenderArea:
  002f3	0f 2f c8	 comiss	 xmm1, xmm0
  002f6	72 04		 jb	 SHORT $LN137@RenderArea
  002f8	33 ff		 xor	 edi, edi
  002fa	eb 1a		 jmp	 SHORT $LN138@RenderArea
$LN137@RenderArea:
  002fc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00304	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0030c	e8 00 00 00 00	 call	 __ftoui3
  00311	8b f8		 mov	 edi, eax
  00313	0f 57 c9	 xorps	 xmm1, xmm1
$LN138@RenderArea:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00316	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00319	f3 0f 10 80 38
	01 00 00	 movss	 xmm0, DWORD PTR [eax+312]
  00321	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00328	72 07		 jb	 SHORT $LN143@RenderArea
  0032a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0032f	eb 1e		 jmp	 SHORT $LN142@RenderArea
$LN143@RenderArea:
  00331	0f 2f c8	 comiss	 xmm1, xmm0
  00334	72 04		 jb	 SHORT $LN141@RenderArea
  00336	33 c0		 xor	 eax, eax
  00338	eb 15		 jmp	 SHORT $LN142@RenderArea
$LN141@RenderArea:
  0033a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00342	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0034a	e8 00 00 00 00	 call	 __ftoui3
$LN142@RenderArea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 440  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, mc_pEnvironmentData->FogColor);

  0034f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00355	c1 e0 08	 shl	 eax, 8
  00358	0b 45 fc	 or	 eax, DWORD PTR _dwR$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0035b	c1 e0 08	 shl	 eax, 8
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 440  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, mc_pEnvironmentData->FogColor);

  0035e	0b c3		 or	 eax, ebx
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00360	c1 e0 08	 shl	 eax, 8
  00363	0b c7		 or	 eax, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 440  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, mc_pEnvironmentData->FogColor);

  00365	50		 push	 eax
  00366	6a 22		 push	 34			; 00000022H
  00368	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN17@RenderArea:

; 441  : 	}
; 442  : #endif
; 443  : 
; 444  : 	STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, TRUE);

  0036d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00373	6a 01		 push	 1
  00375	6a 0e		 push	 14			; 0000000eH
  00377	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 494  : 		static std::vector<CGraphicThingInstance*> s_kVct_pkOpaqueThingInstSort;

  0037c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4IA
  00381	a8 01		 test	 al, 1
  00383	75 33		 jne	 SHORT $LN6@RenderArea
  00385	83 c8 01	 or	 eax, 1
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00388	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A, 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 494  : 		static std::vector<CGraphicThingInstance*> s_kVct_pkOpaqueThingInstSort;

  00392	68 00 00 00 00	 push	 OFFSET ??__Fs_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@YAXXZ ; `CMapOutdoor::RenderArea'::`33'::`dynamic atexit destructor for 's_kVct_pkOpaqueThingInstSort''
  00397	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4IA, eax
; File a:\vs\vc\include\vector

; 483  : 		_Mylast = pointer();

  0039c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4, 0

; 484  : 		_Myend = pointer();

  003a6	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+8, 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 494  : 		static std::vector<CGraphicThingInstance*> s_kVct_pkOpaqueThingInstSort;

  003b0	e8 00 00 00 00	 call	 _atexit
  003b5	83 c4 04	 add	 esp, 4
$LN6@RenderArea:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  003b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 497  : 		for (int i = 0; i < AROUND_AREA_NUM; ++i)

  003bd	33 ff		 xor	 edi, edi
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  003bf	a3 04 00 00 00	 mov	 DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4, eax
$LL5@RenderArea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 500  : 			if (GetAreaPointer(i, &pArea))

  003c4	8d 45 fc	 lea	 eax, DWORD PTR _pArea$3[ebp]
  003c7	8b ce		 mov	 ecx, esi
  003c9	50		 push	 eax
  003ca	57		 push	 edi
  003cb	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  003d0	85 c0		 test	 eax, eax
  003d2	74 0d		 je	 SHORT $LN4@RenderArea

; 501  : 			{
; 502  : 				pArea->CollectRenderingObject(s_kVct_pkOpaqueThingInstSort);

  003d4	8b 4d fc	 mov	 ecx, DWORD PTR _pArea$3[ebp]
  003d7	68 00 00 00 00	 push	 OFFSET ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  003dc	e8 00 00 00 00	 call	 ?CollectRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z ; CArea::CollectRenderingObject
$LN4@RenderArea:

; 497  : 		for (int i = 0; i < AROUND_AREA_NUM; ++i)

  003e1	47		 inc	 edi
  003e2	83 ff 09	 cmp	 edi, 9
  003e5	7c dd		 jl	 SHORT $LL5@RenderArea
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  003e7	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4
  003ed	8b c2		 mov	 eax, edx
  003ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  003f5	2b c1		 sub	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 511  : 		std::sort(s_kVct_pkOpaqueThingInstSort.begin(), s_kVct_pkOpaqueThingInstSort.end(), CMapOutdoor_LessThingInstancePtrRenderOrder());

  003f7	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  003fb	ff 75 fc	 push	 DWORD PTR $T1[ebp]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  003fe	c1 f8 02	 sar	 eax, 2
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00401	50		 push	 eax
  00402	52		 push	 edx
  00403	51		 push	 ecx
  00404	e8 00 00 00 00	 call	 ??$_Sort@PAPAVCGraphicThingInstance@@HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@std@@YAXPAPAVCGraphicThingInstance@@0HUCMapOutdoor_LessThingInstancePtrRenderOrder@@@Z ; std::_Sort<CGraphicThingInstance * *,int,CMapOutdoor_LessThingInstancePtrRenderOrder>

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00409	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A
  0040f	33 d2		 xor	 edx, edx
  00411	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  00417	83 c4 10	 add	 esp, 16			; 00000010H
  0041a	2b cf		 sub	 ecx, edi
  0041c	33 db		 xor	 ebx, ebx
  0041e	83 c1 03	 add	 ecx, 3
  00421	c1 e9 02	 shr	 ecx, 2
  00424	3b 3d 04 00 00
	00		 cmp	 edi, DWORD PTR ?s_kVct_pkOpaqueThingInstSort@?CB@??RenderArea@CMapOutdoor@@QAEX_N@Z@4V?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@A+4
  0042a	0f 47 ca	 cmova	 ecx, edx

; 23   : 	for (; _First != _Last; ++_First)

  0042d	85 c9		 test	 ecx, ecx
  0042f	74 14		 je	 SHORT $LN474@RenderArea
  00431	8b f1		 mov	 esi, ecx
$LL476@RenderArea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 370  : 		pkThingInst->Render();

  00433	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00435	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  0043a	43		 inc	 ebx
  0043b	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  0043e	3b de		 cmp	 ebx, esi
  00440	75 f1		 jne	 SHORT $LL476@RenderArea
  00442	8b 75 f8	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN474@RenderArea:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 515  : 	STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);

  00445	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0044b	6a 0e		 push	 14			; 0000000eH
  0044d	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 516  : 
; 517  : #ifndef WORLD_EDITOR
; 518  : 	// Shadow Receiver
; 519  : 	if (m_bDrawShadow && m_bDrawChrShadow)

  00452	80 be 31 01 00
	00 00		 cmp	 BYTE PTR [esi+305], 0
  00459	74 3b		 je	 SHORT $LN559@RenderArea
  0045b	80 be 32 01 00
	00 00		 cmp	 BYTE PTR [esi+306], 0
  00462	74 32		 je	 SHORT $LN559@RenderArea
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00464	8b 86 10 0a 00
	00		 mov	 eax, DWORD PTR [esi+2576]
  0046a	33 c9		 xor	 ecx, ecx
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0046c	8b b6 0c 0a 00
	00		 mov	 esi, DWORD PTR [esi+2572]
  00472	8b d8		 mov	 ebx, eax
  00474	2b de		 sub	 ebx, esi
  00476	33 ff		 xor	 edi, edi
  00478	83 c3 03	 add	 ebx, 3
  0047b	c1 eb 02	 shr	 ebx, 2
  0047e	3b f0		 cmp	 esi, eax
  00480	0f 47 d9	 cmova	 ebx, ecx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00483	85 db		 test	 ebx, ebx
  00485	74 0f		 je	 SHORT $LN559@RenderArea
$LL517@RenderArea:
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h

; 41   : 		{((_P->*_Ptr)()); }

  00487	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00489	e8 00 00 00 00	 call	 ?Show@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Show
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  0048e	47		 inc	 edi
  0048f	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00492	3b fb		 cmp	 edi, ebx
  00494	75 f1		 jne	 SHORT $LL517@RenderArea
$LN559@RenderArea:
  00496	5b		 pop	 ebx
  00497	5f		 pop	 edi
$LN515@RenderArea:
  00498	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 524  : }

  00499	8b e5		 mov	 esp, ebp
  0049b	5d		 pop	 ebp
  0049c	c2 04 00	 ret	 4
?RenderArea@CMapOutdoor@@QAEX_N@Z ENDP			; CMapOutdoor::RenderArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderTerrain@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_v3Eye$ = -84						; size = 12
$T1 = -72						; size = 1
$T2 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
?RenderTerrain@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::RenderTerrain, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 19   : 	if (!IsVisiblePart(PART_TERRAIN))

  00011	6a 00		 push	 0
  00013	8b f9		 mov	 edi, ecx
  00015	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  0001a	84 c0		 test	 al, al
  0001c	0f 84 e9 00 00
	00		 je	 $LN1@RenderTerr

; 20   : 		return;
; 21   : 
; 22   : 	if (!m_bSettingTerrainVisible)

  00022	80 bf ac 13 00
	00 00		 cmp	 BYTE PTR [edi+5036], 0
  00029	0f 84 dc 00 00
	00		 je	 $LN1@RenderTerr

; 23   : 		return;
; 24   : 
; 25   : 	// Inserted by levites
; 26   : 	if (!m_pTerrainPatchProxyList)

  0002f	83 7f 64 00	 cmp	 DWORD PTR [edi+100], 0
  00033	0f 84 d2 00 00
	00		 je	 $LN1@RenderTerr

; 27   : 		return;
; 28   : 
; 29   : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  00045	8b f0		 mov	 esi, eax

; 30   : 	if (!pCamera)

  00047	85 f6		 test	 esi, esi
  00049	0f 84 bb 00 00
	00		 je	 $LN55@RenderTerr
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  0004f	68 00 00 00 00	 push	 OFFSET ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matProj
  00054	68 00 00 00 00	 push	 OFFSET ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matView
  00059	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 33   : 	BuildViewFrustum(ms_matView * ms_matProj);

  00062	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  00065	8b cf		 mov	 ecx, edi
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?BuildViewFrustum@CMapOutdoor@@IAEXAAUD3DXMATRIX@@@Z ; CMapOutdoor::BuildViewFrustum

; 34   : 
; 35   : 	D3DXVECTOR3 v3Eye = pCamera->GetEye();

  0006d	f3 0f 7e 46 30	 movq	 xmm0, QWORD PTR [esi+48]

; 43   : 	__RenderTerrain_RecurseRenderQuadTree(m_pRootNode);

  00072	8b cf		 mov	 ecx, edi
  00074	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00077	66 0f d6 45 ac	 movq	 QWORD PTR _v3Eye$[ebp], xmm0
  0007c	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _v3Eye$[ebp]
  00081	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00088	f3 0f 11 87 10
	09 00 00	 movss	 DWORD PTR [edi+2320], xmm0
  00090	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _v3Eye$[ebp+4]
  00095	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0009c	f3 0f 11 87 14
	09 00 00	 movss	 DWORD PTR [edi+2324], xmm0
  000a4	89 45 b4	 mov	 DWORD PTR _v3Eye$[ebp+8], eax
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000a7	8b 87 18 01 00
	00		 mov	 eax, DWORD PTR [edi+280]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 43   : 	__RenderTerrain_RecurseRenderQuadTree(m_pRootNode);

  000ad	6a 01		 push	 1
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000af	89 87 1c 01 00
	00		 mov	 DWORD PTR [edi+284], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 43   : 	__RenderTerrain_RecurseRenderQuadTree(m_pRootNode);

  000b5	ff b7 14 01 00
	00		 push	 DWORD PTR [edi+276]
  000bb	e8 00 00 00 00	 call	 ?__RenderTerrain_RecurseRenderQuadTree@CMapOutdoor@@IAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree
; File a:\vs\vc\include\algorithm

; 3164 : 	_STD sort(_First, _Last, less<>());

  000c0	8b 87 1c 01 00
	00		 mov	 eax, DWORD PTR [edi+284]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000c6	8b f0		 mov	 esi, eax
; File a:\vs\vc\include\algorithm

; 3164 : 	_STD sort(_First, _Last, less<>());

  000c8	8b 97 18 01 00
	00		 mov	 edx, DWORD PTR [edi+280]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000ce	2b f2		 sub	 esi, edx
; File a:\vs\vc\include\algorithm

; 3164 : 	_STD sort(_First, _Last, less<>());

  000d0	c6 45 b8 00	 mov	 BYTE PTR $T1[ebp], 0

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  000d4	ff 75 b8	 push	 DWORD PTR $T1[ebp]
; File a:\vs\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

  000d7	c1 fe 03	 sar	 esi, 3
; File a:\vs\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

  000da	56		 push	 esi
  000db	50		 push	 eax
  000dc	52		 push	 edx
  000dd	e8 00 00 00 00	 call	 ??$_Sort@PAU?$pair@MJ@std@@HU?$less@X@2@@std@@YAXPAU?$pair@MJ@0@0HU?$less@X@0@@Z ; std::_Sort<std::pair<float,long> *,int,std::less<void> >
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 50   : 		__RenderTerrain_RenderSoftwareTransformPatch();

  000e5	8b cf		 mov	 ecx, edi
  000e7	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SOFTWARE_TRANSFORM_PATCH_ENABLE@CTerrainPatch@@2_NA, 0 ; CTerrainPatch::SOFTWARE_TRANSFORM_PATCH_ENABLE
  000ee	74 15		 je	 SHORT $LN2@RenderTerr
  000f0	e8 00 00 00 00	 call	 ?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch
  000f5	5e		 pop	 esi
  000f6	5f		 pop	 edi

; 53   : }

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	33 cd		 xor	 ecx, ebp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
$LN2@RenderTerr:

; 51   : 	else
; 52   : 		__RenderTerrain_RenderHardwareTransformPatch();

  00105	e8 00 00 00 00	 call	 ?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch
$LN55@RenderTerr:
  0010a	5e		 pop	 esi
$LN1@RenderTerr:

; 53   : }

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	5f		 pop	 edi
  00111	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c3		 ret	 0
?RenderTerrain@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::RenderTerrain
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderScreenFiltering@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
?RenderScreenFiltering@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::RenderScreenFiltering, COMDAT
; _this$ = ecx

; 221  : 	m_ScreenFilter.Render();

  00000	81 c1 2c 07 00
	00		 add	 ecx, 1836		; 0000072cH
  00006	e9 00 00 00 00	 jmp	 ?Render@CScreenFilter@@QAEXXZ ; CScreenFilter::Render
?RenderScreenFiltering@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::RenderScreenFiltering
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderAfterLensFlare@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
?RenderAfterLensFlare@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::RenderAfterLensFlare, COMDAT
; _this$ = ecx

; 204  : {

  00000	56		 push	 esi

; 205  : 	m_LensFlare.AdjustBrightness();

  00001	8d b1 b8 06 00
	00		 lea	 esi, DWORD PTR [ecx+1720]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?AdjustBrightness@CLensFlare@@QAEXXZ ; CLensFlare::AdjustBrightness

; 206  : 	m_LensFlare.DrawFlare();

  0000e	8b ce		 mov	 ecx, esi
  00010	5e		 pop	 esi
  00011	e9 00 00 00 00	 jmp	 ?DrawFlare@CLensFlare@@QAEXXZ ; CLensFlare::DrawFlare
?RenderAfterLensFlare@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::RenderAfterLensFlare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderBeforeLensFlare@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?RenderBeforeLensFlare@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::RenderBeforeLensFlare, COMDAT
; _this$ = ecx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx
  00013	57		 push	 edi

; 192  : 	m_LensFlare.DrawBeforeFlare();	

  00014	8d 8e b8 06 00
	00		 lea	 ecx, DWORD PTR [esi+1720]
  0001a	e8 00 00 00 00	 call	 ?DrawBeforeFlare@CLensFlare@@QAEXXZ ; CLensFlare::DrawBeforeFlare

; 193  : 
; 194  : 	if (!mc_pEnvironmentData)

  0001f	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00022	85 c0		 test	 eax, eax
  00024	75 1d		 jne	 SHORT $LN1@RenderBefo

; 195  : 	{
; 196  : 		TraceError("CMapOutdoor::RenderBeforeLensFlare mc_pEnvironmentData is NULL");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@MKJEJLFD@CMapOutdoor?3?3RenderBeforeLensFla@
  0002b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00030	83 c4 04	 add	 esp, 4
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 201  : }

  00035	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00038	33 cd		 xor	 ecx, ebp
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN1@RenderBefo:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 172  :     x = v.x;

  00043	f3 0f 10 40 48	 movss	 xmm0, DWORD PTR [eax+72]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 200  : 	m_LensFlare.Compute(mc_pEnvironmentData->DirLights[ENV_DIRLIGHT_BACKGROUND].Direction);

  00048	8d 8e b8 06 00
	00		 lea	 ecx, DWORD PTR [esi+1720]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 172  :     x = v.x;

  0004e	f3 0f 11 45 f0	 movss	 DWORD PTR $T1[ebp], xmm0

; 173  :     y = v.y;

  00053	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [eax+76]
  00058	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 174  :     z = v.z;

  0005d	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [eax+80]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 200  : 	m_LensFlare.Compute(mc_pEnvironmentData->DirLights[ENV_DIRLIGHT_BACKGROUND].Direction);

  00062	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00065	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 174  :     z = v.z;

  00066	f3 0f 11 45 f8	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 200  : 	m_LensFlare.Compute(mc_pEnvironmentData->DirLights[ENV_DIRLIGHT_BACKGROUND].Direction);

  0006b	e8 00 00 00 00	 call	 ?Compute@CLensFlare@@QAEXABUD3DXVECTOR3@@@Z ; CLensFlare::Compute

; 201  : }

  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	5f		 pop	 edi
  00074	33 cd		 xor	 ecx, ebp
  00076	5e		 pop	 esi
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?RenderBeforeLensFlare@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::RenderBeforeLensFlare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderCloud@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
?RenderCloud@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::RenderCloud, COMDAT
; _this$ = ecx

; 231  : {

  00000	56		 push	 esi

; 232  : 	if (IsVisiblePart(PART_CLOUD))

  00001	6a 02		 push	 2
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  0000a	84 c0		 test	 al, al
  0000c	74 0c		 je	 SHORT $LN1@RenderClou

; 233  : 		m_SkyBox.RenderCloud();

  0000e	8d 8e 38 03 00
	00		 lea	 ecx, DWORD PTR [esi+824]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ?RenderCloud@CSkyBox@@QAEXXZ ; CSkyBox::RenderCloud
$LN1@RenderClou:
  0001a	5e		 pop	 esi

; 234  : }

  0001b	c3		 ret	 0
?RenderCloud@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::RenderCloud
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderSky@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
?RenderSky@CMapOutdoor@@QAEXXZ PROC			; CMapOutdoor::RenderSky, COMDAT
; _this$ = ecx

; 225  : {

  00000	56		 push	 esi

; 226  : 	if (IsVisiblePart(PART_SKY))

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?IsVisiblePart@CMapOutdoor@@IAE_NH@Z ; CMapOutdoor::IsVisiblePart
  0000a	84 c0		 test	 al, al
  0000c	74 10		 je	 SHORT $LN1@RenderSky

; 227  : 		m_SkyBox.Render();

  0000e	8b 86 38 03 00
	00		 mov	 eax, DWORD PTR [esi+824]
  00014	8d 8e 38 03 00
	00		 lea	 ecx, DWORD PTR [esi+824]
  0001a	5e		 pop	 esi
  0001b	ff 60 08	 jmp	 DWORD PTR [eax+8]
$LN1@RenderSky:
  0001e	5e		 pop	 esi

; 228  : }

  0001f	c3		 ret	 0
?RenderSky@CMapOutdoor@@QAEXXZ ENDP			; CMapOutdoor::RenderSky
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderCollision@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_pArea$1 = -4						; size = 4
?RenderCollision@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::RenderCollision, COMDAT
; _this$ = ecx

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 211  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00008	33 f6		 xor	 esi, esi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL4@RenderColl:

; 212  : 	{
; 213  : 		CArea * pArea;
; 214  : 		if (GetAreaPointer(i, &pArea))

  00010	8d 45 fc	 lea	 eax, DWORD PTR _pArea$1[ebp]
  00013	8b cf		 mov	 ecx, edi
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
  0001c	85 c0		 test	 eax, eax
  0001e	74 08		 je	 SHORT $LN3@RenderColl

; 215  : 			pArea->RenderCollision();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _pArea$1[ebp]
  00023	e8 00 00 00 00	 call	 ?RenderCollision@CArea@@QAEXXZ ; CArea::RenderCollision
$LN3@RenderColl:

; 211  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00028	46		 inc	 esi
  00029	83 fe 09	 cmp	 esi, 9
  0002c	7c e2		 jl	 SHORT $LL4@RenderColl
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 216  : 	}
; 217  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?RenderCollision@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::RenderCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?DrawPatchAttr@CMapOutdoor@@QAEXJ@Z
_TEXT	SEGMENT
_ucTerrainNum$ = -76					; size = 1
_pTerrain$ = -72					; size = 4
_matTexTransform$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_patchnum$ = 8						; size = 4
?DrawPatchAttr@CMapOutdoor@@QAEXJ@Z PROC		; CMapOutdoor::DrawPatchAttr, COMDAT
; _this$ = ecx

; 917  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _patchnum$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx

; 918  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00017	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0001e	2b d0		 sub	 edx, eax
  00020	8b 47 64	 mov	 eax, DWORD PTR [edi+100]

; 919  : 	if (!pTerrainPatchProxy->isUsed())

  00023	80 7c 90 04 00	 cmp	 BYTE PTR [eax+edx*4+4], 0
  00028	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]
  0002b	0f 84 12 01 00
	00		 je	 $LN6@DrawPatchA

; 920  : 		return;
; 921  : 
; 922  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();
; 923  : 	if (sPatchNum < 0)

  00031	66 83 7e 06 00	 cmp	 WORD PTR [esi+6], 0
  00036	0f 8c 07 01 00
	00		 jl	 $LN6@DrawPatchA
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h

; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  0003c	8a 46 08	 mov	 al, BYTE PTR [esi+8]
  0003f	88 45 b4	 mov	 BYTE PTR _ucTerrainNum$[ebp], al
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 927  : 	if (0xFF == ucTerrainNum)

  00042	3c ff		 cmp	 al, 255			; 000000ffH
  00044	0f 84 f9 00 00
	00		 je	 $LN6@DrawPatchA

; 928  : 		return;
; 929  : 
; 930  : 	// Deal with this material buffer
; 931  : 	CTerrain * pTerrain;
; 932  : 	if (!GetTerrainPointer(ucTerrainNum, &pTerrain))

  0004a	8d 45 b8	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0004d	50		 push	 eax
  0004e	ff 75 b4	 push	 DWORD PTR _ucTerrainNum$[ebp]
  00051	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00056	85 c0		 test	 eax, eax
  00058	0f 84 e5 00 00
	00		 je	 $LN6@DrawPatchA

; 933  : 		return;
; 934  : 
; 935  : 	if (!pTerrain->IsMarked())

  0005e	8b 45 b8	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00061	83 b8 d8 c1 06
	00 00		 cmp	 DWORD PTR [eax+442840], 0
  00068	0f 84 d5 00 00
	00		 je	 $LN6@DrawPatchA
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h

; 93   : 			*usCoordY = m_wY;

  0006e	0f b7 88 6e a5
	06 00		 movzx	 ecx, WORD PTR [eax+435566]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 941  : 	m_matWorldForCommonUse._41 = -(float) (wCoordX * CTerrainImpl::XSIZE * CTerrainImpl::CELLSCALE);

  00075	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  0007c	69 c0 00 9c ff
	ff		 imul	 eax, eax, -25600
  00082	66 0f 6e c0	 movd	 xmm0, eax

; 942  : 	m_matWorldForCommonUse._42 = (float) (wCoordY * CTerrainImpl::YSIZE * CTerrainImpl::CELLSCALE);

  00086	8b c1		 mov	 eax, ecx
  00088	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  0008e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00091	f3 0f 11 87 78
	07 00 00	 movss	 DWORD PTR [edi+1912], xmm0
  00099	66 0f 6e c0	 movd	 xmm0, eax

; 943  : 
; 944  : 	D3DXMATRIX matTexTransform, matTexTransformTemp;
; 945  : 	D3DXMatrixMultiply(&matTexTransform, &m_matViewInverse, &m_matWorldForCommonUse);

  0009d	8d 87 48 07 00
	00		 lea	 eax, DWORD PTR [edi+1864]
  000a3	50		 push	 eax
  000a4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a7	8d 87 88 07 00
	00		 lea	 eax, DWORD PTR [edi+1928]
  000ad	50		 push	 eax
  000ae	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  000b1	50		 push	 eax
  000b2	f3 0f 11 87 7c
	07 00 00	 movss	 DWORD PTR [edi+1916], xmm0
  000ba	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 946  : 	D3DXMatrixMultiply(&matTexTransform, &matTexTransform, &m_matStaticShadow);

  000bf	8d 87 08 08 00
	00		 lea	 eax, DWORD PTR [edi+2056]
  000c5	50		 push	 eax
  000c6	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  000c9	50		 push	 eax
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 947  : 	STATEMANAGER.SetTransform(D3DTS_TEXTURE1, &matTexTransform);

  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d6	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  000d9	50		 push	 eax
  000da	6a 11		 push	 17			; 00000011H
  000dc	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 948  : 
; 949  : 	TTerrainSplatPatch & rAttrSplatPatch = pTerrain->GetMarkedSplatPatch();
; 950  :  	STATEMANAGER.SetTexture(1, rAttrSplatPatch.Splats[0].pd3dTexture);

  000e1	8b 45 b8	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ea	ff b0 e4 c5 07
	00		 push	 DWORD PTR [eax+509412]
  000f0	6a 01		 push	 1
  000f2	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 951  : 
; 952  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_NORMAL);

  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000fd	6a 12		 push	 18			; 00000012H
  000ff	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 953  : 	STATEMANAGER.SetStreamSource(0, pTerrainPatchProxy->HardwareTransformPatch_GetVertexBufferPtr()->GetD3DVertexBuffer(), m_iPatchTerrainVertexSize);

  00104	8b ce		 mov	 ecx, esi
  00106	e8 00 00 00 00	 call	 ?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr
  0010b	ff b7 a8 09 00
	00		 push	 DWORD PTR [edi+2472]
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00117	ff 70 04	 push	 DWORD PTR [eax+4]
  0011a	6a 00		 push	 0
  0011c	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 954  : 
; 955  : #ifdef WORLD_EDITOR
; 956  : 	STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLESTRIP, 0, m_iPatchTerrainVertexCount, 0, m_wNumIndices - 2);
; 957  : #else
; 958  : 	STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLESTRIP, 0, m_iPatchTerrainVertexCount, 0, m_wNumIndices[0] - 2);

  00121	0f b7 87 d8 00
	00 00		 movzx	 eax, WORD PTR [edi+216]
  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0012e	83 e8 02	 sub	 eax, 2
  00131	50		 push	 eax
  00132	6a 00		 push	 0
  00134	ff b7 a0 09 00
	00		 push	 DWORD PTR [edi+2464]
  0013a	6a 00		 push	 0
  0013c	6a 05		 push	 5
  0013e	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN6@DrawPatchA:

; 959  : #endif
; 960  : }

  00143	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00146	5f		 pop	 edi
  00147	33 cd		 xor	 ecx, ebp
  00149	5e		 pop	 esi
  0014a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 04 00	 ret	 4
?DrawPatchAttr@CMapOutdoor@@QAEXJ@Z ENDP		; CMapOutdoor::DrawPatchAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z
_TEXT	SEGMENT
_Node$ = 8						; size = 4
_bCullEnable$ = 12					; size = 1
?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z PROC ; CMapOutdoor::RecurseRenderAttr, COMDAT
; _this$ = ecx

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _bCullEnable$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _Node$[ebp]
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b ff		 npad	 2
$LL11@RecurseRen:

; 891  : 	if (bCullEnable)

  00010	84 db		 test	 bl, bl
  00012	74 13		 je	 SHORT $LN7@RecurseRen

; 892  : 	{
; 893  : 		if (__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle(Node->center, Node->radius)==VIEW_NONE)

  00014	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  00017	8b cf		 mov	 ecx, edi
  00019	50		 push	 eax
  0001a	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle@CMapOutdoor@@IAEHABUD3DXVECTOR3@@ABM@Z ; CMapOutdoor::__RenderTerrain_RecurseRenderQuadTree_CheckBoundingCircle
  00023	85 c0		 test	 eax, eax
  00025	74 4e		 je	 SHORT $LN1@RecurseRen
$LN7@RecurseRen:

; 894  : 			return;
; 895  : 	}
; 896  : 
; 897  : 	{
; 898  : 		if (Node->Size == 1)

  00027	83 7e 24 01	 cmp	 DWORD PTR [esi+36], 1
  0002b	74 3e		 je	 SHORT $LN14@RecurseRen

; 901  : 		}
; 902  : 		else
; 903  : 		{
; 904  : 			if (Node->NW_Node != NULL)

  0002d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00030	85 c0		 test	 eax, eax
  00032	74 09		 je	 SHORT $LN4@RecurseRen

; 905  : 				RecurseRenderAttr(Node->NW_Node, bCullEnable);

  00034	53		 push	 ebx
  00035	50		 push	 eax
  00036	8b cf		 mov	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::RecurseRenderAttr
$LN4@RecurseRen:

; 906  : 			if (Node->NE_Node != NULL)

  0003d	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00040	85 c0		 test	 eax, eax
  00042	74 09		 je	 SHORT $LN3@RecurseRen

; 907  : 				RecurseRenderAttr(Node->NE_Node, bCullEnable);

  00044	53		 push	 ebx
  00045	50		 push	 eax
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::RecurseRenderAttr
$LN3@RecurseRen:

; 908  : 			if (Node->SW_Node != NULL)

  0004d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00050	85 c0		 test	 eax, eax
  00052	74 09		 je	 SHORT $LN2@RecurseRen

; 909  : 				RecurseRenderAttr(Node->SW_Node, bCullEnable);

  00054	53		 push	 ebx
  00055	50		 push	 eax
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::RecurseRenderAttr
$LN2@RecurseRen:

; 910  : 			if (Node->SE_Node != NULL)

  0005d	8b 76 20	 mov	 esi, DWORD PTR [esi+32]
  00060	85 f6		 test	 esi, esi
  00062	75 ac		 jne	 SHORT $LL11@RecurseRen
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx

; 911  : 				RecurseRenderAttr(Node->SE_Node, bCullEnable);
; 912  : 		}
; 913  :  	}
; 914  : }

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
$LN14@RecurseRen:

; 899  : 		{
; 900  : 			DrawPatchAttr(Node->PatchNum);

  0006b	ff 76 28	 push	 DWORD PTR [esi+40]
  0006e	8b cf		 mov	 ecx, edi
  00070	e8 00 00 00 00	 call	 ?DrawPatchAttr@CMapOutdoor@@QAEXJ@Z ; CMapOutdoor::DrawPatchAttr
$LN1@RecurseRen:
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 911  : 				RecurseRenderAttr(Node->SE_Node, bCullEnable);
; 912  : 		}
; 913  :  	}
; 914  : }

  00078	5d		 pop	 ebp
  00079	c2 08 00	 ret	 8
?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z ENDP ; CMapOutdoor::RecurseRenderAttr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?RenderMarkedArea@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_eType$ = -76						; size = 4
_wPrimitiveCount$ = -72					; size = 2
_matTexTransform$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
?RenderMarkedArea@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::RenderMarkedArea, COMDAT
; _this$ = ecx

; 818  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx

; 819  : 	if (!m_pTerrainPatchProxyList)

  00013	83 7f 64 00	 cmp	 DWORD PTR [edi+100], 0
  00017	0f 84 e7 03 00
	00		 je	 $LN3@RenderMark

; 820  : 		return;
; 821  : 
; 822  : 	m_matWorldForCommonUse._41 = 0.0f;
; 823  : 	m_matWorldForCommonUse._42 = 0.0f;
; 824  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorldForCommonUse);

  0001d	56		 push	 esi
  0001e	8d 87 48 07 00
	00		 lea	 eax, DWORD PTR [edi+1864]
  00024	c7 87 78 07 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1912], 0
  0002e	50		 push	 eax
  0002f	c7 87 7c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1916], 0
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0003f	68 00 01 00 00	 push	 256			; 00000100H
  00044	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 825  : 
; 826  : 	WORD wPrimitiveCount;
; 827  : 	D3DPRIMITIVETYPE eType;
; 828  : 	SelectIndexBuffer(0, &wPrimitiveCount, &eType);

  00049	8d 45 b4	 lea	 eax, DWORD PTR _eType$[ebp]
  0004c	8b cf		 mov	 ecx, edi
  0004e	50		 push	 eax
  0004f	8d 45 b8	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 829  : 
; 830  : 	D3DXMATRIX matTexTransform, matTexTransformTemp;
; 831  : 
; 832  : 	D3DXMatrixScaling(&matTexTransform, m_fTerrainTexCoordBase * 32.0f, -m_fTerrainTexCoordBase * 32.0f, 0.0f);

  0005a	f3 0f 10 8f 08
	09 00 00	 movss	 xmm1, DWORD PTR [edi+2312]
  00062	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  00065	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00068	0f 28 c1	 movaps	 xmm0, xmm1
  0006b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@c2000000
  00073	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@42000000
  0007b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  00083	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00089	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 833  : 	D3DXMatrixMultiply(&matTexTransform, &m_matViewInverse, &matTexTransform);

  00094	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  00097	50		 push	 eax
  00098	8d 87 88 07 00
	00		 lea	 eax, DWORD PTR [edi+1928]
  0009e	50		 push	 eax
  0009f	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 834  : 	STATEMANAGER.SaveTransform(D3DTS_TEXTURE0, &matTexTransform);

  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ae	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  000b1	50		 push	 eax
  000b2	6a 10		 push	 16			; 00000010H
  000b4	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 835  : 	STATEMANAGER.SaveTransform(D3DTS_TEXTURE1, &matTexTransform);

  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000bf	8d 45 bc	 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  000c2	50		 push	 eax
  000c3	6a 11		 push	 17			; 00000011H
  000c5	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 836  : 
; 837  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d0	6a 01		 push	 1
  000d2	6a 1b		 push	 27			; 0000001bH
  000d4	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 838  : 	STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000df	6a 05		 push	 5
  000e1	6a 13		 push	 19			; 00000013H
  000e3	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 839  : 	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  000e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ee	6a 06		 push	 6
  000f0	6a 14		 push	 20			; 00000014H
  000f2	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 840  : 
; 841  : 	static long lStartTime = timeGetTime();

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S3@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4IA
  000fc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__timeGetTime@0
  00102	a8 01		 test	 al, 1
  00104	75 0f		 jne	 SHORT $LN1@RenderMark
  00106	83 c8 01	 or	 eax, 1
  00109	a3 00 00 00 00	 mov	 DWORD PTR ?$S3@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4IA, eax
  0010e	ff d6		 call	 esi
  00110	a3 00 00 00 00	 mov	 DWORD PTR ?lStartTime@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4JA, eax
$LN1@RenderMark:

; 842  : 	float fTime = float((timeGetTime() - lStartTime)%3000) / 3000.0f;

  00115	ff d6		 call	 esi
  00117	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?lStartTime@?3??RenderMarkedArea@CMapOutdoor@@QAEXXZ@4JA
  0011d	33 d2		 xor	 edx, edx
  0011f	b9 b8 0b 00 00	 mov	 ecx, 3000		; 00000bb8H

; 843  : 	float fAlpha = fabs(fTime - 0.5f) / 2.0f + 0.1f;

  00124	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000
  0012c	f7 f1		 div	 ecx
  0012e	66 0f 6e c2	 movd	 xmm0, edx
  00132	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00136	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  00139	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  00142	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00146	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@453b8000
  0014e	f3 0f 5c c1	 subss	 xmm0, xmm1
; File a:\vs\vc\include\math.h

; 687  :     return (float)fabs(_X);

  00152	0f 5a c0	 cvtps2pd xmm0, xmm0
  00155	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  0015d	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 843  : 	float fAlpha = fabs(fTime - 0.5f) / 2.0f + 0.1f;

  00161	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00165	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3dcccccd
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0016d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00174	72 07		 jb	 SHORT $LN43@RenderMark
  00176	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0017b	eb 1d		 jmp	 SHORT $LN42@RenderMark
$LN43@RenderMark:
  0017d	0f 57 d2	 xorps	 xmm2, xmm2
  00180	0f 2f d0	 comiss	 xmm2, xmm0
  00183	72 04		 jb	 SHORT $LN41@RenderMark
  00185	33 c0		 xor	 eax, eax
  00187	eb 11		 jmp	 SHORT $LN42@RenderMark
$LN41@RenderMark:
  00189	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00191	f3 0f 58 c1	 addss	 xmm0, xmm1
  00195	e8 00 00 00 00	 call	 __ftoui3
$LN42@RenderMark:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 844  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, D3DXCOLOR(1.0f, 1.0f, 1.0f, fAlpha));

  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a0	c1 e0 18	 shl	 eax, 24			; 00000018H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  001a3	0d ff ff ff 00	 or	 eax, 16777215		; 00ffffffH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 844  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, D3DXCOLOR(1.0f, 1.0f, 1.0f, fAlpha));

  001a8	50		 push	 eax
  001a9	6a 3c		 push	 60			; 0000003cH
  001ab	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 845  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b6	6a 02		 push	 2
  001b8	6a 02		 push	 2
  001ba	6a 00		 push	 0
  001bc	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 846  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TFACTOR);

  001c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c7	6a 03		 push	 3
  001c9	6a 03		 push	 3
  001cb	6a 00		 push	 0
  001cd	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 847  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);

  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d8	6a 03		 push	 3
  001da	6a 01		 push	 1
  001dc	6a 00		 push	 0
  001de	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 848  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e9	6a 02		 push	 2
  001eb	6a 05		 push	 5
  001ed	6a 00		 push	 0
  001ef	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 849  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);

  001f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001fa	6a 03		 push	 3
  001fc	6a 06		 push	 6
  001fe	6a 00		 push	 0
  00200	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 850  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2);

  00205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020b	6a 03		 push	 3
  0020d	6a 04		 push	 4
  0020f	6a 00		 push	 0
  00211	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 851  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  00216	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0021c	68 00 00 02 00	 push	 131072			; 00020000H
  00221	6a 0b		 push	 11			; 0000000bH
  00223	6a 00		 push	 0
  00225	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 852  : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  0022a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00230	6a 02		 push	 2
  00232	6a 18		 push	 24			; 00000018H
  00234	6a 00		 push	 0
  00236	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 853  : 
; 854  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0023b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00241	6a 01		 push	 1
  00243	6a 02		 push	 2
  00245	6a 01		 push	 1
  00247	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 855  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

  0024c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00252	6a 02		 push	 2
  00254	6a 01		 push	 1
  00256	6a 01		 push	 1
  00258	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 856  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  0025d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00263	6a 02		 push	 2
  00265	6a 05		 push	 5
  00267	6a 01		 push	 1
  00269	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 857  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);

  0026e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00274	6a 01		 push	 1
  00276	6a 06		 push	 6
  00278	6a 01		 push	 1
  0027a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 858  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);

  0027f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00285	6a 04		 push	 4
  00287	6a 04		 push	 4
  00289	6a 01		 push	 1
  0028b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 859  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  00290	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00296	68 00 00 02 00	 push	 131072			; 00020000H
  0029b	6a 0b		 push	 11			; 0000000bH
  0029d	6a 01		 push	 1
  0029f	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 860  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  002a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002aa	6a 02		 push	 2
  002ac	6a 18		 push	 24			; 00000018H
  002ae	6a 01		 push	 1
  002b0	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 861  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_MINFILTER,	D3DTEXF_POINT);

  002b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002bb	6a 01		 push	 1
  002bd	6a 11		 push	 17			; 00000011H
  002bf	6a 01		 push	 1
  002c1	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 862  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_MAGFILTER,	D3DTEXF_POINT);

  002c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002cc	6a 01		 push	 1
  002ce	6a 10		 push	 16			; 00000010H
  002d0	6a 01		 push	 1
  002d2	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 863  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_MIPFILTER,	D3DTEXF_POINT);

  002d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002dd	6a 01		 push	 1
  002df	6a 12		 push	 18			; 00000012H
  002e1	6a 01		 push	 1
  002e3	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 864  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  002e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ee	6a 03		 push	 3
  002f0	6a 0d		 push	 13			; 0000000dH
  002f2	6a 01		 push	 1
  002f4	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 865  : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);

  002f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ff	6a 03		 push	 3
  00301	6a 0e		 push	 14			; 0000000eH
  00303	6a 01		 push	 1
  00305	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  0030a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 867  : 	STATEMANAGER.SetTexture(0, m_attrImageInstance.GetTexturePointer()->GetD3DTexture());

  00310	8d 8f ec 0d 00
	00		 lea	 ecx, DWORD PTR [edi+3564]
  00316	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  0031b	8b c8		 mov	 ecx, eax
  0031d	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00322	50		 push	 eax
  00323	6a 00		 push	 0
  00325	8b ce		 mov	 ecx, esi
  00327	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 868  : 
; 869  : 	RecurseRenderAttr(m_pRootNode);

  0032c	6a 01		 push	 1
  0032e	ff b7 14 01 00
	00		 push	 DWORD PTR [edi+276]
  00334	8b cf		 mov	 ecx, edi
  00336	e8 00 00 00 00	 call	 ?RecurseRenderAttr@CMapOutdoor@@QAEXPAVCTerrainQuadtreeNode@@_N@Z ; CMapOutdoor::RecurseRenderAttr

; 870  : 
; 871  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXCOORDINDEX);

  0033b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00341	6a 0b		 push	 11			; 0000000bH
  00343	6a 00		 push	 0
  00345	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 872  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS);

  0034a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00350	6a 18		 push	 24			; 00000018H
  00352	6a 00		 push	 0
  00354	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 873  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXCOORDINDEX);

  00359	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0035f	6a 0b		 push	 11			; 0000000bH
  00361	6a 01		 push	 1
  00363	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 874  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS);

  00368	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0036e	6a 18		 push	 24			; 00000018H
  00370	6a 01		 push	 1
  00372	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 875  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_MINFILTER);

  00377	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0037d	6a 11		 push	 17			; 00000011H
  0037f	6a 01		 push	 1
  00381	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 876  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_MAGFILTER);

  00386	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0038c	6a 10		 push	 16			; 00000010H
  0038e	6a 01		 push	 1
  00390	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 877  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_MIPFILTER);

  00395	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0039b	6a 12		 push	 18			; 00000012H
  0039d	6a 01		 push	 1
  0039f	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 878  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSU);

  003a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003aa	6a 0d		 push	 13			; 0000000dH
  003ac	6a 01		 push	 1
  003ae	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 879  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_ADDRESSV);

  003b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003b9	6a 0e		 push	 14			; 0000000eH
  003bb	6a 01		 push	 1
  003bd	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 880  : 
; 881  : 	STATEMANAGER.RestoreTransform(D3DTS_TEXTURE0);

  003c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003c8	6a 10		 push	 16			; 00000010H
  003ca	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 882  : 	STATEMANAGER.RestoreTransform(D3DTS_TEXTURE1);

  003cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003d5	6a 11		 push	 17			; 00000011H
  003d7	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 883  : 
; 884  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  003dc	6a 1b		 push	 27			; 0000001bH
  003de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003e4	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 885  : 	STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);

  003e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ef	6a 13		 push	 19			; 00000013H
  003f1	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 886  : 	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  003f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003fc	6a 14		 push	 20			; 00000014H
  003fe	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState
  00403	5e		 pop	 esi
$LN3@RenderMark:

; 887  : }

  00404	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00407	33 cd		 xor	 ecx, ebp
  00409	5f		 pop	 edi
  0040a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040f	8b e5		 mov	 esp, ebp
  00411	5d		 pop	 ebp
  00412	c3		 ret	 0
?RenderMarkedArea@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::RenderMarkedArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?ApplyLight@CMapOutdoor@@UAEXKABU_D3DLIGHT8@@@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
_c_rkLight$ = 12					; size = 4
?ApplyLight@CMapOutdoor@@UAEXKABU_D3DLIGHT8@@@Z PROC	; CMapOutdoor::ApplyLight, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  : 	m_kSTPD.m_dwLightVersion=dwVersion;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwVersion$[ebp]
  00006	89 81 08 0a 00
	00		 mov	 DWORD PTR [ecx+2568], eax

; 133  : 	STATEMANAGER.SetLight(0, &c_rkLight);

  0000c	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _dwVersion$[ebp], 0
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 134  : }

  00019	5d		 pop	 ebp

; 133  : 	STATEMANAGER.SetLight(0, &c_rkLight);

  0001a	e9 00 00 00 00	 jmp	 ?SetLight@CStateManager@@QAEXKPBU_D3DLIGHT8@@@Z ; CStateManager::SetLight
?ApplyLight@CMapOutdoor@@UAEXKABU_D3DLIGHT8@@@Z ENDP	; CMapOutdoor::ApplyLight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?GetRenderedGraphicThingInstanceNum@CMapOutdoor@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@PAK0@Z
_TEXT	SEGMENT
_pdwGraphicThingInstanceNum$ = 8			; size = 4
_pdwCRCNum$ = 12					; size = 4
?GetRenderedGraphicThingInstanceNum@CMapOutdoor@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@PAK0@Z PROC ; CMapOutdoor::GetRenderedGraphicThingInstanceNum, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 184  : 	*pdwGraphicThingInstanceNum = m_dwRenderedGraphicThingInstanceNum;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pdwGraphicThingInstanceNum$[ebp]
  00006	8b 91 b4 09 00
	00		 mov	 edx, DWORD PTR [ecx+2484]
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 185  : 	*pdwCRCNum = m_dwRenderedCRCNum;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _pdwCRCNum$[ebp]
  00011	8b 89 b0 09 00
	00		 mov	 ecx, DWORD PTR [ecx+2480]
  00017	89 08		 mov	 DWORD PTR [eax], ecx

; 186  : 
; 187  : 	return m_dwRenderedCRCWithNumberVector;

  00019	b8 00 00 00 00	 mov	 eax, OFFSET ?m_dwRenderedCRCWithNumberVector@@3V?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@A ; m_dwRenderedCRCWithNumberVector

; 188  : }

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?GetRenderedGraphicThingInstanceNum@CMapOutdoor@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@PAK0@Z ENDP ; CMapOutdoor::GetRenderedGraphicThingInstanceNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?GetRenderedSplatNum@CMapOutdoor@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@PAH0PAM@Z
_TEXT	SEGMENT
_piPatch$ = 8						; size = 4
_piSplat$ = 12						; size = 4
_pfSplatRatio$ = 16					; size = 4
?GetRenderedSplatNum@CMapOutdoor@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@PAH0PAM@Z PROC ; CMapOutdoor::GetRenderedSplatNum, COMDAT
; _this$ = ecx

; 174  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 175  : 	*piPatch = m_iRenderedPatchNum;

  00003	8b 45 08	 mov	 eax, DWORD PTR _piPatch$[ebp]
  00006	8b 91 8c 09 00
	00		 mov	 edx, DWORD PTR [ecx+2444]
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 176  : 	*piSplat = m_iRenderedSplatNum;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _piSplat$[ebp]
  00011	8b 91 88 09 00
	00		 mov	 edx, DWORD PTR [ecx+2440]
  00017	89 10		 mov	 DWORD PTR [eax], edx
  00019	66 0f 6e 89 84
	09 00 00	 movd	 xmm1, DWORD PTR [ecx+2436]
  00021	66 0f 6e 81 8c
	09 00 00	 movd	 xmm0, DWORD PTR [ecx+2444]

; 177  : 	*pfSplatRatio = m_iRenderedSplatNumSqSum/float(m_iRenderedPatchNum);

  00029	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0002c	8b 45 10	 mov	 eax, DWORD PTR _pfSplatRatio$[ebp]
  0002f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00032	f3 0f 5e c8	 divss	 xmm1, xmm0
  00036	f3 0f 11 08	 movss	 DWORD PTR [eax], xmm1

; 178  : 
; 179  : 	return m_RenderedTextureNumVector;

  0003a	8d 81 90 09 00
	00		 lea	 eax, DWORD PTR [ecx+2448]

; 180  : }

  00040	5d		 pop	 ebp
  00041	c2 0c 00	 ret	 12			; 0000000cH
?GetRenderedSplatNum@CMapOutdoor@@QAEAAV?$vector@HV?$allocator@H@std@@@std@@PAH0PAM@Z ENDP ; CMapOutdoor::GetRenderedSplatNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?SetSplatLimit@CMapOutdoor@@QAEXH@Z
_TEXT	SEGMENT
_iSplatNum$ = 8						; size = 4
?SetSplatLimit@CMapOutdoor@@QAEXH@Z PROC		; CMapOutdoor::SetSplatLimit, COMDAT
; _this$ = ecx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 	m_iSplatLimit = iSplatNum;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iSplatNum$[ebp]
  00006	89 81 9c 09 00
	00		 mov	 DWORD PTR [ecx+2460], eax

; 171  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetSplatLimit@CMapOutdoor@@QAEXH@Z ENDP		; CMapOutdoor::SetSplatLimit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?SetVisiblePart@CMapOutdoor@@QAEXH_N@Z
_TEXT	SEGMENT
_ePart$ = 8						; size = 4
_isVisible$ = 12					; size = 1
?SetVisiblePart@CMapOutdoor@@QAEXH_N@Z PROC		; CMapOutdoor::SetVisiblePart, COMDAT
; _this$ = ecx

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 145  : 	DWORD dwMask=(1<<ePart);

  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _ePart$[ebp]
  0000d	d3 e0		 shl	 eax, cl

; 146  : 	if (isVisible)

  0000f	80 7d 0c 00	 cmp	 BYTE PTR _isVisible$[ebp], 0
  00013	74 0a		 je	 SHORT $LN2@SetVisible

; 147  : 	{
; 148  : 		m_dwVisiblePartFlags|=dwMask;

  00015	09 82 80 09 00
	00		 or	 DWORD PTR [edx+2432], eax

; 154  : 	}
; 155  : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
$LN2@SetVisible:

; 149  : 	}	
; 150  : 	else
; 151  : 	{
; 152  : 		DWORD dwReverseMask=~dwMask;

  0001f	f7 d0		 not	 eax

; 153  : 		m_dwVisiblePartFlags&=dwReverseMask;

  00021	21 82 80 09 00
	00		 and	 DWORD PTR [edx+2432], eax

; 154  : 	}
; 155  : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?SetVisiblePart@CMapOutdoor@@QAEXH_N@Z ENDP		; CMapOutdoor::SetVisiblePart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?SetInverseViewAndDynamicShaodwMatrices@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
$T1 = -168						; size = 64
$T2 = -104						; size = 64
$T3 = -40						; size = 12
_v3LightEye$ = -28					; size = 12
_v3Target$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?SetInverseViewAndDynamicShaodwMatrices@CMapOutdoor@@QAEXXZ PROC ; CMapOutdoor::SetInverseViewAndDynamicShaodwMatrices, COMDAT
; _this$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx

; 244  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0001c	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 245  : 
; 246  : 	if (!pCamera)

  00021	85 c0		 test	 eax, eax
  00023	0f 84 0d 01 00
	00		 je	 $LN2@SetInverse

; 249  : 	m_matViewInverse = pCamera->GetInverseViewMatrix();

  00029	f3 0f 6f 80 ac
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [eax+172]
  00031	56		 push	 esi
  00032	57		 push	 edi
  00033	f3 0f 7f 83 88
	07 00 00	 movdqu	 XMMWORD PTR [ebx+1928], xmm0
  0003b	8d bb 88 07 00
	00		 lea	 edi, DWORD PTR [ebx+1928]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00041	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 249  : 	m_matViewInverse = pCamera->GetInverseViewMatrix();

  00048	f3 0f 6f 80 bc
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [eax+188]

; 257  : 	D3DXMatrixLookAtRH(&m_matLightView, &v3LightEye, &v3Target, &D3DXVECTOR3(0.0f, 0.0f, 1.0f));

  00050	8d b3 c8 08 00
	00		 lea	 esi, DWORD PTR [ebx+2248]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00056	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0

; 182  :     z = fz;

  0005d	c7 45 e0 00 00
	80 3f		 mov	 DWORD PTR $T3[ebp+8], 1065353216 ; 3f800000H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 249  : 	m_matViewInverse = pCamera->GetInverseViewMatrix();

  00064	f3 0f 7f 47 10	 movdqu	 XMMWORD PTR [edi+16], xmm0
  00069	f3 0f 6f 80 cc
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [eax+204]
  00071	f3 0f 7f 47 20	 movdqu	 XMMWORD PTR [edi+32], xmm0
  00076	f3 0f 6f 80 dc
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [eax+220]
  0007e	f3 0f 7f 47 30	 movdqu	 XMMWORD PTR [edi+48], xmm0

; 250  : 	
; 251  : 	D3DXVECTOR3 v3Target = pCamera->GetTarget();

  00083	f3 0f 7e 40 3c	 movq	 xmm0, QWORD PTR [eax+60]
  00088	66 0f d6 45 f0	 movq	 QWORD PTR _v3Target$[ebp], xmm0

; 255  : 						   v3Target.z + 2.0f * 1.732f * 1250.0f);

  0008d	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3Target$[ebp]
  00092	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@45075000
  0009a	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  0009d	89 45 f8	 mov	 DWORD PTR _v3Target$[ebp+8], eax

; 257  : 	D3DXMatrixLookAtRH(&m_matLightView, &v3LightEye, &v3Target, &D3DXVECTOR3(0.0f, 0.0f, 1.0f));

  000a0	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  000a3	50		 push	 eax
  000a4	8d 45 f0	 lea	 eax, DWORD PTR _v3Target$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  000a7	f3 0f 11 45 e4	 movss	 DWORD PTR _v3LightEye$[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 255  : 						   v3Target.z + 2.0f * 1.732f * 1250.0f);

  000ac	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3Target$[ebp+4]
  000b1	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@449c4000

; 257  : 	D3DXMatrixLookAtRH(&m_matLightView, &v3LightEye, &v3Target, &D3DXVECTOR3(0.0f, 0.0f, 1.0f));

  000b9	50		 push	 eax
  000ba	8d 45 e4	 lea	 eax, DWORD PTR _v3LightEye$[ebp]
  000bd	50		 push	 eax
  000be	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  000bf	f3 0f 11 45 e8	 movss	 DWORD PTR _v3LightEye$[ebp+4], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 255  : 						   v3Target.z + 2.0f * 1.732f * 1250.0f);

  000c4	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Target$[ebp+8]
  000c9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@45875000
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000d1	f3 0f 11 45 ec	 movss	 DWORD PTR _v3LightEye$[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 257  : 	D3DXMatrixLookAtRH(&m_matLightView, &v3LightEye, &v3Target, &D3DXVECTOR3(0.0f, 0.0f, 1.0f));

  000d6	e8 00 00 00 00	 call	 _D3DXMatrixLookAtRH@16
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  000db	56		 push	 esi
  000dc	57		 push	 edi
  000dd	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 258  : 	m_matDynamicShadow = m_matViewInverse * m_matLightView * m_matDynamicShadowScale;

  000e9	8d 83 88 08 00
	00		 lea	 eax, DWORD PTR [ebx+2184]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  000ef	50		 push	 eax
  000f0	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000f6	50		 push	 eax
  000f7	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp

; 258  : 	m_matDynamicShadow = m_matViewInverse * m_matLightView * m_matDynamicShadowScale;

  00100	f3 0f 6f 45 98	 movdqu	 xmm0, XMMWORD PTR $T2[ebp]
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	f3 0f 7f 83 48
	08 00 00	 movdqu	 XMMWORD PTR [ebx+2120], xmm0
  0010f	f3 0f 6f 45 a8	 movdqu	 xmm0, XMMWORD PTR $T2[ebp+16]
  00114	f3 0f 7f 83 58
	08 00 00	 movdqu	 XMMWORD PTR [ebx+2136], xmm0
  0011c	f3 0f 6f 45 b8	 movdqu	 xmm0, XMMWORD PTR $T2[ebp+32]
  00121	f3 0f 7f 83 68
	08 00 00	 movdqu	 XMMWORD PTR [ebx+2152], xmm0
  00129	f3 0f 6f 45 c8	 movdqu	 xmm0, XMMWORD PTR $T2[ebp+48]
  0012e	f3 0f 7f 83 78
	08 00 00	 movdqu	 XMMWORD PTR [ebx+2168], xmm0
$LN2@SetInverse:

; 259  : }

  00136	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00139	33 cd		 xor	 ecx, ebp
  0013b	5b		 pop	 ebx
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
?SetInverseViewAndDynamicShaodwMatrices@CMapOutdoor@@QAEXXZ ENDP ; CMapOutdoor::SetInverseViewAndDynamicShaodwMatrices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\mapoutdoorrender.cpp
;	COMDAT ?OnRender@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
?OnRender@CMapOutdoor@@MAEXXZ PROC			; CMapOutdoor::OnRender, COMDAT
; _this$ = ecx

; 262  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 263  : #ifdef __PERFORMANCE_CHECKER__
; 264  : 	DWORD t1=ELTimer_GetMSec();
; 265  : 	SetInverseViewAndDynamicShaodwMatrices();
; 266  : 
; 267  : 	SetBlendOperation();
; 268  : 	DWORD t2=ELTimer_GetMSec();
; 269  : 	RenderArea();
; 270  : 	DWORD t3=ELTimer_GetMSec();
; 271  : 	if (!m_bEnableTerrainOnlyForHeight)
; 272  : 		RenderTerrain();
; 273  : 	DWORD t4=ELTimer_GetMSec();
; 274  : 	RenderTree();
; 275  : 	DWORD t5=ELTimer_GetMSec();
; 276  : 	DWORD tEnd=ELTimer_GetMSec();
; 277  : 
; 278  : 	if (tEnd-t1<7)
; 279  : 		return;
; 280  : 
; 281  : 	static FILE* fp=fopen("perf_map_render.txt", "w");
; 282  :  	fprintf(fp, "MAP.Total %d (Time %d)\n", tEnd-t1, ELTimer_GetMSec());
; 283  : 	fprintf(fp, "MAP.ENV %d\n", t2-t1);
; 284  : 	fprintf(fp, "MAP.OBJ %d\n", t3-t2);
; 285  : 	fprintf(fp, "MAP.TRN %d\n", t4-t3);
; 286  : 	fprintf(fp, "MAP.TRE %d\n", t5-t4);
; 287  : 
; 288  : #else
; 289  : 	SetInverseViewAndDynamicShaodwMatrices();

  00003	e8 00 00 00 00	 call	 ?SetInverseViewAndDynamicShaodwMatrices@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetInverseViewAndDynamicShaodwMatrices

; 290  : 
; 291  : 	SetBlendOperation();

  00008	8b ce		 mov	 ecx, esi
  0000a	e8 00 00 00 00	 call	 ?SetBlendOperation@CScreen@@QAEXXZ ; CScreen::SetBlendOperation

; 292  : 	RenderArea();

  0000f	6a 01		 push	 1
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ?RenderArea@CMapOutdoor@@QAEX_N@Z ; CMapOutdoor::RenderArea

; 293  : 	RenderTree();

  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?RenderTree@CMapOutdoor@@QAEXXZ ; CMapOutdoor::RenderTree

; 294  : 	if (!m_bEnableTerrainOnlyForHeight)

  0001f	80 be b6 0e 00
	00 00		 cmp	 BYTE PTR [esi+3766], 0
  00026	75 07		 jne	 SHORT $LN1@OnRender

; 295  : 		RenderTerrain();

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?RenderTerrain@CMapOutdoor@@QAEXXZ ; CMapOutdoor::RenderTerrain
$LN1@OnRender:

; 296  : 	RenderBlendArea();

  0002f	8b ce		 mov	 ecx, esi
  00031	5e		 pop	 esi
  00032	e9 00 00 00 00	 jmp	 ?RenderBlendArea@CMapOutdoor@@QAEXXZ ; CMapOutdoor::RenderBlendArea
?OnRender@CMapOutdoor@@MAEXXZ ENDP			; CMapOutdoor::OnRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h
;	COMDAT ?GetCoordinate@CTerrain@@QAEXPAG0@Z
_TEXT	SEGMENT
_usCoordX$ = 8						; size = 4
_usCoordY$ = 12						; size = 4
?GetCoordinate@CTerrain@@QAEXPAG0@Z PROC		; CTerrain::GetCoordinate, COMDAT
; _this$ = ecx

; 91   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   : 			*usCoordX = m_wX;

  00003	8b 45 08	 mov	 eax, DWORD PTR _usCoordX$[ebp]
  00006	66 8b 91 6c a5
	06 00		 mov	 dx, WORD PTR [ecx+435564]
  0000d	66 89 10	 mov	 WORD PTR [eax], dx

; 93   : 			*usCoordY = m_wY;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _usCoordY$[ebp]
  00013	66 8b 89 6e a5
	06 00		 mov	 cx, WORD PTR [ecx+435566]
  0001a	66 89 08	 mov	 WORD PTR [eax], cx

; 94   : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?GetCoordinate@CTerrain@@QAEXPAG0@Z ENDP		; CTerrain::GetCoordinate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h
;	COMDAT ?GetMarkedSplatPatch@CTerrain@@QAEAAUTTerrainSplatPatch@@XZ
_TEXT	SEGMENT
?GetMarkedSplatPatch@CTerrain@@QAEAAUTTerrainSplatPatch@@XZ PROC ; CTerrain::GetMarkedSplatPatch, COMDAT
; _this$ = ecx

; 87   : 		TTerrainSplatPatch &		GetMarkedSplatPatch() { return m_MarkedSplatPatch; }

  00000	8d 81 dc c1 06
	00		 lea	 eax, DWORD PTR [ecx+442844]
  00006	c3		 ret	 0
?GetMarkedSplatPatch@CTerrain@@QAEAAUTTerrainSplatPatch@@XZ ENDP ; CTerrain::GetMarkedSplatPatch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\areaterrain.h
;	COMDAT ?IsMarked@CTerrain@@QAEHXZ
_TEXT	SEGMENT
?IsMarked@CTerrain@@QAEHXZ PROC				; CTerrain::IsMarked, COMDAT
; _this$ = ecx

; 84   : 		BOOL						IsMarked() { return m_bMarked; }

  00000	8b 81 d8 c1 06
	00		 mov	 eax, DWORD PTR [ecx+442840]
  00006	c3		 ret	 0
?IsMarked@CTerrain@@QAEHXZ ENDP				; CTerrain::IsMarked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ
_TEXT	SEGMENT
?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ PROC		; CTerrainPatchProxy::GetTerrainNum, COMDAT
; _this$ = ecx

; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  00000	8a 41 08	 mov	 al, BYTE PTR [ecx+8]
  00003	c3		 ret	 0
?GetTerrainNum@CTerrainPatchProxy@@QAEEXZ ENDP		; CTerrainPatchProxy::GetTerrainNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?GetPatchNum@CTerrainPatchProxy@@QAEFXZ
_TEXT	SEGMENT
?GetPatchNum@CTerrainPatchProxy@@QAEFXZ PROC		; CTerrainPatchProxy::GetPatchNum, COMDAT
; _this$ = ecx

; 173  : 	short GetPatchNum()																{ return m_sPatchNum; }

  00000	66 8b 41 06	 mov	 ax, WORD PTR [ecx+6]
  00004	c3		 ret	 0
?GetPatchNum@CTerrainPatchProxy@@QAEFXZ ENDP		; CTerrainPatchProxy::GetPatchNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\terrainpatch.h
;	COMDAT ?isUsed@CTerrainPatchProxy@@QAE_NXZ
_TEXT	SEGMENT
?isUsed@CTerrainPatchProxy@@QAE_NXZ PROC		; CTerrainPatchProxy::isUsed, COMDAT
; _this$ = ecx

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00003	c3		 ret	 0
?isUsed@CTerrainPatchProxy@@QAE_NXZ ENDP		; CTerrainPatchProxy::isUsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXPAUSCRCWithNumber@CArea@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXPAUSCRCWithNumber@CArea@@0@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXPAUSCRCWithNumber@CArea@@0@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEXXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 03	 sar	 eax, 3

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 1f	 mov	 ebx, 536870911		; 1fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 03	 sar	 esi, 3

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 03	 sar	 edx, 3

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Ptr$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$1$ = 8						; size = 4
__Cat$3 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$4 = 11						; size = 1
?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	33 f6		 xor	 esi, esi
  00032	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00035	85 db		 test	 ebx, ebx
  00037	74 26		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00039	81 fb ff ff ff
	1f		 cmp	 ebx, 536870911		; 1fffffffH
  0003f	77 19		 ja	 SHORT $LN15@Reallocate
  00041	8d 04 dd 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*8]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004e	8b f0		 mov	 esi, eax
  00050	83 c4 04	 add	 esp, 4
  00053	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00056	85 f6		 test	 esi, esi
  00058	75 05		 jne	 SHORT $LN16@Reallocate
$LN15@Reallocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0005a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN60@Reallocate:
$LN16@Reallocate:
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0005f	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  00062	8d 45 0b	 lea	 eax, DWORD PTR __Alval$4[ebp]
; File a:\vs\vc\include\vector

; 1590 : 		_TRY_BEGIN

  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0006c	6a 00		 push	 0
  0006e	50		 push	 eax
  0006f	56		 push	 esi
  00070	ff 77 04	 push	 DWORD PTR [edi+4]
  00073	ff 37		 push	 DWORD PTR [edi]
  00075	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSCRCWithNumber@CArea@@PAU12@V?$allocator@USCRCWithNumber@CArea@@@std@@U12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber>,CArea::SCRCWithNumber>
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007a	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0007c	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00082	2b c1		 sub	 eax, ecx
  00084	c1 f8 03	 sar	 eax, 3
  00087	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0008a	85 c9		 test	 ecx, ecx
  0008c	74 09		 je	 SHORT $LN54@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00094	83 c4 04	 add	 esp, 4
$LN54@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  00097	8d 04 de	 lea	 eax, DWORD PTR [esi+ebx*8]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  0009a	89 37		 mov	 DWORD PTR [edi], esi
  0009c	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0009f	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  000a2	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  000a5	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1609 : 		}

  000a8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b2	59		 pop	 ecx
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000bc	ff 75 ec	 push	 DWORD PTR __Ptr$2[ebp]
  000bf	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c4	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1594 : 		_RERAISE;

  000c7	6a 00		 push	 0
  000c9	6a 00		 push	 0
  000cb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN61@Reallocate:
$LN59@Reallocate:
  000d0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reallocate
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBE_NPBUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBE_NPBUSCRCWithNumber@CArea@@@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBE_NPBUSCRCWithNumber@CArea@@@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEII@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 03	 sar	 edx, 3

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IBEII@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXPAUSCRCWithNumber@CArea@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXPAUSCRCWithNumber@CArea@@0@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXPAUSCRCWithNumber@CArea@@0@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 38		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 32		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 03	 sar	 edi, 3

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002d	85 d2		 test	 edx, edx
  0002f	74 37		 je	 SHORT $LN49@push_back
  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00033	8b 04 f9	 mov	 eax, DWORD PTR [ecx+edi*8]
  00036	89 02		 mov	 DWORD PTR [edx], eax
  00038	8b 44 f9 04	 mov	 eax, DWORD PTR [ecx+edi*8+4]
  0003c	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0003f	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00049	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0004c	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  0004e	6a 01		 push	 1
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@IAEXI@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00057	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005a	85 c9		 test	 ecx, ecx
  0005c	74 0a		 je	 SHORT $LN49@push_back
  0005e	8b 07		 mov	 eax, DWORD PTR [edi]
  00060	89 01		 mov	 DWORD PTR [ecx], eax
  00062	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00065	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00068	83 46 04 08	 add	 DWORD PTR [esi+4], 8
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?push_back@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@2@XZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 03	 sar	 eax, 3

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::~vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::~vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@ABV?$allocator@USCRCWithNumber@CArea@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@ABV?$allocator@USCRCWithNumber@CArea@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@@std@@QAE@ABV?$allocator@USCRCWithNumber@CArea@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >::_Vector_alloc<0,std::_Vec_base_types<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> >::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> >::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >::_Wrap_alloc<std::allocator<CArea::SCRCWithNumber> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAIABV?$allocator@USCRCWithNumber@CArea@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAIABV?$allocator@USCRCWithNumber@CArea@@@2@@Z PROC ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@SAIABV?$allocator@USCRCWithNumber@CArea@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CArea::SCRCWithNumber> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@USCRCWithNumber@CArea@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@USCRCWithNumber@CArea@@@std@@QBEIXZ PROC ; std::allocator<CArea::SCRCWithNumber>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@USCRCWithNumber@CArea@@@std@@QBEIXZ ENDP ; std::allocator<CArea::SCRCWithNumber>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU34@@Z PROC ; std::allocator<CArea::SCRCWithNumber>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 594  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@ABU34@@Z ENDP ; std::allocator<CArea::SCRCWithNumber>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z PROC ; std::allocator<CArea::SCRCWithNumber>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEPAUSCRCWithNumber@CArea@@I@Z ENDP ; std::allocator<CArea::SCRCWithNumber>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z PROC ; std::allocator<CArea::SCRCWithNumber>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXPAUSCRCWithNumber@CArea@@I@Z ENDP ; std::allocator<CArea::SCRCWithNumber>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@USCRCWithNumber@CArea@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USCRCWithNumber@CArea@@@std@@QAE@XZ PROC	; std::allocator<CArea::SCRCWithNumber>::allocator<CArea::SCRCWithNumber>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USCRCWithNumber@CArea@@@std@@QAE@XZ ENDP	; std::allocator<CArea::SCRCWithNumber>::allocator<CArea::SCRCWithNumber>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
;	COMDAT ??RCRCNumComp@CArea@@QBE_NAAUSCRCWithNumber@1@0@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??RCRCNumComp@CArea@@QBE_NAAUSCRCWithNumber@1@0@Z PROC	; CArea::CRCNumComp::operator(), COMDAT
; _this$ = ecx

; 189  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00003	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  0000c	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  0000f	1b c0		 sbb	 eax, eax
  00011	f7 d8		 neg	 eax

; 191  : 			}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??RCRCNumComp@CArea@@QBE_NAAUSCRCWithNumber@1@0@Z ENDP	; CArea::CRCNumComp::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
;	COMDAT ??RFFindIfCRC@CArea@@QAE_NAAUSCRCWithNumber@1@@Z
_TEXT	SEGMENT
_rCRCWithNumber$ = 8					; size = 4
??RFFindIfCRC@CArea@@QAE_NAAUSCRCWithNumber@1@@Z PROC	; CArea::FFindIfCRC::operator(), COMDAT
; _this$ = ecx

; 177  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 178  : 				if (rCRCWithNumber.dwCRC == m_dwCRC)

  00003	8b 45 08	 mov	 eax, DWORD PTR _rCRCWithNumber$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	0f 94 c0	 sete	 al

; 179  : 					return true;
; 180  : 				return false;
; 181  : 			}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??RFFindIfCRC@CArea@@QAE_NAAUSCRCWithNumber@1@@Z ENDP	; CArea::FFindIfCRC::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\area.h
;	COMDAT ??0FFindIfCRC@CArea@@QAE@K@Z
_TEXT	SEGMENT
_dwCRC$ = 8						; size = 4
??0FFindIfCRC@CArea@@QAE@K@Z PROC			; CArea::FFindIfCRC::FFindIfCRC, COMDAT
; _this$ = ecx

; 174  : 			FFindIfCRC(DWORD dwCRC) { m_dwCRC = dwCRC; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _dwCRC$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0FFindIfCRC@CArea@@QAE@K@Z ENDP			; CArea::FFindIfCRC::FFindIfCRC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXPAPAVCGraphicThingInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXPAPAVCGraphicThingInstance@@0@Z PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@IAEXPAPAVCGraphicThingInstance@@0@Z ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicThingInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicThingInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicThingInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >::_Wrap_alloc<std::allocator<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z PROC ; std::allocator<CGraphicThingInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXPAPAVCGraphicThingInstance@@I@Z ENDP ; std::allocator<CGraphicThingInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGraphicThingInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGraphicThingInstance@@@std@@QAE@XZ PROC ; std::allocator<CGraphicThingInstance *>::allocator<CGraphicThingInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGraphicThingInstance@@@std@@QAE@XZ ENDP ; std::allocator<CGraphicThingInstance *>::allocator<CGraphicThingInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ PROC ; CSingleton<CSpeedTreeForestDirectX8>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCSpeedTreeForestDirectX8@@@@SAAAVCSpeedTreeForestDirectX8@@XZ ENDP ; CSingleton<CSpeedTreeForestDirectX8>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicObjectInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicObjectInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpvertexbuffer.h
;	COMDAT ?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ
_TEXT	SEGMENT
?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ PROC ; CGraphicVertexBuffer::GetD3DVertexBuffer, COMDAT
; _this$ = ecx

; 33   : 		inline	LPDIRECT3DVERTEXBUFFER8 GetD3DVertexBuffer() const	{ return m_lpd3dVB; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetD3DVertexBuffer@CGraphicVertexBuffer@@QBEPAUIDirect3DVertexBuffer8@@XZ ENDP ; CGraphicVertexBuffer::GetD3DVertexBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00012	3b c7		 cmp	 eax, edi
  00014	73 44		 jae	 SHORT $LN2@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00016	53		 push	 ebx
  00017	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00019	8b c3		 mov	 eax, ebx
  0001b	2b c6		 sub	 eax, esi
  0001d	48		 dec	 eax
  0001e	3b c7		 cmp	 eax, edi
  00020	72 3e		 jb	 SHORT $LN43@Reserve

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00022	2b f3		 sub	 esi, ebx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00024	2b d3		 sub	 edx, ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00026	03 f7		 add	 esi, edi

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00028	83 c8 ff	 or	 eax, -1
  0002b	8b fa		 mov	 edi, edx
  0002d	d1 ef		 shr	 edi, 1
  0002f	2b c7		 sub	 eax, edi
  00031	5b		 pop	 ebx
  00032	3b c2		 cmp	 eax, edx
  00034	73 12		 jae	 SHORT $LN27@Reserve
  00036	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00038	3b d6		 cmp	 edx, esi
  0003a	5f		 pop	 edi
  0003b	0f 42 d6	 cmovb	 edx, esi
  0003e	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0003f	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  00042	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00043	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
$LN27@Reserve:

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00048	03 d7		 add	 edx, edi

; 1576 : 		if (_Capacity < _Count)

  0004a	3b d6		 cmp	 edx, esi
  0004c	5f		 pop	 edi
  0004d	0f 42 d6	 cmovb	 edx, esi
  00050	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00051	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  00054	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00055	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
$LN2@Reserve:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00065	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  0006a	cc		 int	 3
?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00009	33 f6		 xor	 esi, esi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b d9		 mov	 ebx, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 ff		 test	 edi, edi
  0000f	74 14		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	83 ff ff	 cmp	 edi, -1
  00014	77 50		 ja	 SHORT $LN61@Reallocate
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b f0		 mov	 esi, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 f6		 test	 esi, esi
  00023	74 41		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00025	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00027	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002a	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00039	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003c	2b c8		 sub	 ecx, eax
  0003e	89 4d 08	 mov	 DWORD PTR __Size$1$[ebp], ecx

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00041	85 c0		 test	 eax, eax
  00043	74 0c		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  0004e	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  00051	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00054	89 33		 mov	 DWORD PTR [ebx], esi
  00056	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00059	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00061	5b		 pop	 ebx

; 1609 : 		}

  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00066	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0006b	cc		 int	 3
?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	83 c8 ff	 or	 eax, -1

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00009	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0000b	8b ca		 mov	 ecx, edx
  0000d	d1 e9		 shr	 ecx, 1
  0000f	2b c1		 sub	 eax, ecx
  00011	3b c2		 cmp	 eax, edx
  00013	73 0f		 jae	 SHORT $LN4@Grow_to
  00015	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00017	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001a	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  0001e	8b c2		 mov	 eax, edx

; 1579 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00024	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  00026	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  00029	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  0002d	8b c2		 mov	 eax, edx

; 1579 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEXABE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEXABE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 2d		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 27		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)

  00017	2b f9		 sub	 edi, ecx
  00019	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001c	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  0001e	6a 01		 push	 1
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 29		 je	 SHORT $LN49@push_back
  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	8a 04 07	 mov	 al, BYTE PTR [edi+eax]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00033	88 01		 mov	 BYTE PTR [ecx], al
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00035	ff 46 04	 inc	 DWORD PTR [esi+4]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  0003e	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00041	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00043	6a 01		 push	 1
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0004c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004f	85 c9		 test	 ecx, ecx
  00051	74 04		 je	 SHORT $LN49@push_back
  00053	8a 07		 mov	 al, BYTE PTR [edi]
  00055	88 01		 mov	 BYTE PTR [ecx], al
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00057	ff 46 04	 inc	 DWORD PTR [esi+4]
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEXABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	83 c8 ff	 or	 eax, -1

; 1154 : 		}

  00003	c3		 ret	 0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1149 : 		}

  00005	c3		 ret	 0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 1016 : 		}

  00006	c3		 ret	 0
?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1011 : 		}

  00005	c3		 ret	 0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 885  : 		}

  00003	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 14		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	77 15		 ja	 SHORT $LN14@allocate
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	8b c8		 mov	 ecx, eax
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c9		 test	 ecx, ecx
  0001e	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00020	8b c1		 mov	 eax, ecx

; 848  : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  0002b	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 736  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@E@std@@QBEIXZ PROC		; std::allocator<unsigned char>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 613  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@E@std@@QBEIXZ ENDP		; std::allocator<unsigned char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@E@std@@QAEXPAEABE@Z PROC		; std::allocator<unsigned char>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@E@std@@QAEXPAEABE@Z ENDP		; std::allocator<unsigned char>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 14		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	83 f8 ff	 cmp	 eax, -1
  0000f	77 15		 ja	 SHORT $LN11@allocate
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	8b c8		 mov	 ecx, eax
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c9		 test	 ecx, ecx
  0001e	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00020	8b c1		 mov	 eax, ecx

; 579  : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  0002b	cc		 int	 3
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXPAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@E@std@@QAEXPAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXPlaneDotCoord@@YAMPBUD3DXPLANE@@PBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv153 = 8						; size = 4
_pP$ = 8						; size = 4
_pV$ = 12						; size = 4
?D3DXPlaneDotCoord@@YAMPBUD3DXPLANE@@PBUD3DXVECTOR3@@@Z PROC ; D3DXPlaneDotCoord, COMDAT

; 1641 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1642 : #ifdef D3DX_DEBUG
; 1643 :     if(!pP || !pV)
; 1644 :         return 0.0f;
; 1645 : #endif
; 1646 : 
; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pP$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV$[ebp]
  00009	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000d	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00012	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00017	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0001b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0001f	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00024	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00029	f3 0f 58 c8	 addss	 xmm1, xmm0
  0002d	f3 0f 58 49 0c	 addss	 xmm1, DWORD PTR [ecx+12]
  00032	f3 0f 11 4d 08	 movss	 DWORD PTR tv153[ebp], xmm1
  00037	d9 45 08	 fld	 DWORD PTR tv153[ebp]

; 1648 : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?D3DXPlaneDotCoord@@YAMPBUD3DXPLANE@@PBUD3DXVECTOR3@@@Z ENDP ; D3DXPlaneDotCoord
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3LengthSq, COMDAT

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0000b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00014	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00018	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00020	f3 0f 58 d1	 addss	 xmm2, xmm1
  00024	f3 0f 58 d0	 addss	 xmm2, xmm0
  00028	f3 0f 11 55 08	 movss	 DWORD PTR tv160[ebp], xmm2
  0002d	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1254 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??BD3DXCOLOR@@QBEKXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
??BD3DXCOLOR@@QBEKXZ PROC				; D3DXCOLOR::operator unsigned long, COMDAT
; _this$ = ecx

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00004	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  0000c	0f 57 c9	 xorps	 xmm1, xmm1
  0000f	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b f1		 mov	 esi, ecx
  0001b	57		 push	 edi
  0001c	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
  0001f	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00023	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0002a	72 07		 jb	 SHORT $LN5@operator
  0002c	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00031	eb 2b		 jmp	 SHORT $LN4@operator
$LN5@operator:
  00033	0f 2f c8	 comiss	 xmm1, xmm0
  00036	72 04		 jb	 SHORT $LN3@operator
  00038	33 db		 xor	 ebx, ebx
  0003a	eb 22		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0003c	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00040	f3 0f 58 c4	 addss	 xmm0, xmm4
  00044	e8 00 00 00 00	 call	 __ftoui3
  00049	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00051	8b d8		 mov	 ebx, eax
  00053	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  0005b	0f 57 c9	 xorps	 xmm1, xmm1
$LN4@operator:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0005e	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00063	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0006a	72 07		 jb	 SHORT $LN9@operator
  0006c	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  00071	eb 18		 jmp	 SHORT $LN8@operator
$LN9@operator:
  00073	0f 2f c8	 comiss	 xmm1, xmm0
  00076	72 04		 jb	 SHORT $LN7@operator
  00078	33 ff		 xor	 edi, edi
  0007a	eb 0f		 jmp	 SHORT $LN8@operator
$LN7@operator:
  0007c	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00080	f3 0f 58 c4	 addss	 xmm0, xmm4
  00084	e8 00 00 00 00	 call	 __ftoui3
  00089	8b f8		 mov	 edi, eax
$LN8@operator:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0008b	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0009a	72 07		 jb	 SHORT $LN13@operator
  0009c	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  000a1	eb 23		 jmp	 SHORT $LN12@operator
$LN13@operator:
  000a3	0f 2f c8	 comiss	 xmm1, xmm0
  000a6	72 04		 jb	 SHORT $LN11@operator
  000a8	33 f6		 xor	 esi, esi
  000aa	eb 1a		 jmp	 SHORT $LN12@operator
$LN11@operator:
  000ac	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000b4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000bc	e8 00 00 00 00	 call	 __ftoui3
  000c1	8b f0		 mov	 esi, eax
  000c3	0f 57 c9	 xorps	 xmm1, xmm1
$LN12@operator:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000c9	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000ce	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000d5	72 07		 jb	 SHORT $LN17@operator
  000d7	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000dc	eb 1e		 jmp	 SHORT $LN16@operator
$LN17@operator:
  000de	0f 2f c8	 comiss	 xmm1, xmm0
  000e1	72 04		 jb	 SHORT $LN15@operator
  000e3	33 c0		 xor	 eax, eax
  000e5	eb 15		 jmp	 SHORT $LN16@operator
$LN15@operator:
  000e7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000ef	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000f7	e8 00 00 00 00	 call	 __ftoui3
$LN16@operator:

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  000fc	c1 e0 08	 shl	 eax, 8
  000ff	0b c3		 or	 eax, ebx
  00101	c1 e0 08	 shl	 eax, 8
  00104	0b c7		 or	 eax, edi
  00106	c1 e0 08	 shl	 eax, 8
  00109	5f		 pop	 edi
  0010a	0b c6		 or	 eax, esi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 937  : }

  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
??BD3DXCOLOR@@QBEKXZ ENDP				; D3DXCOLOR::operator unsigned long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT
_fr$ = 8						; size = 4
_fg$ = 12						; size = 4
_fb$ = 16						; size = 4
_fa$ = 20						; size = 4
??0D3DXCOLOR@@QAE@MMMM@Z PROC				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 919  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 920  :     r = fr;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fr$[ebp]

; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fg$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fb$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fa$[ebp]
  00027	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??0D3DXCOLOR@@QAE@MMMM@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00003	ff 75 0c	 push	 DWORD PTR _mat$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 582  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@ABU_D3DVECTOR@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??0D3DXVECTOR3@@QAE@ABU_D3DVECTOR@@@Z PROC		; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 172  :     x = v.x;

  00003	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 173  :     y = v.y;

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 174  :     z = v.z;

  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 175  : }

  00016	8b c1		 mov	 eax, ecx
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0D3DXVECTOR3@@QAE@ABU_D3DVECTOR@@@Z ENDP		; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 1066 :         {return (fabsf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00013	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 1066 :         {return (fabsf(_X)); }

  00017	f3 0f 11 45 08	 movss	 DWORD PTR tv65[ebp], xmm0
  0001c	d9 45 08	 fld	 DWORD PTR tv65[ebp]
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00013	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00017	f3 0f 11 45 08	 movss	 DWORD PTR tv68[ebp], xmm0
  0001c	d9 45 08	 fld	 DWORD PTR tv68[ebp]

; 688  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\string.h
;	COMDAT ?memchr@@YAPAXPAXHI@Z
_TEXT	SEGMENT
__Pv$ = 8						; size = 4
__C$ = 12						; size = 4
__N$ = 16						; size = 4
?memchr@@YAPAXPAXHI@Z PROC				; memchr, COMDAT

; 233  :         { return (void*)memchr((const void*)_Pv, _C, _N); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	e9 00 00 00 00	 jmp	 _memchr
?memchr@@YAPAXPAXHI@Z ENDP				; memchr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
