; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\GameLib\SnowEnvironment.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
PUBLIC	??DD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator*
PUBLIC	?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ; CSingleton<CTimer>::Instance
PUBLIC	??0CSnowEnvironment@@QAE@XZ			; CSnowEnvironment::CSnowEnvironment
PUBLIC	??1CSnowEnvironment@@UAE@XZ			; CSnowEnvironment::~CSnowEnvironment
PUBLIC	?Create@CSnowEnvironment@@QAE_NXZ		; CSnowEnvironment::Create
PUBLIC	?Destroy@CSnowEnvironment@@QAEXXZ		; CSnowEnvironment::Destroy
PUBLIC	?Enable@CSnowEnvironment@@QAEXXZ		; CSnowEnvironment::Enable
PUBLIC	?Disable@CSnowEnvironment@@QAEXXZ		; CSnowEnvironment::Disable
PUBLIC	?Update@CSnowEnvironment@@QAEXABUD3DXVECTOR3@@@Z ; CSnowEnvironment::Update
PUBLIC	?Deform@CSnowEnvironment@@QAEXXZ		; CSnowEnvironment::Deform
PUBLIC	?Render@CSnowEnvironment@@QAEXXZ		; CSnowEnvironment::Render
PUBLIC	?__Initialize@CSnowEnvironment@@IAEXXZ		; CSnowEnvironment::__Initialize
PUBLIC	?__CreateBlurTexture@CSnowEnvironment@@IAE_NXZ	; CSnowEnvironment::__CreateBlurTexture
PUBLIC	?__CreateGeometry@CSnowEnvironment@@IAE_NXZ	; CSnowEnvironment::__CreateGeometry
PUBLIC	?__BeginBlur@CSnowEnvironment@@IAEXXZ		; CSnowEnvironment::__BeginBlur
PUBLIC	?__ApplyBlur@CSnowEnvironment@@IAEXXZ		; CSnowEnvironment::__ApplyBlur
PUBLIC	??0?$allocator@PAVCSnowParticle@@@std@@QAE@XZ	; std::allocator<CSnowParticle *>::allocator<CSnowParticle *>
PUBLIC	?deallocate@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@I@Z ; std::allocator<CSnowParticle *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCSnowParticle@@@std@@QAEPAPAVCSnowParticle@@I@Z ; std::allocator<CSnowParticle *>::allocate
PUBLIC	?construct@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@ABQAV3@@Z ; std::allocator<CSnowParticle *>::construct
PUBLIC	?max_size@?$allocator@PAVCSnowParticle@@@std@@QBEIXZ ; std::allocator<CSnowParticle *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAIABV?$allocator@PAVCSnowParticle@@@2@@Z ; std::allocator_traits<std::allocator<CSnowParticle *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::_Wrap_alloc<std::allocator<CSnowParticle *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEPAPAVCSnowParticle@@I@Z ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@I@Z ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CSnowParticle *> >::_Vector_val<std::_Simple_types<CSnowParticle *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSnowParticle@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >::_Getal
PUBLIC	??0?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::vector<CSnowParticle *,std::allocator<CSnowParticle *> >
PUBLIC	??1?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::~vector<CSnowParticle *,std::allocator<CSnowParticle *> >
PUBLIC	?reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::reserve
PUBLIC	?capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::begin
PUBLIC	?end@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::end
PUBLIC	?_Make_iter@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Make_iter
PUBLIC	?size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::size
PUBLIC	?max_size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::max_size
PUBLIC	?empty@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE_NXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::empty
PUBLIC	?push_back@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXABQAVCSnowParticle@@@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::push_back
PUBLIC	?erase@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::erase
PUBLIC	?clear@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXPAPAVCSnowParticle@@0@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEII@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBE_NPBQAVCSnowParticle@@@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXXZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXPAPAVCSnowParticle@@0@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Orphan_range
PUBLIC	??_GCSnowEnvironment@@UAEPAXI@Z			; CSnowEnvironment::`scalar deleting destructor'
PUBLIC	?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ; CSingleton<CStateManager>::Instance
PUBLIC	?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ		; CCamera::GetUp
PUBLIC	?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ		; CCamera::GetView
PUBLIC	?GetCross@CCamera@@QBEABUD3DXVECTOR3@@XZ	; CCamera::GetCross
PUBLIC	?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ; CSingleton<CCameraManager>::Instance
PUBLIC	?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ; CSingleton<CResourceManager>::Instance
PUBLIC	??0BlurVertex@@QAE@UD3DXVECTOR3@@MKMM@Z		; BlurVertex::BlurVertex
PUBLIC	??1BlurVertex@@QAE@XZ				; BlurVertex::~BlurVertex
PUBLIC	??_GCSnowParticle@@QAEPAXI@Z			; CSnowParticle::`scalar deleting destructor'
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEABQAVCSnowParticle@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEAAPAVCSnowParticle@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator++
PUBLIC	??$stl_wipe@V?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@@YAXAAV?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@Z ; stl_wipe<std::vector<CSnowParticle *,std::allocator<CSnowParticle *> > >
PUBLIC	??$addressof@QAVCSnowParticle@@@std@@YAPBQAVCSnowParticle@@ABQAV1@@Z ; std::addressof<CSnowParticle * const>
PUBLIC	??$construct@PAVCSnowParticle@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * &>
PUBLIC	??$construct@PAVCSnowParticle@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * const &>
PUBLIC	??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00@Z ; std::_Move<CSnowParticle * *,CSnowParticle * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
PUBLIC	??$_Umove@PAPAVCSnowParticle@@@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEPAPAVCSnowParticle@@PAPAV2@00@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Umove<CSnowParticle * *>
PUBLIC	??$_Allocate@PAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@IPAPAV1@@Z ; std::_Allocate<CSnowParticle *>
PUBLIC	??$forward@AAPAVCSnowParticle@@@std@@YAAAPAVCSnowParticle@@AAPAV1@@Z ; std::forward<CSnowParticle * &>
PUBLIC	??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * &>
PUBLIC	??$forward@ABQAVCSnowParticle@@@std@@YAABQAVCSnowParticle@@ABQAV1@@Z ; std::forward<CSnowParticle * const &>
PUBLIC	??$construct@PAVCSnowParticle@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * const &>
PUBLIC	??$_Ptr_cat@PAVCSnowParticle@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSnowParticle@@0@Z ; std::_Ptr_cat<CSnowParticle *,CSnowParticle *>
PUBLIC	??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<CSnowParticle * *,CSnowParticle * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z ; std::_Uninitialized_move<CSnowParticle * *,CSnowParticle * *,std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
PUBLIC	??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z ; std::allocator<CSnowParticle *>::construct<CSnowParticle *,CSnowParticle * &>
PUBLIC	??$_Unchecked@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z ; std::_Unchecked<CSnowParticle * *>
PUBLIC	??$_Uninit_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z ; std::_Uninit_move<CSnowParticle * *,CSnowParticle * *,std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
PUBLIC	??$_Rechecked@PAPAVCSnowParticle@@PAPAV1@@std@@YAAAPAPAVCSnowParticle@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CSnowParticle * *,CSnowParticle * *>
PUBLIC	??$_Val_type@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z ; std::_Val_type<CSnowParticle * *>
PUBLIC	??$_Uninit_move@PAVCSnowParticle@@PAV1@PAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CSnowParticle *,CSnowParticle *,CSnowParticle *>
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	??_7CSnowEnvironment@@6B@			; CSnowEnvironment::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_C@_0BO@KOAGJMMK@d?3?1ymir?5work?1special?1snow?4dds?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CSnowEnvironment@@6B@			; CSnowEnvironment::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSnowEnvironment@@@8			; CSnowEnvironment `RTTI Type Descriptor'
PUBLIC	??_R3CSnowEnvironment@@8			; CSnowEnvironment::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSnowEnvironment@@8			; CSnowEnvironment::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSnowEnvironment@@8		; CSnowEnvironment::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CScreen@@8			; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCScreen@@@8				; CScreen `RTTI Type Descriptor'
PUBLIC	??_R3CScreen@@8					; CScreen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CScreen@@8					; CScreen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	__real@447a0000
PUBLIC	__real@455ac000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?GetCurrentMillisecond@CTimer@@QAEKXZ:PROC	; CTimer::GetCurrentMillisecond
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?SetTextureStage@CGraphicTexture@@QBEXH@Z:PROC	; CGraphicTexture::SetTextureStage
EXTRN	?GetTextureReference@CGraphicImage@@QBEABVCGraphicTexture@@XZ:PROC ; CGraphicImage::GetTextureReference
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?GetGraphicImagePointer@CGraphicImageInstance@@QAEPAVCGraphicImage@@XZ:PROC ; CGraphicImageInstance::GetGraphicImagePointer
EXTRN	?New@CGraphicImageInstance@@SAPAV1@XZ:PROC	; CGraphicImageInstance::New
EXTRN	?Delete@CGraphicImageInstance@@SAXPAV1@@Z:PROC	; CGraphicImageInstance::Delete
EXTRN	??_ECSnowEnvironment@@UAEPAXI@Z:PROC		; CSnowEnvironment::`vector deleting destructor'
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z:PROC ; CStateManager::SetIndices
EXTRN	?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z:PROC ; CStateManager::DrawPrimitiveUP
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	??1CSnowParticle@@QAE@XZ:PROC			; CSnowParticle::~CSnowParticle
EXTRN	?New@CSnowParticle@@SAPAV1@XZ:PROC		; CSnowParticle::New
EXTRN	?Delete@CSnowParticle@@SAXPAV1@@Z:PROC		; CSnowParticle::Delete
EXTRN	?DestroyPool@CSnowParticle@@SAXXZ:PROC		; CSnowParticle::DestroyPool
EXTRN	?Init@CSnowParticle@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CSnowParticle::Init
EXTRN	?SetCameraVertex@CSnowParticle@@QAEXABUD3DXVECTOR3@@0@Z:PROC ; CSnowParticle::SetCameraVertex
EXTRN	?IsActivate@CSnowParticle@@QAE_NXZ:PROC		; CSnowParticle::IsActivate
EXTRN	?Update@CSnowParticle@@QAEXMABUD3DXVECTOR3@@@Z:PROC ; CSnowParticle::Update
EXTRN	?GetVerticies@CSnowParticle@@QAEXAAUSParticleVertex@@000@Z:PROC ; CSnowParticle::GetVerticies
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A:DWORD ; CGraphicBase::ms_lpd3dDevice
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_lLastTime@?6??Deform@CSnowEnvironment@@QAEXXZ@4JA
_BSS	SEGMENT
?s_lLastTime@?6??Deform@CSnowEnvironment@@QAEXXZ@4JA DD 01H DUP (?) ; `CSnowEnvironment::Deform'::`7'::s_lLastTime
_BSS	ENDS
;	COMDAT ?$S1@?6??Deform@CSnowEnvironment@@QAEXXZ@4IA
_BSS	SEGMENT
?$S1@?6??Deform@CSnowEnvironment@@QAEXXZ@4IA DD 01H DUP (?) ; `CSnowEnvironment::Deform'::`7'::$S1
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@455ac000
CONST	SEGMENT
__real@455ac000 DD 0455ac000r			; 3500
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$r	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$r	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CScreen@@8
rdata$r	SEGMENT
??_R2CScreen@@8 DD FLAT:??_R1A@?0A@EA@CScreen@@8	; CScreen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CScreen@@8
rdata$r	SEGMENT
??_R3CScreen@@8 DD 00H					; CScreen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCScreen@@@8
data$r	SEGMENT
??_R0?AVCScreen@@@8 DD FLAT:??_7type_info@@6B@		; CScreen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCScreen@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CScreen@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CScreen@@8 DD FLAT:??_R0?AVCScreen@@@8	; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSnowEnvironment@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSnowEnvironment@@8 DD FLAT:??_R0?AVCSnowEnvironment@@@8 ; CSnowEnvironment::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSnowEnvironment@@8
rdata$r	ENDS
;	COMDAT ??_R2CSnowEnvironment@@8
rdata$r	SEGMENT
??_R2CSnowEnvironment@@8 DD FLAT:??_R1A@?0A@EA@CSnowEnvironment@@8 ; CSnowEnvironment::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CScreen@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CSnowEnvironment@@8
rdata$r	SEGMENT
??_R3CSnowEnvironment@@8 DD 00H				; CSnowEnvironment::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CSnowEnvironment@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSnowEnvironment@@@8
data$r	SEGMENT
??_R0?AVCSnowEnvironment@@@8 DD FLAT:??_7type_info@@6B@	; CSnowEnvironment `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSnowEnvironment@@', 00H
data$r	ENDS
;	COMDAT ??_R4CSnowEnvironment@@6B@
rdata$r	SEGMENT
??_R4CSnowEnvironment@@6B@ DD 00H			; CSnowEnvironment::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSnowEnvironment@@@8
	DD	FLAT:??_R3CSnowEnvironment@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KOAGJMMK@d?3?1ymir?5work?1special?1snow?4dds?$AA@
CONST	SEGMENT
??_C@_0BO@KOAGJMMK@d?3?1ymir?5work?1special?1snow?4dds?$AA@ DB 'd:/ymir w'
	DB	'ork/special/snow.dds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CSnowEnvironment@@6B@
CONST	SEGMENT
??_7CSnowEnvironment@@6B@ DD FLAT:??_R4CSnowEnvironment@@6B@ ; CSnowEnvironment::`vftable'
	DD	FLAT:??_ECSnowEnvironment@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__ApplyBlur@CSnowEnvironment@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__ApplyBlur@CSnowEnvironment@@IAEXXZ$0
__ehfuncinfo$?__ApplyBlur@CSnowEnvironment@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__ApplyBlur@CSnowEnvironment@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Deform@CSnowEnvironment@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Deform@CSnowEnvironment@@QAEXXZ$0
__ehfuncinfo$?Deform@CSnowEnvironment@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Deform@CSnowEnvironment@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CSnowEnvironment@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CSnowEnvironment@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CSnowEnvironment@@UAE@XZ$1
__ehfuncinfo$??1CSnowEnvironment@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CSnowEnvironment@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CSnowEnvironment@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CSnowEnvironment@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSnowEnvironment@@QAE@XZ$1
__ehfuncinfo$??0CSnowEnvironment@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CSnowEnvironment@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCSnowParticle@@PAV1@PAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCSnowParticle@@PAV1@PAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CSnowParticle *,CSnowParticle *,CSnowParticle *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCSnowParticle@@PAV1@PAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CSnowParticle *,CSnowParticle *,CSnowParticle *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z PROC ; std::_Val_type<CSnowParticle * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z ENDP ; std::_Val_type<CSnowParticle * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCSnowParticle@@PAPAV1@@std@@YAAAPAPAVCSnowParticle@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCSnowParticle@@PAPAV1@@std@@YAAAPAPAVCSnowParticle@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CSnowParticle * *,CSnowParticle * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCSnowParticle@@PAPAV1@@std@@YAAAPAPAVCSnowParticle@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CSnowParticle * *,CSnowParticle * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z PROC ; std::_Uninit_move<CSnowParticle * *,CSnowParticle * *,std::_Wrap_alloc<std::allocator<CSnowParticle *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z ENDP ; std::_Uninit_move<CSnowParticle * *,CSnowParticle * *,std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z PROC ; std::_Unchecked<CSnowParticle * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@PAPAV1@@Z ENDP ; std::_Unchecked<CSnowParticle * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z PROC ; std::allocator<CSnowParticle *>::construct<CSnowParticle *,CSnowParticle * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z ENDP ; std::allocator<CSnowParticle *>::construct<CSnowParticle *,CSnowParticle * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CSnowParticle * *,CSnowParticle * *,std::_Wrap_alloc<std::allocator<CSnowParticle *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCSnowParticle@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAPAPAVCSnowParticle@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CSnowParticle * *,CSnowParticle * *,std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSnowParticle *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CSnowParticle * *,CSnowParticle * *>, COMDAT

; 2428 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2432 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2433 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CSnowParticle * *,CSnowParticle * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCSnowParticle@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSnowParticle@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCSnowParticle@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSnowParticle@@0@Z PROC ; std::_Ptr_cat<CSnowParticle *,CSnowParticle *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCSnowParticle@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCSnowParticle@@0@Z ENDP ; std::_Ptr_cat<CSnowParticle *,CSnowParticle *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSnowParticle@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCSnowParticle@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCSnowParticle@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCSnowParticle@@@std@@YAABQAVCSnowParticle@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCSnowParticle@@@std@@YAABQAVCSnowParticle@@ABQAV1@@Z PROC ; std::forward<CSnowParticle * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCSnowParticle@@@std@@YAABQAVCSnowParticle@@ABQAV1@@Z ENDP ; std::forward<CSnowParticle * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCSnowParticle@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAXAAV?$allocator@PAVCSnowParticle@@@1@PAPAVCSnowParticle@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCSnowParticle@@@std@@YAAAPAVCSnowParticle@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCSnowParticle@@@std@@YAAAPAVCSnowParticle@@AAPAV1@@Z PROC ; std::forward<CSnowParticle * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCSnowParticle@@@std@@YAAAPAVCSnowParticle@@AAPAV1@@Z ENDP ; std::forward<CSnowParticle * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@IPAPAV1@@Z PROC ; std::_Allocate<CSnowParticle *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCSnowParticle@@@std@@YAPAPAVCSnowParticle@@IPAPAV1@@Z ENDP ; std::_Allocate<CSnowParticle *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCSnowParticle@@@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEPAPAVCSnowParticle@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCSnowParticle@@@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEPAPAVCSnowParticle@@PAPAV2@00@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Umove<CSnowParticle * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCSnowParticle@@@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEPAPAVCSnowParticle@@PAPAV2@00@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Umove<CSnowParticle * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSnowParticle *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@YAXPAPAVCSnowParticle@@0AAU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00@Z PROC ; std::_Move<CSnowParticle * *,CSnowParticle * *>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2432 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Move@PAPAVCSnowParticle@@PAPAV1@@std@@YAPAPAVCSnowParticle@@PAPAV1@00@Z ENDP ; std::_Move<CSnowParticle * *,CSnowParticle * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSnowParticle@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCSnowParticle@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCSnowParticle@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCSnowParticle@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCSnowParticle@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCSnowParticle@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::construct<CSnowParticle *,CSnowParticle * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@QAVCSnowParticle@@@std@@YAPBQAVCSnowParticle@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCSnowParticle@@@std@@YAPBQAVCSnowParticle@@ABQAV1@@Z PROC ; std::addressof<CSnowParticle * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCSnowParticle@@@std@@YAPBQAVCSnowParticle@@ABQAV1@@Z ENDP ; std::addressof<CSnowParticle * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h
;	COMDAT ??$stl_wipe@V?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@@YAXAAV?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@Z
_TEXT	SEGMENT
_container$ = 8						; size = 4
??$stl_wipe@V?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@@YAXAAV?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@Z PROC ; stl_wipe<std::vector<CSnowParticle *,std::allocator<CSnowParticle *> > >, COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _container$[ebp]
  00007	56		 push	 esi
  00008	8b 33		 mov	 esi, DWORD PTR [ebx]

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  0000a	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h

; 95   : 	for (TContainer::iterator i = container.begin(); i != container.end(); ++i)

  0000d	74 2f		 je	 SHORT $LN53@stl_wipe
  0000f	57		 push	 edi
$LL18@stl_wipe:

; 96   : 	{
; 97   : 		delete *i;

  00010	8b 3e		 mov	 edi, DWORD PTR [esi]
  00012	85 ff		 test	 edi, edi
  00014	74 10		 je	 SHORT $LN38@stl_wipe
  00016	8b cf		 mov	 ecx, edi
  00018	e8 00 00 00 00	 call	 ??1CSnowParticle@@QAE@XZ ; CSnowParticle::~CSnowParticle
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	83 c4 04	 add	 esp, 4
$LN38@stl_wipe:

; 98   : 		*i = NULL;

  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  0002c	83 c6 04	 add	 esi, 4

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  0002f	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h

; 95   : 	for (TContainer::iterator i = container.begin(); i != container.end(); ++i)

  00032	75 dc		 jne	 SHORT $LL18@stl_wipe
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0003b	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h

; 102  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN53@stl_wipe:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00044	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterbase\stl.h

; 102  : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$stl_wipe@V?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@@YAXAAV?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@Z ENDP ; stl_wipe<std::vector<CSnowParticle *,std::allocator<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEAAPAVCSnowParticle@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEAAPAVCSnowParticle@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEAAPAVCSnowParticle@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEABQAVCSnowParticle@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEABQAVCSnowParticle@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QBEABQAVCSnowParticle@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@std@@QAE@PAPAVCSnowParticle@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCSnowParticle@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSnowParticle@@QAEPAXI@Z PROC			; CSnowParticle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CSnowParticle@@QAE@XZ ; CSnowParticle::~CSnowParticle
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCSnowParticle@@QAEPAXI@Z ENDP			; CSnowParticle::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h
;	COMDAT ??1BlurVertex@@QAE@XZ
_TEXT	SEGMENT
??1BlurVertex@@QAE@XZ PROC				; BlurVertex::~BlurVertex, COMDAT
; _this$ = ecx

; 19   : 	~BlurVertex(){};

  00000	c3		 ret	 0
??1BlurVertex@@QAE@XZ ENDP				; BlurVertex::~BlurVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h
;	COMDAT ??0BlurVertex@@QAE@UD3DXVECTOR3@@MKMM@Z
_TEXT	SEGMENT
_p$ = 8							; size = 12
_w$ = 20						; size = 4
_c$ = 24						; size = 4
_u$ = 28						; size = 4
_v$ = 32						; size = 4
??0BlurVertex@@QAE@UD3DXVECTOR3@@MKMM@Z PROC		; BlurVertex::BlurVertex, COMDAT
; _this$ = ecx

; 18   : 	BlurVertex(D3DXVECTOR3 p, float w,DWORD c,float u,float v):pos(p),rhw(w),color(c),tu(u),tv(v) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 45 08	 movq	 xmm0, QWORD PTR _p$[ebp]
  00008	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp+8]
  0000b	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0000f	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _w$[ebp]
  00014	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  00019	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _u$[ebp]
  0001e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00021	8b 45 18	 mov	 eax, DWORD PTR _c$[ebp]
  00024	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0
  00029	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _v$[ebp]
  0002e	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00031	8b c1		 mov	 eax, ecx
  00033	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0
  00038	5d		 pop	 ebp
  00039	c2 1c 00	 ret	 28			; 0000001cH
??0BlurVertex@@QAE@UD3DXVECTOR3@@MKMM@Z ENDP		; BlurVertex::BlurVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ PROC ; CSingleton<CResourceManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ENDP ; CSingleton<CResourceManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ PROC ; CSingleton<CCameraManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCCameraManager@@@@SAAAVCCameraManager@@XZ ENDP ; CSingleton<CCameraManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetCross@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetCross@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetCross, COMDAT
; _this$ = ecx

; 172  : 		const D3DXVECTOR3 & GetCross() const	{ return m_v3Cross; }

  00000	8d 41 60	 lea	 eax, DWORD PTR [ecx+96]
  00003	c3		 ret	 0
?GetCross@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetCross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetView, COMDAT
; _this$ = ecx

; 171  : 		const D3DXVECTOR3 & GetView() const		{ return m_v3View; }

  00000	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00003	c3		 ret	 0
?GetView@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetView
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
;	COMDAT ?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ PROC		; CCamera::GetUp, COMDAT
; _this$ = ecx

; 170  : 		const D3DXVECTOR3 & GetUp() const		{ return m_v3Up; }

  00000	8d 41 48	 lea	 eax, DWORD PTR [ecx+72]
  00003	c3		 ret	 0
?GetUp@CCamera@@QBEABUD3DXVECTOR3@@XZ ENDP		; CCamera::GetUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ PROC ; CSingleton<CStateManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ENDP ; CSingleton<CStateManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCSnowEnvironment@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSnowEnvironment@@UAEPAXI@Z PROC			; CSnowEnvironment::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CSnowEnvironment@@UAE@XZ ; CSnowEnvironment::~CSnowEnvironment
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCSnowEnvironment@@UAEPAXI@Z ENDP			; CSnowEnvironment::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXPAPAVCSnowParticle@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXPAPAVCSnowParticle@@0@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXPAPAVCSnowParticle@@0@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEXXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBE_NPBQAVCSnowParticle@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBE_NPBQAVCSnowParticle@@@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBE_NPBQAVCSnowParticle@@@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEII@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IBEII@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXPAPAVCSnowParticle@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXPAPAVCSnowParticle@@0@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXPAPAVCSnowParticle@@0@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::erase, COMDAT
; _this$ = ecx

; 1452 : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  0000d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00010	2b d6		 sub	 edx, esi

; 2431 : 		_Count * sizeof (*_First));

  00012	83 e2 fc	 and	 edx, -4			; fffffffcH
  00015	52		 push	 edx
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\xutility

; 2431 : 		_Count * sizeof (*_First));

  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  00023	83 47 04 fc	 add	 DWORD PTR [edi+4], -4	; fffffffcH

; 47   : 		{	// construct with pointer _Parg

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0002a	5f		 pop	 edi
  0002b	89 08		 mov	 DWORD PTR [eax], ecx
  0002d	5e		 pop	 esi

; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?erase@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXABQAVCSnowParticle@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXABQAVCSnowParticle@@@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXABQAVCSnowParticle@@@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE_NXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1044 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@@2@XZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXI@Z PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::reserve, COMDAT
; _this$ = ecx

; 999  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1000 : 		if (capacity() < _Count)

  00008	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	c1 f8 02	 sar	 eax, 2

; 1000 : 		if (capacity() < _Count)

  0000e	3b c2		 cmp	 eax, edx
  00010	73 11		 jae	 SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

  00012	81 fa ff ff ff
	3f		 cmp	 edx, 1073741823		; 3fffffffH
  00018	77 0d		 ja	 SHORT $LN22@reserve

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  0001a	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1005 : 			}
; 1006 : 		}

  0001d	5d		 pop	 ebp

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  0001e	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reallocate
$LN2@reserve:

; 1005 : 			}
; 1006 : 		}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN22@reserve:

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN24@reserve:
$LN21@reserve:
  00031	cc		 int	 3
?reserve@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::~vector<CSnowParticle *,std::allocator<CSnowParticle *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::~vector<CSnowParticle *,std::allocator<CSnowParticle *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ PROC ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::vector<CSnowParticle *,std::allocator<CSnowParticle *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::vector<CSnowParticle *,std::allocator<CSnowParticle *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSnowParticle@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSnowParticle@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCSnowParticle@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >::_Vector_alloc<0,std::_Vec_base_types<CSnowParticle *,std::allocator<CSnowParticle *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CSnowParticle *> >::_Vector_val<std::_Simple_types<CSnowParticle *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCSnowParticle@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CSnowParticle *> >::_Vector_val<std::_Simple_types<CSnowParticle *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXPAPAVCSnowParticle@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEPAPAVCSnowParticle@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEPAPAVCSnowParticle@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEPAPAVCSnowParticle@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::_Wrap_alloc<std::allocator<CSnowParticle *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CSnowParticle *> >::_Wrap_alloc<std::allocator<CSnowParticle *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAIABV?$allocator@PAVCSnowParticle@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAIABV?$allocator@PAVCSnowParticle@@@2@@Z PROC ; std::allocator_traits<std::allocator<CSnowParticle *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCSnowParticle@@@std@@@std@@SAIABV?$allocator@PAVCSnowParticle@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CSnowParticle *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCSnowParticle@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCSnowParticle@@@std@@QBEIXZ PROC ; std::allocator<CSnowParticle *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCSnowParticle@@@std@@QBEIXZ ENDP ; std::allocator<CSnowParticle *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@ABQAV3@@Z PROC ; std::allocator<CSnowParticle *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@ABQAV3@@Z ENDP ; std::allocator<CSnowParticle *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCSnowParticle@@@std@@QAEPAPAVCSnowParticle@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCSnowParticle@@@std@@QAEPAPAVCSnowParticle@@I@Z PROC ; std::allocator<CSnowParticle *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCSnowParticle@@@std@@QAEPAPAVCSnowParticle@@I@Z ENDP ; std::allocator<CSnowParticle *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@I@Z PROC ; std::allocator<CSnowParticle *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCSnowParticle@@@std@@QAEXPAPAVCSnowParticle@@I@Z ENDP ; std::allocator<CSnowParticle *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCSnowParticle@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCSnowParticle@@@std@@QAE@XZ PROC	; std::allocator<CSnowParticle *>::allocator<CSnowParticle *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCSnowParticle@@@std@@QAE@XZ ENDP	; std::allocator<CSnowParticle *>::allocator<CSnowParticle *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?__ApplyBlur@CSnowEnvironment@@IAEXXZ
_TEXT	SEGMENT
$T2 = -184						; size = 8
$T3 = -176						; size = 4
$T4 = -172						; size = 12
$T5 = -172						; size = 12
$T6 = -172						; size = 12
$T7 = -172						; size = 12
_desc$8 = -160						; size = 32
_V$9 = -128						; size = 112
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?__ApplyBlur@CSnowEnvironment@@IAEXXZ PROC		; CSnowEnvironment::__ApplyBlur, COMDAT
; _this$ = ecx

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__ApplyBlur@CSnowEnvironment@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f1		 mov	 esi, ecx

; 105  : 	if (!m_bBlurEnable)

  0002e	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  00032	0f 84 f0 01 00
	00		 je	 $LN4@ApplyBlur

; 106  : 		return;
; 107  : 
; 108  : //			{
; 109  : //				STATEMANAGER.SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE );
; 110  : //				STATEMANAGER.SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
; 111  : //				STATEMANAGER.SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
; 112  : //				STATEMANAGER.SetRenderState( D3DRS_COLORVERTEX ,TRUE);
; 113  : //				STATEMANAGER.SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE , D3DMCS_COLOR1 );
; 114  : //				STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
; 115  : //				STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
; 116  : //				STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
; 117  : //				STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
; 118  : //				STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
; 119  : //				STATEMANAGER.SetTextureStageState(0,  D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
; 120  : //				DWORD	alphaColor = 0xFFFFFF | ((DWORD)(0.6f*255.0f) << 24);
; 121  : //
; 122  : //				BlurVertex V[4] = { BlurVertex(D3DXVECTOR3(0.0f,0.0f,0.0f),1.0f,		alphaColor, 0,0) ,
; 123  : //									BlurVertex(D3DXVECTOR3(wTextureSize,0.0f,0.0f),1.0f,		alphaColor, 1,0) , 
; 124  : //									BlurVertex(D3DXVECTOR3(0.0f,wTextureSize,0.0f),1.0f,		alphaColor, 0,1) , 
; 125  : //									BlurVertex(D3DXVECTOR3(wTextureSize,wTextureSize,0.0f),1.0f,	alphaColor, 1,1) };
; 126  : //				//   .
; 127  : //				STATEMANAGER.SetTexture(0,m_lpAccumTexture);
; 128  : //				STATEMANAGER.SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE|D3DFVF_TEX1 );
; 129  : //				STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP,2,V,sizeof(BlurVertex));
; 130  : //			}
; 131  : //
; 132  : //			{
; 133  : //				STATEMANAGER.SetRenderTarget(m_lpAccumRenderTargetSurface, m_lpAccumDepthSurface);
; 134  : //
; 135  : //				BlurVertex V[4] = { BlurVertex(D3DXVECTOR3(0.0f,0.0f,0.0f),1.0f,		0xFFFFFF, 0,0) ,
; 136  : //									BlurVertex(D3DXVECTOR3(wTextureSize,0.0f,0.0f),1.0f,		0xFFFFFF, 1,0) , 
; 137  : //									BlurVertex(D3DXVECTOR3(0.0f,wTextureSize,0.0f),1.0f,		0xFFFFFF, 0,1) , 
; 138  : //									BlurVertex(D3DXVECTOR3(wTextureSize,wTextureSize,0.0f),1.0f,	0xFFFFFF, 1,1) };
; 139  : //
; 140  : //				STATEMANAGER.SetTexture(0,m_lpSnowTexture);
; 141  : //				STATEMANAGER.SetRenderState( D3DRS_ALPHABLENDENABLE,   FALSE);
; 142  : //				STATEMANAGER.SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE|D3DFVF_TEX1 );
; 143  : //				STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP,2,V,sizeof(BlurVertex));
; 144  : //			}
; 145  : 
; 146  : 	///////////////
; 147  : 	{
; 148  : 		ms_lpd3dDevice->SetRenderTarget(m_lpOldSurface, m_lpOldDepthStencilSurface);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0003d	ff 76 08	 push	 DWORD PTR [esi+8]
  00040	ff 76 04	 push	 DWORD PTR [esi+4]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	50		 push	 eax
  00046	ff 51 7c	 call	 DWORD PTR [ecx+124]

; 149  : 
; 150  : 		STATEMANAGER.SetTexture(0,m_lpSnowTexture);

  00049	ff 76 0c	 push	 DWORD PTR [esi+12]
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00052	6a 00		 push	 0
  00054	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 151  : 		STATEMANAGER.SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE);

  00059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005f	6a 01		 push	 1
  00061	6a 1b		 push	 27			; 0000001bH
  00063	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 152  : 
; 153  : 		D3DSURFACE_DESC	desc;
; 154  : 		m_lpOldSurface->GetDesc(&desc);

  00068	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006b	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _desc$8[ebp]
  00071	52		 push	 edx
  00072	50		 push	 eax
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	ff 51 20	 call	 DWORD PTR [ecx+32]

; 155  : 		float sx = (float)desc.Width ;

  00078	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _desc$8[ebp+24]

; 156  : 		float sy = (float)desc.Height;
; 157  : 		SAFE_RELEASE( m_lpOldSurface );

  0007e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00081	66 0f 6e c0	 movd	 xmm0, eax
  00085	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00089	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0008c	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00095	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _desc$8[ebp+28]
  0009b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0009f	66 0f d6 85 48
	ff ff ff	 movq	 QWORD PTR $T2[ebp], xmm0
  000a7	66 0f 6e c0	 movd	 xmm0, eax
  000ab	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000af	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000b2	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000bb	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  000bf	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR $T3[ebp], xmm0
  000c7	85 c9		 test	 ecx, ecx
  000c9	74 0d		 je	 SHORT $LN2@ApplyBlur
  000cb	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cd	51		 push	 ecx
  000ce	ff 50 08	 call	 DWORD PTR [eax+8]
  000d1	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN2@ApplyBlur:

; 158  : 		SAFE_RELEASE( m_lpOldDepthStencilSurface );

  000d8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000db	85 c9		 test	 ecx, ecx
  000dd	74 0d		 je	 SHORT $LN1@ApplyBlur
  000df	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e1	51		 push	 ecx
  000e2	ff 50 08	 call	 DWORD PTR [eax+8]
  000e5	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@ApplyBlur:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h

; 18   : 	BlurVertex(D3DXVECTOR3 p, float w,DWORD c,float u,float v):pos(p),rhw(w),color(c),tu(u),tv(v) {}

  000ec	f3 0f 7e 95 48
	ff ff ff	 movq	 xmm2, QWORD PTR $T2[ebp]
  000f4	0f 57 c9	 xorps	 xmm1, xmm1
  000f7	f3 0f 10 c1	 movss	 xmm0, xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000fb	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h

; 18   : 	BlurVertex(D3DXVECTOR3 p, float w,DWORD c,float u,float v):pos(p),rhw(w),color(c),tu(u),tv(v) {}

  00105	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp+8]
  0010b	0f 14 c1	 unpcklps xmm0, xmm1
  0010e	66 0f d6 45 80	 movq	 QWORD PTR _V$9[ebp], xmm0
  00113	f3 0f 10 c2	 movss	 xmm0, xmm2
  00117	0f 14 c1	 unpcklps xmm0, xmm1
  0011a	89 45 88	 mov	 DWORD PTR _V$9[ebp+8], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0011d	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h

; 18   : 	BlurVertex(D3DXVECTOR3 p, float w,DWORD c,float u,float v):pos(p),rhw(w),color(c),tu(u),tv(v) {}

  00127	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+8]
  0012d	66 0f d6 45 9c	 movq	 QWORD PTR _V$9[ebp+28], xmm0
  00132	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR $T3[ebp]
  0013a	89 45 a4	 mov	 DWORD PTR _V$9[ebp+36], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0013d	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h

; 18   : 	BlurVertex(D3DXVECTOR3 p, float w,DWORD c,float u,float v):pos(p),rhw(w),color(c),tu(u),tv(v) {}

  00147	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+8]
  0014d	0f 14 c8	 unpcklps xmm1, xmm0
  00150	89 45 c0	 mov	 DWORD PTR _V$9[ebp+64], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00153	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowparticle.h

; 18   : 	BlurVertex(D3DXVECTOR3 p, float w,DWORD c,float u,float v):pos(p),rhw(w),color(c),tu(u),tv(v) {}

  0015d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+8]
  00163	0f 14 d0	 unpcklps xmm2, xmm0
  00166	c7 45 8c 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+12], 1065353216 ; 3f800000H
  0016d	c7 45 90 ff ff
	ff 00		 mov	 DWORD PTR _V$9[ebp+16], 16777215 ; 00ffffffH
  00174	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _V$9[ebp+20], 0
  0017b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _V$9[ebp+24], 0
  00182	c7 45 a8 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+40], 1065353216 ; 3f800000H
  00189	c7 45 ac ff ff
	ff 00		 mov	 DWORD PTR _V$9[ebp+44], 16777215 ; 00ffffffH
  00190	c7 45 b0 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+48], 1065353216 ; 3f800000H
  00197	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _V$9[ebp+52], 0
  0019e	66 0f d6 4d b8	 movq	 QWORD PTR _V$9[ebp+56], xmm1
  001a3	c7 45 c4 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+68], 1065353216 ; 3f800000H
  001aa	c7 45 c8 ff ff
	ff 00		 mov	 DWORD PTR _V$9[ebp+72], 16777215 ; 00ffffffH
  001b1	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _V$9[ebp+76], 0
  001b8	c7 45 d0 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+80], 1065353216 ; 3f800000H
  001bf	66 0f d6 55 d4	 movq	 QWORD PTR _V$9[ebp+84], xmm2
  001c4	89 45 dc	 mov	 DWORD PTR _V$9[ebp+92], eax
  001c7	c7 45 e0 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+96], 1065353216 ; 3f800000H
  001ce	c7 45 e4 ff ff
	ff 00		 mov	 DWORD PTR _V$9[ebp+100], 16777215 ; 00ffffffH
  001d5	c7 45 e8 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+104], 1065353216 ; 3f800000H
  001dc	c7 45 ec 00 00
	80 3f		 mov	 DWORD PTR _V$9[ebp+108], 1065353216 ; 3f800000H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 165  : 		STATEMANAGER.SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE|D3DFVF_TEX1 );

  001e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e9	68 44 01 00 00	 push	 324			; 00000144H
  001ee	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001f5	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 166  : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP,2,V,sizeof(BlurVertex));

  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00200	8d 45 80	 lea	 eax, DWORD PTR _V$9[ebp]
  00203	6a 1c		 push	 28			; 0000001cH
  00205	50		 push	 eax
  00206	6a 02		 push	 2
  00208	6a 05		 push	 5
  0020a	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP

; 167  : 	}

  0020f	68 00 00 00 00	 push	 OFFSET ??1BlurVertex@@QAE@XZ ; BlurVertex::~BlurVertex
  00214	6a 04		 push	 4
  00216	6a 1c		 push	 28			; 0000001cH
  00218	8d 45 80	 lea	 eax, DWORD PTR _V$9[ebp]
  0021b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
$LN4@ApplyBlur:

; 168  : }

  00228	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0022b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00232	59		 pop	 ecx
  00233	5e		 pop	 esi
  00234	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00237	33 cd		 xor	 ecx, ebp
  00239	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__ApplyBlur@CSnowEnvironment@@IAEXXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1BlurVertex@@QAE@XZ ; BlurVertex::~BlurVertex
  00005	6a 04		 push	 4
  00007	6a 1c		 push	 28			; 0000001cH
  00009	8d 45 80	 lea	 eax, DWORD PTR _V$9[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00012	c3		 ret	 0
__ehhandler$?__ApplyBlur@CSnowEnvironment@@IAEXXZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a 4c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-180]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__ApplyBlur@CSnowEnvironment@@IAEXXZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__ApplyBlur@CSnowEnvironment@@IAEXXZ ENDP		; CSnowEnvironment::__ApplyBlur
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?__BeginBlur@CSnowEnvironment@@IAEXXZ
_TEXT	SEGMENT
?__BeginBlur@CSnowEnvironment@@IAEXXZ PROC		; CSnowEnvironment::__BeginBlur, COMDAT
; _this$ = ecx

; 89   : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 90   : 	if (!m_bBlurEnable)

  00003	83 7f 50 00	 cmp	 DWORD PTR [edi+80], 0
  00007	0f 84 86 00 00
	00		 je	 $LN2@BeginBlur

; 91   : 		return;
; 92   : 
; 93   : 	ms_lpd3dDevice->GetRenderTarget(&m_lpOldSurface);

  0000d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00013	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	52		 push	 edx
  00019	8b 32		 mov	 esi, DWORD PTR [edx]
  0001b	ff 96 80 00 00
	00		 call	 DWORD PTR [esi+128]

; 94   : 	ms_lpd3dDevice->GetDepthStencilSurface(&m_lpOldDepthStencilSurface);

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00027	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	ff 92 84 00 00
	00		 call	 DWORD PTR [edx+132]

; 95   : 	ms_lpd3dDevice->SetRenderTarget(m_lpSnowRenderTargetSurface, m_lpSnowDepthSurface);

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00039	ff 77 14	 push	 DWORD PTR [edi+20]
  0003c	ff 77 10	 push	 DWORD PTR [edi+16]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	50		 push	 eax
  00042	ff 51 7c	 call	 DWORD PTR [ecx+124]

; 96   : 	ms_lpd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L);

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0004a	6a 00		 push	 0
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	51		 push	 ecx
  0004f	c7 04 24 00 00
	80 3f		 mov	 DWORD PTR [esp], 1065353216 ; 3f800000H
  00056	6a 00		 push	 0
  00058	6a 03		 push	 3
  0005a	6a 00		 push	 0
  0005c	6a 00		 push	 0
  0005e	50		 push	 eax
  0005f	ff 91 90 00 00
	00		 call	 DWORD PTR [ecx+144]

; 97   : 
; 98   : 	STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006b	6a 01		 push	 1
  0006d	6a 1b		 push	 27			; 0000001bH
  0006f	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 99   : 	STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007a	6a 05		 push	 5
  0007c	6a 13		 push	 19			; 00000013H
  0007e	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 100  : 	STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_DESTALPHA);

  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00089	6a 07		 push	 7
  0008b	6a 14		 push	 20			; 00000014H
  0008d	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
  00092	5e		 pop	 esi
$LN2@BeginBlur:
  00093	5f		 pop	 edi

; 101  : }

  00094	c3		 ret	 0
?__BeginBlur@CSnowEnvironment@@IAEXXZ ENDP		; CSnowEnvironment::__BeginBlur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?__CreateGeometry@CSnowEnvironment@@IAE_NXZ
_TEXT	SEGMENT
tv566 = -12						; size = 4
_i$1$ = -8						; size = 4
_dstIndices$ = -4					; size = 4
?__CreateGeometry@CSnowEnvironment@@IAE_NXZ PROC	; CSnowEnvironment::__CreateGeometry, COMDAT
; _this$ = ecx

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  : 	if (FAILED(ms_lpd3dDevice->CreateVertexBuffer(sizeof(SParticleVertex)*m_dwParticleMaxNum*4,
; 256  : 											D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY,
; 257  : 											D3DFVF_XYZ | D3DFVF_TEX1,
; 258  : 											D3DPOOL_SYSTEMMEM,
; 259  : 											&m_pVB)))

  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00009	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 32		 mov	 esi, DWORD PTR [edx]
  00010	8b d9		 mov	 ebx, ecx
  00012	8d 43 24	 lea	 eax, DWORD PTR [ebx+36]
  00015	50		 push	 eax
  00016	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  00019	6a 02		 push	 2
  0001b	68 02 01 00 00	 push	 258			; 00000102H
  00020	68 08 02 00 00	 push	 520			; 00000208H
  00025	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00028	c1 e0 04	 shl	 eax, 4
  0002b	50		 push	 eax
  0002c	52		 push	 edx
  0002d	ff 56 5c	 call	 DWORD PTR [esi+92]
  00030	85 c0		 test	 eax, eax
  00032	79 08		 jns	 SHORT $LN9@CreateGeom
$LN26@CreateGeom:
  00034	5e		 pop	 esi

; 260  : 		return false;

  00035	32 c0		 xor	 al, al
  00037	5b		 pop	 ebx

; 284  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN9@CreateGeom:

; 261  : 
; 262  : 	if (FAILED(ms_lpd3dDevice->CreateIndexBuffer(sizeof(WORD)*m_dwParticleMaxNum*6,
; 263  : 										   D3DUSAGE_WRITEONLY, 
; 264  : 										   D3DFMT_INDEX16,
; 265  : 										   D3DPOOL_MANAGED,
; 266  : 										   &m_pIB)))

  0003c	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  0003f	8d 73 28	 lea	 esi, DWORD PTR [ebx+40]
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00048	56		 push	 esi
  00049	6a 01		 push	 1
  0004b	6a 65		 push	 101			; 00000065H
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00052	6a 08		 push	 8
  00054	c1 e0 02	 shl	 eax, 2
  00057	50		 push	 eax
  00058	51		 push	 ecx
  00059	89 75 f4	 mov	 DWORD PTR tv566[ebp], esi
  0005c	ff 52 60	 call	 DWORD PTR [edx+96]
  0005f	85 c0		 test	 eax, eax
  00061	78 d1		 js	 SHORT $LN26@CreateGeom

; 267  : 		return false;
; 268  : 
; 269  : 	WORD* dstIndices;
; 270  : 	if (FAILED(m_pIB->Lock(0, sizeof(WORD)*m_dwParticleMaxNum*6, (BYTE**)&dstIndices, 0)))

  00063	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00065	8d 45 fc	 lea	 eax, DWORD PTR _dstIndices$[ebp]
  00068	6a 00		 push	 0
  0006a	50		 push	 eax
  0006b	8b 43 4c	 mov	 eax, DWORD PTR [ebx+76]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00073	c1 e0 02	 shl	 eax, 2
  00076	50		 push	 eax
  00077	6a 00		 push	 0
  00079	51		 push	 ecx
  0007a	ff 52 2c	 call	 DWORD PTR [edx+44]
  0007d	85 c0		 test	 eax, eax
  0007f	78 b3		 js	 SHORT $LN26@CreateGeom

; 271  : 		return false;
; 272  : 
; 273  : 	const WORD c_awFillRectIndices[6] = { 0, 2, 1, 2, 3, 1, };
; 274  : 	for (int i = 0; i < m_dwParticleMaxNum; ++i)

  00081	33 c0		 xor	 eax, eax
  00083	89 45 f8	 mov	 DWORD PTR _i$1$[ebp], eax
  00086	39 43 4c	 cmp	 DWORD PTR [ebx+76], eax
  00089	76 59		 jbe	 SHORT $LN4@CreateGeom
  0008b	57		 push	 edi
  0008c	bf 06 00 00 00	 mov	 edi, 6
$LL6@CreateGeom:

; 275  : 	{
; 276  : 		for (int j = 0; j < 6; ++j)
; 277  : 		{
; 278  : 			dstIndices[i*6 + j] = i*4 + c_awFillRectIndices[j];

  00091	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00098	8b 45 fc	 mov	 eax, DWORD PTR _dstIndices$[ebp]
  0009b	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  0009e	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  000a1	8d 7f 0c	 lea	 edi, DWORD PTR [edi+12]
  000a4	66 89 74 07 ee	 mov	 WORD PTR [edi+eax-18], si
  000a9	8b 45 fc	 mov	 eax, DWORD PTR _dstIndices$[ebp]
  000ac	66 89 4c 07 f0	 mov	 WORD PTR [edi+eax-16], cx
  000b1	8b 45 fc	 mov	 eax, DWORD PTR _dstIndices$[ebp]
  000b4	66 89 54 07 f2	 mov	 WORD PTR [edi+eax-14], dx
  000b9	8b 45 fc	 mov	 eax, DWORD PTR _dstIndices$[ebp]
  000bc	66 89 4c 07 f4	 mov	 WORD PTR [edi+eax-12], cx
  000c1	8d 4e 03	 lea	 ecx, DWORD PTR [esi+3]
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _dstIndices$[ebp]
  000c7	66 89 4c 07 f6	 mov	 WORD PTR [edi+eax-10], cx
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _dstIndices$[ebp]
  000cf	66 89 54 07 f8	 mov	 WORD PTR [edi+eax-8], dx
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _i$1$[ebp]
  000d7	40		 inc	 eax
  000d8	89 45 f8	 mov	 DWORD PTR _i$1$[ebp], eax
  000db	3b 43 4c	 cmp	 eax, DWORD PTR [ebx+76]
  000de	72 b1		 jb	 SHORT $LL6@CreateGeom
  000e0	8b 75 f4	 mov	 esi, DWORD PTR tv566[ebp]
  000e3	5f		 pop	 edi
$LN4@CreateGeom:

; 279  : 		}
; 280  : 	}
; 281  : 
; 282  : 	m_pIB->Unlock();

  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	50		 push	 eax
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	ff 51 30	 call	 DWORD PTR [ecx+48]
  000ec	5e		 pop	 esi

; 283  : 	return true;

  000ed	b0 01		 mov	 al, 1
  000ef	5b		 pop	 ebx

; 284  : }

  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
?__CreateGeometry@CSnowEnvironment@@IAE_NXZ ENDP	; CSnowEnvironment::__CreateGeometry
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?__CreateBlurTexture@CSnowEnvironment@@IAE_NXZ
_TEXT	SEGMENT
?__CreateBlurTexture@CSnowEnvironment@@IAE_NXZ PROC	; CSnowEnvironment::__CreateBlurTexture, COMDAT
; _this$ = ecx

; 232  : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 233  : 	if (!m_bBlurEnable)

  00003	83 7f 50 00	 cmp	 DWORD PTR [edi+80], 0
  00007	75 04		 jne	 SHORT $LN7@CreateBlur

; 234  : 		return true;

  00009	b0 01		 mov	 al, 1
  0000b	5f		 pop	 edi

; 248  : 		return false;
; 249  : 
; 250  : 	return true;
; 251  : }

  0000c	c3		 ret	 0
$LN7@CreateBlur:

; 235  : 
; 236  : 	if (FAILED(ms_lpd3dDevice->CreateTexture(m_wBlurTextureSize, m_wBlurTextureSize, 1, D3DUSAGE_RENDERTARGET, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &m_lpSnowTexture)))

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00013	0f b7 47 38	 movzx	 eax, WORD PTR [edi+56]
  00017	56		 push	 esi
  00018	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	56		 push	 esi
  0001e	6a 00		 push	 0
  00020	6a 16		 push	 22			; 00000016H
  00022	6a 01		 push	 1
  00024	6a 01		 push	 1
  00026	50		 push	 eax
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	ff 52 50	 call	 DWORD PTR [edx+80]
  0002c	85 c0		 test	 eax, eax
  0002e	78 64		 js	 SHORT $LN11@CreateBlur

; 237  : 		return false;
; 238  : 	if (FAILED(m_lpSnowTexture->GetSurfaceLevel(0, &m_lpSnowRenderTargetSurface)))

  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00032	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00035	50		 push	 eax
  00036	6a 00		 push	 0
  00038	51		 push	 ecx
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	ff 52 3c	 call	 DWORD PTR [edx+60]
  0003e	85 c0		 test	 eax, eax
  00040	78 52		 js	 SHORT $LN11@CreateBlur

; 239  : 		return false;
; 240  : 	if (FAILED(ms_lpd3dDevice->CreateDepthStencilSurface(m_wBlurTextureSize, m_wBlurTextureSize, D3DFMT_D16, D3DMULTISAMPLE_NONE, &m_lpSnowDepthSurface)))

  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00048	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  0004b	0f b7 4f 38	 movzx	 ecx, WORD PTR [edi+56]
  0004f	50		 push	 eax
  00050	6a 00		 push	 0
  00052	8b 32		 mov	 esi, DWORD PTR [edx]
  00054	6a 50		 push	 80			; 00000050H
  00056	51		 push	 ecx
  00057	51		 push	 ecx
  00058	52		 push	 edx
  00059	ff 56 68	 call	 DWORD PTR [esi+104]
  0005c	85 c0		 test	 eax, eax
  0005e	78 34		 js	 SHORT $LN11@CreateBlur

; 241  : 		return false;
; 242  : 
; 243  : 	if (FAILED(ms_lpd3dDevice->CreateTexture(m_wBlurTextureSize, m_wBlurTextureSize, 1, D3DUSAGE_RENDERTARGET, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &m_lpAccumTexture)))

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00066	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00069	0f b7 47 38	 movzx	 eax, WORD PTR [edi+56]
  0006d	56		 push	 esi
  0006e	6a 00		 push	 0
  00070	8b 11		 mov	 edx, DWORD PTR [ecx]
  00072	6a 16		 push	 22			; 00000016H
  00074	6a 01		 push	 1
  00076	6a 01		 push	 1
  00078	50		 push	 eax
  00079	50		 push	 eax
  0007a	51		 push	 ecx
  0007b	ff 52 50	 call	 DWORD PTR [edx+80]
  0007e	85 c0		 test	 eax, eax
  00080	78 12		 js	 SHORT $LN11@CreateBlur

; 244  : 		return false;
; 245  : 	if (FAILED(m_lpAccumTexture->GetSurfaceLevel(0, &m_lpAccumRenderTargetSurface)))

  00082	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00084	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  00087	50		 push	 eax
  00088	6a 00		 push	 0
  0008a	51		 push	 ecx
  0008b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008d	ff 52 3c	 call	 DWORD PTR [edx+60]
  00090	85 c0		 test	 eax, eax
  00092	79 05		 jns	 SHORT $LN2@CreateBlur
$LN11@CreateBlur:
  00094	5e		 pop	 esi

; 246  : 		return false;

  00095	32 c0		 xor	 al, al
  00097	5f		 pop	 edi

; 248  : 		return false;
; 249  : 
; 250  : 	return true;
; 251  : }

  00098	c3		 ret	 0
$LN2@CreateBlur:

; 247  : 	if (FAILED(ms_lpd3dDevice->CreateDepthStencilSurface(m_wBlurTextureSize, m_wBlurTextureSize, D3DFMT_D16, D3DMULTISAMPLE_NONE, &m_lpAccumDepthSurface)))

  00099	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0009f	8d 47 20	 lea	 eax, DWORD PTR [edi+32]
  000a2	0f b7 4f 38	 movzx	 ecx, WORD PTR [edi+56]
  000a6	50		 push	 eax
  000a7	6a 00		 push	 0
  000a9	8b 32		 mov	 esi, DWORD PTR [edx]
  000ab	6a 50		 push	 80			; 00000050H
  000ad	51		 push	 ecx
  000ae	51		 push	 ecx
  000af	52		 push	 edx
  000b0	ff 56 68	 call	 DWORD PTR [esi+104]
  000b3	85 c0		 test	 eax, eax
  000b5	5e		 pop	 esi
  000b6	0f 99 c0	 setns	 al
  000b9	5f		 pop	 edi

; 248  : 		return false;
; 249  : 
; 250  : 	return true;
; 251  : }

  000ba	c3		 ret	 0
?__CreateBlurTexture@CSnowEnvironment@@IAE_NXZ ENDP	; CSnowEnvironment::__CreateBlurTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?__Initialize@CSnowEnvironment@@IAEXXZ
_TEXT	SEGMENT
?__Initialize@CSnowEnvironment@@IAEXXZ PROC		; CSnowEnvironment::__Initialize, COMDAT
; _this$ = ecx

; 328  : 	m_bSnowEnable = FALSE;
; 329  : 	m_lpSnowTexture = NULL;
; 330  : 	m_lpSnowRenderTargetSurface = NULL;
; 331  : 	m_lpSnowDepthSurface = NULL;
; 332  : 	m_lpAccumTexture = NULL;
; 333  : 	m_lpAccumRenderTargetSurface = NULL;
; 334  : 	m_lpAccumDepthSurface = NULL;
; 335  : 	m_pVB = NULL;
; 336  : 	m_pIB = NULL;
; 337  : 	m_pImageInstance = NULL;
; 338  : 
; 339  : 	m_kVct_pkParticleSnow.reserve(m_dwParticleMaxNum);

  00000	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00003	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
  0000a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00011	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00018	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0001f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00026	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  0002d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00034	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  0003b	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00042	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00049	83 c1 40	 add	 ecx, 64			; 00000040H
; File a:\vs\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0004c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00051	c1 f8 02	 sar	 eax, 2

; 1000 : 		if (capacity() < _Count)

  00054	3b c2		 cmp	 eax, edx
  00056	73 0e		 jae	 SHORT $LN4@Initialize

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

  00058	81 fa ff ff ff
	3f		 cmp	 edx, 1073741823		; 3fffffffH
  0005e	77 07		 ja	 SHORT $LN24@Initialize

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@IAEXI@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::_Reallocate
$LN4@Initialize:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 340  : }

  00066	c3		 ret	 0
$LN24@Initialize:
; File a:\vs\vc\include\vector

; 1754 : 		_Xlength_error("vector<T> too long");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN26@Initialize:
$LN23@Initialize:
  00071	cc		 int	 3
?__Initialize@CSnowEnvironment@@IAEXXZ ENDP		; CSnowEnvironment::__Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?Render@CSnowEnvironment@@QAEXXZ
_TEXT	SEGMENT
_pv3Verticies$ = -24					; size = 4
_c_rv3Up$1$ = -20					; size = 4
_c_rv3Cross$1$ = -16					; size = 4
_dwParticleCount$1$ = -12				; size = 4
_i$1$ = -8						; size = 4
tv498 = -4						; size = 4
?Render@CSnowEnvironment@@QAEXXZ PROC			; CSnowEnvironment::Render, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 172  : 	if (!m_bSnowEnable)

  00009	83 7f 54 00	 cmp	 DWORD PTR [edi+84], 0
  0000d	75 0c		 jne	 SHORT $LN6@Render
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0000f	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00012	3b 47 44	 cmp	 eax, DWORD PTR [edi+68]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 174  : 		if (m_kVct_pkParticleSnow.empty())

  00015	0f 84 1c 02 00
	00		 je	 $LN8@Render
$LN6@Render:
  0001b	53		 push	 ebx

; 175  : 			return;
; 176  : 	}
; 177  : 
; 178  : 	__BeginBlur();

  0001c	e8 00 00 00 00	 call	 ?__BeginBlur@CSnowEnvironment@@IAEXXZ ; CSnowEnvironment::__BeginBlur
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00024	2b 47 40	 sub	 eax, DWORD PTR [edi+64]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 180  : 	DWORD dwParticleCount = min(m_dwParticleMaxNum, m_kVct_pkParticleSnow.size());

  00027	8b 5f 4c	 mov	 ebx, DWORD PTR [edi+76]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002a	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 180  : 	DWORD dwParticleCount = min(m_dwParticleMaxNum, m_kVct_pkParticleSnow.size());

  0002d	89 5d f4	 mov	 DWORD PTR _dwParticleCount$1$[ebp], ebx
  00030	3b d8		 cmp	 ebx, eax
  00032	72 0c		 jb	 SHORT $LN11@Render
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00034	8b 5f 44	 mov	 ebx, DWORD PTR [edi+68]
  00037	2b 5f 40	 sub	 ebx, DWORD PTR [edi+64]
  0003a	c1 fb 02	 sar	 ebx, 2
  0003d	89 5d f4	 mov	 DWORD PTR _dwParticleCount$1$[ebp], ebx
$LN11@Render:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 182  : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00046	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 183  : 	if (!pCamera)

  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 e3 01 00
	00		 je	 $LN97@Render
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h

; 170  : 		const D3DXVECTOR3 & GetUp() const		{ return m_v3Up; }

  00053	8d 48 48	 lea	 ecx, DWORD PTR [eax+72]

; 171  : 		const D3DXVECTOR3 & GetView() const		{ return m_v3View; }
; 172  : 		const D3DXVECTOR3 & GetCross() const	{ return m_v3Cross; }

  00056	83 c0 60	 add	 eax, 96			; 00000060H
  00059	89 45 f0	 mov	 DWORD PTR _c_rv3Cross$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 190  : 	if (SUCCEEDED(m_pVB->Lock(0, sizeof(SParticleVertex)*dwParticleCount*4, (BYTE **) &pv3Verticies, D3DLOCK_DISCARD)))

  0005c	8d 45 e8	 lea	 eax, DWORD PTR _pv3Verticies$[ebp]
  0005f	68 00 20 00 00	 push	 8192			; 00002000H
  00064	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h

; 170  : 		const D3DXVECTOR3 & GetUp() const		{ return m_v3Up; }

  00065	89 4d ec	 mov	 DWORD PTR _c_rv3Up$1$[ebp], ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 190  : 	if (SUCCEEDED(m_pVB->Lock(0, sizeof(SParticleVertex)*dwParticleCount*4, (BYTE **) &pv3Verticies, D3DLOCK_DISCARD)))

  00068	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]
  0006b	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  0006e	c1 e0 04	 shl	 eax, 4
  00071	50		 push	 eax
  00072	6a 00		 push	 0
  00074	8b 11		 mov	 edx, DWORD PTR [ecx]
  00076	51		 push	 ecx
  00077	ff 52 2c	 call	 DWORD PTR [edx+44]
  0007a	85 c0		 test	 eax, eax
  0007c	78 63		 js	 SHORT $LN4@Render

; 191  : 	{
; 192  : 		int i = 0;

  0007e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  00085	56		 push	 esi
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  00086	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 194  : 		for (; i < dwParticleCount && itor != m_kVct_pkParticleSnow.end(); ++i, ++itor)

  00089	85 db		 test	 ebx, ebx
  0008b	74 4a		 je	 SHORT $LN96@Render

; 191  : 	{
; 192  : 		int i = 0;

  0008d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv498[ebp], 0
$LL34@Render:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00094	3b 77 44	 cmp	 esi, DWORD PTR [edi+68]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 194  : 		for (; i < dwParticleCount && itor != m_kVct_pkParticleSnow.end(); ++i, ++itor)

  00097	74 3e		 je	 SHORT $LN96@Render

; 195  : 		{
; 196  : 			CSnowParticle * pSnow = *itor;
; 197  : 			pSnow->SetCameraVertex(c_rv3Up, c_rv3Cross);

  00099	ff 75 f0	 push	 DWORD PTR _c_rv3Cross$1$[ebp]
  0009c	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0009e	8b cb		 mov	 ecx, ebx
  000a0	ff 75 ec	 push	 DWORD PTR _c_rv3Up$1$[ebp]
  000a3	e8 00 00 00 00	 call	 ?SetCameraVertex@CSnowParticle@@QAEXABUD3DXVECTOR3@@0@Z ; CSnowParticle::SetCameraVertex

; 198  : 			pSnow->GetVerticies(pv3Verticies[i*4+0],
; 199  : 								pv3Verticies[i*4+1],
; 200  : 								pv3Verticies[i*4+2],
; 201  : 								pv3Verticies[i*4+3]);

  000a8	8b 55 fc	 mov	 edx, DWORD PTR tv498[ebp]
  000ab	8b cb		 mov	 ecx, ebx
  000ad	03 55 e8	 add	 edx, DWORD PTR _pv3Verticies$[ebp]
  000b0	8d 42 3c	 lea	 eax, DWORD PTR [edx+60]
  000b3	50		 push	 eax
  000b4	8d 42 28	 lea	 eax, DWORD PTR [edx+40]
  000b7	50		 push	 eax
  000b8	8d 42 14	 lea	 eax, DWORD PTR [edx+20]
  000bb	50		 push	 eax
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 ?GetVerticies@CSnowParticle@@QAEXAAUSParticleVertex@@000@Z ; CSnowParticle::GetVerticies
  000c2	8b 45 f8	 mov	 eax, DWORD PTR _i$1$[ebp]
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  000c5	83 c6 04	 add	 esi, 4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 194  : 		for (; i < dwParticleCount && itor != m_kVct_pkParticleSnow.end(); ++i, ++itor)

  000c8	83 45 fc 50	 add	 DWORD PTR tv498[ebp], 80 ; 00000050H
  000cc	40		 inc	 eax
  000cd	8b 5d f4	 mov	 ebx, DWORD PTR _dwParticleCount$1$[ebp]
  000d0	89 45 f8	 mov	 DWORD PTR _i$1$[ebp], eax
  000d3	3b c3		 cmp	 eax, ebx
  000d5	72 bd		 jb	 SHORT $LL34@Render
$LN96@Render:

; 202  : 		}
; 203  : 		m_pVB->Unlock();

  000d7	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  000da	50		 push	 eax
  000db	8b 08		 mov	 ecx, DWORD PTR [eax]
  000dd	ff 51 30	 call	 DWORD PTR [ecx+48]
  000e0	5e		 pop	 esi
$LN4@Render:

; 204  : 	}
; 205  : 
; 206  : 	STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, FALSE);

  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e7	6a 00		 push	 0
  000e9	6a 0e		 push	 14			; 0000000eH
  000eb	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 207  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  000f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f6	6a 01		 push	 1
  000f8	6a 1b		 push	 27			; 0000001bH
  000fa	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 208  : 	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00105	6a 01		 push	 1
  00107	6a 16		 push	 22			; 00000016H
  00109	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 209  : 	STATEMANAGER.SetRenderState(D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA);

  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00114	6a 05		 push	 5
  00116	6a 13		 push	 19			; 00000013H
  00118	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 210  : 	STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00123	6a 06		 push	 6
  00125	6a 14		 push	 20			; 00000014H
  00127	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 211  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0012c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00132	6a 02		 push	 2
  00134	6a 02		 push	 2
  00136	6a 00		 push	 0
  00138	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 212  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

  0013d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00143	6a 02		 push	 2
  00145	6a 01		 push	 1
  00147	6a 00		 push	 0
  00149	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 213  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00154	6a 02		 push	 2
  00156	6a 05		 push	 5
  00158	6a 00		 push	 0
  0015a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 214  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00165	6a 02		 push	 2
  00167	6a 04		 push	 4
  00169	6a 00		 push	 0
  0016b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 215  : 	STATEMANAGER.SetTexture(1, NULL);

  00170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00176	6a 00		 push	 0
  00178	6a 01		 push	 1
  0017a	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 216  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

  0017f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00185	6a 01		 push	 1
  00187	6a 01		 push	 1
  00189	6a 01		 push	 1
  0018b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 217  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00196	6a 01		 push	 1
  00198	6a 04		 push	 4
  0019a	6a 01		 push	 1
  0019c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 218  : 
; 219  : 	m_pImageInstance->GetGraphicImagePointer()->GetTextureReference().SetTextureStage(0);

  001a1	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  001a4	6a 00		 push	 0
  001a6	e8 00 00 00 00	 call	 ?GetGraphicImagePointer@CGraphicImageInstance@@QAEPAVCGraphicImage@@XZ ; CGraphicImageInstance::GetGraphicImagePointer
  001ab	8b c8		 mov	 ecx, eax
  001ad	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImage@@QBEABVCGraphicTexture@@XZ ; CGraphicImage::GetTextureReference
  001b2	8b c8		 mov	 ecx, eax
  001b4	e8 00 00 00 00	 call	 ?SetTextureStage@CGraphicTexture@@QBEXH@Z ; CGraphicTexture::SetTextureStage

; 220  : 	STATEMANAGER.SetIndices(m_pIB, 0);

  001b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001bf	6a 00		 push	 0
  001c1	ff 77 28	 push	 DWORD PTR [edi+40]
  001c4	e8 00 00 00 00	 call	 ?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z ; CStateManager::SetIndices

; 221  : 	STATEMANAGER.SetStreamSource(0, m_pVB, sizeof(SParticleVertex));

  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001cf	6a 14		 push	 20			; 00000014H
  001d1	ff 77 24	 push	 DWORD PTR [edi+36]
  001d4	6a 00		 push	 0
  001d6	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 222  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);

  001db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e1	68 02 01 00 00	 push	 258			; 00000102H
  001e6	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 223  : 	STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, dwParticleCount*4, 0, dwParticleCount*2);

  001eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f1	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  001f4	50		 push	 eax
  001f5	6a 00		 push	 0
  001f7	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  001fe	50		 push	 eax
  001ff	6a 00		 push	 0
  00201	6a 04		 push	 4
  00203	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 224  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020e	6a 1b		 push	 27			; 0000001bH
  00210	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 225  : 	STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);

  00215	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0021b	6a 0e		 push	 14			; 0000000eH
  0021d	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 226  : 	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);

  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00228	6a 16		 push	 22			; 00000016H
  0022a	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 227  : 
; 228  : 	__ApplyBlur();

  0022f	8b cf		 mov	 ecx, edi
  00231	e8 00 00 00 00	 call	 ?__ApplyBlur@CSnowEnvironment@@IAEXXZ ; CSnowEnvironment::__ApplyBlur
$LN97@Render:
  00236	5b		 pop	 ebx
$LN8@Render:
  00237	5f		 pop	 edi

; 229  : }

  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c3		 ret	 0
?Render@CSnowEnvironment@@QAEXXZ ENDP			; CSnowEnvironment::Render
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?Deform@CSnowEnvironment@@QAEXXZ
_TEXT	SEGMENT
_pSnow$1$ = -40						; size = 4
_this$GSCopy$1$ = -36					; size = 4
_fElapsedTime$1$ = -32					; size = 4
_pSnowParticle$2 = -32					; size = 4
_v3ChangedPos$ = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Deform@CSnowEnvironment@@QAEXXZ PROC			; CSnowEnvironment::Deform, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Deform@CSnowEnvironment@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d dc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx

; 37   : 	if (!m_bSnowEnable)

  00030	83 7b 54 00	 cmp	 DWORD PTR [ebx+84], 0
  00034	75 0c		 jne	 SHORT $LN11@Deform
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00036	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00039	3b 43 44	 cmp	 eax, DWORD PTR [ebx+68]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 39   : 		if (m_kVct_pkParticleSnow.empty())

  0003c	0f 84 68 01 00
	00		 je	 $LN92@Deform
$LN11@Deform:

; 40   : 			return;
; 41   : 	}
; 42   : 
; 43   : 	const D3DXVECTOR3 & c_rv3Pos=m_v3Center;
; 44   : 	
; 45   : 	static long s_lLastTime = CTimer::Instance().GetCurrentMillisecond();

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?6??Deform@CSnowEnvironment@@QAEXXZ@4IA
  00047	a8 01		 test	 al, 1
  00049	75 26		 jne	 SHORT $LN10@Deform
  0004b	83 c8 01	 or	 eax, 1
  0004e	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?6??Deform@CSnowEnvironment@@QAEXXZ@4IA, eax
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond
  00065	a3 00 00 00 00	 mov	 DWORD PTR ?s_lLastTime@?6??Deform@CSnowEnvironment@@QAEXXZ@4JA, eax
  0006a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN10@Deform:

; 46   : 	long lcurTime = CTimer::Instance().GetCurrentMillisecond();

  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00077	e8 00 00 00 00	 call	 ?GetCurrentMillisecond@CTimer@@QAEKXZ ; CTimer::GetCurrentMillisecond

; 47   : 	float fElapsedTime = float(lcurTime - s_lLastTime) / 1000.0f;

  0007c	8b c8		 mov	 ecx, eax
  0007e	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?s_lLastTime@?6??Deform@CSnowEnvironment@@QAEXXZ@4JA

; 48   : 	s_lLastTime = lcurTime;

  00084	a3 00 00 00 00	 mov	 DWORD PTR ?s_lLastTime@?6??Deform@CSnowEnvironment@@QAEXXZ@4JA, eax
  00089	66 0f 6e c1	 movd	 xmm0, ecx
  0008d	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 49   : 
; 50   : 	CCamera * pCamera = CCameraManager::Instance().GetCurrentCamera();

  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  00096	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  0009e	f3 0f 11 45 e0	 movss	 DWORD PTR _fElapsedTime$1$[ebp], xmm0
  000a3	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera

; 51   : 	if (!pCamera)

  000a8	85 c0		 test	 eax, eax
  000aa	0f 84 fa 00 00
	00		 je	 $LN92@Deform
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  000b0	f3 0f 10 50 54	 movss	 xmm2, DWORD PTR [eax+84]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 59   : 	std::vector<CSnowParticle*>::iterator itor = m_kVct_pkParticleSnow.begin();

  000b5	8d 7b 40	 lea	 edi, DWORD PTR [ebx+64]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  000b8	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@455ac000
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  000c0	8b 37		 mov	 esi, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000c2	f3 0f 10 43 2c	 movss	 xmm0, DWORD PTR [ebx+44]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  000c7	f3 0f 10 48 58	 movss	 xmm1, DWORD PTR [eax+88]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000cc	f3 0f 58 c2	 addss	 xmm0, xmm2

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  000d0	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@455ac000

; 180  :     x = fx;

  000d8	f3 0f 11 45 e4	 movss	 DWORD PTR _v3ChangedPos$[ebp], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  000dd	f3 0f 10 43 30	 movss	 xmm0, DWORD PTR [ebx+48]
  000e2	f3 0f 58 c1	 addss	 xmm0, xmm1

; 181  :     y = fy;

  000e6	f3 0f 11 45 e8	 movss	 DWORD PTR _v3ChangedPos$[ebp+4], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 57   : 	v3ChangedPos.z = c_rv3Pos.z;

  000eb	f3 0f 10 43 34	 movss	 xmm0, DWORD PTR [ebx+52]
  000f0	f3 0f 11 45 ec	 movss	 DWORD PTR _v3ChangedPos$[ebp+8], xmm0
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000f5	3b 73 44	 cmp	 esi, DWORD PTR [ebx+68]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 60   : 	for (; itor != m_kVct_pkParticleSnow.end();)

  000f8	74 5e		 je	 SHORT $LN7@Deform
; File a:\from c\desktop\serwer\source\source client\client\eterlib\camera.h

; 171  : 		const D3DXVECTOR3 & GetView() const		{ return m_v3View; }

  000fa	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  000fd	8d 49 00	 npad	 3
$LL8@Deform:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 62   : 		CSnowParticle * pSnow = *itor;

  00100	8b 06		 mov	 eax, DWORD PTR [esi]

; 63   : 		pSnow->Update(fElapsedTime, v3ChangedPos);

  00102	8d 4d e4	 lea	 ecx, DWORD PTR _v3ChangedPos$[ebp]
  00105	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fElapsedTime$1$[ebp]
  0010a	51		 push	 ecx
  0010b	51		 push	 ecx
  0010c	8b c8		 mov	 ecx, eax
  0010e	89 45 d8	 mov	 DWORD PTR _pSnow$1$[ebp], eax
  00111	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00116	e8 00 00 00 00	 call	 ?Update@CSnowParticle@@QAEXMABUD3DXVECTOR3@@@Z ; CSnowParticle::Update

; 64   : 
; 65   : 		if (!pSnow->IsActivate())

  0011b	8b 4d d8	 mov	 ecx, DWORD PTR _pSnow$1$[ebp]
  0011e	e8 00 00 00 00	 call	 ?IsActivate@CSnowParticle@@QAE_NXZ ; CSnowParticle::IsActivate
  00123	84 c0		 test	 al, al
  00125	75 21		 jne	 SHORT $LN6@Deform

; 66   : 		{
; 67   : 			CSnowParticle::Delete(pSnow);

  00127	ff 75 d8	 push	 DWORD PTR _pSnow$1$[ebp]
  0012a	e8 00 00 00 00	 call	 ?Delete@CSnowParticle@@SAXPAV1@@Z ; CSnowParticle::Delete
; File a:\vs\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

  0012f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00132	2b c3		 sub	 eax, ebx

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

  00134	83 e0 fc	 and	 eax, -4			; fffffffcH
  00137	50		 push	 eax
  00138	53		 push	 ebx
  00139	56		 push	 esi
  0013a	e8 00 00 00 00	 call	 _memmove
  0013f	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 1456 : 		--this->_Mylast;

  00142	83 47 04 fc	 add	 DWORD PTR [edi+4], -4	; fffffffcH
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 71   : 		else

  00146	eb 06		 jmp	 SHORT $LN80@Deform
$LN6@Deform:
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  00148	83 c6 04	 add	 esi, 4
  0014b	83 c3 04	 add	 ebx, 4
$LN80@Deform:

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0014e	8b 45 dc	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00151	3b 70 44	 cmp	 esi, DWORD PTR [eax+68]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 60   : 	for (; itor != m_kVct_pkParticleSnow.end();)

  00154	75 aa		 jne	 SHORT $LL8@Deform
  00156	8b d8		 mov	 ebx, eax
$LN7@Deform:

; 72   : 		{
; 73   : 			++itor;
; 74   : 		}
; 75   : 	}
; 76   : 
; 77   : 	if (m_bSnowEnable)

  00158	83 7b 54 00	 cmp	 DWORD PTR [ebx+84], 0
  0015c	74 4c		 je	 SHORT $LN92@Deform

; 79   : 		for (int p = 0; p < min(10, m_dwParticleMaxNum - m_kVct_pkParticleSnow.size()); ++p)

  0015e	33 f6		 xor	 esi, esi
$LL3@Deform:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00160	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00163	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 79   : 		for (int p = 0; p < min(10, m_dwParticleMaxNum - m_kVct_pkParticleSnow.size()); ++p)

  00165	8b 53 4c	 mov	 edx, DWORD PTR [ebx+76]
  00168	8b c2		 mov	 eax, edx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0016a	c1 f9 02	 sar	 ecx, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 79   : 		for (int p = 0; p < min(10, m_dwParticleMaxNum - m_kVct_pkParticleSnow.size()); ++p)

  0016d	2b c1		 sub	 eax, ecx
  0016f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00172	76 07		 jbe	 SHORT $LN15@Deform
  00174	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  00179	eb 0a		 jmp	 SHORT $LN16@Deform
$LN15@Deform:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0017b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0017e	2b 07		 sub	 eax, DWORD PTR [edi]
  00180	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 79   : 		for (int p = 0; p < min(10, m_dwParticleMaxNum - m_kVct_pkParticleSnow.size()); ++p)

  00183	2b d0		 sub	 edx, eax
$LN16@Deform:
  00185	3b f2		 cmp	 esi, edx
  00187	73 21		 jae	 SHORT $LN92@Deform

; 80   : 		{
; 81   : 			CSnowParticle * pSnowParticle = CSnowParticle::New();

  00189	e8 00 00 00 00	 call	 ?New@CSnowParticle@@SAPAV1@XZ ; CSnowParticle::New

; 82   : 			pSnowParticle->Init(v3ChangedPos);

  0018e	8d 4d e4	 lea	 ecx, DWORD PTR _v3ChangedPos$[ebp]
  00191	89 45 e0	 mov	 DWORD PTR _pSnowParticle$2[ebp], eax
  00194	51		 push	 ecx
  00195	8b c8		 mov	 ecx, eax
  00197	e8 00 00 00 00	 call	 ?Init@CSnowParticle@@QAEXABUD3DXVECTOR3@@@Z ; CSnowParticle::Init

; 83   : 			m_kVct_pkParticleSnow.push_back(pSnowParticle);

  0019c	8d 45 e0	 lea	 eax, DWORD PTR _pSnowParticle$2[ebp]
  0019f	8b cf		 mov	 ecx, edi
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAEXABQAVCSnowParticle@@@Z ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::push_back
  001a7	46		 inc	 esi
  001a8	eb b6		 jmp	 SHORT $LL3@Deform
$LN92@Deform:

; 84   : 		}
; 85   : 	}
; 86   : }

  001aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b4	59		 pop	 ecx
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bb	33 cd		 xor	 ecx, ebp
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Deform@CSnowEnvironment@@QAEXXZ$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$S1@?6??Deform@CSnowEnvironment@@QAEXXZ@4IA
  00005	83 e0 fe	 and	 eax, -2			; fffffffeH
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?$S1@?6??Deform@CSnowEnvironment@@QAEXXZ@4IA, eax
  0000d	c3		 ret	 0
__ehhandler$?Deform@CSnowEnvironment@@QAEXXZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Deform@CSnowEnvironment@@QAEXXZ
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Deform@CSnowEnvironment@@QAEXXZ ENDP			; CSnowEnvironment::Deform
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?Update@CSnowEnvironment@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_c_rv3Pos$ = 8						; size = 4
?Update@CSnowEnvironment@@QAEXABUD3DXVECTOR3@@@Z PROC	; CSnowEnvironment::Update, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 26   : 	if (!m_bSnowEnable)

  00003	83 79 54 00	 cmp	 DWORD PTR [ecx+84], 0
  00007	75 08		 jne	 SHORT $LN1@Update
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00009	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0000c	3b 41 44	 cmp	 eax, DWORD PTR [ecx+68]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 28   : 		if (m_kVct_pkParticleSnow.empty())

  0000f	74 12		 je	 SHORT $LN3@Update
$LN1@Update:

; 29   : 			return;
; 30   : 	}
; 31   : 
; 32   : 	m_v3Center=c_rv3Pos;

  00011	8b 45 08	 mov	 eax, DWORD PTR _c_rv3Pos$[ebp]
  00014	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00018	66 0f d6 41 2c	 movq	 QWORD PTR [ecx+44], xmm0
  0001d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00020	89 41 34	 mov	 DWORD PTR [ecx+52], eax
$LN3@Update:

; 33   : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?Update@CSnowEnvironment@@QAEXABUD3DXVECTOR3@@@Z ENDP	; CSnowEnvironment::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?Disable@CSnowEnvironment@@QAEXXZ
_TEXT	SEGMENT
?Disable@CSnowEnvironment@@QAEXXZ PROC			; CSnowEnvironment::Disable, COMDAT
; _this$ = ecx

; 21   : 	m_bSnowEnable = FALSE;

  00000	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 22   : }

  00007	c3		 ret	 0
?Disable@CSnowEnvironment@@QAEXXZ ENDP			; CSnowEnvironment::Disable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?Enable@CSnowEnvironment@@QAEXXZ
_TEXT	SEGMENT
?Enable@CSnowEnvironment@@QAEXXZ PROC			; CSnowEnvironment::Enable, COMDAT
; _this$ = ecx

; 10   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 11   : 	if (!m_bSnowEnable)

  00003	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  00007	75 05		 jne	 SHORT $LN4@Enable

; 12   : 	{
; 13   : 		Create();

  00009	e8 00 00 00 00	 call	 ?Create@CSnowEnvironment@@QAE_NXZ ; CSnowEnvironment::Create
$LN4@Enable:

; 14   : 	}
; 15   : 
; 16   : 	m_bSnowEnable = TRUE;

  0000e	c7 46 54 01 00
	00 00		 mov	 DWORD PTR [esi+84], 1
  00015	5e		 pop	 esi

; 17   : }

  00016	c3		 ret	 0
?Enable@CSnowEnvironment@@QAEXXZ ENDP			; CSnowEnvironment::Enable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?Destroy@CSnowEnvironment@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CSnowEnvironment@@QAEXXZ PROC			; CSnowEnvironment::Destroy, COMDAT
; _this$ = ecx

; 304  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 305  : 	SAFE_RELEASE(m_lpSnowTexture);

  00003	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0d		 je	 SHORT $LN9@Destroy
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	51		 push	 ecx
  0000d	ff 50 08	 call	 DWORD PTR [eax+8]
  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN9@Destroy:

; 306  : 	SAFE_RELEASE(m_lpSnowRenderTargetSurface);

  00017	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 0d		 je	 SHORT $LN8@Destroy
  0001e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00020	51		 push	 ecx
  00021	ff 50 08	 call	 DWORD PTR [eax+8]
  00024	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN8@Destroy:

; 307  : 	SAFE_RELEASE(m_lpSnowDepthSurface);

  0002b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0002e	85 c9		 test	 ecx, ecx
  00030	74 0d		 je	 SHORT $LN7@Destroy
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	51		 push	 ecx
  00035	ff 50 08	 call	 DWORD PTR [eax+8]
  00038	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN7@Destroy:

; 308  : 	SAFE_RELEASE(m_lpAccumTexture);

  0003f	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00042	85 c9		 test	 ecx, ecx
  00044	74 0d		 je	 SHORT $LN6@Destroy
  00046	8b 01		 mov	 eax, DWORD PTR [ecx]
  00048	51		 push	 ecx
  00049	ff 50 08	 call	 DWORD PTR [eax+8]
  0004c	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN6@Destroy:

; 309  : 	SAFE_RELEASE(m_lpAccumRenderTargetSurface);

  00053	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00056	85 c9		 test	 ecx, ecx
  00058	74 0d		 je	 SHORT $LN5@Destroy
  0005a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005c	51		 push	 ecx
  0005d	ff 50 08	 call	 DWORD PTR [eax+8]
  00060	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN5@Destroy:

; 310  : 	SAFE_RELEASE(m_lpAccumDepthSurface);

  00067	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 0d		 je	 SHORT $LN4@Destroy
  0006e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00070	51		 push	 ecx
  00071	ff 50 08	 call	 DWORD PTR [eax+8]
  00074	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN4@Destroy:

; 311  : 	SAFE_RELEASE(m_pVB);

  0007b	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0007e	85 c9		 test	 ecx, ecx
  00080	74 0d		 je	 SHORT $LN3@Destroy
  00082	8b 01		 mov	 eax, DWORD PTR [ecx]
  00084	51		 push	 ecx
  00085	ff 50 08	 call	 DWORD PTR [eax+8]
  00088	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
$LN3@Destroy:

; 312  : 	SAFE_RELEASE(m_pIB);

  0008f	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00092	85 c9		 test	 ecx, ecx
  00094	74 0d		 je	 SHORT $LN2@Destroy
  00096	8b 01		 mov	 eax, DWORD PTR [ecx]
  00098	51		 push	 ecx
  00099	ff 50 08	 call	 DWORD PTR [eax+8]
  0009c	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN2@Destroy:

; 313  : 
; 314  : 	stl_wipe(m_kVct_pkParticleSnow);

  000a3	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??$stl_wipe@V?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@@YAXAAV?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@@Z ; stl_wipe<std::vector<CSnowParticle *,std::allocator<CSnowParticle *> > >
  000ac	83 c4 04	 add	 esp, 4

; 315  : 	CSnowParticle::DestroyPool();

  000af	e8 00 00 00 00	 call	 ?DestroyPool@CSnowParticle@@SAXXZ ; CSnowParticle::DestroyPool

; 316  : 
; 317  : 	if (m_pImageInstance)

  000b4	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  000b7	85 c0		 test	 eax, eax
  000b9	74 10		 je	 SHORT $LN1@Destroy

; 318  : 	{
; 319  : 		CGraphicImageInstance::Delete(m_pImageInstance);

  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?Delete@CGraphicImageInstance@@SAXPAV1@@Z ; CGraphicImageInstance::Delete
  000c1	83 c4 04	 add	 esp, 4

; 320  : 		m_pImageInstance = NULL;

  000c4	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
$LN1@Destroy:

; 321  : 	}
; 322  : 
; 323  : 	__Initialize();

  000cb	8b ce		 mov	 ecx, esi
  000cd	5e		 pop	 esi
  000ce	e9 00 00 00 00	 jmp	 ?__Initialize@CSnowEnvironment@@IAEXXZ ; CSnowEnvironment::__Initialize
?Destroy@CSnowEnvironment@@QAEXXZ ENDP			; CSnowEnvironment::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ?Create@CSnowEnvironment@@QAE_NXZ
_TEXT	SEGMENT
?Create@CSnowEnvironment@@QAE_NXZ PROC			; CSnowEnvironment::Create, COMDAT
; _this$ = ecx

; 287  : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 288  : 	Destroy();

  00003	e8 00 00 00 00	 call	 ?Destroy@CSnowEnvironment@@QAEXXZ ; CSnowEnvironment::Destroy

; 289  : 
; 290  : 	if (!__CreateBlurTexture())

  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 ?__CreateBlurTexture@CSnowEnvironment@@IAE_NXZ ; CSnowEnvironment::__CreateBlurTexture
  0000f	84 c0		 test	 al, al
  00011	75 04		 jne	 SHORT $LN2@Create
$LN7@Create:

; 291  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	5f		 pop	 edi

; 301  : }

  00016	c3		 ret	 0
$LN2@Create:

; 292  : 
; 293  : 	if (!__CreateGeometry())

  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?__CreateGeometry@CSnowEnvironment@@IAE_NXZ ; CSnowEnvironment::__CreateGeometry
  0001e	84 c0		 test	 al, al
  00020	74 f1		 je	 SHORT $LN7@Create

; 294  : 		return false;
; 295  : 
; 296  : 	CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer("d:/ymir work/special/snow.dds");

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00028	56		 push	 esi
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KOAGJMMK@d?3?1ymir?5work?1special?1snow?4dds?$AA@
  0002e	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00033	8b f0		 mov	 esi, eax

; 297  : 	m_pImageInstance = CGraphicImageInstance::New();

  00035	e8 00 00 00 00	 call	 ?New@CGraphicImageInstance@@SAPAV1@XZ ; CGraphicImageInstance::New

; 298  : 	m_pImageInstance->SetImagePointer(pImage);

  0003a	56		 push	 esi
  0003b	8b c8		 mov	 ecx, eax
  0003d	89 47 3c	 mov	 DWORD PTR [edi+60], eax
  00040	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
  00045	5e		 pop	 esi

; 299  : 
; 300  : 	return true;

  00046	b0 01		 mov	 al, 1
  00048	5f		 pop	 edi

; 301  : }

  00049	c3		 ret	 0
?Create@CSnowEnvironment@@QAE_NXZ ENDP			; CSnowEnvironment::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ??1CSnowEnvironment@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CSnowEnvironment@@UAE@XZ PROC			; CSnowEnvironment::~CSnowEnvironment, COMDAT
; _this$ = ecx

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CSnowEnvironment@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CSnowEnvironment@@6B@
  0002f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 352  : 	Destroy();

  00036	e8 00 00 00 00	 call	 ?Destroy@CSnowEnvironment@@QAEXXZ ; CSnowEnvironment::Destroy
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0003b	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0003e	85 c0		 test	 eax, eax
  00040	74 1e		 je	 SHORT $LN7@CSnowEnvir
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0004b	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0

; 1630 : 			this->_Mylast = pointer();

  00052	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 1631 : 			this->_Myend = pointer();

  00059	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
$LN7@CSnowEnvir:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 353  : }

  00060	8b ce		 mov	 ecx, esi
  00062	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00069	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	5e		 pop	 esi
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CSnowEnvironment@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
__unwindfunclet$??1CSnowEnvironment@@UAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 40	 add	 ecx, 64			; 00000040H
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::~vector<CSnowParticle *,std::allocator<CSnowParticle *> >
__ehhandler$??1CSnowEnvironment@@UAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CSnowEnvironment@@UAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CSnowEnvironment@@UAE@XZ ENDP			; CSnowEnvironment::~CSnowEnvironment
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp
;	COMDAT ??0CSnowEnvironment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CSnowEnvironment@@QAE@XZ PROC			; CSnowEnvironment::CSnowEnvironment, COMDAT
; _this$ = ecx

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CSnowEnvironment@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  0002e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CSnowEnvironment@@6B@
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0003b	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0

; 483  : 		_Mylast = pointer();

  00042	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 484  : 		_Myend = pointer();

  00049	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\snowenvironment.cpp

; 346  : 	m_wBlurTextureSize = 512;

  00050	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 347  : 
; 348  : 	__Initialize();

  00059	8b ce		 mov	 ecx, esi
  0005b	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
  00062	c7 46 4c b8 0b
	00 00		 mov	 DWORD PTR [esi+76], 3000 ; 00000bb8H
  00069	66 89 46 38	 mov	 WORD PTR [esi+56], ax
  0006d	e8 00 00 00 00	 call	 ?__Initialize@CSnowEnvironment@@IAEXXZ ; CSnowEnvironment::__Initialize

; 349  : }

  00072	8b c6		 mov	 eax, esi
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5e		 pop	 esi
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CSnowEnvironment@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
__unwindfunclet$??0CSnowEnvironment@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 40	 add	 ecx, 64			; 00000040H
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCSnowParticle@@V?$allocator@PAVCSnowParticle@@@std@@@std@@QAE@XZ ; std::vector<CSnowParticle *,std::allocator<CSnowParticle *> >::~vector<CSnowParticle *,std::allocator<CSnowParticle *> >
__ehhandler$??0CSnowEnvironment@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CSnowEnvironment@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CSnowEnvironment@@QAE@XZ ENDP			; CSnowEnvironment::CSnowEnvironment
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ PROC	; CSingleton<CTimer>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ENDP	; CSingleton<CTimer>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??DD3DXVECTOR3@@QBE?AU0@M@Z PROC			; D3DXVECTOR3::operator*, COMDAT
; _this$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00003	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0000f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00013	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00017	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001c	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00020	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00025	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002a	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 270  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??DD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]

; 180  :     x = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00015	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0001a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00024	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00029	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 258  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
