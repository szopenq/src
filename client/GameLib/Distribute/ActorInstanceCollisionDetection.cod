; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\GameLib\ActorInstanceCollisionDetection.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_cosf
PUBLIC	_sinf
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z	; std::_Container_base0::_Swap_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator+=
PUBLIC	??XD3DXVECTOR3@@QAEAAU0@M@Z			; D3DXVECTOR3::operator*=
PUBLIC	??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator+
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z			; D3DXVECTOR3::operator-
PUBLIC	??DD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator*
PUBLIC	??KD3DXVECTOR3@@QBE?AU0@M@Z			; D3DXVECTOR3::operator/
PUBLIC	??D@YA?AUD3DXVECTOR3@@MABU0@@Z			; operator*
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??XD3DXMATRIX@@QAEAAU0@ABU0@@Z			; D3DXMATRIX::operator*=
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
PUBLIC	?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ; CSingleton<CTimer>::Instance
PUBLIC	??0CDynamicSphereInstance@@QAE@XZ		; CDynamicSphereInstance::CDynamicSphereInstance
PUBLIC	??R?$less@M@std@@QBE_NABM0@Z			; std::less<float>::operator()
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Isnil
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAU?$pair@$$CBMUCDynamicSphereInstance@@@2@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Myval
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Min
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@M@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Getcomp
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::lower_bound
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::upper_bound
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Lbound
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Root
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Ubound
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMABU?$pair@$$CBMUCDynamicSphereInstance@@@2@@Z ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Key
PUBLIC	?begin@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ ; std::vector<NRaceData::SHitData,std::allocator<NRaceData::SHitData> >::begin
PUBLIC	?end@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ ; std::vector<NRaceData::SHitData,std::allocator<NRaceData::SHitData> >::end
PUBLIC	?begin@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::begin
PUBLIC	?end@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::end
PUBLIC	?size@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEIXZ ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::size
PUBLIC	??A?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEABVCSphereCollisionInstance@@I@Z ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::operator[]
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z	; GetVector3Distance
PUBLIC	??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>
PUBLIC	?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal
PUBLIC	??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin
PUBLIC	?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end
PUBLIC	?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	?size@?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QBEIXZ ; std::vector<CGrannyLODController *,std::allocator<CGrannyLODController *> >::size
PUBLIC	??A?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QAEAAPAVCGrannyLODController@@I@Z ; std::vector<CGrannyLODController *,std::allocator<CGrannyLODController *> >::operator[]
PUBLIC	??0?$allocator@UCDynamicSphereInstance@@@std@@QAE@XZ ; std::allocator<CDynamicSphereInstance>::allocator<CDynamicSphereInstance>
PUBLIC	?deallocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z ; std::allocator<CDynamicSphereInstance>::deallocate
PUBLIC	?allocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEPAUCDynamicSphereInstance@@I@Z ; std::allocator<CDynamicSphereInstance>::allocate
PUBLIC	?construct@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@ABU3@@Z ; std::allocator<CDynamicSphereInstance>::construct
PUBLIC	?max_size@?$allocator@UCDynamicSphereInstance@@@std@@QBEIXZ ; std::allocator<CDynamicSphereInstance>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAIABV?$allocator@UCDynamicSphereInstance@@@2@@Z ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEPAUCDynamicSphereInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::max_size
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> > >::_Getal
PUBLIC	?reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::reserve
PUBLIC	?capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::capacity
PUBLIC	?_Unused_capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Unused_capacity
PUBLIC	?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::begin
PUBLIC	?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::begin
PUBLIC	?end@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::end
PUBLIC	?size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::size
PUBLIC	?max_size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::max_size
PUBLIC	?at@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::at
PUBLIC	??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::operator[]
PUBLIC	??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEAAUCDynamicSphereInstance@@I@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::operator[]
PUBLIC	?push_back@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXABUCDynamicSphereInstance@@@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::push_back
PUBLIC	?clear@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXXZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::clear
PUBLIC	?_Destroy@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXPAUCDynamicSphereInstance@@0@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Destroy
PUBLIC	?_Grow_to@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEII@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Grow_to
PUBLIC	?_Inside@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBE_NPBUCDynamicSphereInstance@@@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Inside
PUBLIC	?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reserve
PUBLIC	?_Xlen@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Xlen
PUBLIC	?_Xran@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Xran
PUBLIC	?_Orphan_range@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXPAUCDynamicSphereInstance@@0@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Orphan_range
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAPAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >::_Nextnode
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAUSCollisionPointInstance@CActorInstance@@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >::_Myval
PUBLIC	?begin@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ ; std::list<CActorInstance::SCollisionPointInstance,std::allocator<CActorInstance::SCollisionPointInstance> >::begin
PUBLIC	?end@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ ; std::list<CActorInstance::SCollisionPointInstance,std::allocator<CActorInstance::SCollisionPointInstance> >::end
PUBLIC	??R?$less@PAVCActorInstance@@@std@@QBE_NABQAVCActorInstance@@0@Z ; std::less<CActorInstance *>::operator()
PUBLIC	??0?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@XZ ; std::allocator<std::pair<CActorInstance * const,float> >::allocator<std::pair<CActorInstance * const,float> >
PUBLIC	?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBE?AV12@XZ ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::select_on_container_copy_construction
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocate
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::max_size
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Isnil
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAU?$pair@QAVCActorInstance@@M@2@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Myval
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Min
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Freeheadnode
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Freenode0
PUBLIC	??1?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::~_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Getcomp
PUBLIC	?_Swapcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXABU?$less@PAVCActorInstance@@@2@@Z ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Swapcomp
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::~_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@$$QAV01@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
PUBLIC	?_Assign_rv@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Assign_rv
PUBLIC	??1?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::~_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::max_size
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::key_comp
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::find
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::lower_bound
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Erase
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@ABQAVCActorInstance@@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lbound
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rrotate
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tidy
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Key
PUBLIC	??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
PUBLIC	??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@ABV01@@Z ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
PUBLIC	??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@$$QAV01@@Z ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
PUBLIC	??1?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::~map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
PUBLIC	?CreateCollisionInstancePiece@CActorInstance@@QAE_NKPBUSAttachingData@NRaceData@@PAUSCollisionPointInstance@1@@Z ; CActorInstance::CreateCollisionInstancePiece
PUBLIC	?UpdatePointInstance@CActorInstance@@QAEXXZ	; CActorInstance::UpdatePointInstance
PUBLIC	?UpdatePointInstance@CActorInstance@@QAEXPAUSCollisionPointInstance@1@@Z ; CActorInstance::UpdatePointInstance
PUBLIC	?CheckCollisionDetection@CActorInstance@@QAE_NPBV?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@PAUD3DXVECTOR3@@@Z ; CActorInstance::CheckCollisionDetection
PUBLIC	?TestCollisionWithDynamicSphere@CActorInstance@@UAE_NABUCDynamicSphereInstance@@@Z ; CActorInstance::TestCollisionWithDynamicSphere
PUBLIC	?UpdateAdvancingPointInstance@CActorInstance@@QAEXXZ ; CActorInstance::UpdateAdvancingPointInstance
PUBLIC	?AvoidObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z ; CActorInstance::AvoidObject
PUBLIC	?IsBlockObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z ; CActorInstance::IsBlockObject
PUBLIC	?BlockMovement@CActorInstance@@QAEXXZ		; CActorInstance::BlockMovement
PUBLIC	?__TestObjectCollision@CActorInstance@@IAEHPBVCGraphicObjectInstance@@@Z ; CActorInstance::__TestObjectCollision
PUBLIC	?TestActorCollision@CActorInstance@@QAEHAAV1@@Z	; CActorInstance::TestActorCollision
PUBLIC	?TestPhysicsBlendingCollision@CActorInstance@@QAEHAAV1@@Z ; CActorInstance::TestPhysicsBlendingCollision
PUBLIC	?AttackingProcess@CActorInstance@@QAEHAAV1@@Z	; CActorInstance::AttackingProcess
PUBLIC	?__SplashAttackProcess@CActorInstance@@QAEHAAV1@@Z ; CActorInstance::__SplashAttackProcess
PUBLIC	?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z ; CActorInstance::__NormalAttackProcess
PUBLIC	??R?$less@PBUSHitData@NRaceData@@@std@@QBE_NABQBUSHitData@NRaceData@@0@Z ; std::less<NRaceData::SHitData const *>::operator()
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::allocate
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::max_size
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Isnil
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Myval
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Max
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Getal
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Freenode0
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PBUSHitData@NRaceData@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Getcomp
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::end
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::max_size
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::find
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::lower_bound
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Destroy_if_not_nil
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@ABQBUSHitData@NRaceData@@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lbound
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Rrotate
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Key
PUBLIC	?EnableSkipCollision@CActorInstance@@QAEXXZ	; CActorInstance::EnableSkipCollision
PUBLIC	?DisableSkipCollision@CActorInstance@@QAEXXZ	; CActorInstance::DisableSkipCollision
PUBLIC	?CanSkipCollision@CActorInstance@@QAE_NXZ	; CActorInstance::CanSkipCollision
PUBLIC	?__InitializeCollisionData@CActorInstance@@IAEXXZ ; CActorInstance::__InitializeCollisionData
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEABUSCollisionPointInstance@CActorInstance@@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator!=
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEAAUSCollisionPointInstance@CActorInstance@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEPAUSCollisionPointInstance@CActorInstance@@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator->
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator++
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEABVCSphereCollisionInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator*
PUBLIC	??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEPBVCSphereCollisionInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator->
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Compat
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEABUCDynamicSphereInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEAAUCDynamicSphereInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEPAUCDynamicSphereInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator->
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator++
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator--
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEABU?$pair@QAVCActorInstance@@M@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator++
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator--
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVCActorInstance@@M@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVCActorInstance@@M@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator->
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator--
PUBLIC	??$make_pair@PAVCActorInstance@@M@std@@YA?AU?$pair@PAVCActorInstance@@M@0@$$QAPAVCActorInstance@@$$QAM@Z ; std::make_pair<CActorInstance *,float>
PUBLIC	??$?0PAVCActorInstance@@MX@?$pair@QAVCActorInstance@@M@std@@QAE@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::pair<CActorInstance * const,float>::pair<CActorInstance * const,float><CActorInstance *,float,void>
PUBLIC	??$insert@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::insert<std::pair<CActorInstance *,float> >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAE@PAUSHitData@NRaceData@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEABUSHitData@NRaceData@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::_Compat
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::operator--
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator*
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator--
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator->
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator--
PUBLIC	??1?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::~pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
PUBLIC	??_G?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAEPAXI@Z ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::`scalar deleting destructor'
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator*
PUBLIC	??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator->
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator!=
PUBLIC	??$make_pair@PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA?AU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@@Z ; std::make_pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>
PUBLIC	??1?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ ; std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::~pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
PUBLIC	??$?0PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > ><NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,void>
PUBLIC	??$insert@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::insert<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$addressof@$$CBUCDynamicSphereInstance@@@std@@YAPBUCDynamicSphereInstance@@ABU1@@Z ; std::addressof<CDynamicSphereInstance const >
PUBLIC	??$construct@UCDynamicSphereInstance@@AAU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance &>
PUBLIC	??$construct@UCDynamicSphereInstance@@ABU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance const &>
PUBLIC	?pointer_to@?$pointer_traits@PAUSCollisionPointInstance@CActorInstance@@@std@@SAPAUSCollisionPointInstance@CActorInstance@@AAU34@@Z ; std::pointer_traits<CActorInstance::SCollisionPointInstance *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PBVCSphereCollisionInstance@@@std@@SAPBVCSphereCollisionInstance@@ABV3@@Z ; std::pointer_traits<CSphereCollisionInstance const *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PAUCDynamicSphereInstance@@@std@@SAPAUCDynamicSphereInstance@@AAU3@@Z ; std::pointer_traits<CDynamicSphereInstance *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@QAVCActorInstance@@M@std@@@std@@SAPAU?$pair@QAVCActorInstance@@M@2@AAU32@@Z ; std::pointer_traits<std::pair<CActorInstance * const,float> *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@AAU32@@Z ; std::pointer_traits<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@SAPBU?$pair@$$CBMUCDynamicSphereInstance@@@2@ABU32@@Z ; std::pointer_traits<std::pair<float const ,CDynamicSphereInstance> const *>::pointer_to
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
PUBLIC	??$_Umove@PAUCDynamicSphereInstance@@@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEPAUCDynamicSphereInstance@@PAU2@00@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Umove<CDynamicSphereInstance *>
PUBLIC	??$addressof@USCollisionPointInstance@CActorInstance@@@std@@YAPAUSCollisionPointInstance@CActorInstance@@AAU12@@Z ; std::addressof<CActorInstance::SCollisionPointInstance>
PUBLIC	??$addressof@$$CBVCSphereCollisionInstance@@@std@@YAPBVCSphereCollisionInstance@@ABV1@@Z ; std::addressof<CSphereCollisionInstance const >
PUBLIC	??$addressof@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@AAU1@@Z ; std::addressof<CDynamicSphereInstance>
PUBLIC	??$addressof@U?$pair@QAVCActorInstance@@M@std@@@std@@YAPAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z ; std::addressof<std::pair<CActorInstance * const,float> >
PUBLIC	??$addressof@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z ; std::addressof<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$addressof@$$CBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@YAPBU?$pair@$$CBMUCDynamicSphereInstance@@@0@ABU10@@Z ; std::addressof<std::pair<float const ,CDynamicSphereInstance> const >
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$_Kfn@QAVCActorInstance@@M@?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@SAABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@1@@Z ; std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0>::_Kfn<CActorInstance * const,float>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$_Kfn@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@SAABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0>::_Kfn<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
PUBLIC	??$_Kfn@$$CBMUCDynamicSphereInstance@@@?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@SAABMABU?$pair@$$CBMUCDynamicSphereInstance@@@1@@Z ; std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0>::_Kfn<float const ,CDynamicSphereInstance>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$_Allocate@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@IPAU1@@Z ; std::_Allocate<CDynamicSphereInstance>
PUBLIC	??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::pair<CActorInstance * const,float> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
PUBLIC	??$forward@PAVCActorInstance@@@std@@YA$$QAPAVCActorInstance@@AAPAV1@@Z ; std::forward<CActorInstance *>
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??$?0PAVCActorInstance@@MX@?$pair@PAVCActorInstance@@M@std@@QAE@$$QAPAVCActorInstance@@$$QAM@Z ; std::pair<CActorInstance *,float>::pair<CActorInstance *,float><CActorInstance *,float,void>
PUBLIC	??$forward@U?$pair@PAVCActorInstance@@M@std@@@std@@YA$$QAU?$pair@PAVCActorInstance@@M@0@AAU10@@Z ; std::forward<std::pair<CActorInstance *,float> >
PUBLIC	??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance *,float> >
PUBLIC	??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_nohint<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$forward@PBUSHitData@NRaceData@@@std@@YA$$QAPBUSHitData@NRaceData@@AAPBU12@@Z ; std::forward<NRaceData::SHitData const *>
PUBLIC	??$forward@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YAAAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z ; std::forward<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>
PUBLIC	??$?0PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@1@@Z ; std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > ><NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &,void>
PUBLIC	??$forward@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YA$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z ; std::forward<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_nohint<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
PUBLIC	??$forward@AAUCDynamicSphereInstance@@@std@@YAAAUCDynamicSphereInstance@@AAU1@@Z ; std::forward<CDynamicSphereInstance &>
PUBLIC	??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@AAU3@@Z ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance &>
PUBLIC	??$forward@ABUCDynamicSphereInstance@@@std@@YAABUCDynamicSphereInstance@@ABU1@@Z ; std::forward<CDynamicSphereInstance const &>
PUBLIC	??$construct@UCDynamicSphereInstance@@ABU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@ABU3@@Z ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance const &>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Ptr_cat@UCDynamicSphereInstance@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCDynamicSphereInstance@@0@Z ; std::_Ptr_cat<CDynamicSphereInstance,CDynamicSphereInstance>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
PUBLIC	??$_Uninitialized_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
PUBLIC	??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
PUBLIC	??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::pair<CActorInstance * const,float> >
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
PUBLIC	??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >
PUBLIC	??$forward@AAU?$pair@QAVCActorInstance@@M@std@@@std@@YAAAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z ; std::forward<std::pair<CActorInstance * const,float> &>
PUBLIC	??$_Insert_at@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@1@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_at<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool,void>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > &,bool,void>
PUBLIC	??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$forward@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z ; std::forward<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &>
PUBLIC	??$_Insert_at@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_at<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool,void>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > &,bool,void>
PUBLIC	??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z ; std::allocator<CDynamicSphereInstance>::construct<CDynamicSphereInstance,CDynamicSphereInstance &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$destroy@UCDynamicSphereInstance@@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@@Z ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::destroy<CDynamicSphereInstance>
PUBLIC	??$_Unchecked@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z ; std::_Unchecked<CDynamicSphereInstance *>
PUBLIC	??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
PUBLIC	??$_Rechecked@PAUCDynamicSphereInstance@@PAU1@@std@@YAAAPAUCDynamicSphereInstance@@AAPAU1@PAU1@@Z ; std::_Rechecked<CDynamicSphereInstance *,CDynamicSphereInstance *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::destroy<std::pair<CActorInstance * const,float> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
PUBLIC	??$?0U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z ; std::allocator<std::pair<CActorInstance * const,float> >::allocator<std::pair<CActorInstance * const,float> ><std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
PUBLIC	??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
PUBLIC	??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy<std::integral_constant<bool,0> >
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >
PUBLIC	??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@AAU?$pair@QAVCActorInstance@@M@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Buynode_if_nil<std::pair<CActorInstance * const,float> &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > &>
PUBLIC	??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PAU21@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Buynode_if_nil<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > >
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > &>
PUBLIC	??$destroy@UCDynamicSphereInstance@@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@@Z ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::destroy<CDynamicSphereInstance>
PUBLIC	??$_Val_type@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z ; std::_Val_type<CDynamicSphereInstance *>
PUBLIC	??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::allocator<CDynamicSphereInstance>,CDynamicSphereInstance>
PUBLIC	??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
PUBLIC	??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
PUBLIC	??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >
PUBLIC	??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$destroy@UCDynamicSphereInstance@@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@@Z ; std::allocator<CDynamicSphereInstance>::destroy<CDynamicSphereInstance>
PUBLIC	??$construct@UCDynamicSphereInstance@@U1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance>
PUBLIC	??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
PUBLIC	??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_or_move<std::integral_constant<bool,0>,std::integral_constant<bool,1>,std::integral_constant<bool,0>,int>
PUBLIC	??$forward@UCDynamicSphereInstance@@@std@@YA$$QAUCDynamicSphereInstance@@AAU1@@Z ; std::forward<CDynamicSphereInstance>
PUBLIC	??$construct@UCDynamicSphereInstance@@U1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@$$QAU3@@Z ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance>
PUBLIC	??$_Buynode@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance * const,float> &>
PUBLIC	??$forward@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z ; std::forward<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
PUBLIC	??$construct@UCDynamicSphereInstance@@U1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z ; std::allocator<CDynamicSphereInstance>::construct<CDynamicSphereInstance,CDynamicSphereInstance>
PUBLIC	??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>
PUBLIC	??$move@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z ; std::move<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>
PUBLIC	??$forward@V?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@@std@@YA$$QAV?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@0@AAV10@@Z ; std::forward<std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> > >
PUBLIC	??$_Swap_adl@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z ; std::_Swap_adl<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
PUBLIC	??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@AAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>
PUBLIC	??$swap@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z ; std::swap<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
PUBLIC	??$_Move@AAI@std@@YA$$QAIAAI@Z			; std::_Move<unsigned int &>
PUBLIC	??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>
PUBLIC	??$_Move@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z ; std::_Move<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	??_C@_0GM@IMNFDCHL@CActorInstance?3?3UpdateAdvancingP@ ; `string'
PUBLIC	??_C@_0GI@OFDOMPIB@CActorInstance?3?3UpdateAdvancingP@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@42480000
PUBLIC	__real@47afc800
PUBLIC	__real@48742400
PUBLIC	__real@491c4000
PUBLIC	__real@49742400
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	?Tracenf@@YAXPBDZZ:PROC				; Tracenf
EXTRN	?GetElapsedSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetElapsedSecond
EXTRN	?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ:PROC ; CSphereCollisionInstance::GetAttribute
EXTRN	?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z:PROC ; DetectCollisionDynamicSphereVSDynamicSphere
EXTRN	?DetectCollisionDynamicZCylinderVSDynamicZCylinder@@YA_NABUCDynamicSphereInstance@@0@Z:PROC ; DetectCollisionDynamicZCylinderVSDynamicZCylinder
EXTRN	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ:PROC ; CGraphicObjectInstance::GetPosition
EXTRN	?MovementCollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z:PROC ; CGraphicObjectInstance::MovementCollisionDynamicSphere
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	?GetMotionAttackDataPointer@CRaceMotionData@@QBEPBUSMotionAttackData@NRaceData@@XZ:PROC ; CRaceMotionData::GetMotionAttackDataPointer
EXTRN	?GetLastPosition@CPhysicsObject@@QAEXPAUD3DXVECTOR3@@@Z:PROC ; CPhysicsObject::GetLastPosition
EXTRN	?GetBoneMatrixPointer@CGrannyModelInstance@@QBEPBMH@Z:PROC ; CGrannyModelInstance::GetBoneMatrixPointer
EXTRN	?GetCompositeBoneMatrixPointer@CGrannyModelInstance@@QBEPBMH@Z:PROC ; CGrannyModelInstance::GetCompositeBoneMatrixPointer
EXTRN	?GetBoneIndexByName@CGrannyModelInstance@@QBE_NPBDPAH@Z:PROC ; CGrannyModelInstance::GetBoneIndexByName
EXTRN	?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ:PROC ; CGrannyLODController::GetModelInstance
EXTRN	?GetLocalTime@CGraphicThingInstance@@QAEMXZ:PROC ; CGraphicThingInstance::GetLocalTime
EXTRN	?GetRace@CActorInstance@@QAEKXZ:PROC		; CActorInstance::GetRace
EXTRN	?isAttacking@CActorInstance@@QAEHXZ:PROC	; CActorInstance::isAttacking
EXTRN	?GetAttackingElapsedTime@CActorInstance@@QAEMXZ:PROC ; CActorInstance::GetAttackingElapsedTime
EXTRN	?GetBlendingPosition@CActorInstance@@QAEXPAUD3DXVECTOR3@@@Z:PROC ; CActorInstance::GetBlendingPosition
EXTRN	?IsWaiting@CActorInstance@@QAEHXZ:PROC		; CActorInstance::IsWaiting
EXTRN	?IsDead@CActorInstance@@QAEHXZ:PROC		; CActorInstance::IsDead
EXTRN	?NEW_SetAtkPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CActorInstance::NEW_SetAtkPixelPosition
EXTRN	?NEW_GetCurPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ:PROC ; CActorInstance::NEW_GetCurPixelPositionRef
EXTRN	?GetRotation@CActorInstance@@QAEMXZ:PROC	; CActorInstance::GetRotation
EXTRN	?__AdjustCollisionMovement@CActorInstance@@IAEXPBVCGraphicObjectInstance@@@Z:PROC ; CActorInstance::__AdjustCollisionMovement
EXTRN	?__IsInSplashTime@CActorInstance@@IAE_NXZ:PROC	; CActorInstance::__IsInSplashTime
EXTRN	?isValidAttacking@CActorInstance@@IAEHXZ:PROC	; CActorInstance::isValidAttacking
EXTRN	?__InitializeMovement@CActorInstance@@IAEXXZ:PROC ; CActorInstance::__InitializeMovement
EXTRN	?__ProcessDataAttackSuccess@CActorInstance@@IAEXABUSAttackData@NRaceData@@AAV1@ABUD3DXVECTOR3@@IH@Z:PROC ; CActorInstance::__ProcessDataAttackSuccess
EXTRN	?__isInvisible@CActorInstance@@IAE_NXZ:PROC	; CActorInstance::__isInvisible
EXTRN	?__GetReachScale@CActorInstance@@IAEMXZ:PROC	; CActorInstance::__GetReachScale
EXTRN	?__IsFlyTargetPC@CActorInstance@@IAE_NXZ:PROC	; CActorInstance::__IsFlyTargetPC
EXTRN	?__IsSameFlyTarget@CActorInstance@@IAE_NPAV1@@Z:PROC ; CActorInstance::__IsSameFlyTarget
EXTRN	?IS_HUGE_RACE@@YA_NI@Z:PROC			; IS_HUGE_RACE
EXTRN	?IS_HUGE_RACE@@YA_NI@Z:PROC			; IS_HUGE_RACE
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT __real@49742400
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+006
CONST	ENDS
;	COMDAT __real@491c4000
CONST	SEGMENT
__real@491c4000 DD 0491c4000r			; 640000
CONST	ENDS
;	COMDAT __real@48742400
CONST	SEGMENT
__real@48742400 DD 048742400r			; 250000
CONST	ENDS
;	COMDAT __real@47afc800
CONST	SEGMENT
__real@47afc800 DD 047afc800r			; 90000
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ DB 'invalid v'
	DB	'ector<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OFDOMPIB@CActorInstance?3?3UpdateAdvancingP@
CONST	SEGMENT
??_C@_0GI@OFDOMPIB@CActorInstance?3?3UpdateAdvancingP@ DB 'CActorInstance'
	DB	'::UpdateAdvancingPointInstance - m_LODControllerVector[rInsta'
	DB	'nce.dwModelIndex=%d] is NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@IMNFDCHL@CActorInstance?3?3UpdateAdvancingP@
CONST	SEGMENT
??_C@_0GM@IMNFDCHL@CActorInstance?3?3UpdateAdvancingP@ DB 'CActorInstance'
	DB	'::UpdateAdvancingPointInstance - rInstance.dwModelIndex=%d >='
	DB	' m_LODControllerVector.size()=%d', 00H	; `string'
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$0
__unwindtable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$2
__ehfuncinfo$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0
__ehfuncinfo$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z$2
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0
__tryblocktable$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$8
__unwindtable$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z$2
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z$1
__ehfuncinfo$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z$5
__unwindtable$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1
__ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z PROC ; std::_Move<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z ENDP ; std::_Move<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAI@std@@YA$$QAIAAI@Z PROC			; std::_Move<unsigned int &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::_Move<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z PROC ; std::swap<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z ENDP ; std::swap<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@AAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@AAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@AAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$_Swap_adl@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z PROC ; std::_Swap_adl<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT

; 60   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 53   : 	_Left = _Move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi

; 52   : 	_Ty _Tmp = _Move(_Left);

  0000a	8b 32		 mov	 esi, DWORD PTR [edx]

; 53   : 	_Left = _Move(_Right);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 61   : 	swap(_Left, _Right);
; 62   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@0@Z ENDP ; std::_Swap_adl<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@@std@@YA$$QAV?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@@std@@YA$$QAV?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> > >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@@std@@YA$$QAV?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z PROC ; std::move<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z ENDP ; std::move<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@QAVCActorInstance@@M@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@AAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance * const,float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@U1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UCDynamicSphereInstance@@U1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z PROC ; std::allocator<CDynamicSphereInstance>::construct<CDynamicSphereInstance,CDynamicSphereInstance>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN3@construct:

; 601  : 		}

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??$construct@UCDynamicSphereInstance@@U1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z ENDP ; std::allocator<CDynamicSphereInstance>::construct<CDynamicSphereInstance,CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z PROC ; std::forward<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA$$QAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z ENDP ; std::forward<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Buynode@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@@Z PROC ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance * const,float> &>, COMDAT
; _this$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode0
  00009	8b d0		 mov	 edx, eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000b	8d 72 10	 lea	 esi, DWORD PTR [edx+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0000e	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00014	85 f6		 test	 esi, esi
  00016	74 0f		 je	 SHORT $LN30@Buynode
  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	89 0e		 mov	 DWORD PTR [esi], ecx
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\xtree

; 939  : 		return (_Pnode);

  00025	8b c2		 mov	 eax, edx
$LN30@Buynode:
  00027	5e		 pop	 esi

; 940  : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$_Buynode@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@@Z ENDP ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance * const,float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@U1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UCDynamicSphereInstance@@U1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$construct@UCDynamicSphereInstance@@U1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@UCDynamicSphereInstance@@@std@@YA$$QAUCDynamicSphereInstance@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UCDynamicSphereInstance@@@std@@YA$$QAUCDynamicSphereInstance@@AAU1@@Z PROC ; std::forward<CDynamicSphereInstance>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UCDynamicSphereInstance@@@std@@YA$$QAUCDynamicSphereInstance@@AAU1@@Z ENDP ; std::forward<CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_or_move<std::integral_constant<bool,0>,std::integral_constant<bool,1>,std::integral_constant<bool,0>,int>, COMDAT
; _this$ = ecx

; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 604  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance * const,float> &>

; 1952 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 14 00	 ret	 20			; 00000014H
??$_Copy_or_move@U?$integral_constant@_N$0A@@std@@U?$integral_constant@_N$00@2@U12@H@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@U?$integral_constant@_N$0A@@1@U?$integral_constant@_N$00@1@1H@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_or_move<std::integral_constant<bool,0>,std::integral_constant<bool,1>,std::integral_constant<bool,0>,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000d	50		 push	 eax
  0000e	ff 30		 push	 DWORD PTR [eax]
  00010	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00019	ff 76 04	 push	 DWORD PTR [esi+4]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
  00024	5e		 pop	 esi

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@U1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UCDynamicSphereInstance@@U1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??$construct@UCDynamicSphereInstance@@U1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UCDynamicSphereInstance@@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UCDynamicSphereInstance@@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@@Z PROC ; std::allocator<CDynamicSphereInstance>::destroy<CDynamicSphereInstance>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UCDynamicSphereInstance@@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@@Z ENDP ; std::allocator<CDynamicSphereInstance>::destroy<CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00028	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 f6		 test	 esi, esi
  00034	74 35		 je	 SHORT $LN3@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00036	8b 7d 0c	 mov	 edi, DWORD PTR _<_Args_0>$[ebp]
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  00039	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	89 06		 mov	 DWORD PTR [esi], eax
; File a:\vs\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 570  : 		this->_Mysize = 0;

  00047	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  0004e	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00053	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00056	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00059	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 54   : 	_Right = _Move(_Tmp);

  0005c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 52   : 	_Ty _Tmp = _Move(_Left);

  0005f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 53   : 	_Left = _Move(_Right);

  00062	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 	_Right = _Move(_Tmp);

  00068	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
$LN3@construct:
; File a:\vs\vc\include\xmemory0

; 601  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:
; File a:\vs\vc\include\xmemory0

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Newroot$ = 12						; size = 4
__Wherenode$ = 12					; size = 4
__Movefl$ = 16						; size = 1
??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))

  00030	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00033	8b 3e		 mov	 edi, DWORD PTR [esi]
  00035	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00039	75 4e		 jne	 SHORT $LN8@Copy_nodes

; 604  : 		return ((reference)_Pnode->_Myval);

  0003b	83 c0 10	 add	 eax, 16			; 00000010H

; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();
; 774  : 		}
; 775  : 
; 776  : 	~_Tree_alloc() _NOEXCEPT
; 777  : 		{	// destroy head node
; 778  : 		_Freeheadnode(this->_Myhead);
; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));
; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));
; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));
; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());
; 870  : 		}
; 871  : 	};
; 872  : 
; 873  : 		// TEMPLATE CLASS _Tree_buy
; 874  : template<class _Ty,
; 875  : 	class _Alloc>
; 876  : 	class _Tree_buy
; 877  : 		: public _Tree_alloc<!is_empty<_Alloc>::value,
; 878  : 			_Tree_base_types<_Ty, _Alloc> >
; 879  : 	{	// base class for tree to hold buynode/freenode functions
; 880  : public:
; 881  : 	typedef _Tree_alloc<!is_empty<_Alloc>::value,
; 882  : 		_Tree_base_types<_Ty, _Alloc> > _Mybase;
; 883  : 	typedef typename _Mybase::_Alty _Alty;
; 884  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	_Tree_buy(const _Alloc& _Al = _Alloc())
; 888  : 		: _Mybase(_Al)
; 889  : 		{	// construct from allocator
; 890  : 		}
; 891  : 
; 892  : 	_Nodeptr _Buynode0()
; 893  : 		{	// allocate a non-value node
; 894  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 895  : 
; 896  : 		_TRY_BEGIN
; 897  : 		this->_Getal().construct(
; 898  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);
; 899  : 		this->_Getal().construct(
; 900  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);
; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);
; 903  : 		_CATCH_ALL
; 904  : 		this->_Getal().deallocate(_Pnode, 1);
; 905  : 		_RERAISE;
; 906  : 		_CATCH_END
; 907  : 
; 908  : 		return (_Pnode);
; 909  : 		}
; 910  : 
; 911  : 	void _Freenode0(_Nodeptr _Pnode)
; 912  : 		{	// free non-value node using current allocator
; 913  : 		this->_Getal().destroy(
; 914  : 			_STD addressof(this->_Left(_Pnode)));
; 915  : 		this->_Getal().destroy(
; 916  : 			_STD addressof(this->_Parent(_Pnode)));
; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Right(_Pnode)));
; 919  : 		this->_Getal().deallocate(_Pnode, 1);
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)
; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();
; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;
; 928  : 		this->_Isnil(_Pnode) = false;
; 929  : 
; 930  : 		_TRY_BEGIN
; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);
; 934  : 		_CATCH_ALL
; 935  : 		_Freenode0(_Pnode);
; 936  : 		_RERAISE;
; 937  : 		_CATCH_END
; 938  : 
; 939  : 		return (_Pnode);
; 940  : 		}
; 941  : 
; 942  : 	};
; 943  : 
; 944  : 		// TEMPLATE CLASS _Tree_comp
; 945  : template<bool _Pr_has_storage,
; 946  : 	class _Traits>
; 947  : 	class _Tree_comp
; 948  : 		: public _Tree_buy<typename _Traits::value_type,
; 949  : 			typename _Traits::allocator_type>
; 950  : 	{	// base class for _Tree to hold ordering predicate with storage
; 951  : public:
; 952  : 	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
; 953  : 	typedef _Tree_buy<typename _Traits::value_type,
; 954  : 		typename _Traits::allocator_type> _Mybase;
; 955  : 
; 956  : 	typedef typename _Traits::allocator_type allocator_type;
; 957  : 	typedef typename _Traits::key_compare key_compare;
; 958  : 
; 959  : 	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
; 960  : 		: _Mybase(_Al), comp(_Parg)
; 961  : 		{	// construct ordering predicate
; 962  : 		}
; 963  : 
; 964  : 	key_compare& _Getcomp()
; 965  : 		{	// get reference to ordering predicate
; 966  : 		return (comp);
; 967  : 		}
; 968  : 
; 969  : 	const key_compare& _Getcomp() const
; 970  : 		{	// get reference to ordering predicate
; 971  : 		return (comp);
; 972  : 		}
; 973  : 
; 974  : 	void _Setcomp(const key_compare& _Right)
; 975  : 		{	// copy ordering predicate
; 976  : 		comp = _Right;
; 977  : 		}
; 978  : 
; 979  : 	void _Swapcomp(key_compare& _Right)
; 980  : 		{	// swap ordering predicate
; 981  : 		_Swap_adl(comp, _Right);
; 982  : 		}
; 983  : 
; 984  : 	key_compare comp;
; 985  : 	};
; 986  : 
; 987  : template<class _Traits>
; 988  : 	class _Tree_comp<false, _Traits>
; 989  : 		: public _Tree_buy<typename _Traits::value_type,
; 990  : 			typename _Traits::allocator_type>
; 991  : 	{	// base class for _Tree to hold ordering predicate with no storage
; 992  : public:
; 993  : 	typedef _Tree_comp<false, _Traits> _Myt;
; 994  : 	typedef _Tree_buy<typename _Traits::value_type,
; 995  : 		typename _Traits::allocator_type> _Mybase;
; 996  : 
; 997  : 	typedef typename _Traits::allocator_type allocator_type;
; 998  : 	typedef typename _Traits::key_compare key_compare;
; 999  : 
; 1000 : 	_Tree_comp(const key_compare&, const allocator_type& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct ordering predicate
; 1003 : 		}
; 1004 : 
; 1005 : 	key_compare _Getcomp() const
; 1006 : 		{	// get ordering predicate
; 1007 : 		return (key_compare());
; 1008 : 		}
; 1009 : 
; 1010 : 	void _Setcomp(const key_compare&)
; 1011 : 		{	// copy ordering predicate
; 1012 : 		}
; 1013 : 
; 1014 : 	void _Swapcomp(const key_compare&)
; 1015 : 		{	// swap ordering predicate
; 1016 : 		}
; 1017 : 	};
; 1018 : 
; 1019 : 		// TEMPLATE CLASS _Tree
; 1020 : template<class _Traits>
; 1021 : 	class _Tree
; 1022 : 		: public _Tree_comp<
; 1023 : 			!is_empty<typename _Traits::key_compare>::value, _Traits>
; 1024 : 	{	// ordered red-black tree for [multi_]{map set}
; 1025 : public:
; 1026 : 	typedef _Tree<_Traits> _Myt;
; 1027 : 	typedef _Tree_comp<
; 1028 : 		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;
; 1029 : 
; 1030 : 	typedef typename _Traits::key_type key_type;
; 1031 : 	typedef typename _Traits::value_compare value_compare;
; 1032 : 	enum
; 1033 : 		{	// get multi parameter
; 1034 : 		_Multi = _Traits::_Multi};
; 1035 : 
; 1036 : 	typedef typename _Mybase::_Node _Node;
; 1037 : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 1038 : 	typedef typename _Mybase::_Alty _Alty;
; 1039 : 
; 1040 : 	typedef typename _Mybase::key_compare key_compare;
; 1041 : 	typedef typename _Mybase::allocator_type allocator_type;
; 1042 : 
; 1043 : 	typedef typename _Mybase::value_type value_type;
; 1044 : 	typedef typename _Mybase::size_type size_type;
; 1045 : 	typedef typename _Mybase::difference_type difference_type;
; 1046 : 	typedef typename _Mybase::pointer pointer;
; 1047 : 	typedef typename _Mybase::const_pointer const_pointer;
; 1048 : 	typedef typename _Mybase::reference reference;
; 1049 : 	typedef typename _Mybase::const_reference const_reference;
; 1050 : 
; 1051 : 	typedef typename _Mybase::const_iterator const_iterator;
; 1052 : 	typedef typename _If<is_same<key_type, value_type>::value,
; 1053 : 		typename _Mybase::const_iterator,
; 1054 : 		typename _Mybase::iterator>::type iterator;
; 1055 : 
; 1056 : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 1057 : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 1058 : 
; 1059 : 	typedef pair<iterator, bool> _Pairib;
; 1060 : 	typedef pair<iterator, iterator> _Pairii;
; 1061 : 	typedef pair<const_iterator, const_iterator> _Paircc;
; 1062 : 
; 1063 : 	_Tree(const key_compare& _Parg,
; 1064 : 		const allocator_type& _Al)
; 1065 : 		: _Mybase(_Parg, _Al)
; 1066 : 		{	// construct empty tree
; 1067 : 		}
; 1068 : 
; 1069 : 	_Tree(const value_type *_First, const value_type *_Last,
; 1070 : 		const key_compare& _Parg, const allocator_type& _Al)
; 1071 : 		: _Mybase(_Parg, _Al)
; 1072 : 		{	// construct tree from [_First, _Last) array
; 1073 : 		_TRY_BEGIN
; 1074 : 		insert(_First, _Last);
; 1075 : 		_CATCH_ALL
; 1076 : 		_Tidy();
; 1077 : 		_RERAISE;
; 1078 : 		_CATCH_END
; 1079 : 		}
; 1080 : 
; 1081 : 	_Tree(const _Myt& _Right, const allocator_type& _Al)
; 1082 : 		: _Mybase(_Right.key_comp(), _Al)
; 1083 : 		{	// construct tree by copying _Right, allocator
; 1084 : 		_TRY_BEGIN
; 1085 : 		_Copy(_Right, false_type());
; 1086 : 		_CATCH_ALL
; 1087 : 		_Tidy();
; 1088 : 		_RERAISE;
; 1089 : 		_CATCH_END
; 1090 : 		}
; 1091 : 
; 1092 : 	_Tree(_Myt&& _Right)
; 1093 : 		: _Mybase(_Right.key_comp(), _Right._Getal())
; 1094 : 		{	// construct tree by moving _Right
; 1095 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1096 : 		}
; 1097 : 
; 1098 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1099 : 		: _Mybase(_Right.key_comp(), _Al)
; 1100 : 		{	// construct tree by moving _Right, allocator
; 1101 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1102 : 		}
; 1103 : 
; 1104 : 	_Myt& operator=(_Myt&& _Right)
; 1105 : 		{	// assign by moving _Right
; 1106 : 		if (this != &_Right)
; 1107 : 			{	// different, move it
; 1108 : 			clear();
; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Change_alloc(_Right._Getal());
; 1112 : 
; 1113 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1114 : 			}
; 1115 : 		return (*this);
; 1116 : 		}
; 1117 : 
; 1118 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1119 : 		{	// move from _Right, stealing its contents
; 1120 : 		this->_Swap_all(_Right);
; 1121 : 		this->_Swapcomp(_Right._Getcomp());
; 1122 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1123 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1127 : 		{	// move from _Right, possibly moving its contents
; 1128 : 		if (get_allocator() == _Right.get_allocator())
; 1129 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1130 : 		else
; 1131 : 			_Copy(_Right, true_type());
; 1132 : 		}
; 1133 : 
; 1134 : 	void _Assign_rv(_Myt&& _Right)
; 1135 : 		{	// assign by moving _Right
; 1136 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1137 : 			typename _Alty::propagate_on_container_move_assignment());
; 1138 : 		}
; 1139 : 
; 1140 : 
; 1141 : 	_Pairib insert(value_type&& _Val)
; 1142 : 		{	// try to insert node with value _Val, favoring right side
; 1143 : 		return (_Insert_nohint(false,
; 1144 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1145 : 		}
; 1146 : 
; 1147 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1148 : 		{	// try to insert node with value _Val using _Where as a hint
; 1149 : 		return (_Insert_hint(_Where,
; 1150 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1151 : 		}
; 1152 : 
; 1153 : 	template<class _Valty>
; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));
; 1161 : 		}
; 1162 : 
; 1163 : 	template<class _Valty>
; 1164 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1165 : 			iterator>::type
; 1166 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1167 : 		{	// try to insert node with value _Val using _Where as a hint
; 1168 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1169 : 		return (_Insert_hint(_Where,
; 1170 : 			this->_Myval(_Newnode), _Newnode));
; 1171 : 		}
; 1172 : 
; 1173 : 	template<class... _Valty>
; 1174 : 		_Pairib emplace(_Valty&&... _Val)
; 1175 : 		{	// try to insert value_type(_Val...), favoring right side
; 1176 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1177 : 		return (_Insert_nohint(false,
; 1178 : 			this->_Myval(_Newnode), _Newnode));
; 1179 : 		}
; 1180 : 
; 1181 : 	template<class... _Valty>
; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));
; 1187 : 		}
; 1188 : 
; 1189 : 
; 1190 : 	~_Tree() _NOEXCEPT
; 1191 : 		{	// destroy tree
; 1192 : 		_Tidy();
; 1193 : 		}
; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));

  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance * const,float> &>

; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);

  00044	8b 4d 08	 mov	 ecx, DWORD PTR __Rootnode$[ebp]
  00047	8b d8		 mov	 ebx, eax
  00049	8b 45 0c	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN

  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00056	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00059	88 43 0c	 mov	 BYTE PTR [ebx+12], al

; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);

  0005c	ff 75 10	 push	 DWORD PTR __Movefl$[ebp]
  0005f	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00063	53		 push	 ebx
  00064	ff 31		 push	 DWORD PTR [ecx]
  00066	0f 45 fb	 cmovne	 edi, ebx
  00069	8b ce		 mov	 ecx, esi
  0006b	89 7d 0c	 mov	 DWORD PTR __Newroot$[ebp], edi
  0006e	e8 00 00 00 00	 call	 ??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
  00073	89 03		 mov	 DWORD PTR [ebx], eax

; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);

  00075	8b ce		 mov	 ecx, esi
  00077	ff 75 10	 push	 DWORD PTR __Movefl$[ebp]
  0007a	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007d	53		 push	 ebx
  0007e	ff 70 08	 push	 DWORD PTR [eax+8]
  00081	e8 00 00 00 00	 call	 ??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
  00086	89 43 08	 mov	 DWORD PTR [ebx+8], eax
$LN8@Copy_nodes:

; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree

  00089	8b c7		 mov	 eax, edi

; 2001 : 		}

  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z$0:

; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out

  0009f	ff 75 0c	 push	 DWORD PTR __Newroot$[ebp]
  000a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Erase

; 1996 : 			_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN30@Copy_nodes:
$LN29@Copy_nodes:
  000b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
$T1 = 12						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000d	50		 push	 eax
  0000e	ff 30		 push	 DWORD PTR [eax]
  00010	8d 45 0c	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00019	ff 76 04	 push	 DWORD PTR [esi+4]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
  00024	5e		 pop	 esi

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::allocator<CDynamicSphereInstance>,CDynamicSphereInstance>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 26		 je	 SHORT $LN4@Uninit_mov
$LL6@Uninit_mov:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00011	85 c0		 test	 eax, eax
  00013	74 18		 je	 SHORT $LN24@Uninit_mov
  00015	f3 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [ecx]
  00019	f3 0f 7f 00	 movdqu	 XMMWORD PTR [eax], xmm0
  0001d	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  00022	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  00027	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0002a	89 50 18	 mov	 DWORD PTR [eax+24], edx
$LN24@Uninit_mov:
; File a:\vs\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00030	83 c0 1c	 add	 eax, 28			; 0000001cH
  00033	3b ce		 cmp	 ecx, esi
  00035	75 da		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:
  00037	5e		 pop	 esi

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);
; 451  : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::allocator<CDynamicSphereInstance>,CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z PROC ; std::_Val_type<CDynamicSphereInstance *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z ENDP ; std::_Val_type<CDynamicSphereInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UCDynamicSphereInstance@@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UCDynamicSphereInstance@@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@@Z PROC ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::destroy<CDynamicSphereInstance>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@UCDynamicSphereInstance@@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::destroy<CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PAU21@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PAU21@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Buynode_if_nil<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &>, COMDAT
; _this$ = ecx

; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1639 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PAU21@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Buynode_if_nil<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00028	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 f6		 test	 esi, esi
  00034	74 35		 je	 SHORT $LN7@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00036	8b 7d 10	 mov	 edi, DWORD PTR _<_Args_0>$[ebp]
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  00039	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	89 06		 mov	 DWORD PTR [esi], eax
; File a:\vs\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 570  : 		this->_Mysize = 0;

  00047	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  0004e	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00053	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00056	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00059	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 54   : 	_Right = _Move(_Tmp);

  0005c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 52   : 	_Ty _Tmp = _Move(_Left);

  0005f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 53   : 	_Left = _Move(_Right);

  00062	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 	_Right = _Move(_Tmp);

  00068	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
$LN7@construct:
; File a:\vs\vc\include\xmemory0

; 724  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@1@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@AAU?$pair@QAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@AAU?$pair@QAVCActorInstance@@M@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Buynode_if_nil<std::pair<CActorInstance * const,float> &>, COMDAT
; _this$ = ecx

; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1639 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@QAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@AAU?$pair@QAVCActorInstance@@M@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Buynode_if_nil<std::pair<CActorInstance * const,float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:
; File a:\vs\vc\include\xmemory0

; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 26		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00012	77 19		 ja	 SHORT $LN1@Allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 02	 shl	 eax, 2
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002d	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Movefl$ = 12						; size = 1
??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy<std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 1927 : 		void _Copy(const _Myt& _Right,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]

; 1927 : 		void _Copy(const _Myt& _Right,

  00009	8b d9		 mov	 ebx, ecx

; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);

  0000b	ff 75 0c	 push	 DWORD PTR __Movefl$[ebp]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 33		 mov	 esi, DWORD PTR [ebx]

; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);

  00012	56		 push	 esi
  00013	ff 70 04	 push	 DWORD PTR [eax+4]
  00016	e8 00 00 00 00	 call	 ??$_Copy_nodes@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PAU21@0U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy_nodes<std::integral_constant<bool,0> >
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0001e	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1931 : 		this->_Mysize = _Right.size();

  00020	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00023	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00026	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 1932 : 		if (!this->_Isnil(_Root()))

  00029	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002d	75 37		 jne	 SHORT $LN2@Copy

; 584  : 		return ((char&)_Pnode->_Isnil);

  0002f	8b 01		 mov	 eax, DWORD PTR [ecx]

; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00031	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00035	75 0a		 jne	 SHORT $LN25@Copy
$LL26@Copy:

; 617  : 			_Pnode = _Left(_Pnode);

  00037	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00039	8b 01		 mov	 eax, DWORD PTR [ecx]

; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0003b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0003f	74 f6		 je	 SHORT $LL26@Copy
$LN25@Copy:

; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());

  00041	89 0a		 mov	 DWORD PTR [edx], ecx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00043	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1935 : 			_Rmost() = this->_Max(_Root());

  00045	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 584  : 		return ((char&)_Pnode->_Isnil);

  00048	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  0004b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004f	75 0b		 jne	 SHORT $LN43@Copy
$LL44@Copy:

; 610  : 			_Pnode = _Right(_Pnode);

  00051	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00053	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00056	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0005a	74 f5		 je	 SHORT $LL44@Copy
$LN43@Copy:
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 1935 : 			_Rmost() = this->_Max(_Root());

  0005e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00061	5b		 pop	 ebx

; 1941 : 			}
; 1942 : 		}

  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
$LN2@Copy:

; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;

  00066	89 12		 mov	 DWORD PTR [edx], edx

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00068	8b 03		 mov	 eax, DWORD PTR [ebx]
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx

; 1940 : 			_Rmost() = this->_Myhead;

  0006d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1941 : 			}
; 1942 : 		}

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy<std::integral_constant<bool,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000d	50		 push	 eax
  0000e	ff 30		 push	 DWORD PTR [eax]
  00010	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00019	ff 76 04	 push	 DWORD PTR [esi+4]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00021	83 c4 04	 add	 esp, 4
  00024	5e		 pop	 esi

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??$destroy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::destroy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?0U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z PROC ; std::allocator<std::pair<CActorInstance * const,float> >::allocator<std::pair<CActorInstance * const,float> ><std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >, COMDAT
; _this$ = ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z ENDP ; std::allocator<std::pair<CActorInstance * const,float> >::allocator<std::pair<CActorInstance * const,float> ><std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::destroy<std::pair<CActorInstance * const,float> >, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::destroy<std::pair<CActorInstance * const,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUCDynamicSphereInstance@@PAU1@@std@@YAAAPAUCDynamicSphereInstance@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUCDynamicSphereInstance@@PAU1@@std@@YAAAPAUCDynamicSphereInstance@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<CDynamicSphereInstance *,CDynamicSphereInstance *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUCDynamicSphereInstance@@PAU1@@std@@YAAAPAUCDynamicSphereInstance@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<CDynamicSphereInstance *,CDynamicSphereInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::allocator<CDynamicSphereInstance>,CDynamicSphereInstance>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 485  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z PROC ; std::_Unchecked<CDynamicSphereInstance *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@PAU1@@Z ENDP ; std::_Unchecked<CDynamicSphereInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@UCDynamicSphereInstance@@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UCDynamicSphereInstance@@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::destroy<CDynamicSphereInstance>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@UCDynamicSphereInstance@@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::destroy<CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z PROC ; std::allocator<CDynamicSphereInstance>::construct<CDynamicSphereInstance,CDynamicSphereInstance &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN3@construct:

; 601  : 		}

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z ENDP ; std::allocator<CDynamicSphereInstance>::construct<CDynamicSphereInstance,CDynamicSphereInstance &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > &,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > > &,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_at<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>, COMDAT
; _this$ = ecx

; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)

  00008	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000b	3d 48 92 24 09	 cmp	 eax, 153391688		; 09249248H
  00010	0f 83 de 01 00
	00		 jae	 $LN469@Insert_at

; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;

  00016	8b 5d 18	 mov	 ebx, DWORD PTR __Node$[ebp]
  00019	40		 inc	 eax
  0001a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00020	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)

  00023	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00025	3b c1		 cmp	 eax, ecx
  00027	75 0e		 jne	 SHORT $LN16@Insert_at

; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;

  00029	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0002c	8b 07		 mov	 eax, DWORD PTR [edi]

; 1850 : 			_Lmost() = _Newnode;

  0002e	89 18		 mov	 DWORD PTR [eax], ebx

; 1851 : 			_Rmost() = _Newnode;

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
  00032	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00035	eb 1f		 jmp	 SHORT $LN11@Insert_at
$LN16@Insert_at:

; 1852 : 			}
; 1853 : 		else if (_Addleft)

  00037	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003b	74 0c		 je	 SHORT $LN14@Insert_at

; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;

  0003d	89 18		 mov	 DWORD PTR [eax], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0003f	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1856 : 			if (_Wherenode == _Lmost())

  00041	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00043	75 11		 jne	 SHORT $LN11@Insert_at

; 1857 : 				_Lmost() = _Newnode;

  00045	89 19		 mov	 DWORD PTR [ecx], ebx

; 1858 : 			}
; 1859 : 		else

  00047	eb 0d		 jmp	 SHORT $LN11@Insert_at
$LN14@Insert_at:

; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;

  00049	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0004c	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1862 : 			if (_Wherenode == _Rmost())

  0004e	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00051	75 03		 jne	 SHORT $LN11@Insert_at

; 1863 : 				_Rmost() = _Newnode;

  00053	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00056	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00059	8b c3		 mov	 eax, ebx
  0005b	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0005f	0f 85 7a 01 00
	00		 jne	 $LN9@Insert_at
$LL10@Insert_at:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00068	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]

; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  0006b	8b 16		 mov	 edx, DWORD PTR [esi]
  0006d	3b ca		 cmp	 ecx, edx
  0006f	0f 85 ab 00 00
	00		 jne	 $LN8@Insert_at

; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00075	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)

  00078	80 7a 0c 00	 cmp	 BYTE PTR [edx+12], 0
  0007c	0f 84 a4 00 00
	00		 je	 $LN468@Insert_at

; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  00082	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00085	75 3a		 jne	 SHORT $LN200@Insert_at

; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);

  00087	8b c1		 mov	 eax, ecx

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00089	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0008c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0008e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00091	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00093	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00097	75 03		 jne	 SHORT $LN199@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00099	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN199@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0009c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000a2	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  000a4	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000a7	75 05		 jne	 SHORT $LN198@Insert_at

; 2136 : 			_Root() = _Pnode;

  000a9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000ac	eb 0e		 jmp	 SHORT $LN195@Insert_at
$LN198@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000b3	75 04		 jne	 SHORT $LN196@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000b5	89 11		 mov	 DWORD PTR [ecx], edx

; 2139 : 		else

  000b7	eb 03		 jmp	 SHORT $LN195@Insert_at
$LN196@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000b9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN195@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  000bc	89 02		 mov	 DWORD PTR [edx], eax

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  000be	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN200@Insert_at:

; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up

  000c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c4	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;

  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000ce	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  000d8	8b 32		 mov	 esi, DWORD PTR [edx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  000da	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dd	89 0a		 mov	 DWORD PTR [edx], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  000df	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  000e2	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e6	75 03		 jne	 SHORT $LN262@Insert_at

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  000e8	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN262@Insert_at:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000ee	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000f1	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  000f3	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000f6	75 0b		 jne	 SHORT $LN261@Insert_at

; 2166 : 			_Root() = _Pnode;

  000f8	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  000fb	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  000fe	e9 cc 00 00 00	 jmp	 $LN467@Insert_at
$LN261@Insert_at:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00103	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00106	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00109	75 0b		 jne	 SHORT $LN259@Insert_at

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0010b	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0010e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  00111	e9 b9 00 00 00	 jmp	 $LN467@Insert_at
$LN259@Insert_at:

; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00116	89 31		 mov	 DWORD PTR [ecx], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00118	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  0011b	e9 af 00 00 00	 jmp	 $LN467@Insert_at
$LN8@Insert_at:

; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)

  00120	80 7a 0c 00	 cmp	 BYTE PTR [edx+12], 0
  00124	75 1d		 jne	 SHORT $LN3@Insert_at
$LN468@Insert_at:

; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00126	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1902 : 					this->_Color(_Wherenode) = this->_Black;

  0012a	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1

; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;

  0012e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00131	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00134	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1906 : 					}
; 1907 : 				else

  0013e	e9 8f 00 00 00	 jmp	 $LN405@Insert_at
$LN3@Insert_at:

; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00143	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00145	75 3c		 jne	 SHORT $LN342@Insert_at

; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);

  00147	8b c1		 mov	 eax, ecx

; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00149	8b 10		 mov	 edx, DWORD PTR [eax]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0014b	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0014e	89 08		 mov	 DWORD PTR [eax], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00150	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00153	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00157	75 03		 jne	 SHORT $LN341@Insert_at

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00159	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN341@Insert_at:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0015c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00162	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00164	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00167	75 05		 jne	 SHORT $LN340@Insert_at

; 2166 : 			_Root() = _Pnode;

  00169	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  0016c	eb 0f		 jmp	 SHORT $LN337@Insert_at
$LN340@Insert_at:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0016e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00171	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00174	75 05		 jne	 SHORT $LN338@Insert_at

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00176	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 2169 : 		else

  00179	eb 02		 jmp	 SHORT $LN337@Insert_at
$LN338@Insert_at:

; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0017b	89 11		 mov	 DWORD PTR [ecx], edx
$LN337@Insert_at:

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0017d	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00180	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN342@Insert_at:

; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up

  00183	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00186	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;

  0018a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00190	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  00194	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00197	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0019a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0019d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  001a2	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  001a4	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001a8	75 03		 jne	 SHORT $LN404@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  001aa	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN404@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  001ad	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001b0	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  001b3	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  001b5	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b8	75 05		 jne	 SHORT $LN403@Insert_at

; 2136 : 			_Root() = _Pnode;

  001ba	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  001bd	eb 0e		 jmp	 SHORT $LN400@Insert_at
$LN403@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  001bf	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  001c2	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001c4	75 04		 jne	 SHORT $LN401@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  001c6	89 31		 mov	 DWORD PTR [ecx], esi

; 2139 : 		else

  001c8	eb 03		 jmp	 SHORT $LN400@Insert_at
$LN401@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  001ca	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN400@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  001cd	89 16		 mov	 DWORD PTR [esi], edx
$LN467@Insert_at:

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  001cf	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN405@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  001d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d5	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001d9	0f 84 86 fe ff
	ff		 je	 $LL10@Insert_at
$LN9@Insert_at:

; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  001df	8b 07		 mov	 eax, DWORD PTR [edi]
  001e1	5f		 pop	 edi
  001e2	5e		 pop	 esi
  001e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 44   : 		{	// construct with node pointer _Pnode

  001ea	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ed	89 18		 mov	 DWORD PTR [eax], ebx
  001ef	5b		 pop	 ebx

; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}

  001f0	5d		 pop	 ebp
  001f1	c2 14 00	 ret	 20			; 00000014H
$LN469@Insert_at:

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  001f4	8b 7d 18	 mov	 edi, DWORD PTR __Node$[ebp]

; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  001f7	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  001fa	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  001fd	50		 push	 eax
  001fe	ff 30		 push	 DWORD PTR [eax]
  00200	8d 45 0c	 lea	 eax, DWORD PTR $T1[ebp]
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00209	ff 77 14	 push	 DWORD PTR [edi+20]
  0020c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00211	57		 push	 edi
  00212	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00217	83 c4 08	 add	 esp, 8
; File a:\vs\vc\include\xtree

; 1839 : 			_Xlength_error("map/set<T> too long");

  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0021f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN471@Insert_at:
$LN466@Insert_at:
  00224	cc		 int	 3
??$_Insert_at@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_at<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00028	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	85 f6		 test	 esi, esi
  00034	74 35		 je	 SHORT $LN11@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00036	8b 7d 0c	 mov	 edi, DWORD PTR _<_Args_0>$[ebp]
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  00039	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	89 06		 mov	 DWORD PTR [esi], eax
; File a:\vs\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 570  : 		this->_Mysize = 0;

  00047	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  0004e	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00053	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00056	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00059	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 54   : 	_Right = _Move(_Tmp);

  0005c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 52   : 	_Ty _Tmp = _Move(_Left);

  0005f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 53   : 	_Left = _Move(_Right);

  00062	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00065	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 54   : 	_Right = _Move(_Tmp);

  00068	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
$LN11@construct:
; File a:\vs\vc\include\xmemory0

; 873  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::construct<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > &,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > > &,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_NX@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >,bool,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_at<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT
; _this$ = ecx

; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)

  00007	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000a	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  0000f	0f 83 df 01 00
	00		 jae	 $LN396@Insert_at

; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;

  00015	8b 5d 18	 mov	 ebx, DWORD PTR __Node$[ebp]
  00018	40		 inc	 eax
  00019	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001c	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0001f	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)

  00022	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00024	3b c1		 cmp	 eax, ecx
  00026	75 0e		 jne	 SHORT $LN16@Insert_at

; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;

  00028	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0002b	8b 07		 mov	 eax, DWORD PTR [edi]

; 1850 : 			_Lmost() = _Newnode;

  0002d	89 18		 mov	 DWORD PTR [eax], ebx

; 1851 : 			_Rmost() = _Newnode;

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
  00031	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00034	eb 1f		 jmp	 SHORT $LN11@Insert_at
$LN16@Insert_at:

; 1852 : 			}
; 1853 : 		else if (_Addleft)

  00036	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003a	74 0c		 je	 SHORT $LN14@Insert_at

; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;

  0003c	89 18		 mov	 DWORD PTR [eax], ebx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0003e	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1856 : 			if (_Wherenode == _Lmost())

  00040	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00042	75 11		 jne	 SHORT $LN11@Insert_at

; 1857 : 				_Lmost() = _Newnode;

  00044	89 19		 mov	 DWORD PTR [ecx], ebx

; 1858 : 			}
; 1859 : 		else

  00046	eb 0d		 jmp	 SHORT $LN11@Insert_at
$LN14@Insert_at:

; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;

  00048	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0004b	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1862 : 			if (_Wherenode == _Rmost())

  0004d	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00050	75 03		 jne	 SHORT $LN11@Insert_at

; 1863 : 				_Rmost() = _Newnode;

  00052	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00055	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00058	8b c3		 mov	 eax, ebx
  0005a	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0005e	0f 85 7c 01 00
	00		 jne	 $LN9@Insert_at
  00064	56		 push	 esi
$LL10@Insert_at:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00068	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]

; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  0006b	8b 16		 mov	 edx, DWORD PTR [esi]
  0006d	3b ca		 cmp	 ecx, edx
  0006f	0f 85 ab 00 00
	00		 jne	 $LN8@Insert_at

; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00075	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)

  00078	80 7a 0c 00	 cmp	 BYTE PTR [edx+12], 0
  0007c	0f 84 a4 00 00
	00		 je	 $LN395@Insert_at

; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  00082	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00085	75 3a		 jne	 SHORT $LN127@Insert_at

; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);

  00087	8b c1		 mov	 eax, ecx

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00089	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0008c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0008e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00091	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00093	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00097	75 03		 jne	 SHORT $LN126@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00099	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN126@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0009c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000a2	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  000a4	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000a7	75 05		 jne	 SHORT $LN125@Insert_at

; 2136 : 			_Root() = _Pnode;

  000a9	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000ac	eb 0e		 jmp	 SHORT $LN122@Insert_at
$LN125@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000b1	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000b3	75 04		 jne	 SHORT $LN123@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000b5	89 11		 mov	 DWORD PTR [ecx], edx

; 2139 : 		else

  000b7	eb 03		 jmp	 SHORT $LN122@Insert_at
$LN123@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000b9	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN122@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  000bc	89 02		 mov	 DWORD PTR [edx], eax

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  000be	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN127@Insert_at:

; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up

  000c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c4	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;

  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000ce	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  000d8	8b 32		 mov	 esi, DWORD PTR [edx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  000da	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dd	89 0a		 mov	 DWORD PTR [edx], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  000df	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  000e2	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e6	75 03		 jne	 SHORT $LN189@Insert_at

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  000e8	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN189@Insert_at:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000ee	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000f1	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  000f3	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000f6	75 0b		 jne	 SHORT $LN188@Insert_at

; 2166 : 			_Root() = _Pnode;

  000f8	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  000fb	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  000fe	e9 cc 00 00 00	 jmp	 $LN394@Insert_at
$LN188@Insert_at:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00103	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00106	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00109	75 0b		 jne	 SHORT $LN186@Insert_at

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0010b	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0010e	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  00111	e9 b9 00 00 00	 jmp	 $LN394@Insert_at
$LN186@Insert_at:

; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00116	89 31		 mov	 DWORD PTR [ecx], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00118	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1893 : 					}
; 1894 : 				}
; 1895 : 			else

  0011b	e9 af 00 00 00	 jmp	 $LN394@Insert_at
$LN8@Insert_at:

; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)

  00120	80 7a 0c 00	 cmp	 BYTE PTR [edx+12], 0
  00124	75 1d		 jne	 SHORT $LN3@Insert_at
$LN395@Insert_at:

; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00126	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1902 : 					this->_Color(_Wherenode) = this->_Black;

  0012a	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1

; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;

  0012e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00131	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00134	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1906 : 					}
; 1907 : 				else

  0013e	e9 8f 00 00 00	 jmp	 $LN332@Insert_at
$LN3@Insert_at:

; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00143	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00145	75 3c		 jne	 SHORT $LN269@Insert_at

; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);

  00147	8b c1		 mov	 eax, ecx

; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00149	8b 10		 mov	 edx, DWORD PTR [eax]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0014b	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0014e	89 08		 mov	 DWORD PTR [eax], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00150	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00153	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00157	75 03		 jne	 SHORT $LN268@Insert_at

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00159	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN268@Insert_at:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0015c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00162	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00164	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00167	75 05		 jne	 SHORT $LN267@Insert_at

; 2166 : 			_Root() = _Pnode;

  00169	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  0016c	eb 0f		 jmp	 SHORT $LN264@Insert_at
$LN267@Insert_at:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0016e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00171	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00174	75 05		 jne	 SHORT $LN265@Insert_at

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00176	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 2169 : 		else

  00179	eb 02		 jmp	 SHORT $LN264@Insert_at
$LN265@Insert_at:

; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0017b	89 11		 mov	 DWORD PTR [ecx], edx
$LN264@Insert_at:

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0017d	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00180	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN269@Insert_at:

; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up

  00183	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00186	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;

  0018a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0018d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00190	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  00194	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00197	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0019a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0019d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  001a2	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  001a4	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001a8	75 03		 jne	 SHORT $LN331@Insert_at

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  001aa	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN331@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  001ad	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001b0	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  001b3	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  001b5	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b8	75 05		 jne	 SHORT $LN330@Insert_at

; 2136 : 			_Root() = _Pnode;

  001ba	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  001bd	eb 0e		 jmp	 SHORT $LN327@Insert_at
$LN330@Insert_at:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  001bf	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  001c2	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001c4	75 04		 jne	 SHORT $LN328@Insert_at

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  001c6	89 31		 mov	 DWORD PTR [ecx], esi

; 2139 : 		else

  001c8	eb 03		 jmp	 SHORT $LN327@Insert_at
$LN328@Insert_at:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  001ca	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN327@Insert_at:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  001cd	89 16		 mov	 DWORD PTR [esi], edx
$LN394@Insert_at:

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  001cf	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN332@Insert_at:

; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  001d2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d5	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001d9	0f 84 86 fe ff
	ff		 je	 $LL10@Insert_at
  001df	5e		 pop	 esi
$LN9@Insert_at:

; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  001e0	8b 07		 mov	 eax, DWORD PTR [edi]
  001e2	5f		 pop	 edi
  001e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 44   : 		{	// construct with node pointer _Pnode

  001ea	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001ed	89 18		 mov	 DWORD PTR [eax], ebx
  001ef	5b		 pop	 ebx

; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}

  001f0	5d		 pop	 ebp
  001f1	c2 14 00	 ret	 20			; 00000014H
$LN396@Insert_at:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  001f4	ff 75 18	 push	 DWORD PTR __Node$[ebp]
  001f7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001fc	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 1839 : 			_Xlength_error("map/set<T> too long");

  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  00204	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN398@Insert_at:
$LN393@Insert_at:
  00209	cc		 int	 3
??$_Insert_at@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_at<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@QAVCActorInstance@@M@std@@@std@@YAAAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@QAVCActorInstance@@M@std@@@std@@YAAAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z PROC ; std::forward<std::pair<CActorInstance * const,float> &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@QAVCActorInstance@@M@std@@@std@@YAAAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z ENDP ; std::forward<std::pair<CActorInstance * const,float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:
; File a:\vs\vc\include\xmemory0

; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@QAVCActorInstance@@M@std@@U?$pair@PAVCActorInstance@@M@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::pair<CActorInstance * const,float>,std::pair<CActorInstance *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::pair<CActorInstance * const,float> >, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAU?$pair@QAVCActorInstance@@M@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::pair<CActorInstance * const,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCRotationDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CRotationDecorator *,NEffectUpdateDecorator::CRotationDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGravityDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CGravityDecorator *,NEffectUpdateDecorator::CGravityDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CAirResistanceDecorator *,NEffectUpdateDecorator::CAirResistanceDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCNullDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CNullDecorator *,NEffectUpdateDecorator::CNullDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCHeaderDecorator@NEffectUpdateDecorator@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::_Ptr_cat<NEffectUpdateDecorator::CHeaderDecorator *,NEffectUpdateDecorator::CHeaderDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::allocator<CDynamicSphereInstance>,CDynamicSphereInstance>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUCDynamicSphereInstance@@PAU1@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UCDynamicSphereInstance@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCDynamicSphereInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UCDynamicSphereInstance@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCDynamicSphereInstance@@0@Z PROC ; std::_Ptr_cat<CDynamicSphereInstance,CDynamicSphereInstance>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UCDynamicSphereInstance@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUCDynamicSphereInstance@@0@Z ENDP ; std::_Ptr_cat<CDynamicSphereInstance,CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCRotationDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CRotationDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCRotationDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCGravityDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CGravityDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCGravityDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CAirResistanceDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationRandomDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CTextureAnimationCWDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCNullDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CNullDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCNullDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YA$$QAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z PROC ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@P6AXPAV12@@Z@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAP6AXPAV12@@Z@Z ENDP ; std::_For_each<NEffectUpdateDecorator::CHeaderDecorator * *,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAPAPAVCHeaderDecorator@NEffectUpdateDecorator@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@ABU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UCDynamicSphereInstance@@ABU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$construct@UCDynamicSphereInstance@@ABU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABUCDynamicSphereInstance@@@std@@YAABUCDynamicSphereInstance@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUCDynamicSphereInstance@@@std@@YAABUCDynamicSphereInstance@@ABU1@@Z PROC ; std::forward<CDynamicSphereInstance const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUCDynamicSphereInstance@@@std@@YAABUCDynamicSphereInstance@@ABU1@@Z ENDP ; std::forward<CDynamicSphereInstance const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$construct@UCDynamicSphereInstance@@AAU1@@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAXAAV?$allocator@UCDynamicSphereInstance@@@1@PAUCDynamicSphereInstance@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAUCDynamicSphereInstance@@@std@@YAAAUCDynamicSphereInstance@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUCDynamicSphereInstance@@@std@@YAAAUCDynamicSphereInstance@@AAU1@@Z PROC ; std::forward<CDynamicSphereInstance &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUCDynamicSphereInstance@@@std@@YAAAUCDynamicSphereInstance@@AAU1@@Z ENDP ; std::forward<CDynamicSphereInstance &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
$T4 = 12						; size = 4
__Where$5 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_nohint<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>, COMDAT
; _this$ = ecx

; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;

  00030	8b fa		 mov	 edi, edx
  00032	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  0003f	b2 01		 mov	 dl, 1
  00041	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	75 31		 jne	 SHORT $LN11@Insert_noh
  0004a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0004c	8a 75 0c	 mov	 dh, BYTE PTR __Leftish$[ebp]
  0004f	90		 npad	 1
$LL12@Insert_noh:

; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;

  00050	8b f8		 mov	 edi, eax

; 1788 : 			if (_Leftish)

  00052	84 f6		 test	 dh, dh
  00054	74 08		 je	 SHORT $LN10@Insert_noh
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00056	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File a:\vs\vc\include\xtree

; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

  00059	0f 93 c2	 setae	 dl

; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else

  0005c	eb 06		 jmp	 SHORT $LN234@Insert_noh
$LN10@Insert_noh:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0005e	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00061	0f 92 c2	 setb	 dl
$LN234@Insert_noh:
; File a:\vs\vc\include\xtree

; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

  00064	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);

  00067	84 d2		 test	 dl, dl
  00069	74 04		 je	 SHORT $LN16@Insert_noh
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  0006f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00072	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00076	74 d8		 je	 SHORT $LL12@Insert_noh
  00078	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode

  0007b	8b f7		 mov	 esi, edi
  0007d	89 75 0c	 mov	 DWORD PTR __Where$5[ebp], esi

; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)

  00080	84 d2		 test	 dl, dl
  00082	74 40		 je	 SHORT $LN106@Insert_noh

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00084	8b 01		 mov	 eax, DWORD PTR [ecx]
  00086	3b 38		 cmp	 edi, DWORD PTR [eax]

; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())

  00088	75 2f		 jne	 SHORT $LN4@Insert_noh

; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  0008a	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0008d	53		 push	 ebx
  0008e	57		 push	 edi
  0008f	6a 01		 push	 1
$LN236@Insert_noh:
  00091	8d 45 0c	 lea	 eax, DWORD PTR $T4[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_at<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	89 08		 mov	 DWORD PTR [eax], ecx
  000a1	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File a:\vs\vc\include\xtree

; 1829 : 		}

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000af	59		 pop	 ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 10 00	 ret	 16			; 00000010H
$LN4@Insert_noh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000b9	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$5[ebp]
  000bc	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::operator--
  000c1	8b 75 0c	 mov	 esi, DWORD PTR __Where$5[ebp]
$LN106@Insert_noh:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000c4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c7	3b 03		 cmp	 eax, DWORD PTR [ebx]
; File a:\vs\vc\include\xtree

; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  000c9	73 21		 jae	 SHORT $LN2@Insert_noh

; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000cb	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000ce	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	53		 push	 ebx
  000d2	57		 push	 edi
  000d3	ff 75 ec	 push	 DWORD PTR __Addleft$2[ebp]
  000d6	eb b9		 jmp	 SHORT $LN236@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z$0:

; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);

  000d8	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000db	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Destroy_if_not_nil

; 1827 : 		_RERAISE;

  000e3	6a 00		 push	 0
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN237@Insert_noh:
$LN2@Insert_noh:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  000ec	8b 5d 14	 mov	 ebx, DWORD PTR __Newnode$[ebp]

; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  000ef	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000f2	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]
  000f5	50		 push	 eax
  000f6	ff 30		 push	 DWORD PTR [eax]
  000f8	8d 45 0c	 lea	 eax, DWORD PTR $T3[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00101	ff 73 14	 push	 DWORD PTR [ebx+20]
  00104	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00109	53		 push	 ebx
  0010a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0010f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00112	83 c4 08	 add	 esp, 8
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00115	89 30		 mov	 DWORD PTR [eax], esi
  00117	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File a:\vs\vc\include\xtree

; 1829 : 		}

  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 10 00	 ret	 16			; 00000010H
$LN233@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_nohint<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
__Ptr$ = -24						; size = 4
__Pnode$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_<_Val_0>$ = 8						; size = 4
??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT
; _this$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  0002b	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode0
  00030	8b f0		 mov	 esi, eax

; 928  : 		this->_Isnil(_Pnode) = false;
; 929  : 
; 930  : 		_TRY_BEGIN

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	89 75 ec	 mov	 DWORD PTR __Pnode$[ebp], esi

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0003c	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0003f	66 c7 46 0c 00
	00		 mov	 WORD PTR [esi+12], 0

; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);

  00045	89 4d e8	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00048	89 4d e4	 mov	 DWORD PTR $T2[ebp], ecx
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004f	85 c9		 test	 ecx, ecx
  00051	74 34		 je	 SHORT $LN30@Buynode
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00053	8b 5d 08	 mov	 ebx, DWORD PTR _<_Val_0>$[ebp]
  00056	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00059	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005b	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  0005d	8b cf		 mov	 ecx, edi

; 569  : 		this->_Myhead = 0;

  0005f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 570  : 		this->_Mysize = 0;

  00065	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  0006c	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00071	89 07		 mov	 DWORD PTR [edi], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00073	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00076	89 0f		 mov	 DWORD PTR [edi], ecx

; 54   : 	_Right = _Move(_Tmp);

  00078	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 52   : 	_Ty _Tmp = _Move(_Left);

  0007b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 53   : 	_Left = _Move(_Right);

  0007e	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00081	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 54   : 	_Right = _Move(_Tmp);

  00084	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
$LN30@Buynode:
; File a:\vs\vc\include\xtree

; 939  : 		return (_Pnode);

  00087	8b c6		 mov	 eax, esi

; 940  : 		}

  00089	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00093	59		 pop	 ecx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
__catch$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0009d	ff 75 ec	 push	 DWORD PTR __Pnode$[ebp]
  000a0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a5	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 936  : 		_RERAISE;

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN126@Buynode:
$LN125@Buynode:
  000b1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z$2:
  00000	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YA$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YA$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YA$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\map
; File a:\vs\vc\include\utility
;	COMDAT ??$?0PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
$T1 = 11						; size = 1
__Val2$ = 12						; size = 4
??$?0PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@1@@Z PROC ; std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > ><NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	89 06		 mov	 DWORD PTR [esi], eax
  0000d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\map

; 109  : 		{	// construct map by copying _Right

  00010	8d 45 0b	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	ff 75 0c	 push	 DWORD PTR __Val2$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
; File a:\vs\vc\include\utility

; 145  : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??$?0PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@1@@Z ENDP ; std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > ><NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YAAAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YAAAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z PROC ; std::forward<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YAAAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@AAV10@@Z ENDP ; std::forward<std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@PBUSHitData@NRaceData@@@std@@YA$$QAPBUSHitData@NRaceData@@AAPBU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PBUSHitData@NRaceData@@@std@@YA$$QAPBUSHitData@NRaceData@@AAPBU12@@Z PROC ; std::forward<NRaceData::SHitData const *>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PBUSHitData@NRaceData@@@std@@YA$$QAPBUSHitData@NRaceData@@AAPBU12@@Z ENDP ; std::forward<NRaceData::SHitData const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
_TEXT	SEGMENT
tv495 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_nohint<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT
; _this$ = ecx

; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c1		 mov	 eax, ecx
  0002d	89 45 e8	 mov	 DWORD PTR _this$1$[ebp], eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  00032	b2 01		 mov	 dl, 1
  00034	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]
  00037	8b f9		 mov	 edi, ecx
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00040	89 4d e4	 mov	 DWORD PTR tv495[ebp], ecx

; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty

  00046	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00049	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004d	75 30		 jne	 SHORT $LN11@Insert_noh
  0004f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00051	8a 75 0c	 mov	 dh, BYTE PTR __Leftish$[ebp]
$LL12@Insert_noh:

; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;

  00054	8b f8		 mov	 edi, eax

; 1788 : 			if (_Leftish)

  00056	84 f6		 test	 dh, dh
  00058	74 08		 je	 SHORT $LN10@Insert_noh
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0005a	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File a:\vs\vc\include\xtree

; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

  0005d	0f 93 c2	 setae	 dl

; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else

  00060	eb 06		 jmp	 SHORT $LN175@Insert_noh
$LN10@Insert_noh:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00062	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00065	0f 92 c2	 setb	 dl
$LN175@Insert_noh:
; File a:\vs\vc\include\xtree

; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

  00068	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);

  0006b	84 d2		 test	 dl, dl
  0006d	74 04		 je	 SHORT $LN16@Insert_noh
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  00073	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))

  00076	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007a	74 d8		 je	 SHORT $LL12@Insert_noh
  0007c	8b 4d e4	 mov	 ecx, DWORD PTR tv495[ebp]
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode

  0007f	8b f7		 mov	 esi, edi
  00081	89 75 0c	 mov	 DWORD PTR __Where$4[ebp], esi

; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)

  00084	84 d2		 test	 dl, dl
  00086	74 41		 je	 SHORT $LN106@Insert_noh

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00088	3b 39		 cmp	 edi, DWORD PTR [ecx]

; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())

  0008a	75 32		 jne	 SHORT $LN4@Insert_noh

; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  0008c	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0008f	53		 push	 ebx
  00090	57		 push	 edi
  00091	6a 01		 push	 1
$LN176@Insert_noh:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00096	8d 45 0c	 lea	 eax, DWORD PTR $T3[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAU?$pair@QAVCActorInstance@@M@1@1@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_at<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
  000a6	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File a:\vs\vc\include\xtree

; 1829 : 		}

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN4@Insert_noh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000be	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$4[ebp]
  000c1	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator--
  000c6	8b 75 0c	 mov	 esi, DWORD PTR __Where$4[ebp]
$LN106@Insert_noh:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000c9	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File a:\vs\vc\include\xtree

; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000cc	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  000cf	3b 03		 cmp	 eax, DWORD PTR [ebx]
; File a:\vs\vc\include\xtree

; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  000d1	73 1b		 jae	 SHORT $LN2@Insert_noh

; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000d3	53		 push	 ebx
  000d4	57		 push	 edi
  000d5	ff 75 ec	 push	 DWORD PTR __Addleft$2[ebp]
  000d8	eb b9		 jmp	 SHORT $LN176@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000da	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000dd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e2	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 1827 : 		_RERAISE;

  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN177@Insert_noh:
$LN2@Insert_noh:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  000f3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000f6	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  000f9	89 30		 mov	 DWORD PTR [eax], esi
  000fb	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File a:\vs\vc\include\xtree

; 1829 : 		}

  000ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00102	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00109	59		 pop	 ecx
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 10 00	 ret	 16			; 00000010H
$LN174@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_nohint<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z PROC ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance *,float> >, COMDAT
; _this$ = ecx

; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();

  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode0
  00009	8b d0		 mov	 edx, eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000b	8d 72 10	 lea	 esi, DWORD PTR [edx+16]

; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;

  0000e	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00014	85 f6		 test	 esi, esi
  00016	74 0f		 je	 SHORT $LN30@Buynode
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	89 0e		 mov	 DWORD PTR [esi], ecx
  0001f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00022	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\xtree

; 939  : 		return (_Pnode);

  00025	8b c2		 mov	 eax, edx
$LN30@Buynode:
  00027	5e		 pop	 esi

; 940  : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ENDP ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@PAVCActorInstance@@M@std@@@std@@YA$$QAU?$pair@PAVCActorInstance@@M@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@PAVCActorInstance@@M@std@@@std@@YA$$QAU?$pair@PAVCActorInstance@@M@0@AAU10@@Z PROC ; std::forward<std::pair<CActorInstance *,float> >, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@PAVCActorInstance@@M@std@@@std@@YA$$QAU?$pair@PAVCActorInstance@@M@0@AAU10@@Z ENDP ; std::forward<std::pair<CActorInstance *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0PAVCActorInstance@@MX@?$pair@PAVCActorInstance@@M@std@@QAE@$$QAPAVCActorInstance@@$$QAM@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAVCActorInstance@@MX@?$pair@PAVCActorInstance@@M@std@@QAE@$$QAPAVCActorInstance@@$$QAM@Z PROC ; std::pair<CActorInstance *,float>::pair<CActorInstance *,float><CActorInstance *,float,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0PAVCActorInstance@@MX@?$pair@PAVCActorInstance@@M@std@@QAE@$$QAPAVCActorInstance@@$$QAM@Z ENDP ; std::pair<CActorInstance *,float>::pair<CActorInstance *,float><CActorInstance *,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@PAVCActorInstance@@@std@@YA$$QAPAVCActorInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVCActorInstance@@@std@@YA$$QAPAVCActorInstance@@AAPAV1@@Z PROC ; std::forward<CActorInstance *>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAVCActorInstance@@@std@@YA$$QAPAVCActorInstance@@AAPAV1@@Z ENDP ; std::forward<CActorInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 577  : 		{	// allocate array of _Count elements

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 21		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00011	77 15		 ja	 SHORT $LN1@Allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 03	 shl	 eax, 3
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00028	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002d	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::construct<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::pair<CActorInstance * const,float> >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@QAVCActorInstance@@M@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVCActorInstance@@M@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::pair<CActorInstance * const,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@IPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@IPAU1@@Z PROC ; std::_Allocate<CDynamicSphereInstance>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 26		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00012	77 19		 ja	 SHORT $LN1@Allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 02	 shl	 eax, 2
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002d	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Allocate@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@IPAU1@@Z ENDP ; std::_Allocate<CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0AAU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\map
;	COMDAT ??$_Kfn@$$CBMUCDynamicSphereInstance@@@?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@SAABMABU?$pair@$$CBMUCDynamicSphereInstance@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBMUCDynamicSphereInstance@@@?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@SAABMABU?$pair@$$CBMUCDynamicSphereInstance@@@1@@Z PROC ; std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0>::_Kfn<float const ,CDynamicSphereInstance>, COMDAT

; 57   : 		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   : 		{	// extract key from element value
; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 60   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBMUCDynamicSphereInstance@@@?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@SAABMABU?$pair@$$CBMUCDynamicSphereInstance@@@1@@Z ENDP ; std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0>::_Kfn<float const ,CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\map
;	COMDAT ??$_Kfn@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@SAABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@SAABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0>::_Kfn<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >, COMDAT

; 57   : 		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   : 		{	// extract key from element value
; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 60   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@SAABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0>::_Kfn<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::destroy<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\map
;	COMDAT ??$_Kfn@QAVCActorInstance@@M@?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@SAABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@QAVCActorInstance@@M@?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@SAABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@1@@Z PROC ; std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0>::_Kfn<CActorInstance * const,float>, COMDAT

; 57   : 		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   : 		{	// extract key from element value
; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 60   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@QAVCActorInstance@@M@?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@SAABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@1@@Z ENDP ; std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0>::_Kfn<CActorInstance * const,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 	_Ty _Tmp = _Move(_Left);
; 53   : 	_Left = _Move(_Right);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00009	53		 push	 ebx
  0000a	8a 01		 mov	 al, BYTE PTR [ecx]
  0000c	8a 1a		 mov	 bl, BYTE PTR [edx]
  0000e	88 02		 mov	 BYTE PTR [edx], al

; 54   : 	_Right = _Move(_Tmp);

  00010	88 19		 mov	 BYTE PTR [ecx], bl
  00012	5b		 pop	 ebx

; 55   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@$$CBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@YAPBU?$pair@$$CBMUCDynamicSphereInstance@@@0@ABU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@YAPBU?$pair@$$CBMUCDynamicSphereInstance@@@0@ABU10@@Z PROC ; std::addressof<std::pair<float const ,CDynamicSphereInstance> const >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@YAPBU?$pair@$$CBMUCDynamicSphereInstance@@@0@ABU10@@Z ENDP ; std::addressof<std::pair<float const ,CDynamicSphereInstance> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@YAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@QAVCActorInstance@@M@std@@@std@@YAPAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@QAVCActorInstance@@M@std@@@std@@YAPAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z PROC ; std::addressof<std::pair<CActorInstance * const,float> >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@QAVCActorInstance@@M@std@@@std@@YAPAU?$pair@QAVCActorInstance@@M@0@AAU10@@Z ENDP ; std::addressof<std::pair<CActorInstance * const,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@AAU1@@Z PROC ; std::addressof<CDynamicSphereInstance>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UCDynamicSphereInstance@@@std@@YAPAUCDynamicSphereInstance@@AAU1@@Z ENDP ; std::addressof<CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@$$CBVCSphereCollisionInstance@@@std@@YAPBVCSphereCollisionInstance@@ABV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBVCSphereCollisionInstance@@@std@@YAPBVCSphereCollisionInstance@@ABV1@@Z PROC ; std::addressof<CSphereCollisionInstance const >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBVCSphereCollisionInstance@@@std@@YAPBVCSphereCollisionInstance@@ABV1@@Z ENDP ; std::addressof<CSphereCollisionInstance const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@USCollisionPointInstance@CActorInstance@@@std@@YAPAUSCollisionPointInstance@CActorInstance@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@USCollisionPointInstance@CActorInstance@@@std@@YAPAUSCollisionPointInstance@CActorInstance@@AAU12@@Z PROC ; std::addressof<CActorInstance::SCollisionPointInstance>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@USCollisionPointInstance@CActorInstance@@@std@@YAPAUSCollisionPointInstance@CActorInstance@@AAU12@@Z ENDP ; std::addressof<CActorInstance::SCollisionPointInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAUCDynamicSphereInstance@@@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEPAUCDynamicSphereInstance@@PAU2@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUCDynamicSphereInstance@@@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEPAUCDynamicSphereInstance@@PAU2@00@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Umove<CDynamicSphereInstance *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::allocator<CDynamicSphereInstance>,CDynamicSphereInstance>
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1649 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUCDynamicSphereInstance@@@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEPAUCDynamicSphereInstance@@PAU2@00@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Umove<CDynamicSphereInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@YAXPAUCDynamicSphereInstance@@0AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCRotationDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCRotationDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCGravityDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCGravityDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCNullDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCNullDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBEPAPAVCHeaderDecorator@NEffectUpdateDecorator@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@PAPAVCHeaderDecorator@NEffectUpdateDecorator@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@SAPBU?$pair@$$CBMUCDynamicSphereInstance@@@2@ABU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@SAPBU?$pair@$$CBMUCDynamicSphereInstance@@@2@ABU32@@Z PROC ; std::pointer_traits<std::pair<float const ,CDynamicSphereInstance> const *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PBU?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@SAPBU?$pair@$$CBMUCDynamicSphereInstance@@@2@ABU32@@Z ENDP ; std::pointer_traits<std::pair<float const ,CDynamicSphereInstance> const *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@SAPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@QAVCActorInstance@@M@std@@@std@@SAPAU?$pair@QAVCActorInstance@@M@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@QAVCActorInstance@@M@std@@@std@@SAPAU?$pair@QAVCActorInstance@@M@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<CActorInstance * const,float> *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@QAVCActorInstance@@M@std@@@std@@SAPAU?$pair@QAVCActorInstance@@M@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<CActorInstance * const,float> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAUCDynamicSphereInstance@@@std@@SAPAUCDynamicSphereInstance@@AAU3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAUCDynamicSphereInstance@@@std@@SAPAUCDynamicSphereInstance@@AAU3@@Z PROC ; std::pointer_traits<CDynamicSphereInstance *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAUCDynamicSphereInstance@@@std@@SAPAUCDynamicSphereInstance@@AAU3@@Z ENDP ; std::pointer_traits<CDynamicSphereInstance *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PBVCSphereCollisionInstance@@@std@@SAPBVCSphereCollisionInstance@@ABV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PBVCSphereCollisionInstance@@@std@@SAPBVCSphereCollisionInstance@@ABV3@@Z PROC ; std::pointer_traits<CSphereCollisionInstance const *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PBVCSphereCollisionInstance@@@std@@SAPBVCSphereCollisionInstance@@ABV3@@Z ENDP ; std::pointer_traits<CSphereCollisionInstance const *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAUSCollisionPointInstance@CActorInstance@@@std@@SAPAUSCollisionPointInstance@CActorInstance@@AAU34@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAUSCollisionPointInstance@CActorInstance@@@std@@SAPAUSCollisionPointInstance@CActorInstance@@AAU34@@Z PROC ; std::pointer_traits<CActorInstance::SCollisionPointInstance *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAUSCollisionPointInstance@CActorInstance@@@std@@SAPAUSCollisionPointInstance@CActorInstance@@AAU34@@Z ENDP ; std::pointer_traits<CActorInstance::SCollisionPointInstance *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@ABU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@ABU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UCDynamicSphereInstance@@ABU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??$construct@UCDynamicSphereInstance@@ABU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@UCDynamicSphereInstance@@AAU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UCDynamicSphereInstance@@AAU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??$construct@UCDynamicSphereInstance@@AAU1@@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::construct<CDynamicSphereInstance,CDynamicSphereInstance &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUCDynamicSphereInstance@@@std@@YAPBUCDynamicSphereInstance@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUCDynamicSphereInstance@@@std@@YAPBUCDynamicSphereInstance@@ABU1@@Z PROC ; std::addressof<CDynamicSphereInstance const >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUCDynamicSphereInstance@@@std@@YAPBUCDynamicSphereInstance@@ABU1@@Z ENDP ; std::addressof<CDynamicSphereInstance const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??$insert@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::insert<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >, COMDAT
; _this$ = ecx

; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00004	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0000e	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000f	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00012	8b cf		 mov	 ecx, edi
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_nohint<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	5f		 pop	 edi

; 1161 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??$insert@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::insert<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
;	COMDAT ??$?0PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z PROC ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > ><NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,void>, COMDAT
; _this$ = ecx

; 157  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b d9		 mov	 ebx, ecx
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  0000b	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
; File a:\vs\vc\include\utility

; 157  : 		{	// construct from moved compatible pair

  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	89 03		 mov	 DWORD PTR [ebx], eax
; File a:\vs\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00012	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 570  : 		this->_Mysize = 0;

  00019	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  00020	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00025	89 43 04	 mov	 DWORD PTR [ebx+4], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00028	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0002b	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 54   : 	_Right = _Move(_Tmp);

  0002e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 53   : 	_Left = _Move(_Right);

  00031	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00034	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00037	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 158  : 		}

  0003a	8b c3		 mov	 eax, ebx

; 54   : 	_Right = _Move(_Tmp);

  0003c	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx

; 158  : 		}

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??$?0PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@X@?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ENDP ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > ><NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
;	COMDAT ??1?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ PROC ; std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::~pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	56		 push	 esi
  00008	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0000b	50		 push	 eax
  0000c	ff 30		 push	 DWORD PTR [eax]
  0000e	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00011	8b ce		 mov	 ecx, esi
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00019	ff 36		 push	 DWORD PTR [esi]
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	5e		 pop	 esi
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??1?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ ENDP ; std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::~pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\map
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\map
; File a:\vs\vc\include\utility
;	COMDAT ??$make_pair@PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA?AU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
$T2 = 15						; size = 1
__Val2$ = 16						; size = 4
??$make_pair@PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA?AU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@@Z PROC ; std::make_pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>, COMDAT

; 268  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 		{	// construct from moved values

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
; File a:\vs\vc\include\map

; 109  : 		{	// construct map by copying _Right

  00014	8d 45 0f	 lea	 eax, DWORD PTR $T2[ebp]
  00017	50		 push	 eax
  00018	ff 75 10	 push	 DWORD PTR __Val2$[ebp]
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0001b	89 0e		 mov	 DWORD PTR [esi], ecx
  0001d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\map

; 109  : 		{	// construct map by copying _Right

  00020	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
; File a:\vs\vc\include\utility

; 271  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi

; 272  : 		_STD forward<_Ty2>(_Val2)));
; 273  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$make_pair@PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA?AU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@@Z ENDP ; std::make_pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 342  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 337  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 273  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator->, COMDAT
; _this$ = ecx

; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}

  00005	c3		 ret	 0
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator*, COMDAT
; _this$ = ecx

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBMUCDynamicSphereInstance@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 210  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	8b d1		 mov	 edx, ecx

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	75 42		 jne	 SHORT $LN41@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 1c		 jne	 SHORT $LN34@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:

; 617  : 			_Pnode = _Left(_Pnode);

  00020	8b c8		 mov	 ecx, eax

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

  0002c	8b c2		 mov	 eax, edx

; 74   : 		}

  0002e	c3		 ret	 0
$LN34@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003d	75 0b		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	89 02		 mov	 DWORD PTR [edx], eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	89 02		 mov	 DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

  0004c	8b c2		 mov	 eax, edx

; 74   : 		}

  0004e	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
;	COMDAT ??_G?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAEPAXI@Z PROC ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00008	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0000e	50		 push	 eax
  0000f	ff 30		 push	 DWORD PTR [eax]
  00011	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001a	ff 77 04	 push	 DWORD PTR [edi+4]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
  00025	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00029	74 09		 je	 SHORT $LN68@scalar
  0002b	57		 push	 edi
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
$LN68@scalar:
  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??_G?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
;	COMDAT ??1?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ PROC ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::~pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	56		 push	 esi
  00008	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  0000b	50		 push	 eax
  0000c	ff 30		 push	 DWORD PTR [eax]
  0000e	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00011	8b ce		 mov	 ecx, esi
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00019	ff 36		 push	 DWORD PTR [esi]
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
  00023	5e		 pop	 esi
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??1?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ ENDP ; std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >::~pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::operator--

; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 427  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator->, COMDAT
; _this$ = ecx

; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator*, COMDAT
; _this$ = ecx

; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 385  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 342  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 337  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 312  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator*, COMDAT
; _this$ = ecx

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QBEABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN8@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN21@operator
$LL22@operator:

; 610  : 			_Pnode = _Right(_Pnode);

  00023	8b c8		 mov	 ecx, eax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	8d 64 24 00	 npad	 4
$LL4@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN47@operator
$LN21@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 2c	 add	 DWORD PTR [ecx], 44	; 0000002cH

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEABUSHitData@NRaceData@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEABUSHitData@NRaceData@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QBEABUSHitData@NRaceData@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAE@PAUSHitData@NRaceData@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAE@PAUSHitData@NRaceData@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@std@@QAE@PAUSHitData@NRaceData@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NRaceData::SHitData> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??$insert@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::insert<std::pair<CActorInstance *,float> >, COMDAT
; _this$ = ecx

; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00004	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance *,float> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0000e	50		 push	 eax

; 604  : 		return ((reference)_Pnode->_Myval);

  0000f	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00012	8b cf		 mov	 ecx, edi
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_nohint<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	5f		 pop	 edi

; 1161 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??$insert@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::insert<std::pair<CActorInstance *,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0PAVCActorInstance@@MX@?$pair@QAVCActorInstance@@M@std@@QAE@$$QAU?$pair@PAVCActorInstance@@M@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0PAVCActorInstance@@MX@?$pair@QAVCActorInstance@@M@std@@QAE@$$QAU?$pair@PAVCActorInstance@@M@1@@Z PROC ; std::pair<CActorInstance * const,float>::pair<CActorInstance * const,float><CActorInstance *,float,void>, COMDAT
; _this$ = ecx

; 157  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 158  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??$?0PAVCActorInstance@@MX@?$pair@QAVCActorInstance@@M@std@@QAE@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ENDP ; std::pair<CActorInstance * const,float>::pair<CActorInstance * const,float><CActorInstance *,float,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$make_pair@PAVCActorInstance@@M@std@@YA?AU?$pair@PAVCActorInstance@@M@0@$$QAPAVCActorInstance@@$$QAM@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@PAVCActorInstance@@M@std@@YA?AU?$pair@PAVCActorInstance@@M@0@$$QAPAVCActorInstance@@$$QAM@Z PROC ; std::make_pair<CActorInstance *,float>, COMDAT

; 268  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 144  : 		{	// construct from moved values

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00010	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 269  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 270  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 271  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),
; 272  : 		_STD forward<_Ty2>(_Val2)));
; 273  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@PAVCActorInstance@@M@std@@YA?AU?$pair@PAVCActorInstance@@M@0@$$QAPAVCActorInstance@@$$QAM@Z ENDP ; std::make_pair<CActorInstance *,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator--

; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 427  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVCActorInstance@@M@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVCActorInstance@@M@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator->, COMDAT
; _this$ = ecx

; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVCActorInstance@@M@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVCActorInstance@@M@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVCActorInstance@@M@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator*, COMDAT
; _this$ = ecx

; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVCActorInstance@@M@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 385  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 379  : 		{	// construct with null node
; 380  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 341  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 342  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 337  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 312  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 277  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 271  : 		++(*(_Mybase *)this);

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 280  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 273  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEABU?$pair@QAVCActorInstance@@M@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEABU?$pair@QAVCActorInstance@@M@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator*, COMDAT
; _this$ = ecx

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QBEABU?$pair@QAVCActorInstance@@M@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 210  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN8@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN21@operator
$LL22@operator:

; 610  : 			_Pnode = _Right(_Pnode);

  00023	8b c8		 mov	 ecx, eax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	8d 64 24 00	 npad	 4
$LL4@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN47@operator
$LN21@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	8b d1		 mov	 edx, ecx

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	75 42		 jne	 SHORT $LN41@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 1c		 jne	 SHORT $LN34@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:

; 617  : 			_Pnode = _Left(_Pnode);

  00020	8b c8		 mov	 ecx, eax

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

  0002c	8b c2		 mov	 eax, edx

; 74   : 		}

  0002e	c3		 ret	 0
$LN34@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003d	75 0b		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	89 02		 mov	 DWORD PTR [edx], eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	89 02		 mov	 DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

  0004c	8b c2		 mov	 eax, edx

; 74   : 		}

  0004e	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 1c	 add	 DWORD PTR [ecx], 28	; 0000001cH

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEPAUCDynamicSphereInstance@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEPAUCDynamicSphereInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator->, COMDAT
; _this$ = ecx

; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 330  : 		}

  00002	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEPAUCDynamicSphereInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEAAUCDynamicSphereInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEAAUCDynamicSphereInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEAAUCDynamicSphereInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 1c	 add	 DWORD PTR [ecx], 28	; 0000001cH

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEABUCDynamicSphereInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEABUCDynamicSphereInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QBEABUCDynamicSphereInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@PAUCDynamicSphereInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 43   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDynamicSphereInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 14	 add	 DWORD PTR [ecx], 20	; 00000014H

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEPBVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEPBVCSphereCollisionInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator->, COMDAT
; _this$ = ecx

; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 92   : 		}

  00002	c3		 ret	 0
??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEPBVCSphereCollisionInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEABVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEABVCSphereCollisionInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QBEABVCSphereCollisionInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@PAVCSphereCollisionInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 43   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator++, COMDAT
; _this$ = ecx

; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 375  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEPAUSCollisionPointInstance@CActorInstance@@XZ
_TEXT	SEGMENT
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEPAUSCollisionPointInstance@CActorInstance@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator->, COMDAT
; _this$ = ecx

; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}

  00005	c3		 ret	 0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEPAUSCollisionPointInstance@CActorInstance@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEAAUSCollisionPointInstance@CActorInstance@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEAAUSCollisionPointInstance@CActorInstance@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator*, COMDAT
; _this$ = ecx

; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEAAUSCollisionPointInstance@CActorInstance@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >, COMDAT
; _this$ = ecx

; 345  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 346  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 340  : 		{	// construct with null node
; 341  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator!=, COMDAT
; _this$ = ecx

; 302  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 303  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 304  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator==, COMDAT
; _this$ = ecx

; 284  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 299  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator++, COMDAT
; _this$ = ecx

; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 241  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 242  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEABUSCollisionPointInstance@CActorInstance@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEABUSCollisionPointInstance@CActorInstance@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator*, COMDAT
; _this$ = ecx

; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);
; 534  : 		}
; 535  : 
; 536  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 537  : 		{	// return reference to predecessor pointer in node
; 538  : 		return ((_Nodepref)_Pnode->_Prev);
; 539  : 		}
; 540  : 
; 541  : 	static reference _Myval(_Nodeptr _Pnode)
; 542  : 		{	// return reference to value in node
; 543  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QBEABUSCollisionPointInstance@CActorInstance@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 183  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?__InitializeCollisionData@CActorInstance@@IAEXXZ
_TEXT	SEGMENT
?__InitializeCollisionData@CActorInstance@@IAEXXZ PROC	; CActorInstance::__InitializeCollisionData, COMDAT
; _this$ = ecx

; 8    : 	m_canSkipCollision=false;

  00000	c6 81 90 04 00
	00 00		 mov	 BYTE PTR [ecx+1168], 0

; 9    : }

  00007	c3		 ret	 0
?__InitializeCollisionData@CActorInstance@@IAEXXZ ENDP	; CActorInstance::__InitializeCollisionData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?CanSkipCollision@CActorInstance@@QAE_NXZ
_TEXT	SEGMENT
?CanSkipCollision@CActorInstance@@QAE_NXZ PROC		; CActorInstance::CanSkipCollision, COMDAT
; _this$ = ecx

; 23   : 	return m_canSkipCollision;

  00000	8a 81 90 04 00
	00		 mov	 al, BYTE PTR [ecx+1168]

; 24   : }

  00006	c3		 ret	 0
?CanSkipCollision@CActorInstance@@QAE_NXZ ENDP		; CActorInstance::CanSkipCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?DisableSkipCollision@CActorInstance@@QAEXXZ
_TEXT	SEGMENT
?DisableSkipCollision@CActorInstance@@QAEXXZ PROC	; CActorInstance::DisableSkipCollision, COMDAT
; _this$ = ecx

; 18   : 	m_canSkipCollision=false;

  00000	c6 81 90 04 00
	00 00		 mov	 BYTE PTR [ecx+1168], 0

; 19   : }

  00007	c3		 ret	 0
?DisableSkipCollision@CActorInstance@@QAEXXZ ENDP	; CActorInstance::DisableSkipCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?EnableSkipCollision@CActorInstance@@QAEXXZ
_TEXT	SEGMENT
?EnableSkipCollision@CActorInstance@@QAEXXZ PROC	; CActorInstance::EnableSkipCollision, COMDAT
; _this$ = ecx

; 13   : 	m_canSkipCollision=true;

  00000	c6 81 90 04 00
	00 01		 mov	 BYTE PTR [ecx+1168], 1

; 14   : }

  00007	c3		 ret	 0
?EnableSkipCollision@CActorInstance@@QAEXXZ ENDP	; CActorInstance::EnableSkipCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\map
; File a:\vs\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Key, COMDAT
; _this$ = ecx

; 2239 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\map

; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File a:\vs\vc\include\xtree

; 2241 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2234 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2236 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEABQBUSHitData@NRaceData@@ABU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2157 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2174 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Rrotate:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2174 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2174 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2144 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Lrotate:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2144 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2144 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2123 : 		return (this->_Left(this->_Myhead));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2124 : 		}

  00002	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@ABQBUSHitData@NRaceData@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@ABQBUSHitData@NRaceData@@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 2105 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2106 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN32@Lbound
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Lbound:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00016	73 05		 jae	 SHORT $LN2@Lbound

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001b	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Lbound:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL4@Lbound
$LN32@Lbound:

; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate

  00027	8b c2		 mov	 eax, edx

; 2119 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@ABQBUSHitData@NRaceData@@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1648 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 604  : 		return ((reference)_Pnode->_Myval);

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Newnode$[ebp]

; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  00008	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0000b	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  0000e	50		 push	 eax
  0000f	ff 30		 push	 DWORD PTR [eax]
  00011	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001a	ff 77 14	 push	 DWORD PTR [edi+20]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	57		 push	 edi
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 08	 add	 esp, 8
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
; File a:\vs\vc\include\xtree

; 1653 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN42@lower_boun
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL6@lower_boun:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00016	73 05		 jae	 SHORT $LN4@lower_boun

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001b	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL6@lower_boun
$LN42@lower_boun:

; 44   : 		{	// construct with node pointer _Pnode

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::find, COMDAT
; _this$ = ecx

; 1548 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00004	8b 31		 mov	 esi, DWORD PTR [ecx]

; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00006	8b ce		 mov	 ecx, esi
  00008	57		 push	 edi

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00013	75 16		 jne	 SHORT $LN9@find
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00015	8b 17		 mov	 edx, DWORD PTR [edi]
$LL10@find:
  00017	39 50 10	 cmp	 DWORD PTR [eax+16], edx
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  0001a	73 05		 jae	 SHORT $LN8@find

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001f	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  00021	8b c8		 mov	 ecx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00025	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00029	74 ec		 je	 SHORT $LL10@find
$LN9@find:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0002b	3b ce		 cmp	 ecx, esi

; 1553 : 					? end() : _Where);

  0002d	74 0a		 je	 SHORT $LN3@find
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
; File a:\vs\vc\include\xtree

; 1553 : 					? end() : _Where);

  00031	89 4d 0c	 mov	 DWORD PTR $T1[ebp], ecx
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00034	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
; File a:\vs\vc\include\xtree

; 1553 : 					? end() : _Where);

  00037	73 03		 jae	 SHORT $LN82@find
$LN3@find:

; 44   : 		{	// construct with node pointer _Pnode

  00039	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
$LN82@find:

; 1553 : 					? end() : _Where);

  0003c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003f	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]
  00042	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 08		 mov	 DWORD PTR [eax], ecx

; 1554 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@ABQBUSHitData@NRaceData@@@Z ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 1277 : 		return (this->_Getal().max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1278 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::end, COMDAT
; _this$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::begin, COMDAT
; _this$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PBUSHitData@NRaceData@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PBUSHitData@NRaceData@@@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1006 : 		{	// get ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 		return (key_compare());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@PBUSHitData@NRaceData@@@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Freenode0, COMDAT
; _this$ = ecx

; 912  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 920  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ PROC ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode0, COMDAT
; _this$ = ecx

; 893  : 		{	// allocate a non-value node

  00000	56		 push	 esi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00001	6a 1c		 push	 28			; 0000001cH
; File a:\vs\vc\include\xtree

; 893  : 		{	// allocate a non-value node

  00003	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	8b d0		 mov	 edx, eax
  0000c	83 c4 04	 add	 esp, 4
  0000f	85 d2		 test	 edx, edx
  00011	74 1e		 je	 SHORT $LN96@Buynode0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00015	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 04		 je	 SHORT $LN61@Buynode0
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buynode0:
; File a:\vs\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00022	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	85 c9		 test	 ecx, ecx
  00027	74 04		 je	 SHORT $LN83@Buynode0
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buynode0:
; File a:\vs\vc\include\xtree

; 908  : 		return (_Pnode);

  0002d	8b c2		 mov	 eax, edx
  0002f	5e		 pop	 esi

; 909  : 		}

  00030	c3		 ret	 0
$LN96@Buynode0:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN98@Buynode0:
$LN95@Buynode0:
  00036	cc		 int	 3
?_Buynode0@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Getal, COMDAT
; _this$ = ecx

; 868  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Max, COMDAT

; 608  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00009	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000d	75 0c		 jne	 SHORT $LN15@Max
  0000f	90		 npad	 1
$LL2@Max:

; 610  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 611  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 612  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Myval, COMDAT

; 603  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 604  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 605  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@2@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Right, COMDAT

; 598  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 600  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Parent, COMDAT

; 593  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 595  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Left, COMDAT

; 588  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 590  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Isnil, COMDAT

; 583  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 585  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Color, COMDAT

; 578  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  : 		return ((char&)_Pnode->_Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 580  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 21		 je	 SHORT $LN1@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00012	77 1d		 ja	 SHORT $LN14@allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 02	 shl	 eax, 2
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN14@allocate
$LN1@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00036	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 21		 je	 SHORT $LN1@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00012	77 1d		 ja	 SHORT $LN11@allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 02	 shl	 eax, 2
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN11@allocate
$LN1@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00036	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >::allocator<std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??R?$less@PBUSHitData@NRaceData@@@std@@QBE_NABQBUSHitData@NRaceData@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PBUSHitData@NRaceData@@@std@@QBE_NABQBUSHitData@NRaceData@@0@Z PROC ; std::less<NRaceData::SHitData const *>::operator(), COMDAT
; _this$ = ecx

; 192  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	1b c0		 sbb	 eax, eax
  0000f	f7 d8		 neg	 eax

; 194  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??R?$less@PBUSHitData@NRaceData@@@std@@QBE_NABQBUSHitData@NRaceData@@0@Z ENDP ; std::less<NRaceData::SHitData const *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\math.h
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z
_TEXT	SEGMENT
$T2 = -148						; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
$T5 = -136						; size = 4
$T6 = -132						; size = 8
_f$ = -128						; size = 4
_motiontime$ = -124					; size = 4
_c$1$ = -120						; size = 4
_this$1$ = -116						; size = 4
$T7 = -112						; size = 12
$T8 = -108						; size = 8
$T9 = -108						; size = 8
$T10 = -108						; size = 8
$T11 = -104						; size = 4
$T12 = -104						; size = 4
_c_rHitData$13 = -104					; size = 4
$T14 = -100						; size = 12
$T15 = -96						; size = 8
_v3SrcDir$2$ = -92					; size = 4
$T16 = -92						; size = 4
$T17 = -92						; size = 4
$T18 = -92						; size = 4
_itorHitData$1$ = -88					; size = 4
_HittedInstanceMap$19 = -84				; size = 8
_v3SrcDir$1$ = -80					; size = 4
_fDistance$1$ = -76					; size = 4
__Wherenode$1$ = -76					; size = 4
_pad$1$ = -72						; size = 4
_rVictim$GSCopy$1$ = -68				; size = 4
_this$GSCopy$1$ = -64					; size = 4
_s$1$ = -60						; size = 4
tv3629 = -60						; size = 4
tv2756 = -60						; size = 4
__X$ = -60						; size = 4
__X$ = -60						; size = 4
_v3HitPosition$20 = -56					; size = 12
_dsi$21 = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_rVictim$ = 8						; size = 4
?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z PROC	; CActorInstance::__NormalAttackProcess, COMDAT
; _this$ = ecx

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 5d c0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00033	8b 75 08	 mov	 esi, DWORD PTR _rVictim$[ebp]

; 341  : 	if (IS_HUGE_RACE(rVictim.GetRace()))

  00036	8b ce		 mov	 ecx, esi
  00038	89 75 bc	 mov	 DWORD PTR _rVictim$GSCopy$1$[ebp], esi
  0003b	f3 0f 10 8e a4
	03 00 00	 movss	 xmm1, DWORD PTR [esi+932]
  00043	f3 0f 5c 8b a4
	03 00 00	 subss	 xmm1, DWORD PTR [ebx+932]
  0004b	f3 0f 10 96 9c
	03 00 00	 movss	 xmm2, DWORD PTR [esi+924]
  00053	f3 0f 5c 93 9c
	03 00 00	 subss	 xmm2, DWORD PTR [ebx+924]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0005b	0f 28 c1	 movaps	 xmm0, xmm1
  0005e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00062	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00066	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0006a	f3 0f 58 d0	 addss	 xmm2, xmm0
  0006e	f3 0f 58 d1	 addss	 xmm2, xmm1
  00072	f3 0f 11 55 b4	 movss	 DWORD PTR _fDistance$1$[ebp], xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 341  : 	if (IS_HUGE_RACE(rVictim.GetRace()))

  00077	e8 00 00 00 00	 call	 ?GetRace@CActorInstance@@QAEKXZ ; CActorInstance::GetRace
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?IS_HUGE_RACE@@YA_NI@Z	; IS_HUGE_RACE

; 342  : 	{
; 343  : 		if (fDistance >= 500.0f*500.0f)

  00082	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fDistance$1$[ebp]
  00087	83 c4 04	 add	 esp, 4
  0008a	84 c0		 test	 al, al
  0008c	74 0e		 je	 SHORT $LN30@NormalAtta
  0008e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@48742400
  00095	72 12		 jb	 SHORT $LN27@NormalAtta

; 344  : 			return FALSE;

  00097	e9 42 05 00 00	 jmp	 $LN855@NormalAtta
$LN30@NormalAtta:

; 345  : 	}
; 346  : 	else
; 347  : 	{
; 348  : 		if (fDistance >= 300.0f*300.0f)

  0009c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@47afc800
  000a3	0f 83 35 05 00
	00		 jae	 $LN855@NormalAtta
$LN27@NormalAtta:

; 349  : 			return FALSE;
; 350  : 	}
; 351  : 
; 352  : 	if (!isValidAttacking())

  000a9	8b cb		 mov	 ecx, ebx
  000ab	e8 00 00 00 00	 call	 ?isValidAttacking@CActorInstance@@IAEHXZ ; CActorInstance::isValidAttacking
  000b0	85 c0		 test	 eax, eax
  000b2	0f 84 26 05 00
	00		 je	 $LN855@NormalAtta

; 353  : 		return FALSE;
; 354  : 
; 355  : 	const float c_fAttackRadius = 20.0f;
; 356  : 	const NRaceData::TMotionAttackData * pad = m_pkCurRaceMotionData->GetMotionAttackDataPointer();

  000b8	8b 8b 58 03 00
	00		 mov	 ecx, DWORD PTR [ebx+856]
  000be	e8 00 00 00 00	 call	 ?GetMotionAttackDataPointer@CRaceMotionData@@QBEPBUSMotionAttackData@NRaceData@@XZ ; CRaceMotionData::GetMotionAttackDataPointer
  000c3	8b f8		 mov	 edi, eax

; 358  : 	const float motiontime = GetAttackingElapsedTime();

  000c5	8b cb		 mov	 ecx, ebx
  000c7	89 7d b8	 mov	 DWORD PTR _pad$1$[ebp], edi
  000ca	e8 00 00 00 00	 call	 ?GetAttackingElapsedTime@CActorInstance@@QAEMXZ ; CActorInstance::GetAttackingElapsedTime
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000cf	8b 45 b8	 mov	 eax, DWORD PTR _pad$1$[ebp]

; 47   : 		{	// construct with pointer _Parg

  000d2	8b 7f 1c	 mov	 edi, DWORD PTR [edi+28]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 358  : 	const float motiontime = GetAttackingElapsedTime();

  000d5	d9 5d 84	 fstp	 DWORD PTR _motiontime$[ebp]
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  000d8	89 7d a8	 mov	 DWORD PTR _itorHitData$1$[ebp], edi

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000db	3b 78 20	 cmp	 edi, DWORD PTR [eax+32]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 361  : 	for (; itorHitData != pad->HitDataContainer.end(); ++itorHitData)

  000de	0f 84 fa 04 00
	00		 je	 $LN855@NormalAtta
  000e4	8d 83 78 04 00
	00		 lea	 eax, DWORD PTR [ebx+1144]
  000ea	89 45 8c	 mov	 DWORD PTR _this$1$[ebp], eax
  000ed	8d 49 00	 npad	 3
$LL45@NormalAtta:
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000f0	8b 00		 mov	 eax, DWORD PTR [eax]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  000f2	8b d0		 mov	 edx, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 363  : 		const NRaceData::THitData & c_rHitData = *itorHitData;

  000f4	89 7d 98	 mov	 DWORD PTR _c_rHitData$13[ebp], edi
; File a:\vs\vc\include\xtree

; 2106 : 		_Nodeptr _Pnode = _Root();

  000f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  000fa	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000fe	75 14		 jne	 SHORT $LN69@NormalAtta
$LL70@NormalAtta:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00100	39 79 10	 cmp	 DWORD PTR [ecx+16], edi
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00103	73 05		 jae	 SHORT $LN68@NormalAtta

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00105	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 2112 : 			else

  00108	eb 04		 jmp	 SHORT $LN67@NormalAtta
$LN68@NormalAtta:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0010a	8b d1		 mov	 edx, ecx

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0010c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN67@NormalAtta:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0010e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00112	74 ec		 je	 SHORT $LL70@NormalAtta
$LN69@NormalAtta:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00114	3b d0		 cmp	 edx, eax

; 1553 : 					? end() : _Where);

  00116	74 13		 je	 SHORT $LN63@NormalAtta
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00118	3b 7a 10	 cmp	 edi, DWORD PTR [edx+16]
; File a:\vs\vc\include\xtree

; 1553 : 					? end() : _Where);

  0011b	72 0e		 jb	 SHORT $LN63@NormalAtta
  0011d	89 95 78 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], edx
  00123	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00129	eb 0c		 jmp	 SHORT $LN64@NormalAtta
$LN63@NormalAtta:

; 44   : 		{	// construct with node pointer _Pnode

  0012b	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax

; 1553 : 					? end() : _Where);

  00131	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
$LN64@NormalAtta:
  00137	8b 00		 mov	 eax, DWORD PTR [eax]

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00139	3b 83 78 04 00
	00		 cmp	 eax, DWORD PTR [ebx+1144]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 367  : 		if (itHitData != m_HitDataMap.end())

  0013f	74 75		 je	 SHORT $LN20@NormalAtta
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00141	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00144	8b d0		 mov	 edx, eax
  00146	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00149	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0014d	75 15		 jne	 SHORT $LN179@NormalAtta
  0014f	90		 npad	 1
$LL180@NormalAtta:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00150	39 71 10	 cmp	 DWORD PTR [ecx+16], esi
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00153	73 05		 jae	 SHORT $LN178@NormalAtta

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00155	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 2112 : 			else

  00158	eb 04		 jmp	 SHORT $LN177@NormalAtta
$LN178@NormalAtta:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0015a	8b d1		 mov	 edx, ecx

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0015c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN177@NormalAtta:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0015e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00162	74 ec		 je	 SHORT $LL180@NormalAtta
$LN179@NormalAtta:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00164	3b d0		 cmp	 edx, eax

; 1553 : 					? end() : _Where);

  00166	74 13		 je	 SHORT $LN173@NormalAtta
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00168	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
; File a:\vs\vc\include\xtree

; 1553 : 					? end() : _Where);

  0016b	72 0e		 jb	 SHORT $LN173@NormalAtta
  0016d	89 95 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], edx
  00173	8d b5 74 ff ff
	ff		 lea	 esi, DWORD PTR $T4[ebp]
  00179	eb 0c		 jmp	 SHORT $LN174@NormalAtta
$LN173@NormalAtta:

; 44   : 		{	// construct with node pointer _Pnode

  0017b	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax

; 1553 : 					? end() : _Where);

  00181	8d b5 6c ff ff
	ff		 lea	 esi, DWORD PTR $T2[ebp]
$LN174@NormalAtta:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 372  : 			if ((itInstance=rHittedInstanceMap.find(&rVictim)) != rHittedInstanceMap.end())

  00187	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\vs\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00189	3b f0		 cmp	 esi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 372  : 			if ((itInstance=rHittedInstanceMap.find(&rVictim)) != rHittedInstanceMap.end())

  0018b	74 26		 je	 SHORT $LN860@NormalAtta

; 373  : 			{
; 374  : 				if (pad->iMotionType==NRaceData::MOTION_TYPE_COMBO || itInstance->second > GetLocalTime())

  0018d	8b 45 b8	 mov	 eax, DWORD PTR _pad$1$[ebp]
  00190	83 78 18 02	 cmp	 DWORD PTR [eax+24], 2
  00194	0f 84 ac 02 00
	00		 je	 $LN24@NormalAtta
  0019a	8b cb		 mov	 ecx, ebx
  0019c	e8 00 00 00 00	 call	 ?GetLocalTime@CGraphicThingInstance@@QAEMXZ ; CGraphicThingInstance::GetLocalTime
  001a1	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  001a6	d9 5d c4	 fstp	 DWORD PTR tv3629[ebp]
  001a9	0f 2f 45 c4	 comiss	 xmm0, DWORD PTR tv3629[ebp]
  001ad	0f 87 93 02 00
	00		 ja	 $LN24@NormalAtta
$LN860@NormalAtta:
  001b3	8b 75 bc	 mov	 esi, DWORD PTR _rVictim$GSCopy$1$[ebp]
$LN20@NormalAtta:

; 380  : 		range_start = c_rHitData.mapHitPosition.lower_bound(motiontime-CTimer::Instance().GetElapsedSecond());

  001b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  001bc	e8 00 00 00 00	 call	 ?GetElapsedSecond@CTimer@@QAEMXZ ; CTimer::GetElapsedSecond
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  001c1	8b 57 24	 mov	 edx, DWORD PTR [edi+36]

; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  001c4	8b da		 mov	 ebx, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 380  : 		range_start = c_rHitData.mapHitPosition.lower_bound(motiontime-CTimer::Instance().GetElapsedSecond());

  001c6	d8 6d 84	 fsubr	 DWORD PTR _motiontime$[ebp]
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  001c9	89 55 b4	 mov	 DWORD PTR __Wherenode$1$[ebp], edx

; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();

  001cc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001cf	8b c8		 mov	 ecx, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 380  : 		range_start = c_rHitData.mapHitPosition.lower_bound(motiontime-CTimer::Instance().GetElapsedSecond());

  001d1	d9 5d c4	 fstp	 DWORD PTR tv2756[ebp]
; File a:\vs\vc\include\xtree

; 2092 : 		while (!this->_Isnil(_Pnode))

  001d4	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001d8	75 1b		 jne	 SHORT $LN289@NormalAtta
  001da	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR tv2756[ebp]
  001df	90		 npad	 1
$LL290@NormalAtta:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  001e0	0f 2f 41 10	 comiss	 xmm0, DWORD PTR [ecx+16]
; File a:\vs\vc\include\xtree

; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  001e4	76 05		 jbe	 SHORT $LN288@NormalAtta

; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  001e6	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 2095 : 			else

  001e9	eb 04		 jmp	 SHORT $LN287@NormalAtta
$LN288@NormalAtta:

; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;

  001eb	8b d9		 mov	 ebx, ecx

; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  001ed	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN287@NormalAtta:

; 2092 : 		while (!this->_Isnil(_Pnode))

  001ef	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001f3	74 eb		 je	 SHORT $LL290@NormalAtta
$LN289@NormalAtta:

; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))

  001f5	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001f9	75 1f		 jne	 SHORT $LN325@NormalAtta
  001fb	f3 0f 10 4d 84	 movss	 xmm1, DWORD PTR _motiontime$[ebp]
$LL326@NormalAtta:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00200	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00205	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\xtree

; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

  00208	76 07		 jbe	 SHORT $LN324@NormalAtta

; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;

  0020a	89 45 b4	 mov	 DWORD PTR __Wherenode$1$[ebp], eax

; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0020d	8b 00		 mov	 eax, DWORD PTR [eax]

; 2186 : 				}
; 2187 : 			else

  0020f	eb 03		 jmp	 SHORT $LN323@NormalAtta
$LN324@NormalAtta:

; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00211	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN323@NormalAtta:

; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))

  00214	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00218	74 e6		 je	 SHORT $LL326@NormalAtta
$LN325@NormalAtta:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 382  : 		float c = cosf(D3DXToRadian(GetRotation()));

  0021a	8b 4d c0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0021d	e8 00 00 00 00	 call	 ?GetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetRotation
  00222	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c8efa35
  00228	d9 5d c4	 fstp	 DWORD PTR __X$[ebp]
  0022b	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR __X$[ebp]
; File a:\vs\vc\include\math.h

; 664  :     return (float)cos(_X);

  00230	0f 5a c0	 cvtps2pd xmm0, xmm0
  00233	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 383  : 		float s = sinf(D3DXToRadian(GetRotation()));

  00238	8b 4d c0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File a:\vs\vc\include\math.h

; 664  :     return (float)cos(_X);

  0023b	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0023f	f3 0f 11 45 88	 movss	 DWORD PTR _c$1$[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 383  : 		float s = sinf(D3DXToRadian(GetRotation()));

  00244	e8 00 00 00 00	 call	 ?GetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetRotation
  00249	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3c8efa35
  0024f	d9 5d c4	 fstp	 DWORD PTR __X$[ebp]
  00252	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR __X$[ebp]
; File a:\vs\vc\include\math.h

; 765  :     return (float)sin(_X);

  00257	0f 5a c0	 cvtps2pd xmm0, xmm0
  0025a	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  0025f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00263	f3 0f 11 45 c4	 movss	 DWORD PTR _s$1$[ebp], xmm0
; File a:\vs\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00268	3b 5d b4	 cmp	 ebx, DWORD PTR __Wherenode$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 385  : 		for(;range_start!=range_end;++range_start)

  0026b	0f 84 d2 01 00
	00		 je	 $LN861@NormalAtta
$LL365@NormalAtta:

; 386  : 		{
; 387  : 			const CDynamicSphereInstance& dsiSrc=range_start->second;
; 388  : 
; 389  : 			CDynamicSphereInstance dsi;
; 390  : 			dsi = dsiSrc;

  00271	f3 0f 6f 43 14	 movdqu	 xmm0, XMMWORD PTR [ebx+20]
  00276	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]

; 394  : 				v3SrcDir*=__GetReachScale();

  00279	8b 7d c0	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  0027c	8b cf		 mov	 ecx, edi
  0027e	f3 0f 7f 45 d4	 movdqu	 XMMWORD PTR _dsi$21[ebp], xmm0
  00283	89 45 ec	 mov	 DWORD PTR _dsi$21[ebp+24], eax
  00286	f3 0f 7e 43 24	 movq	 xmm0, QWORD PTR [ebx+36]
  0028b	66 0f d6 45 e4	 movq	 QWORD PTR _dsi$21[ebp+16], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00290	f3 0f 10 43 14	 movss	 xmm0, DWORD PTR [ebx+20]
  00295	f3 0f 5c 43 20	 subss	 xmm0, DWORD PTR [ebx+32]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 391  : 			dsi.fRadius = c_fAttackRadius;

  0029a	c7 45 ec 00 00
	a0 41		 mov	 DWORD PTR _dsi$21[ebp+24], 1101004800 ; 41a00000H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002a1	f3 0f 11 45 b0	 movss	 DWORD PTR _v3SrcDir$1$[ebp], xmm0
  002a6	f3 0f 10 43 18	 movss	 xmm0, DWORD PTR [ebx+24]
  002ab	f3 0f 5c 43 24	 subss	 xmm0, DWORD PTR [ebx+36]
  002b0	f3 0f 11 45 a4	 movss	 DWORD PTR _v3SrcDir$2$[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 394  : 				v3SrcDir*=__GetReachScale();

  002b5	e8 00 00 00 00	 call	 ?__GetReachScale@CActorInstance@@IAEMXZ ; CActorInstance::__GetReachScale
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 222  :     x *= f;

  002ba	f3 0f 10 4d b0	 movss	 xmm1, DWORD PTR _v3SrcDir$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 400  : 				v3Dst += GetPosition();

  002bf	8b cf		 mov	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 223  :     y *= f;

  002c1	f3 0f 10 65 a4	 movss	 xmm4, DWORD PTR _v3SrcDir$2$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  002c6	f3 0f 10 5b 20	 movss	 xmm3, DWORD PTR [ebx+32]
  002cb	f3 0f 10 53 24	 movss	 xmm2, DWORD PTR [ebx+36]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 394  : 				v3SrcDir*=__GetReachScale();

  002d0	d9 5d 80	 fstp	 DWORD PTR _f$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 222  :     x *= f;

  002d3	f3 0f 59 4d 80	 mulss	 xmm1, DWORD PTR _f$[ebp]

; 223  :     y *= f;

  002d8	f3 0f 59 65 80	 mulss	 xmm4, DWORD PTR _f$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  002dd	f3 0f 58 d9	 addss	 xmm3, xmm1
  002e1	f3 0f 58 d4	 addss	 xmm2, xmm4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 398  : 				v3Dst.x = v3Src.x * c - v3Src.y * s;

  002e5	0f 28 cb	 movaps	 xmm1, xmm3

; 399  : 				v3Dst.y = v3Src.x * s + v3Src.y * c;

  002e8	f3 0f 59 5d c4	 mulss	 xmm3, DWORD PTR _s$1$[ebp]
  002ed	f3 0f 59 4d 88	 mulss	 xmm1, DWORD PTR _c$1$[ebp]
  002f2	0f 28 c2	 movaps	 xmm0, xmm2
  002f5	f3 0f 59 45 c4	 mulss	 xmm0, DWORD PTR _s$1$[ebp]
  002fa	f3 0f 59 55 88	 mulss	 xmm2, DWORD PTR _c$1$[ebp]
  002ff	f3 0f 5c c8	 subss	 xmm1, xmm0
  00303	f3 0f 58 da	 addss	 xmm3, xmm2
  00307	f3 0f 11 4d d4	 movss	 DWORD PTR _dsi$21[ebp], xmm1
  0030c	f3 0f 11 5d d8	 movss	 DWORD PTR _dsi$21[ebp+4], xmm3

; 400  : 				v3Dst += GetPosition();

  00311	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition

; 405  : 				v3Dst.x = v3Src.x * c - v3Src.y * s;

  00316	f3 0f 10 5b 20	 movss	 xmm3, DWORD PTR [ebx+32]

; 407  : 				v3Dst += GetPosition();

  0031b	8b cf		 mov	 ecx, edi
  0031d	f3 0f 10 53 24	 movss	 xmm2, DWORD PTR [ebx+36]
  00322	0f 28 cb	 movaps	 xmm1, xmm3
  00325	f3 0f 59 4d 88	 mulss	 xmm1, DWORD PTR _c$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  0032a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0032e	f3 0f 58 45 d4	 addss	 xmm0, DWORD PTR _dsi$21[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 406  : 				v3Dst.y = v3Src.x * s + v3Src.y * c;

  00333	f3 0f 59 5d c4	 mulss	 xmm3, DWORD PTR _s$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  00338	f3 0f 11 45 d4	 movss	 DWORD PTR _dsi$21[ebp], xmm0

; 205  :     y += v.y;

  0033d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00342	f3 0f 58 45 d8	 addss	 xmm0, DWORD PTR _dsi$21[ebp+4]
  00347	f3 0f 11 45 d8	 movss	 DWORD PTR _dsi$21[ebp+4], xmm0

; 206  :     z += v.z;

  0034c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00351	f3 0f 58 45 dc	 addss	 xmm0, DWORD PTR _dsi$21[ebp+8]
  00356	f3 0f 11 45 dc	 movss	 DWORD PTR _dsi$21[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 405  : 				v3Dst.x = v3Src.x * c - v3Src.y * s;

  0035b	0f 28 c2	 movaps	 xmm0, xmm2
  0035e	f3 0f 59 45 c4	 mulss	 xmm0, DWORD PTR _s$1$[ebp]

; 406  : 				v3Dst.y = v3Src.x * s + v3Src.y * c;

  00363	f3 0f 59 55 88	 mulss	 xmm2, DWORD PTR _c$1$[ebp]
  00368	f3 0f 5c c8	 subss	 xmm1, xmm0
  0036c	f3 0f 58 d3	 addss	 xmm2, xmm3
  00370	f3 0f 11 4d e0	 movss	 DWORD PTR _dsi$21[ebp+12], xmm1
  00375	f3 0f 11 55 e4	 movss	 DWORD PTR _dsi$21[ebp+16], xmm2

; 407  : 				v3Dst += GetPosition();

  0037a	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0037f	8b be 74 02 00
	00		 mov	 edi, DWORD PTR [esi+628]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  00385	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00389	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _dsi$21[ebp+12]
  0038e	f3 0f 11 45 e0	 movss	 DWORD PTR _dsi$21[ebp+12], xmm0

; 205  :     y += v.y;

  00393	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00398	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _dsi$21[ebp+16]
  0039d	f3 0f 11 45 e4	 movss	 DWORD PTR _dsi$21[ebp+16], xmm0

; 206  :     z += v.z;

  003a2	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003a7	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _dsi$21[ebp+20]
  003ac	f3 0f 11 45 e8	 movss	 DWORD PTR _dsi$21[ebp+20], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 412  : 			for(cpit = rVictim.m_DefendingPointInstanceList.begin(); cpit!=rVictim.m_DefendingPointInstanceList.end();++cpit)

  003b1	8b 3f		 mov	 edi, DWORD PTR [edi]
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  003b3	3b be 74 02 00
	00		 cmp	 edi, DWORD PTR [esi+628]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 412  : 			for(cpit = rVictim.m_DefendingPointInstanceList.begin(); cpit!=rVictim.m_DefendingPointInstanceList.end();++cpit)

  003b9	74 37		 je	 SHORT $LN17@NormalAtta
  003bb	eb 03 8d 49 00	 npad	 5
$LL443@NormalAtta:

; 417  : 				for(dsit = c_DefendingSphereVector.begin(); dsit!= c_DefendingSphereVector.end();++dsit, ++index)

  003c0	8b 77 18	 mov	 esi, DWORD PTR [edi+24]
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  003c3	3b 77 1c	 cmp	 esi, DWORD PTR [edi+28]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 417  : 				for(dsit = c_DefendingSphereVector.begin(); dsit!= c_DefendingSphereVector.end();++dsit, ++index)

  003c6	74 1d		 je	 SHORT $LN14@NormalAtta
$LL12@NormalAtta:

; 418  : 				{
; 419  : 					const CDynamicSphereInstance& sub = *dsit;
; 420  : 					if (DetectCollisionDynamicZCylinderVSDynamicZCylinder(dsi, sub))

  003c8	8d 45 d4	 lea	 eax, DWORD PTR _dsi$21[ebp]
  003cb	56		 push	 esi
  003cc	50		 push	 eax
  003cd	e8 00 00 00 00	 call	 ?DetectCollisionDynamicZCylinderVSDynamicZCylinder@@YA_NABUCDynamicSphereInstance@@0@Z ; DetectCollisionDynamicZCylinderVSDynamicZCylinder
  003d2	83 c4 08	 add	 esp, 8
  003d5	84 c0		 test	 al, al
  003d7	0f 85 89 00 00
	00		 jne	 $LN826@NormalAtta
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  003dd	83 c6 1c	 add	 esi, 28			; 0000001cH

; 205  : 		return (this->_Ptr == _Right._Ptr);

  003e0	3b 77 1c	 cmp	 esi, DWORD PTR [edi+28]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 417  : 				for(dsit = c_DefendingSphereVector.begin(); dsit!= c_DefendingSphereVector.end();++dsit, ++index)

  003e3	75 e3		 jne	 SHORT $LL12@NormalAtta
$LN14@NormalAtta:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  003e5	8b 75 bc	 mov	 esi, DWORD PTR _rVictim$GSCopy$1$[ebp]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  003e8	8b 3f		 mov	 edi, DWORD PTR [edi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  003ea	3b be 74 02 00
	00		 cmp	 edi, DWORD PTR [esi+628]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 412  : 			for(cpit = rVictim.m_DefendingPointInstanceList.begin(); cpit!=rVictim.m_DefendingPointInstanceList.end();++cpit)

  003f0	75 ce		 jne	 SHORT $LL443@NormalAtta
$LN17@NormalAtta:
; File a:\vs\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  003f2	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  003f6	75 3f		 jne	 SHORT $LN831@NormalAtta

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  003f8	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  003fb	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  003ff	75 1b		 jne	 SHORT $LN825@NormalAtta

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00401	8b d8		 mov	 ebx, eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00403	8b 03		 mov	 eax, DWORD PTR [ebx]

; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00405	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00409	75 2c		 jne	 SHORT $LN831@NormalAtta
  0040b	eb 03 8d 49 00	 npad	 5
$LL380@NormalAtta:

; 617  : 			_Pnode = _Left(_Pnode);

  00410	8b d8		 mov	 ebx, eax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00412	8b 03		 mov	 eax, DWORD PTR [ebx]

; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00414	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00418	74 f6		 je	 SHORT $LL380@NormalAtta

; 65   : 		else

  0041a	eb 1b		 jmp	 SHORT $LN831@NormalAtta
$LN825@NormalAtta:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0041c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0041f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00423	75 10		 jne	 SHORT $LN856@NormalAtta
$LL364@NormalAtta:
  00425	3b 58 08	 cmp	 ebx, DWORD PTR [eax+8]
  00428	75 0b		 jne	 SHORT $LN856@NormalAtta

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0042a	8b d8		 mov	 ebx, eax
  0042c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0042f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00433	74 f0		 je	 SHORT $LL364@NormalAtta
$LN856@NormalAtta:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00435	8b d8		 mov	 ebx, eax
$LN831@NormalAtta:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00437	3b 5d b4	 cmp	 ebx, DWORD PTR __Wherenode$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 385  : 		for(;range_start!=range_end;++range_start)

  0043a	0f 85 31 fe ff
	ff		 jne	 $LL365@NormalAtta
  00440	8b 7d a8	 mov	 edi, DWORD PTR _itorHitData$1$[ebp]
$LN861@NormalAtta:
  00443	8b 5d c0	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
$LN24@NormalAtta:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00446	8b 75 b8	 mov	 esi, DWORD PTR _pad$1$[ebp]

; 112  : 		++this->_Ptr;

  00449	83 c7 2c	 add	 edi, 44			; 0000002cH
  0044c	89 7d a8	 mov	 DWORD PTR _itorHitData$1$[ebp], edi

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0044f	3b 7e 20	 cmp	 edi, DWORD PTR [esi+32]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 361  : 	for (; itorHitData != pad->HitDataContainer.end(); ++itorHitData)

  00452	0f 84 86 01 00
	00		 je	 $LN855@NormalAtta
  00458	8b 75 bc	 mov	 esi, DWORD PTR _rVictim$GSCopy$1$[ebp]
  0045b	8d 83 78 04 00
	00		 lea	 eax, DWORD PTR [ebx+1144]
  00461	e9 8a fc ff ff	 jmp	 $LL45@NormalAtta
$LN826@NormalAtta:
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00466	8b 5d 8c	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00469	8b 4d a8	 mov	 ecx, DWORD PTR _itorHitData$1$[ebp]
  0046c	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0046e	8b f8		 mov	 edi, eax
  00470	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00473	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00477	75 1b		 jne	 SHORT $LN505@NormalAtta
  00479	8d a4 24 00 00
	00 00		 npad	 7
$LL506@NormalAtta:
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00480	39 4a 10	 cmp	 DWORD PTR [edx+16], ecx
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00483	73 05		 jae	 SHORT $LN504@NormalAtta

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00485	8b 52 08	 mov	 edx, DWORD PTR [edx+8]

; 2112 : 			else

  00488	eb 04		 jmp	 SHORT $LN503@NormalAtta
$LN504@NormalAtta:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0048a	8b fa		 mov	 edi, edx

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0048c	8b 12		 mov	 edx, DWORD PTR [edx]
$LN503@NormalAtta:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  0048e	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00492	74 ec		 je	 SHORT $LL506@NormalAtta
$LN505@NormalAtta:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00494	3b f8		 cmp	 edi, eax

; 1553 : 					? end() : _Where);

  00496	74 08		 je	 SHORT $LN499@NormalAtta
  00498	89 7d a4	 mov	 DWORD PTR $T17[ebp], edi
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0049b	3b 4f 10	 cmp	 ecx, DWORD PTR [edi+16]
; File a:\vs\vc\include\xtree

; 1553 : 					? end() : _Where);

  0049e	73 03		 jae	 SHORT $LN863@NormalAtta
$LN499@NormalAtta:

; 44   : 		{	// construct with node pointer _Pnode

  004a0	89 45 a4	 mov	 DWORD PTR $T16[ebp], eax
$LN863@NormalAtta:

; 1553 : 					? end() : _Where);

  004a3	8d 7d a4	 lea	 edi, DWORD PTR $T16[ebp]
  004a6	8b 3f		 mov	 edi, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

  004a8	3b f8		 cmp	 edi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 423  : 						if (itHitData == m_HitDataMap.end())

  004aa	0f 85 e0 00 00
	00		 jne	 $LN8@NormalAtta
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  004b0	8d 4d ac	 lea	 ecx, DWORD PTR _HittedInstanceMap$19[ebp]

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

  004b3	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _HittedInstanceMap$19[ebp], 0

; 570  : 		this->_Mysize = 0;

  004ba	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _HittedInstanceMap$19[ebp+4], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  004c1	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  004c6	89 45 ac	 mov	 DWORD PTR _HittedInstanceMap$19[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 426  : 							HittedInstanceMap.insert(make_pair(&rVictim, GetLocalTime()+pad->fInvisibleTime));

  004c9	8b 4d c0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004cc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  004d3	e8 00 00 00 00	 call	 ?GetLocalTime@CGraphicThingInstance@@QAEMXZ ; CGraphicThingInstance::GetLocalTime
  004d8	8b 45 b8	 mov	 eax, DWORD PTR _pad$1$[ebp]
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  004db	8d 4d ac	 lea	 ecx, DWORD PTR _HittedInstanceMap$19[ebp]
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  004de	8b 5d bc	 mov	 ebx, DWORD PTR _rVictim$GSCopy$1$[ebp]
  004e1	89 9d 7c ff ff
	ff		 mov	 DWORD PTR $T6[ebp], ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 426  : 							HittedInstanceMap.insert(make_pair(&rVictim, GetLocalTime()+pad->fInvisibleTime));

  004e7	d8 40 08	 fadd	 DWORD PTR [eax+8]
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  004ea	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  004f0	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 426  : 							HittedInstanceMap.insert(make_pair(&rVictim, GetLocalTime()+pad->fInvisibleTime));

  004f1	d9 5d a4	 fstp	 DWORD PTR $T18[ebp]
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  004f4	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR $T18[ebp]
  004f9	f3 0f 11 45 80	 movss	 DWORD PTR $T6[ebp+4], xmm0
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  004fe	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance *,float> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00503	50		 push	 eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  00504	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00507	8d 4d ac	 lea	 ecx, DWORD PTR _HittedInstanceMap$19[ebp]
  0050a	50		 push	 eax
  0050b	6a 00		 push	 0
  0050d	8d 45 a0	 lea	 eax, DWORD PTR $T15[ebp]
  00510	50		 push	 eax
  00511	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_nohint<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 428  : 							m_HitDataMap.insert(make_pair(&c_rHitData, HittedInstanceMap));

  00516	8d 45 ac	 lea	 eax, DWORD PTR _HittedInstanceMap$19[ebp]
  00519	50		 push	 eax
  0051a	8d 45 98	 lea	 eax, DWORD PTR _c_rHitData$13[ebp]
  0051d	50		 push	 eax
  0051e	8d 45 9c	 lea	 eax, DWORD PTR $T14[ebp]
  00521	50		 push	 eax
  00522	e8 00 00 00 00	 call	 ??$make_pair@PBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@YA?AU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@0@$$QAPBUSHitData@NRaceData@@AAV?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@0@@Z ; std::make_pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > &>
  00527	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0052a	8b 4d 8c	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0052d	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 428  : 							m_HitDataMap.insert(make_pair(&c_rHitData, HittedInstanceMap));

  0052e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00532	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@?$_Tree_buy@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@$$QAU?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@@Z ; std::_Tree_buy<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > > >::_Buynode<std::pair<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  00537	8b 4d 8c	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0053a	50		 push	 eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  0053b	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  0053e	50		 push	 eax
  0053f	6a 00		 push	 0
  00541	8d 45 94	 lea	 eax, DWORD PTR $T10[ebp]
  00544	50		 push	 eax
  00545	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@U?$less@PBUSHitData@NRaceData@@@4@V?$allocator@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@1@PAU?$_Tree_node@U?$pair@QBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<NRaceData::SHitData const *,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >,std::less<NRaceData::SHitData const *>,std::allocator<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > >,0> >::_Insert_nohint<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > > &,std::_Tree_node<std::pair<NRaceData::SHitData const * const,std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > > >,void *> *>

; 2230 : 		erase(begin(), end());

  0054a	8b 45 a0	 mov	 eax, DWORD PTR $T14[ebp+4]
  0054d	8d 4d a0	 lea	 ecx, DWORD PTR $T14[ebp+4]
  00550	50		 push	 eax
  00551	ff 30		 push	 DWORD PTR [eax]
  00553	8d 45 98	 lea	 eax, DWORD PTR $T12[ebp]
  00556	50		 push	 eax
  00557	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0055c	ff 75 a0	 push	 DWORD PTR $T14[ebp+4]
  0055f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00564	8b 45 ac	 mov	 eax, DWORD PTR _HittedInstanceMap$19[ebp]
  00567	8d 4d ac	 lea	 ecx, DWORD PTR _HittedInstanceMap$19[ebp]
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0056a	83 c4 04	 add	 esp, 4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 431  : 						}

  0056d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00574	50		 push	 eax
  00575	ff 30		 push	 DWORD PTR [eax]
  00577	8d 45 98	 lea	 eax, DWORD PTR $T11[ebp]
  0057a	50		 push	 eax
  0057b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00580	ff 75 ac	 push	 DWORD PTR _HittedInstanceMap$19[ebp]
  00583	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00588	83 c4 04	 add	 esp, 4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 432  : 						else

  0058b	e9 76 00 00 00	 jmp	 $LN4@NormalAtta
$LN8@NormalAtta:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00590	8b 45 bc	 mov	 eax, DWORD PTR _rVictim$GSCopy$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 434  : 							itHitData->second.insert(make_pair(&rVictim, GetLocalTime()+pad->fInvisibleTime));

  00593	8b 4d c0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00596	89 45 94	 mov	 DWORD PTR $T9[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 434  : 							itHitData->second.insert(make_pair(&rVictim, GetLocalTime()+pad->fInvisibleTime));

  00599	e8 00 00 00 00	 call	 ?GetLocalTime@CGraphicThingInstance@@QAEMXZ ; CGraphicThingInstance::GetLocalTime
  0059e	8b 45 b8	 mov	 eax, DWORD PTR _pad$1$[ebp]
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  005a1	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 434  : 							itHitData->second.insert(make_pair(&rVictim, GetLocalTime()+pad->fInvisibleTime));

  005a4	d8 40 08	 fadd	 DWORD PTR [eax+8]
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  005a7	8d 45 94	 lea	 eax, DWORD PTR $T9[ebp]
  005aa	50		 push	 eax
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  005ab	d9 5d 98	 fstp	 DWORD PTR $T9[ebp+4]
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  005ae	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance *,float> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  005b3	50		 push	 eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  005b4	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  005b7	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  005ba	50		 push	 eax
  005bb	6a 00		 push	 0
  005bd	8d 45 94	 lea	 eax, DWORD PTR $T8[ebp]
  005c0	50		 push	 eax
  005c1	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_nohint<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 441  : 							if (NRaceData::MOTION_TYPE_COMBO == pad->iMotionType || NRaceData::MOTION_TYPE_NORMAL == pad->iMotionType)

  005c6	8b 55 b8	 mov	 edx, DWORD PTR _pad$1$[ebp]
  005c9	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  005cc	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  005cf	83 f9 02	 cmp	 ecx, 2
  005d2	74 2a		 je	 SHORT $LN5@NormalAtta
  005d4	83 f9 01	 cmp	 ecx, 1
  005d7	74 25		 je	 SHORT $LN5@NormalAtta

; 447  : 								}
; 448  : 							}
; 449  : 							else
; 450  : 							{
; 451  : 								if (iCurrentHitCount > pad->iHitLimitCount)

  005d9	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
$LN864@NormalAtta:

; 442  : 							{
; 443  : 								if (iCurrentHitCount > 16)

  005dc	7e 25		 jle	 SHORT $LN859@NormalAtta
$LN855@NormalAtta:

; 470  : 					}
; 471  : 				}
; 472  : 			}
; 473  : 		}
; 474  : 	}
; 475  : 
; 476  : 	return FALSE;

  005de	33 c0		 xor	 eax, eax
$LN31@NormalAtta:

; 477  : }

  005e0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005e3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005ea	59		 pop	 ecx
  005eb	5f		 pop	 edi
  005ec	5e		 pop	 esi
  005ed	5b		 pop	 ebx
  005ee	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f1	33 cd		 xor	 ecx, ebp
  005f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f8	8b e5		 mov	 esp, ebp
  005fa	5d		 pop	 ebp
  005fb	c2 04 00	 ret	 4
$LN5@NormalAtta:

; 442  : 							{
; 443  : 								if (iCurrentHitCount > 16)

  005fe	83 f8 10	 cmp	 eax, 16			; 00000010H

; 444  : 								{
; 445  : 									//Tracef(" Type NORMAL :: Overflow - Can't process, skip\n");
; 446  : 									return FALSE;

  00601	eb d9		 jmp	 SHORT $LN864@NormalAtta
$LN859@NormalAtta:
  00603	8b 5d bc	 mov	 ebx, DWORD PTR _rVictim$GSCopy$1$[ebp]
$LN4@NormalAtta:

; 452  : 								{
; 453  : 									//Tracef(" Type SKILL :: Overflow - Can't process, skip\n");
; 454  : 									return FALSE;
; 455  : 								}
; 456  : 							}
; 457  : 						}
; 458  : 
; 459  : 						D3DXVECTOR3 v3HitPosition = (GetPosition() + rVictim.GetPosition()) *0.5f;

  00606	8b cb		 mov	 ecx, ebx
  00608	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  0060d	8b 4d c0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00610	8b f8		 mov	 edi, eax
  00612	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00617	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 463  : 						if (IS_HUGE_RACE(rVictim.GetRace()))

  0061b	8b cb		 mov	 ecx, ebx
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0061d	f3 0f 10 4f 04	 movss	 xmm1, DWORD PTR [edi+4]
  00622	f3 0f 10 57 08	 movss	 xmm2, DWORD PTR [edi+8]
  00627	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0062b	f3 0f 58 48 04	 addss	 xmm1, DWORD PTR [eax+4]
  00630	f3 0f 58 50 08	 addss	 xmm2, DWORD PTR [eax+8]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00635	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f000000
  0063d	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00641	f3 0f 59 cb	 mulss	 xmm1, xmm3
  00645	f3 0f 59 d3	 mulss	 xmm2, xmm3

; 180  :     x = fx;

  00649	f3 0f 11 45 c8	 movss	 DWORD PTR _v3HitPosition$20[ebp], xmm0

; 181  :     y = fy;

  0064e	f3 0f 11 4d cc	 movss	 DWORD PTR _v3HitPosition$20[ebp+4], xmm1

; 182  :     z = fz;

  00653	f3 0f 11 55 d0	 movss	 DWORD PTR _v3HitPosition$20[ebp+8], xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 463  : 						if (IS_HUGE_RACE(rVictim.GetRace()))

  00658	e8 00 00 00 00	 call	 ?GetRace@CActorInstance@@QAEKXZ ; CActorInstance::GetRace
  0065d	50		 push	 eax
  0065e	e8 00 00 00 00	 call	 ?IS_HUGE_RACE@@YA_NI@Z	; IS_HUGE_RACE
  00663	83 c4 04	 add	 esp, 4
  00666	84 c0		 test	 al, al
  00668	74 4b		 je	 SHORT $LN1@NormalAtta

; 465  : 							v3HitPosition = (GetPosition() + sub.v3Position) * 0.5f;							

  0066a	8b 4d c0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0066d	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00672	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f000000

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0067a	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0067e	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00683	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00688	f3 0f 58 16	 addss	 xmm2, DWORD PTR [esi]
  0068c	f3 0f 58 4e 04	 addss	 xmm1, DWORD PTR [esi+4]
  00691	f3 0f 58 46 08	 addss	 xmm0, DWORD PTR [esi+8]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00696	f3 0f 59 d3	 mulss	 xmm2, xmm3
  0069a	f3 0f 59 cb	 mulss	 xmm1, xmm3
  0069e	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 465  : 							v3HitPosition = (GetPosition() + sub.v3Position) * 0.5f;							

  006a2	0f 14 d1	 unpcklps xmm2, xmm1
  006a5	66 0f d6 55 c8	 movq	 QWORD PTR _v3HitPosition$20[ebp], xmm2
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  006aa	f3 0f 11 45 98	 movss	 DWORD PTR $T7[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 465  : 							v3HitPosition = (GetPosition() + sub.v3Position) * 0.5f;							

  006af	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp+8]
  006b2	89 45 d0	 mov	 DWORD PTR _v3HitPosition$20[ebp+8], eax
$LN1@NormalAtta:

; 466  : 						}
; 467  : 						
; 468  : 						__ProcessDataAttackSuccess(*pad, rVictim, v3HitPosition, m_kCurMotNode.uSkill);

  006b5	8b 45 c0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  006b8	8d 4d c8	 lea	 ecx, DWORD PTR _v3HitPosition$20[ebp]
  006bb	6a 01		 push	 1
  006bd	ff b0 64 02 00
	00		 push	 DWORD PTR [eax+612]
  006c3	51		 push	 ecx
  006c4	53		 push	 ebx
  006c5	ff 75 b8	 push	 DWORD PTR _pad$1$[ebp]
  006c8	8b c8		 mov	 ecx, eax
  006ca	e8 00 00 00 00	 call	 ?__ProcessDataAttackSuccess@CActorInstance@@IAEXABUSAttackData@NRaceData@@AAV1@ABUD3DXVECTOR3@@IH@Z ; CActorInstance::__ProcessDataAttackSuccess

; 469  : 						return TRUE;

  006cf	b8 01 00 00 00	 mov	 eax, 1
  006d4	e9 07 ff ff ff	 jmp	 $LN31@NormalAtta
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _HittedInstanceMap$19[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ
__unwindfunclet$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z$1:
  00008	8d 4d 9c	 lea	 ecx, DWORD PTR $T14[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@PBUSHitData@NRaceData@@V?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@@std@@QAE@XZ
__ehhandler$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z ENDP	; CActorInstance::__NormalAttackProcess
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\utility
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?__SplashAttackProcess@CActorInstance@@QAEHAAV1@@Z
_TEXT	SEGMENT
_rVictim$GSCopy$ = -28					; size = 4
$T1 = -24						; size = 8
$T2 = -24						; size = 8
$T3 = -20						; size = 4
_v3HitPosition$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_rVictim$ = 8						; size = 4
?__SplashAttackProcess@CActorInstance@@QAEHAAV1@@Z PROC	; CActorInstance::__SplashAttackProcess, COMDAT
; _this$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _rVictim$[ebp]
  00015	8b f1		 mov	 esi, ecx
  00017	89 7d e4	 mov	 DWORD PTR _rVictim$GSCopy$[ebp], edi

; 269  : 	D3DXVECTOR3 v3Distance(rVictim.m_x - m_x, rVictim.m_z - m_z, rVictim.m_z - m_z);

  0001a	f3 0f 10 97 a4
	03 00 00	 movss	 xmm2, DWORD PTR [edi+932]
  00022	f3 0f 5c 96 a4
	03 00 00	 subss	 xmm2, DWORD PTR [esi+932]
  0002a	f3 0f 10 8f 9c
	03 00 00	 movss	 xmm1, DWORD PTR [edi+924]
  00032	f3 0f 5c 8e 9c
	03 00 00	 subss	 xmm1, DWORD PTR [esi+924]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0003a	0f 28 c2	 movaps	 xmm0, xmm2
  0003d	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00041	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00045	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00049	f3 0f 58 c1	 addss	 xmm0, xmm1
  0004d	f3 0f 58 c2	 addss	 xmm0, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 271  : 	if (fDistance >= 1000.0f*1000.0f)

  00051	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@49742400
  00058	72 14		 jb	 SHORT $LN8@SplashAtta
$LN54@SplashAtta:
  0005a	5f		 pop	 edi

; 272  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
  0005d	5e		 pop	 esi

; 328  : 	}
; 329  : 
; 330  : 	return FALSE;
; 331  : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
$LN8@SplashAtta:

; 273  : 
; 274  : 	// Check Distance
; 275  : 	if (!__IsInSplashTime())

  0006e	e8 00 00 00 00	 call	 ?__IsInSplashTime@CActorInstance@@IAE_NXZ ; CActorInstance::__IsInSplashTime
  00073	84 c0		 test	 al, al
  00075	74 e3		 je	 SHORT $LN54@SplashAtta

; 276  : 		return FALSE;
; 277  : 
; 278  : 	const CRaceMotionData::TMotionAttackingEventData * c_pAttackingEvent = m_kSplashArea.c_pAttackingEvent;
; 279  : 	const NRaceData::TAttackData & c_rAttackData = c_pAttackingEvent->AttackData;

  00077	53		 push	 ebx
  00078	8b 9e 8c 02 00
	00		 mov	 ebx, DWORD PTR [esi+652]

; 283  : 	if (rHittedInstanceMap.end() != rHittedInstanceMap.find(&rVictim))

  0007e	8d 4d e4	 lea	 ecx, DWORD PTR _rVictim$GSCopy$[ebp]
  00081	51		 push	 ecx
  00082	8d 4d ec	 lea	 ecx, DWORD PTR $T3[ebp]
  00085	83 c3 28	 add	 ebx, 40			; 00000028H
  00088	51		 push	 ecx
  00089	8d 8e 9c 02 00
	00		 lea	 ecx, DWORD PTR [esi+668]
  0008f	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::find
; File a:\vs\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00094	8b 8e 9c 02 00
	00		 mov	 ecx, DWORD PTR [esi+668]
  0009a	3b 08		 cmp	 ecx, DWORD PTR [eax]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 283  : 	if (rHittedInstanceMap.end() != rHittedInstanceMap.find(&rVictim))

  0009c	0f 85 c4 00 00
	00		 jne	 $LN2@SplashAtta

; 284  : 	{
; 285  : 		return FALSE;
; 286  : 	}
; 287  : 
; 288  : 	// NOTE : Snipe ..
; 289  : 	if (NRaceData::ATTACK_TYPE_SNIPE == c_rAttackData.iAttackType)

  000a2	83 3b 01	 cmp	 DWORD PTR [ebx], 1
  000a5	75 1b		 jne	 SHORT $LN3@SplashAtta

; 290  : 	{
; 291  : 		// Target  PC ..
; 292  : 		if (__IsFlyTargetPC())

  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?__IsFlyTargetPC@CActorInstance@@IAE_NXZ ; CActorInstance::__IsFlyTargetPC
  000ae	84 c0		 test	 al, al
  000b0	74 10		 je	 SHORT $LN3@SplashAtta

; 293  : 			//     
; 294  : 			if (!__IsSameFlyTarget(&rVictim))

  000b2	57		 push	 edi
  000b3	8b ce		 mov	 ecx, esi
  000b5	e8 00 00 00 00	 call	 ?__IsSameFlyTarget@CActorInstance@@IAE_NPAV1@@Z ; CActorInstance::__IsSameFlyTarget
  000ba	84 c0		 test	 al, al
  000bc	0f 84 a4 00 00
	00		 je	 $LN2@SplashAtta
$LN3@SplashAtta:

; 295  : 				return FALSE;
; 296  : 
; 297  : /*
; 298  : 		if (IsFlyTargetObject())
; 299  : 		{
; 300  : 			CActorInstance * pActorInstance = (CActorInstance *)m_kFlyTarget.GetFlyTarget();
; 301  : 
; 302  : 			// NOTE : Target  PC     .
; 303  : 			if (pActorInstance->IsPC())
; 304  : 				if (&rVictim != pActorInstance)
; 305  : 					return FALSE;
; 306  : 		}
; 307  : */
; 308  : 	}
; 309  : 
; 310  : 	D3DXVECTOR3 v3HitPosition;
; 311  : 	if (rVictim.CheckCollisionDetection(&m_kSplashArea.SphereInstanceVector, &v3HitPosition))

  000c2	8d 45 f0	 lea	 eax, DWORD PTR _v3HitPosition$[ebp]
  000c5	8b cf		 mov	 ecx, edi
  000c7	50		 push	 eax
  000c8	8d 86 90 02 00
	00		 lea	 eax, DWORD PTR [esi+656]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ?CheckCollisionDetection@CActorInstance@@QAE_NPBV?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@PAUD3DXVECTOR3@@@Z ; CActorInstance::CheckCollisionDetection
  000d4	84 c0		 test	 al, al
  000d6	0f 84 8a 00 00
	00		 je	 $LN2@SplashAtta

; 313  : 		rHittedInstanceMap.insert(make_pair(&rVictim, GetLocalTime()+c_rAttackData.fInvisibleTime));

  000dc	8b ce		 mov	 ecx, esi
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  000de	89 7d e8	 mov	 DWORD PTR $T2[ebp], edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 313  : 		rHittedInstanceMap.insert(make_pair(&rVictim, GetLocalTime()+c_rAttackData.fInvisibleTime));

  000e1	e8 00 00 00 00	 call	 ?GetLocalTime@CGraphicThingInstance@@QAEMXZ ; CGraphicThingInstance::GetLocalTime
  000e6	d8 43 08	 fadd	 DWORD PTR [ebx+8]
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  000e9	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  000ec	50		 push	 eax
  000ed	8d 8e 9c 02 00
	00		 lea	 ecx, DWORD PTR [esi+668]
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  000f3	d9 5d ec	 fstp	 DWORD PTR $T2[ebp+4]
; File a:\vs\vc\include\xtree

; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  000f6	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@PAVCActorInstance@@M@std@@@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@$$QAU?$pair@PAVCActorInstance@@M@1@@Z ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode<std::pair<CActorInstance *,float> >

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  000fb	50		 push	 eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);

  000fc	83 c0 10	 add	 eax, 16			; 00000010H

; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));

  000ff	8d 8e 9c 02 00
	00		 lea	 ecx, DWORD PTR [esi+668]
  00105	50		 push	 eax
  00106	6a 00		 push	 0
  00108	8d 45 e8	 lea	 eax, DWORD PTR $T1[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@QAVCActorInstance@@M@std@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@QAVCActorInstance@@M@1@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Insert_nohint<std::pair<CActorInstance * const,float> &,std::_Tree_node<std::pair<CActorInstance * const,float>,void *> *>
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 316  : 		int iMaxHitCount = (0 == c_rAttackData.iHitLimitCount ? 16 : c_rAttackData.iHitLimitCount);

  00111	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00114	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00119	85 c0		 test	 eax, eax
  0011b	0f 44 c1	 cmove	 eax, ecx

; 317  : 		//Tracef(" ------------------- Splash Hit : %d\n", iCurrentHitCount);
; 318  : 
; 319  : 		if (iCurrentHitCount > iMaxHitCount)

  0011e	39 86 a0 02 00
	00		 cmp	 DWORD PTR [esi+672], eax
  00124	7f 40		 jg	 SHORT $LN2@SplashAtta

; 320  : 		{
; 321  : 			//Tracef(" ------------------- OVER FLOW :: Splash Hit Count : %d\n", iCurrentHitCount);
; 322  : 			return FALSE;
; 323  : 		}
; 324  : 
; 325  : 		NEW_SetAtkPixelPosition(NEW_GetCurPixelPositionRef());

  00126	8b ce		 mov	 ecx, esi
  00128	e8 00 00 00 00	 call	 ?NEW_GetCurPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetCurPixelPositionRef
  0012d	50		 push	 eax
  0012e	8b ce		 mov	 ecx, esi
  00130	e8 00 00 00 00	 call	 ?NEW_SetAtkPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z ; CActorInstance::NEW_SetAtkPixelPosition

; 326  : 		__ProcessDataAttackSuccess(c_rAttackData, rVictim, v3HitPosition, m_kSplashArea.uSkill, m_kSplashArea.isEnableHitProcess);

  00135	ff b6 7c 02 00
	00		 push	 DWORD PTR [esi+636]
  0013b	8d 45 f0	 lea	 eax, DWORD PTR _v3HitPosition$[ebp]
  0013e	8b ce		 mov	 ecx, esi
  00140	ff b6 80 02 00
	00		 push	 DWORD PTR [esi+640]
  00146	50		 push	 eax
  00147	57		 push	 edi
  00148	53		 push	 ebx
  00149	e8 00 00 00 00	 call	 ?__ProcessDataAttackSuccess@CActorInstance@@IAEXABUSAttackData@NRaceData@@AAV1@ABUD3DXVECTOR3@@IH@Z ; CActorInstance::__ProcessDataAttackSuccess
  0014e	5b		 pop	 ebx
  0014f	5f		 pop	 edi

; 327  : 		return TRUE;

  00150	b8 01 00 00 00	 mov	 eax, 1
  00155	5e		 pop	 esi

; 328  : 	}
; 329  : 
; 330  : 	return FALSE;
; 331  : }

  00156	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	33 cd		 xor	 ecx, ebp
  0015b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 04 00	 ret	 4
$LN2@SplashAtta:
  00166	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00169	33 c0		 xor	 eax, eax
  0016b	5b		 pop	 ebx
  0016c	5f		 pop	 edi
  0016d	33 cd		 xor	 ecx, ebp
  0016f	5e		 pop	 esi
  00170	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 04 00	 ret	 4
?__SplashAttackProcess@CActorInstance@@QAEHAAV1@@Z ENDP	; CActorInstance::__SplashAttackProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?AttackingProcess@CActorInstance@@QAEHAAV1@@Z
_TEXT	SEGMENT
_rVictim$ = 8						; size = 4
?AttackingProcess@CActorInstance@@QAEHAAV1@@Z PROC	; CActorInstance::AttackingProcess, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 481  : 	if (rVictim.__isInvisible())

  00004	8b 75 08	 mov	 esi, DWORD PTR _rVictim$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?__isInvisible@CActorInstance@@IAE_NXZ ; CActorInstance::__isInvisible
  00011	84 c0		 test	 al, al
  00013	74 08		 je	 SHORT $LN3@AttackingP

; 482  : 		return FALSE;

  00015	5f		 pop	 edi
  00016	33 c0		 xor	 eax, eax
  00018	5e		 pop	 esi

; 488  : 		return TRUE;
; 489  : 
; 490  : 	return FALSE;
; 491  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN3@AttackingP:

; 483  : 
; 484  : 	if (__SplashAttackProcess(rVictim))

  0001d	56		 push	 esi
  0001e	8b cf		 mov	 ecx, edi
  00020	e8 00 00 00 00	 call	 ?__SplashAttackProcess@CActorInstance@@QAEHAAV1@@Z ; CActorInstance::__SplashAttackProcess
  00025	85 c0		 test	 eax, eax
  00027	74 0b		 je	 SHORT $LN2@AttackingP

; 485  : 		return TRUE;

  00029	5f		 pop	 edi
  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	5e		 pop	 esi

; 488  : 		return TRUE;
; 489  : 
; 490  : 	return FALSE;
; 491  : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN2@AttackingP:

; 486  : 
; 487  : 	if (__NormalAttackProcess(rVictim))

  00034	56		 push	 esi
  00035	8b cf		 mov	 ecx, edi
  00037	e8 00 00 00 00	 call	 ?__NormalAttackProcess@CActorInstance@@QAEHAAV1@@Z ; CActorInstance::__NormalAttackProcess
  0003c	f7 d8		 neg	 eax
  0003e	5f		 pop	 edi
  0003f	1b c0		 sbb	 eax, eax
  00041	f7 d8		 neg	 eax
  00043	5e		 pop	 esi

; 488  : 		return TRUE;
; 489  : 
; 490  : 	return FALSE;
; 491  : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?AttackingProcess@CActorInstance@@QAEHAAV1@@Z ENDP	; CActorInstance::AttackingProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?TestPhysicsBlendingCollision@CActorInstance@@QAEHAAV1@@Z
_TEXT	SEGMENT
$T1 = -108						; size = 12
_prevLastPosition$1$ = -96				; size = 8
_prevPosition$4$ = -88					; size = 8
_prevPosition$ = -80					; size = 12
_c_rVictimSphere$1$ = -68				; size = 4
_pVictimList$1$ = -64					; size = 4
_i$1$ = -60						; size = 4
_prevPosition$5$ = -56					; size = 4
_prevLastPosition$2$ = -52				; size = 4
_j$1$ = -48						; size = 4
_c_rMainSphere$1$ = -44					; size = 4
_i$1$ = -40						; size = 4
tv894 = -36						; size = 4
_pMainList$1$ = -32					; size = 4
_kPPosLast$ = -28					; size = 12
_kPDelta$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_rVictim$ = 8						; size = 4
?TestPhysicsBlendingCollision@CActorInstance@@QAEHAAV1@@Z PROC ; CActorInstance::TestPhysicsBlendingCollision, COMDAT
; _this$ = ecx

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _rVictim$[ebp]
  00015	8b f1		 mov	 esi, ecx

; 495  : 	if (rVictim.IsDead())

  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?IsDead@CActorInstance@@QAEHXZ ; CActorInstance::IsDead
  0001e	85 c0		 test	 eax, eax
  00020	74 14		 je	 SHORT $LN21@TestPhysic
$LN158@TestPhysic:
  00022	5f		 pop	 edi

; 496  : 		return FALSE;

  00023	33 c0		 xor	 eax, eax
  00025	5e		 pop	 esi

; 573  : }

  00026	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00029	33 cd		 xor	 ecx, ebp
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN21@TestPhysic:

; 497  : 
; 498  : 	TPixelPosition kPPosLast;
; 499  : 	GetBlendingPosition( &kPPosLast );

  00036	8d 45 e4	 lea	 eax, DWORD PTR _kPPosLast$[ebp]
  00039	8b ce		 mov	 ecx, esi
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?GetBlendingPosition@CActorInstance@@QAEXPAUD3DXVECTOR3@@@Z ; CActorInstance::GetBlendingPosition

; 500  : 
; 501  : 	D3DXVECTOR3 v3Distance = D3DXVECTOR3(rVictim.m_x - kPPosLast.x, rVictim.m_y - kPPosLast.y, rVictim.m_z - kPPosLast.z);

  00041	f3 0f 10 8f 9c
	03 00 00	 movss	 xmm1, DWORD PTR [edi+924]
  00049	f3 0f 10 97 a0
	03 00 00	 movss	 xmm2, DWORD PTR [edi+928]
  00051	f3 0f 5c 55 e8	 subss	 xmm2, DWORD PTR _kPPosLast$[ebp+4]
  00056	f3 0f 5c 4d e4	 subss	 xmm1, DWORD PTR _kPPosLast$[ebp]
  0005b	f3 0f 10 87 a4
	03 00 00	 movss	 xmm0, DWORD PTR [edi+932]
  00063	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _kPPosLast$[ebp+8]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00068	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0006c	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00070	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00074	f3 0f 58 d1	 addss	 xmm2, xmm1
  00078	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 503  : 	if (fDistance > 800.0f*800.0f)

  0007c	0f 2f 15 00 00
	00 00		 comiss	 xmm2, DWORD PTR __real@491c4000
  00083	77 9d		 ja	 SHORT $LN158@TestPhysic

; 504  : 		return FALSE;
; 505  : 	
; 506  : 	// NOTE :   Defending Sphere Collision Check .
; 507  : 	// NOTE : Wait       .. - [levites]
; 508  : 	TCollisionPointInstanceList * pMainList;
; 509  : 	TCollisionPointInstanceList * pVictimList;
; 510  : 	if (isAttacking() || IsWaiting())

  00085	53		 push	 ebx
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?isAttacking@CActorInstance@@QAEHXZ ; CActorInstance::isAttacking
  0008d	85 c0		 test	 eax, eax
  0008f	75 19		 jne	 SHORT $LN18@TestPhysic
  00091	8b ce		 mov	 ecx, esi
  00093	e8 00 00 00 00	 call	 ?IsWaiting@CActorInstance@@QAEHXZ ; CActorInstance::IsWaiting
  00098	85 c0		 test	 eax, eax
  0009a	75 0e		 jne	 SHORT $LN18@TestPhysic

; 514  : 	}
; 515  : 	else
; 516  : 	{
; 517  : 		pMainList = &m_BodyPointInstanceList;

  0009c	8d 86 6c 02 00
	00		 lea	 eax, DWORD PTR [esi+620]

; 518  : 		pVictimList = &rVictim.m_BodyPointInstanceList;

  000a2	8d 9f 6c 02 00
	00		 lea	 ebx, DWORD PTR [edi+620]
  000a8	eb 0c		 jmp	 SHORT $LN157@TestPhysic
$LN18@TestPhysic:

; 511  : 	{
; 512  : 		pMainList = &m_DefendingPointInstanceList;

  000aa	8d 86 74 02 00
	00		 lea	 eax, DWORD PTR [esi+628]

; 513  : 		pVictimList = &rVictim.m_DefendingPointInstanceList;

  000b0	8d 9f 74 02 00
	00		 lea	 ebx, DWORD PTR [edi+628]
$LN157@TestPhysic:

; 519  : 	}
; 520  : 
; 521  : 	TPixelPosition kPDelta;
; 522  : 	m_PhysicsObject.GetLastPosition(&kPDelta);

  000b6	89 45 e0	 mov	 DWORD PTR _pMainList$1$[ebp], eax
  000b9	8d 8e b4 02 00
	00		 lea	 ecx, DWORD PTR [esi+692]
  000bf	8d 45 f0	 lea	 eax, DWORD PTR _kPDelta$[ebp]
  000c2	89 5d c0	 mov	 DWORD PTR _pVictimList$1$[ebp], ebx
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?GetLastPosition@CPhysicsObject@@QAEXPAUD3DXVECTOR3@@@Z ; CPhysicsObject::GetLastPosition
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  000cb	8b 4d e0	 mov	 ecx, DWORD PTR _pMainList$1$[ebp]
  000ce	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d0	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 44   : 		{	// construct with node pointer _Pnode

  000d2	8b 38		 mov	 edi, DWORD PTR [eax]
  000d4	8b 31		 mov	 esi, DWORD PTR [ecx]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  000d6	3b f8		 cmp	 edi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 529  : 	for (; itorMain != pMainList->end(); ++itorMain)

  000d8	0f 84 b4 01 00
	00		 je	 $LN154@TestPhysic
  000de	8b 45 e0	 mov	 eax, DWORD PTR _pMainList$1$[ebp]
$LL62@TestPhysic:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  000e1	3b f1		 cmp	 esi, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 531  : 		for (; itorVictim != pVictimList->end(); ++itorVictim)

  000e3	0f 84 9f 01 00
	00		 je	 $LN15@TestPhysic
  000e9	8d a4 24 00 00
	00 00		 npad	 7
$LL82@TestPhysic:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000f0	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 536  : 			for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  000f3	33 c9		 xor	 ecx, ecx
  000f5	89 4d d8	 mov	 DWORD PTR _i$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000f8	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000fd	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00100	2b cb		 sub	 ecx, ebx
  00102	f7 e9		 imul	 ecx
  00104	03 d1		 add	 edx, ecx
  00106	c1 fa 04	 sar	 edx, 4
  00109	8b c2		 mov	 eax, edx
  0010b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010e	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 536  : 			for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00110	0f 84 60 01 00
	00		 je	 $LN12@TestPhysic

; 532  : 		{
; 533  : 			CDynamicSphereInstanceVector & c_rMainSphereVector = (*itorMain).SphereInstanceVector;

  00116	33 c0		 xor	 eax, eax
  00118	89 45 dc	 mov	 DWORD PTR tv894[ebp], eax
  0011b	eb 03 8d 49 00	 npad	 5
$LL10@TestPhysic:

; 540  : 				prevLastPosition = c_rMainSphere.v3LastPosition;

  00120	f3 0f 7e 44 03
	0c		 movq	 xmm0, QWORD PTR [ebx+eax+12]
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00126	03 d8		 add	 ebx, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 540  : 				prevLastPosition = c_rMainSphere.v3LastPosition;

  00128	66 0f d6 45 a0	 movq	 QWORD PTR _prevLastPosition$1$[ebp], xmm0
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0012d	89 5d d4	 mov	 DWORD PTR _c_rMainSphere$1$[ebp], ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 541  : 				prevPosition	 = c_rMainSphere.v3Position;

  00130	f3 0f 7e 03	 movq	 xmm0, QWORD PTR [ebx]
  00134	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00137	66 0f d6 45 a8	 movq	 QWORD PTR _prevPosition$4$[ebp], xmm0
  0013c	66 0f d6 45 b0	 movq	 QWORD PTR _prevPosition$[ebp], xmm0

; 542  : 
; 543  : 				c_rMainSphere.v3LastPosition = prevPosition;

  00141	66 0f 7f c0	 movq	 xmm0, xmm0
  00145	89 45 cc	 mov	 DWORD PTR _prevLastPosition$2$[ebp], eax
  00148	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0014b	66 0f d6 43 0c	 movq	 QWORD PTR [ebx+12], xmm0
  00150	89 45 c8	 mov	 DWORD PTR _prevPosition$5$[ebp], eax
  00153	89 45 b8	 mov	 DWORD PTR _prevPosition$[ebp+8], eax
  00156	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 544  : 
; 545  : 				for( int i = 1; i <= nSubCheckCount; ++ i )

  00159	b8 01 00 00 00	 mov	 eax, 1
  0015e	89 45 c4	 mov	 DWORD PTR _i$1$[ebp], eax
$LL7@TestPhysic:

; 549  : 					for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  00161	66 0f 6e c0	 movd	 xmm0, eax
  00165	33 c9		 xor	 ecx, ecx
  00167	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0016a	89 4d d0	 mov	 DWORD PTR _j$1$[ebp], ecx
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0016d	f3 0f 10 65 f0	 movss	 xmm4, DWORD PTR _kPDelta$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 547  : 					c_rMainSphere.v3Position = prevPosition + (float)(i/(float)nSubCheckCount) * kPDelta;

  00172	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42480000
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0017a	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _kPDelta$[ebp+4]
  0017f	f3 0f 10 5d f8	 movss	 xmm3, DWORD PTR _kPDelta$[ebp+8]

; 183  : }
; 184  : 
; 185  : 
; 186  : // casting
; 187  : D3DXINLINE
; 188  : D3DXVECTOR3::operator FLOAT* ()
; 189  : {
; 190  :     return (FLOAT *) &x;
; 191  : }
; 192  : 
; 193  : D3DXINLINE
; 194  : D3DXVECTOR3::operator CONST FLOAT* () const
; 195  : {
; 196  :     return (CONST FLOAT *) &x;
; 197  : }
; 198  : 
; 199  : 
; 200  : // assignment operators
; 201  : D3DXINLINE D3DXVECTOR3&
; 202  : D3DXVECTOR3::operator += ( CONST D3DXVECTOR3& v )
; 203  : {
; 204  :     x += v.x;
; 205  :     y += v.y;
; 206  :     z += v.z;
; 207  :     return *this;
; 208  : }
; 209  : 
; 210  : D3DXINLINE D3DXVECTOR3&
; 211  : D3DXVECTOR3::operator -= ( CONST D3DXVECTOR3& v )
; 212  : {
; 213  :     x -= v.x;
; 214  :     y -= v.y;
; 215  :     z -= v.z;
; 216  :     return *this;
; 217  : }
; 218  : 
; 219  : D3DXINLINE D3DXVECTOR3&
; 220  : D3DXVECTOR3::operator *= ( FLOAT f )
; 221  : {
; 222  :     x *= f;
; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;
; 226  : }
; 227  : 
; 228  : D3DXINLINE D3DXVECTOR3&
; 229  : D3DXVECTOR3::operator /= ( FLOAT f )
; 230  : {
; 231  :     FLOAT fInv = 1.0f / f;
; 232  :     x *= fInv;
; 233  :     y *= fInv;
; 234  :     z *= fInv;
; 235  :     return *this;
; 236  : }
; 237  : 
; 238  : 
; 239  : // unary operators
; 240  : D3DXINLINE D3DXVECTOR3
; 241  : D3DXVECTOR3::operator + () const
; 242  : {
; 243  :     return *this;
; 244  : }
; 245  : 
; 246  : D3DXINLINE D3DXVECTOR3
; 247  : D3DXVECTOR3::operator - () const
; 248  : {
; 249  :     return D3DXVECTOR3(-x, -y, -z);
; 250  : }
; 251  : 
; 252  : 
; 253  : // binary operators
; 254  : D3DXINLINE D3DXVECTOR3
; 255  : D3DXVECTOR3::operator + ( CONST D3DXVECTOR3& v ) const
; 256  : {
; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00184	f3 0f 10 4d b4	 movss	 xmm1, DWORD PTR _prevPosition$[ebp+4]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00189	f3 0f 59 e0	 mulss	 xmm4, xmm0
  0018d	f3 0f 59 d0	 mulss	 xmm2, xmm0

; 183  : }
; 184  : 
; 185  : 
; 186  : // casting
; 187  : D3DXINLINE
; 188  : D3DXVECTOR3::operator FLOAT* ()
; 189  : {
; 190  :     return (FLOAT *) &x;
; 191  : }
; 192  : 
; 193  : D3DXINLINE
; 194  : D3DXVECTOR3::operator CONST FLOAT* () const
; 195  : {
; 196  :     return (CONST FLOAT *) &x;
; 197  : }
; 198  : 
; 199  : 
; 200  : // assignment operators
; 201  : D3DXINLINE D3DXVECTOR3&
; 202  : D3DXVECTOR3::operator += ( CONST D3DXVECTOR3& v )
; 203  : {
; 204  :     x += v.x;
; 205  :     y += v.y;
; 206  :     z += v.z;
; 207  :     return *this;
; 208  : }
; 209  : 
; 210  : D3DXINLINE D3DXVECTOR3&
; 211  : D3DXVECTOR3::operator -= ( CONST D3DXVECTOR3& v )
; 212  : {
; 213  :     x -= v.x;
; 214  :     y -= v.y;
; 215  :     z -= v.z;
; 216  :     return *this;
; 217  : }
; 218  : 
; 219  : D3DXINLINE D3DXVECTOR3&
; 220  : D3DXVECTOR3::operator *= ( FLOAT f )
; 221  : {
; 222  :     x *= f;
; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;
; 226  : }
; 227  : 
; 228  : D3DXINLINE D3DXVECTOR3&
; 229  : D3DXVECTOR3::operator /= ( FLOAT f )
; 230  : {
; 231  :     FLOAT fInv = 1.0f / f;
; 232  :     x *= fInv;
; 233  :     y *= fInv;
; 234  :     z *= fInv;
; 235  :     return *this;
; 236  : }
; 237  : 
; 238  : 
; 239  : // unary operators
; 240  : D3DXINLINE D3DXVECTOR3
; 241  : D3DXVECTOR3::operator + () const
; 242  : {
; 243  :     return *this;
; 244  : }
; 245  : 
; 246  : D3DXINLINE D3DXVECTOR3
; 247  : D3DXVECTOR3::operator - () const
; 248  : {
; 249  :     return D3DXVECTOR3(-x, -y, -z);
; 250  : }
; 251  : 
; 252  : 
; 253  : // binary operators
; 254  : D3DXINLINE D3DXVECTOR3
; 255  : D3DXVECTOR3::operator + ( CONST D3DXVECTOR3& v ) const
; 256  : {
; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00191	f3 0f 58 65 b0	 addss	 xmm4, DWORD PTR _prevPosition$[ebp]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00196	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 183  : }
; 184  : 
; 185  : 
; 186  : // casting
; 187  : D3DXINLINE
; 188  : D3DXVECTOR3::operator FLOAT* ()
; 189  : {
; 190  :     return (FLOAT *) &x;
; 191  : }
; 192  : 
; 193  : D3DXINLINE
; 194  : D3DXVECTOR3::operator CONST FLOAT* () const
; 195  : {
; 196  :     return (CONST FLOAT *) &x;
; 197  : }
; 198  : 
; 199  : 
; 200  : // assignment operators
; 201  : D3DXINLINE D3DXVECTOR3&
; 202  : D3DXVECTOR3::operator += ( CONST D3DXVECTOR3& v )
; 203  : {
; 204  :     x += v.x;
; 205  :     y += v.y;
; 206  :     z += v.z;
; 207  :     return *this;
; 208  : }
; 209  : 
; 210  : D3DXINLINE D3DXVECTOR3&
; 211  : D3DXVECTOR3::operator -= ( CONST D3DXVECTOR3& v )
; 212  : {
; 213  :     x -= v.x;
; 214  :     y -= v.y;
; 215  :     z -= v.z;
; 216  :     return *this;
; 217  : }
; 218  : 
; 219  : D3DXINLINE D3DXVECTOR3&
; 220  : D3DXVECTOR3::operator *= ( FLOAT f )
; 221  : {
; 222  :     x *= f;
; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;
; 226  : }
; 227  : 
; 228  : D3DXINLINE D3DXVECTOR3&
; 229  : D3DXVECTOR3::operator /= ( FLOAT f )
; 230  : {
; 231  :     FLOAT fInv = 1.0f / f;
; 232  :     x *= fInv;
; 233  :     y *= fInv;
; 234  :     z *= fInv;
; 235  :     return *this;
; 236  : }
; 237  : 
; 238  : 
; 239  : // unary operators
; 240  : D3DXINLINE D3DXVECTOR3
; 241  : D3DXVECTOR3::operator + () const
; 242  : {
; 243  :     return *this;
; 244  : }
; 245  : 
; 246  : D3DXINLINE D3DXVECTOR3
; 247  : D3DXVECTOR3::operator - () const
; 248  : {
; 249  :     return D3DXVECTOR3(-x, -y, -z);
; 250  : }
; 251  : 
; 252  : 
; 253  : // binary operators
; 254  : D3DXINLINE D3DXVECTOR3
; 255  : D3DXVECTOR3::operator + ( CONST D3DXVECTOR3& v ) const
; 256  : {
; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0019a	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _prevPosition$[ebp+8]
  0019f	f3 0f 58 ca	 addss	 xmm1, xmm2
  001a3	f3 0f 58 c3	 addss	 xmm0, xmm3
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 547  : 					c_rMainSphere.v3Position = prevPosition + (float)(i/(float)nSubCheckCount) * kPDelta;

  001a7	0f 14 e1	 unpcklps xmm4, xmm1
  001aa	66 0f d6 23	 movq	 QWORD PTR [ebx], xmm4
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  001ae	f3 0f 11 45 9c	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 547  : 					c_rMainSphere.v3Position = prevPosition + (float)(i/(float)nSubCheckCount) * kPDelta;

  001b3	8b 45 9c	 mov	 eax, DWORD PTR $T1[ebp+8]
  001b6	89 43 08	 mov	 DWORD PTR [ebx+8], eax
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001b9	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001be	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  001c1	2b 4e 18	 sub	 ecx, DWORD PTR [esi+24]
  001c4	f7 e9		 imul	 ecx
  001c6	03 d1		 add	 edx, ecx
  001c8	c1 fa 04	 sar	 edx, 4
  001cb	8b c2		 mov	 eax, edx
  001cd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001d0	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 549  : 					for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  001d2	74 45		 je	 SHORT $LN6@TestPhysic

; 547  : 					c_rMainSphere.v3Position = prevPosition + (float)(i/(float)nSubCheckCount) * kPDelta;

  001d4	33 db		 xor	 ebx, ebx
$LL4@TestPhysic:
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  001d6	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001d9	03 c3		 add	 eax, ebx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 553  : 						if (DetectCollisionDynamicSphereVSDynamicSphere(c_rMainSphere, c_rVictimSphere))

  001db	50		 push	 eax
  001dc	ff 75 d4	 push	 DWORD PTR _c_rMainSphere$1$[ebp]
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  001df	89 45 bc	 mov	 DWORD PTR _c_rVictimSphere$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 553  : 						if (DetectCollisionDynamicSphereVSDynamicSphere(c_rMainSphere, c_rVictimSphere))

  001e2	e8 00 00 00 00	 call	 ?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z ; DetectCollisionDynamicSphereVSDynamicSphere
  001e7	83 c4 08	 add	 esp, 8
  001ea	84 c0		 test	 al, al
  001ec	0f 85 b5 00 00
	00		 jne	 $LN137@TestPhysic
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001f2	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  001f5	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001fa	2b 4e 18	 sub	 ecx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 549  : 					for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  001fd	83 c3 1c	 add	 ebx, 28			; 0000001cH
  00200	ff 45 d0	 inc	 DWORD PTR _j$1$[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00203	f7 e9		 imul	 ecx
  00205	03 d1		 add	 edx, ecx
  00207	c1 fa 04	 sar	 edx, 4
  0020a	8b c2		 mov	 eax, edx
  0020c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0020f	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 549  : 					for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  00211	39 45 d0	 cmp	 DWORD PTR _j$1$[ebp], eax
  00214	72 c0		 jb	 SHORT $LL4@TestPhysic
  00216	8b 5d d4	 mov	 ebx, DWORD PTR _c_rMainSphere$1$[ebp]
$LN6@TestPhysic:

; 544  : 
; 545  : 				for( int i = 1; i <= nSubCheckCount; ++ i )

  00219	8b 45 c4	 mov	 eax, DWORD PTR _i$1$[ebp]
  0021c	40		 inc	 eax
  0021d	89 45 c4	 mov	 DWORD PTR _i$1$[ebp], eax
  00220	83 f8 32	 cmp	 eax, 50			; 00000032H
  00223	0f 8e 38 ff ff
	ff		 jle	 $LL7@TestPhysic

; 566  : 				c_rMainSphere.v3LastPosition = prevLastPosition;

  00229	f3 0f 7e 45 a0	 movq	 xmm0, QWORD PTR _prevLastPosition$1$[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0022e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 566  : 				c_rMainSphere.v3LastPosition = prevLastPosition;

  00233	8b 55 cc	 mov	 edx, DWORD PTR _prevLastPosition$2$[ebp]
  00236	ff 45 d8	 inc	 DWORD PTR _i$1$[ebp]
  00239	83 45 dc 1c	 add	 DWORD PTR tv894[ebp], 28 ; 0000001cH
  0023d	66 0f d6 43 0c	 movq	 QWORD PTR [ebx+12], xmm0

; 567  : 				c_rMainSphere.v3Position	 = prevPosition;

  00242	f3 0f 7e 45 a8	 movq	 xmm0, QWORD PTR _prevPosition$4$[ebp]
  00247	89 53 14	 mov	 DWORD PTR [ebx+20], edx
  0024a	8b 55 c8	 mov	 edx, DWORD PTR _prevPosition$5$[ebp]
  0024d	66 0f d6 03	 movq	 QWORD PTR [ebx], xmm0
  00251	89 53 08	 mov	 DWORD PTR [ebx+8], edx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00254	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00257	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  0025a	2b cb		 sub	 ecx, ebx
  0025c	f7 e9		 imul	 ecx
  0025e	03 d1		 add	 edx, ecx
  00260	c1 fa 04	 sar	 edx, 4
  00263	8b c2		 mov	 eax, edx
  00265	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00268	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 536  : 			for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  0026a	39 45 d8	 cmp	 DWORD PTR _i$1$[ebp], eax
  0026d	8b 45 dc	 mov	 eax, DWORD PTR tv894[ebp]
  00270	0f 82 aa fe ff
	ff		 jb	 $LL10@TestPhysic
$LN12@TestPhysic:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00276	8b 5d c0	 mov	 ebx, DWORD PTR _pVictimList$1$[ebp]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00279	8b 36		 mov	 esi, DWORD PTR [esi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0027b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0027d	3b f1		 cmp	 esi, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 531  : 		for (; itorVictim != pVictimList->end(); ++itorVictim)

  0027f	0f 85 6b fe ff
	ff		 jne	 $LL82@TestPhysic
  00285	8b 45 e0	 mov	 eax, DWORD PTR _pMainList$1$[ebp]
$LN15@TestPhysic:
; File a:\vs\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00288	8b 3f		 mov	 edi, DWORD PTR [edi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0028a	3b 38		 cmp	 edi, DWORD PTR [eax]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 529  : 	for (; itorMain != pMainList->end(); ++itorMain)

  0028c	0f 85 4f fe ff
	ff		 jne	 $LL62@TestPhysic
$LN154@TestPhysic:
  00292	5b		 pop	 ebx
  00293	5f		 pop	 edi

; 568  : 			}
; 569  : 		}
; 570  : 	}
; 571  : 
; 572  : 	return FALSE;

  00294	33 c0		 xor	 eax, eax
  00296	5e		 pop	 esi

; 573  : }

  00297	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029a	33 cd		 xor	 ecx, ebp
  0029c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a1	8b e5		 mov	 esp, ebp
  002a3	5d		 pop	 ebp
  002a4	c2 04 00	 ret	 4
$LN137@TestPhysic:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  002a7	8b 4d d4	 mov	 ecx, DWORD PTR _c_rMainSphere$1$[ebp]
  002aa	8b 45 bc	 mov	 eax, DWORD PTR _c_rVictimSphere$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 557  : 							c_rMainSphere.v3LastPosition = prevLastPosition;

  002ad	f3 0f 7e 45 a0	 movq	 xmm0, QWORD PTR _prevLastPosition$1$[ebp]
  002b2	8b 55 cc	 mov	 edx, DWORD PTR _prevLastPosition$2$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  002b5	f3 0f 10 59 04	 movss	 xmm3, DWORD PTR [ecx+4]
  002ba	f3 0f 10 21	 movss	 xmm4, DWORD PTR [ecx]
  002be	f3 0f 10 51 10	 movss	 xmm2, DWORD PTR [ecx+16]
  002c3	f3 0f 10 49 0c	 movss	 xmm1, DWORD PTR [ecx+12]
  002c8	f3 0f 5c 20	 subss	 xmm4, DWORD PTR [eax]
  002cc	f3 0f 5c 08	 subss	 xmm1, DWORD PTR [eax]
  002d0	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
  002d5	f3 0f 5c 50 04	 subss	 xmm2, DWORD PTR [eax+4]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 555  : 							BOOL bResult = GetVector3Distance(c_rMainSphere.v3Position, c_rVictimSphere.v3Position) <= GetVector3Distance(c_rMainSphere.v3LastPosition, c_rVictimSphere.v3Position);

  002da	33 c0		 xor	 eax, eax

; 557  : 							c_rMainSphere.v3LastPosition = prevLastPosition;

  002dc	66 0f d6 41 0c	 movq	 QWORD PTR [ecx+12], xmm0

; 558  : 							c_rMainSphere.v3Position	 = prevPosition;

  002e1	f3 0f 7e 45 a8	 movq	 xmm0, QWORD PTR _prevPosition$4$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  002e6	f3 0f 59 e4	 mulss	 xmm4, xmm4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 557  : 							c_rMainSphere.v3LastPosition = prevLastPosition;

  002ea	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 558  : 							c_rMainSphere.v3Position	 = prevPosition;

  002ed	8b 55 c8	 mov	 edx, DWORD PTR _prevPosition$5$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  002f0	f3 0f 59 db	 mulss	 xmm3, xmm3
  002f4	5b		 pop	 ebx
  002f5	f3 0f 59 c9	 mulss	 xmm1, xmm1
  002f9	5f		 pop	 edi
  002fa	f3 0f 59 d2	 mulss	 xmm2, xmm2
  002fe	f3 0f 58 e3	 addss	 xmm4, xmm3
  00302	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 558  : 							c_rMainSphere.v3Position	 = prevPosition;

  00303	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00307	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 573  : }

  0030a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0030d	f3 0f 58 ca	 addss	 xmm1, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 555  : 							BOOL bResult = GetVector3Distance(c_rMainSphere.v3Position, c_rVictimSphere.v3Position) <= GetVector3Distance(c_rMainSphere.v3LastPosition, c_rVictimSphere.v3Position);

  00311	0f 2f cc	 comiss	 xmm1, xmm4
  00314	0f 93 c0	 setae	 al

; 573  : }

  00317	33 cd		 xor	 ecx, ebp
  00319	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031e	8b e5		 mov	 esp, ebp
  00320	5d		 pop	 ebp
  00321	c2 04 00	 ret	 4
?TestPhysicsBlendingCollision@CActorInstance@@QAEHAAV1@@Z ENDP ; CActorInstance::TestPhysicsBlendingCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?TestActorCollision@CActorInstance@@QAEHAAV1@@Z
_TEXT	SEGMENT
_c_rVictimSphere$1$ = -24				; size = 4
_pVictimList$1$ = -20					; size = 4
_j$1$ = -16						; size = 4
_pMainList$1$ = -12					; size = 4
_i$1$ = -8						; size = 4
tv798 = -4						; size = 4
tv801 = 8						; size = 4
_rVictim$ = 8						; size = 4
?TestActorCollision@CActorInstance@@QAEHAAV1@@Z PROC	; CActorInstance::TestActorCollision, COMDAT
; _this$ = ecx

; 577  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 578  : /*
; 579  : 	if (m_pkHorse)
; 580  : 	{
; 581  : 		if (m_pkHorse->TestActorCollision(rVictim))
; 582  : 			return TRUE;
; 583  : 
; 584  : 		return FALSE;
; 585  : 	}
; 586  : */
; 587  : 
; 588  : 	if (rVictim.IsDead())

  00008	8b 7d 08	 mov	 edi, DWORD PTR _rVictim$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b cf		 mov	 ecx, edi
  0000f	e8 00 00 00 00	 call	 ?IsDead@CActorInstance@@QAEHXZ ; CActorInstance::IsDead
  00014	85 c0		 test	 eax, eax
  00016	74 0a		 je	 SHORT $LN19@TestActorC
$LN134@TestActorC:
  00018	5f		 pop	 edi

; 589  : 		return FALSE;

  00019	33 c0		 xor	 eax, eax
  0001b	5e		 pop	 esi

; 643  : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN19@TestActorC:

; 590  : 
; 591  : 	// Check Distance
; 592  : 	// NOTE :    
; 593  : 	//                 
; 594  : 	//          Body Sphere Radius     ,
; 595  : 	//             .
; 596  : 	D3DXVECTOR3 v3Distance = D3DXVECTOR3(rVictim.m_x - m_x, rVictim.m_y - m_y, rVictim.m_z - m_z);

  00022	f3 0f 10 8f 9c
	03 00 00	 movss	 xmm1, DWORD PTR [edi+924]
  0002a	f3 0f 10 97 a0
	03 00 00	 movss	 xmm2, DWORD PTR [edi+928]
  00032	f3 0f 5c 96 a0
	03 00 00	 subss	 xmm2, DWORD PTR [esi+928]
  0003a	f3 0f 5c 8e 9c
	03 00 00	 subss	 xmm1, DWORD PTR [esi+924]
  00042	f3 0f 10 87 a4
	03 00 00	 movss	 xmm0, DWORD PTR [edi+932]
  0004a	f3 0f 5c 86 a4
	03 00 00	 subss	 xmm0, DWORD PTR [esi+932]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00052	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00056	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0005a	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0005e	f3 0f 58 d1	 addss	 xmm2, xmm1
  00062	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 598  : 	if (fDistance > 800.0f*800.0f)

  00066	0f 2f 15 00 00
	00 00		 comiss	 xmm2, DWORD PTR __real@491c4000
  0006d	77 a9		 ja	 SHORT $LN134@TestActorC

; 599  : 		return FALSE;
; 600  : 	
; 601  : 	// NOTE :   Defending Sphere Collision Check .
; 602  : 	// NOTE : Wait       .. - [levites]
; 603  : 	TCollisionPointInstanceList * pMainList;
; 604  : 	TCollisionPointInstanceList * pVictimList;
; 605  : 	if (isAttacking() || IsWaiting())

  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?isAttacking@CActorInstance@@QAEHXZ ; CActorInstance::isAttacking
  00076	85 c0		 test	 eax, eax
  00078	75 19		 jne	 SHORT $LN16@TestActorC
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?IsWaiting@CActorInstance@@QAEHXZ ; CActorInstance::IsWaiting
  00081	85 c0		 test	 eax, eax
  00083	75 0e		 jne	 SHORT $LN16@TestActorC

; 609  : 	}
; 610  : 	else
; 611  : 	{
; 612  : 		pMainList = &m_BodyPointInstanceList;

  00085	8d 86 6c 02 00
	00		 lea	 eax, DWORD PTR [esi+620]

; 613  : 		pVictimList = &rVictim.m_BodyPointInstanceList;

  0008b	8d 8f 6c 02 00
	00		 lea	 ecx, DWORD PTR [edi+620]
  00091	eb 0c		 jmp	 SHORT $LN133@TestActorC
$LN16@TestActorC:

; 606  : 	{
; 607  : 		pMainList = &m_DefendingPointInstanceList;

  00093	8d 86 74 02 00
	00		 lea	 eax, DWORD PTR [esi+628]

; 608  : 		pVictimList = &rVictim.m_DefendingPointInstanceList;

  00099	8d 8f 74 02 00
	00		 lea	 ecx, DWORD PTR [edi+628]
$LN133@TestActorC:

; 606  : 	{
; 607  : 		pMainList = &m_DefendingPointInstanceList;

  0009f	89 45 f4	 mov	 DWORD PTR _pMainList$1$[ebp], eax
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 608  : 		pVictimList = &rVictim.m_DefendingPointInstanceList;

  000a4	89 4d ec	 mov	 DWORD PTR _pVictimList$1$[ebp], ecx
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  000a7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a9	53		 push	 ebx

; 44   : 		{	// construct with node pointer _Pnode

  000aa	8b 38		 mov	 edi, DWORD PTR [eax]
  000ac	8b 31		 mov	 esi, DWORD PTR [ecx]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  000ae	3b f8		 cmp	 edi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 618  : 	for (; itorMain != pMainList->end(); ++itorMain)

  000b0	0f 84 04 01 00
	00		 je	 $LN131@TestActorC
  000b6	8b 45 f4	 mov	 eax, DWORD PTR _pMainList$1$[ebp]
  000b9	8d a4 24 00 00
	00 00		 npad	 7
$LL52@TestActorC:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  000c0	3b f1		 cmp	 esi, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 619  : 	for (; itorVictim != pVictimList->end(); ++itorVictim)

  000c2	0f 84 e8 00 00
	00		 je	 $LN13@TestActorC
  000c8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL72@TestActorC:

; 624  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  000d0	33 c9		 xor	 ecx, ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000d2	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 624  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  000d7	89 4d f8	 mov	 DWORD PTR _i$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000da	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  000dd	2b 4f 18	 sub	 ecx, DWORD PTR [edi+24]
  000e0	f7 e9		 imul	 ecx
  000e2	03 d1		 add	 edx, ecx
  000e4	c1 fa 04	 sar	 edx, 4
  000e7	8b c2		 mov	 eax, edx
  000e9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ec	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 624  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  000ee	0f 84 aa 00 00
	00		 je	 $LN10@TestActorC

; 620  : 	{
; 621  : 		const CDynamicSphereInstanceVector & c_rMainSphereVector = (*itorMain).SphereInstanceVector;

  000f4	33 db		 xor	 ebx, ebx
  000f6	89 5d fc	 mov	 DWORD PTR tv798[ebp], ebx
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$LL8@TestActorC:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00100	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00103	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00108	2b 4e 18	 sub	 ecx, DWORD PTR [esi+24]
  0010b	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 625  : 		for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  0010d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _j$1$[ebp], 0
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00114	03 d1		 add	 edx, ecx
  00116	c1 fa 04	 sar	 edx, 4
  00119	8b c2		 mov	 eax, edx
  0011b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0011e	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 625  : 		for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  00120	74 51		 je	 SHORT $LN7@TestActorC
  00122	33 c0		 xor	 eax, eax
  00124	89 45 08	 mov	 DWORD PTR tv801[ebp], eax
$LL5@TestActorC:
; File a:\vs\vc\include\vector

; 1193 : 		return (*(this->_Myfirst + _Pos));

  00127	03 46 18	 add	 eax, DWORD PTR [esi+24]
  0012a	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  0012d	03 5d fc	 add	 ebx, DWORD PTR tv798[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 630  : 			if (DetectCollisionDynamicSphereVSDynamicSphere(c_rMainSphere, c_rVictimSphere))

  00130	50		 push	 eax
  00131	53		 push	 ebx
; File a:\vs\vc\include\vector

; 1193 : 		return (*(this->_Myfirst + _Pos));

  00132	89 45 e8	 mov	 DWORD PTR _c_rVictimSphere$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 630  : 			if (DetectCollisionDynamicSphereVSDynamicSphere(c_rMainSphere, c_rVictimSphere))

  00135	e8 00 00 00 00	 call	 ?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z ; DetectCollisionDynamicSphereVSDynamicSphere
  0013a	83 c4 08	 add	 esp, 8
  0013d	84 c0		 test	 al, al
  0013f	0f 85 80 00 00
	00		 jne	 $LN118@TestActorC
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00145	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00148	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0014d	2b 4e 18	 sub	 ecx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 625  : 		for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  00150	8b 5d f0	 mov	 ebx, DWORD PTR _j$1$[ebp]
  00153	83 45 08 1c	 add	 DWORD PTR tv801[ebp], 28 ; 0000001cH
  00157	43		 inc	 ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00158	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 625  : 		for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  0015a	89 5d f0	 mov	 DWORD PTR _j$1$[ebp], ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0015d	03 d1		 add	 edx, ecx
  0015f	c1 fa 04	 sar	 edx, 4
  00162	8b c2		 mov	 eax, edx
  00164	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00167	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 625  : 		for (DWORD j = 0; j < c_rVictimSphereVector.size(); ++j)

  00169	3b d8		 cmp	 ebx, eax
  0016b	8b 45 08	 mov	 eax, DWORD PTR tv801[ebp]
  0016e	72 b7		 jb	 SHORT $LL5@TestActorC
  00170	8b 5d fc	 mov	 ebx, DWORD PTR tv798[ebp]
$LN7@TestActorC:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00173	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00176	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0017b	2b 4f 18	 sub	 ecx, DWORD PTR [edi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 624  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  0017e	83 c3 1c	 add	 ebx, 28			; 0000001cH
  00181	ff 45 f8	 inc	 DWORD PTR _i$1$[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00184	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 624  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00186	89 5d fc	 mov	 DWORD PTR tv798[ebp], ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00189	03 d1		 add	 edx, ecx
  0018b	c1 fa 04	 sar	 edx, 4
  0018e	8b c2		 mov	 eax, edx
  00190	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00193	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 624  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00195	39 45 f8	 cmp	 DWORD PTR _i$1$[ebp], eax
  00198	0f 82 62 ff ff
	ff		 jb	 $LL8@TestActorC
$LN10@TestActorC:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0019e	8b 45 ec	 mov	 eax, DWORD PTR _pVictimList$1$[ebp]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  001a1	8b 36		 mov	 esi, DWORD PTR [esi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  001a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a5	3b f1		 cmp	 esi, ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 619  : 	for (; itorVictim != pVictimList->end(); ++itorVictim)

  001a7	0f 85 23 ff ff
	ff		 jne	 $LL72@TestActorC
  001ad	8b 45 f4	 mov	 eax, DWORD PTR _pMainList$1$[ebp]
$LN13@TestActorC:
; File a:\vs\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  001b0	8b 3f		 mov	 edi, DWORD PTR [edi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  001b2	3b 38		 cmp	 edi, DWORD PTR [eax]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 618  : 	for (; itorMain != pMainList->end(); ++itorMain)

  001b4	0f 85 06 ff ff
	ff		 jne	 $LL52@TestActorC
$LN131@TestActorC:
  001ba	5b		 pop	 ebx
  001bb	5f		 pop	 edi

; 634  : 				{
; 635  : 					return TRUE;
; 636  : 				}
; 637  : 				return FALSE;
; 638  : 			}
; 639  : 		}
; 640  : 	}
; 641  : 
; 642  : 	return FALSE;

  001bc	33 c0		 xor	 eax, eax
  001be	5e		 pop	 esi

; 643  : }

  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c2 04 00	 ret	 4
$LN118@TestActorC:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001c5	8b 45 e8	 mov	 eax, DWORD PTR _c_rVictimSphere$1$[ebp]
  001c8	f3 0f 10 5b 04	 movss	 xmm3, DWORD PTR [ebx+4]
  001cd	f3 0f 10 23	 movss	 xmm4, DWORD PTR [ebx]
  001d1	f3 0f 10 53 10	 movss	 xmm2, DWORD PTR [ebx+16]
  001d6	f3 0f 5c 20	 subss	 xmm4, DWORD PTR [eax]
  001da	f3 0f 10 4b 0c	 movss	 xmm1, DWORD PTR [ebx+12]
  001df	f3 0f 5c 08	 subss	 xmm1, DWORD PTR [eax]
  001e3	f3 0f 5c 58 04	 subss	 xmm3, DWORD PTR [eax+4]
  001e8	f3 0f 5c 50 04	 subss	 xmm2, DWORD PTR [eax+4]
  001ed	f3 0f 59 e4	 mulss	 xmm4, xmm4
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 633  : 					GetVector3Distance(c_rMainSphere.v3LastPosition, c_rVictimSphere.v3Position))

  001f1	33 c0		 xor	 eax, eax
  001f3	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001f4	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001f8	5f		 pop	 edi
  001f9	f3 0f 59 db	 mulss	 xmm3, xmm3
  001fd	5e		 pop	 esi
  001fe	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00202	f3 0f 58 e3	 addss	 xmm4, xmm3
  00206	f3 0f 58 ca	 addss	 xmm1, xmm2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 633  : 					GetVector3Distance(c_rMainSphere.v3LastPosition, c_rVictimSphere.v3Position))

  0020a	0f 2f cc	 comiss	 xmm1, xmm4
  0020d	0f 93 c0	 setae	 al

; 643  : }

  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c2 04 00	 ret	 4
?TestActorCollision@CActorInstance@@QAEHAAV1@@Z ENDP	; CActorInstance::TestActorCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?__TestObjectCollision@CActorInstance@@IAEHPBVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_c_pObjectInstance$ = 8					; size = 4
?__TestObjectCollision@CActorInstance@@IAEHPBVCGraphicObjectInstance@@@Z PROC ; CActorInstance::__TestObjectCollision, COMDAT
; _this$ = ecx

; 685  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 686  : 	if (m_pkHorse)

  00006	8b 81 80 04 00
	00		 mov	 eax, DWORD PTR [ecx+1152]
  0000c	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	85 c0		 test	 eax, eax
  00011	74 16		 je	 SHORT $LN11@TestObject

; 687  : 	{
; 688  : 		if (m_pkHorse->__TestObjectCollision(c_pObjectInstance))

  00013	ff 75 08	 push	 DWORD PTR _c_pObjectInstance$[ebp]
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?__TestObjectCollision@CActorInstance@@IAEHPBVCGraphicObjectInstance@@@Z ; CActorInstance::__TestObjectCollision
  0001d	f7 d8		 neg	 eax
  0001f	1b c0		 sbb	 eax, eax
  00021	f7 d8		 neg	 eax

; 723  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN11@TestObject:

; 689  : 			return TRUE;
; 690  : 
; 691  : 		return FALSE;
; 692  : 	}
; 693  : 
; 694  : 	if (m_canSkipCollision)

  00029	80 b9 90 04 00
	00 00		 cmp	 BYTE PTR [ecx+1168], 0
  00030	74 08		 je	 SHORT $LN9@TestObject
$LN69@TestObject:

; 695  : 		return FALSE;

  00032	33 c0		 xor	 eax, eax

; 723  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN9@TestObject:

; 696  : 
; 697  : 	if (m_v3Movement.x == 0.0f && m_v3Movement.y == 0.0f && m_v3Movement.z == 0.0f) 

  0003a	f3 0f 10 81 b4
	03 00 00	 movss	 xmm0, DWORD PTR [ecx+948]
  00042	0f 57 c9	 xorps	 xmm1, xmm1
  00045	0f 2e c1	 ucomiss xmm0, xmm1
  00048	9f		 lahf
  00049	f6 c4 44	 test	 ah, 68			; 00000044H
  0004c	7a 22		 jp	 SHORT $LN8@TestObject
  0004e	f3 0f 10 81 b8
	03 00 00	 movss	 xmm0, DWORD PTR [ecx+952]
  00056	0f 2e c1	 ucomiss xmm0, xmm1
  00059	9f		 lahf
  0005a	f6 c4 44	 test	 ah, 68			; 00000044H
  0005d	7a 11		 jp	 SHORT $LN8@TestObject
  0005f	f3 0f 10 81 bc
	03 00 00	 movss	 xmm0, DWORD PTR [ecx+956]
  00067	0f 2e c1	 ucomiss xmm0, xmm1
  0006a	9f		 lahf
  0006b	f6 c4 44	 test	 ah, 68			; 00000044H
  0006e	7b c2		 jnp	 SHORT $LN69@TestObject
$LN8@TestObject:
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00070	8b 81 6c 02 00
	00		 mov	 eax, DWORD PTR [ecx+620]
  00076	53		 push	 ebx
  00077	56		 push	 esi
  00078	57		 push	 edi

; 44   : 		{	// construct with node pointer _Pnode

  00079	8b 30		 mov	 esi, DWORD PTR [eax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0007b	3b f0		 cmp	 esi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 701  : 	for (; itorMain != m_BodyPointInstanceList.end(); ++itorMain)

  0007d	74 68		 je	 SHORT $LN65@TestObject
  0007f	90		 npad	 1
$LL28@TestObject:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00080	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 704  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00083	33 c9		 xor	 ecx, ecx
  00085	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00088	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0008d	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00090	2b cb		 sub	 ecx, ebx
  00092	f7 e9		 imul	 ecx
  00094	03 d1		 add	 edx, ecx
  00096	c1 fa 04	 sar	 edx, 4
  00099	8b c2		 mov	 eax, edx
  0009b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009e	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 704  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  000a0	74 38		 je	 SHORT $LN6@TestObject

; 702  : 	{
; 703  : 		const CDynamicSphereInstanceVector & c_rMainSphereVector = (*itorMain).SphereInstanceVector;

  000a2	33 ff		 xor	 edi, edi
$LL4@TestObject:

; 708  : 			if (c_pObjectInstance->MovementCollisionDynamicSphere(c_rMainSphere))

  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _c_pObjectInstance$[ebp]
; File a:\vs\vc\include\vector

; 1193 : 		return (*(this->_Myfirst + _Pos));

  000a7	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 708  : 			if (c_pObjectInstance->MovementCollisionDynamicSphere(c_rMainSphere))

  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?MovementCollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::MovementCollisionDynamicSphere
  000b0	84 c0		 test	 al, al
  000b2	75 3e		 jne	 SHORT $LN58@TestObject
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000b4	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000b7	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000bc	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 704  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  000bf	83 c7 1c	 add	 edi, 28			; 0000001cH
  000c2	ff 45 fc	 inc	 DWORD PTR _i$1$[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000c5	2b cb		 sub	 ecx, ebx
  000c7	f7 e9		 imul	 ecx
  000c9	03 d1		 add	 edx, ecx
  000cb	c1 fa 04	 sar	 edx, 4
  000ce	8b c2		 mov	 eax, edx
  000d0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000d3	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 704  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  000d5	39 45 fc	 cmp	 DWORD PTR _i$1$[ebp], eax
  000d8	72 ca		 jb	 SHORT $LL4@TestObject
$LN6@TestObject:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  000dd	8b 36		 mov	 esi, DWORD PTR [esi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  000df	3b b0 6c 02 00
	00		 cmp	 esi, DWORD PTR [eax+620]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 701  : 	for (; itorMain != m_BodyPointInstanceList.end(); ++itorMain)

  000e5	75 99		 jne	 SHORT $LL28@TestObject
$LN65@TestObject:
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi

; 715  : 				}
; 716  : 
; 717  : 				//return FALSE;
; 718  : 			}
; 719  : 		}
; 720  : 	}
; 721  : 
; 722  : 	return FALSE;

  000e9	33 c0		 xor	 eax, eax
  000eb	5b		 pop	 ebx

; 723  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 04 00	 ret	 4
$LN58@TestObject:
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi

; 709  : 			{
; 710  : 				//const D3DXVECTOR3 & c_rv3Position = c_pObjectInstance->GetPosition();
; 711  : 				//if (GetVector3Distance(c_rMainSphere.v3Position, c_rv3Position) <
; 712  : 				//	GetVector3Distance(c_rMainSphere.v3LastPosition, c_rv3Position))
; 713  : 				{
; 714  : 					return TRUE;

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	5b		 pop	 ebx

; 723  : }

  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?__TestObjectCollision@CActorInstance@@IAEHPBVCGraphicObjectInstance@@@Z ENDP ; CActorInstance::__TestObjectCollision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?BlockMovement@CActorInstance@@QAEXXZ
_TEXT	SEGMENT
?BlockMovement@CActorInstance@@QAEXXZ PROC		; CActorInstance::BlockMovement, COMDAT
; _this$ = ecx

; 675  : 	if (m_pkHorse)

  00000	8b 81 80 04 00
	00		 mov	 eax, DWORD PTR [ecx+1152]
  00006	85 c0		 test	 eax, eax
  00008	74 02		 je	 SHORT $LN1@BlockMovem

; 676  : 	{
; 677  : 		m_pkHorse->__InitializeMovement();

  0000a	8b c8		 mov	 ecx, eax
$LN1@BlockMovem:
  0000c	e9 00 00 00 00	 jmp	 ?__InitializeMovement@CActorInstance@@IAEXXZ ; CActorInstance::__InitializeMovement
?BlockMovement@CActorInstance@@QAEXXZ ENDP		; CActorInstance::BlockMovement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?IsBlockObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_c_rkBGObj$ = 8						; size = 4
?IsBlockObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z PROC ; CActorInstance::IsBlockObject, COMDAT
; _this$ = ecx

; 663  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 664  : 	if (this==&c_rkBGObj)

  00003	8b 45 08	 mov	 eax, DWORD PTR _c_rkBGObj$[ebp]
  00006	3b c8		 cmp	 ecx, eax
  00008	75 06		 jne	 SHORT $LN2@IsBlockObj

; 665  : 		return false;

  0000a	32 c0		 xor	 al, al

; 668  : 		return false;
; 669  : 	
; 670  : 	return true;
; 671  : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
$LN2@IsBlockObj:

; 666  : 	
; 667  : 	if (!__TestObjectCollision(&c_rkBGObj))

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?__TestObjectCollision@CActorInstance@@IAEHPBVCGraphicObjectInstance@@@Z ; CActorInstance::__TestObjectCollision
  00016	85 c0		 test	 eax, eax
  00018	0f 95 c0	 setne	 al

; 668  : 		return false;
; 669  : 	
; 670  : 	return true;
; 671  : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?IsBlockObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z ENDP ; CActorInstance::IsBlockObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?AvoidObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_c_rkBGObj$ = 8						; size = 4
?AvoidObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z PROC ; CActorInstance::AvoidObject, COMDAT
; _this$ = ecx

; 646  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 647  : #ifdef __MOVIE_MODE__
; 648  : 	if (IsMovieMode())
; 649  : 		return false;
; 650  : #endif	
; 651  : 
; 652  : 	if (this==&c_rkBGObj)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _c_rkBGObj$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	75 08		 jne	 SHORT $LN2@AvoidObjec
$LN5@AvoidObjec:
  0000e	5f		 pop	 edi

; 653  : 		return false;

  0000f	32 c0		 xor	 al, al
  00011	5e		 pop	 esi

; 660  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@AvoidObjec:

; 654  : 
; 655  : 	if (!__TestObjectCollision(&c_rkBGObj))

  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ?__TestObjectCollision@CActorInstance@@IAEHPBVCGraphicObjectInstance@@@Z ; CActorInstance::__TestObjectCollision
  0001c	85 c0		 test	 eax, eax
  0001e	74 ee		 je	 SHORT $LN5@AvoidObjec

; 656  : 		return false;
; 657  : 
; 658  : 	__AdjustCollisionMovement(&c_rkBGObj);

  00020	57		 push	 edi
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?__AdjustCollisionMovement@CActorInstance@@IAEXPBVCGraphicObjectInstance@@@Z ; CActorInstance::__AdjustCollisionMovement
  00028	5f		 pop	 edi

; 659  : 	return true;

  00029	b0 01		 mov	 al, 1
  0002b	5e		 pop	 esi

; 660  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?AvoidObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z ENDP ; CActorInstance::AvoidObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?UpdateAdvancingPointInstance@CActorInstance@@QAEXXZ
_TEXT	SEGMENT
_c_pCollisionData$1$ = -228				; size = 4
_this$GSCopy$1$ = -224					; size = 4
_v3Movement$ = -220					; size = 12
tv626 = -208						; size = 4
_j$1$ = -204						; size = 4
tv627 = -200						; size = 4
$T1 = -196						; size = 64
_matPoint$ = -132					; size = 64
_matCenter$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
?UpdateAdvancingPointInstance@CActorInstance@@QAEXXZ PROC ; CActorInstance::UpdateAdvancingPointInstance, COMDAT
; _this$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx
  00016	56		 push	 esi
  00017	89 9d 20 ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx

; 98   : 	//              - [levites]
; 99   : 	D3DXVECTOR3 v3Movement = m_v3Movement;

  0001d	f3 0f 7e 83 b4
	03 00 00	 movq	 xmm0, QWORD PTR [ebx+948]

; 100  : 	if (m_pkHorse)

  00025	8b 8b 80 04 00
	00		 mov	 ecx, DWORD PTR [ebx+1152]
  0002b	8b 83 bc 03 00
	00		 mov	 eax, DWORD PTR [ebx+956]
  00031	66 0f d6 85 24
	ff ff ff	 movq	 QWORD PTR _v3Movement$[ebp], xmm0
  00039	89 85 2c ff ff
	ff		 mov	 DWORD PTR _v3Movement$[ebp+8], eax
  0003f	85 c9		 test	 ecx, ecx
  00041	74 21		 je	 SHORT $LN13@UpdateAdva

; 101  : 		v3Movement = m_pkHorse->m_v3Movement;

  00043	f3 0f 7e 81 b4
	03 00 00	 movq	 xmm0, QWORD PTR [ecx+948]
  0004b	8b 81 bc 03 00
	00		 mov	 eax, DWORD PTR [ecx+956]
  00051	66 0f d6 85 24
	ff ff ff	 movq	 QWORD PTR _v3Movement$[ebp], xmm0
  00059	89 85 2c ff ff
	ff		 mov	 DWORD PTR _v3Movement$[ebp+8], eax

; 102  : 
; 103  : 	//      - [levites]
; 104  : 	if (m_pkHorse)
; 105  : 		m_pkHorse->UpdateAdvancingPointInstance();

  0005f	e8 00 00 00 00	 call	 ?UpdateAdvancingPointInstance@CActorInstance@@QAEXXZ ; CActorInstance::UpdateAdvancingPointInstance
$LN13@UpdateAdva:
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00064	8b 83 6c 02 00
	00		 mov	 eax, DWORD PTR [ebx+620]

; 44   : 		{	// construct with node pointer _Pnode

  0006a	8b 30		 mov	 esi, DWORD PTR [eax]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  0006c	3b f0		 cmp	 esi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 111  : 	for (; itor != m_BodyPointInstanceList.end(); ++itor)

  0006e	0f 84 6f 02 00
	00		 je	 $LN10@UpdateAdva
  00074	57		 push	 edi
$LL35@UpdateAdva:

; 112  : 	{
; 113  : 		TCollisionPointInstance & rInstance = *itor;
; 114  : 
; 115  : 		if (rInstance.isAttached)

  00075	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00079	0f 84 a9 00 00
	00		 je	 $LN9@UpdateAdva
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007f	8b 83 c0 01 00
	00		 mov	 eax, DWORD PTR [ebx+448]
  00085	2b 83 bc 01 00
	00		 sub	 eax, DWORD PTR [ebx+444]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 117  : 			if (rInstance.dwModelIndex>=m_LODControllerVector.size())

  0008b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0008e	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 117  : 			if (rInstance.dwModelIndex>=m_LODControllerVector.size())

  00091	3b c8		 cmp	 ecx, eax
  00093	72 23		 jb	 SHORT $LN8@UpdateAdva
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00095	8b 83 c0 01 00
	00		 mov	 eax, DWORD PTR [ebx+448]
  0009b	2b 83 bc 01 00
	00		 sub	 eax, DWORD PTR [ebx+444]
  000a1	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 120  : 					rInstance.dwModelIndex, m_LODControllerVector.size());

  000a4	50		 push	 eax
  000a5	51		 push	 ecx
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@IMNFDCHL@CActorInstance?3?3UpdateAdvancingP@
  000ab	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  : 				continue;

  000b3	e9 1c 02 00 00	 jmp	 $LN11@UpdateAdva
$LN8@UpdateAdva:

; 122  : 			}
; 123  : 
; 124  : 			CGrannyLODController* pGrnLODController=m_LODControllerVector[rInstance.dwModelIndex];

  000b8	8b 83 bc 01 00
	00		 mov	 eax, DWORD PTR [ebx+444]
  000be	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 125  : 			if (!pGrnLODController)

  000c1	85 c0		 test	 eax, eax
  000c3	75 13		 jne	 SHORT $LN7@UpdateAdva

; 126  : 			{
; 127  : 				Tracenf("CActorInstance::UpdateAdvancingPointInstance - m_LODControllerVector[rInstance.dwModelIndex=%d] is NULL", rInstance.dwModelIndex);

  000c5	51		 push	 ecx
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OFDOMPIB@CActorInstance?3?3UpdateAdvancingP@
  000cb	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  000d0	83 c4 08	 add	 esp, 8

; 128  : 				continue;

  000d3	e9 fc 01 00 00	 jmp	 $LN11@UpdateAdva
$LN7@UpdateAdva:

; 129  : 			}
; 130  : 
; 131  : 			CGrannyModelInstance * pModelInstance = pGrnLODController->GetModelInstance();

  000d8	8b c8		 mov	 ecx, eax
  000da	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance

; 132  : 			if (!pModelInstance)

  000df	85 c0		 test	 eax, eax
  000e1	0f 84 ed 01 00
	00		 je	 $LN11@UpdateAdva

; 138  : 			matCenter = *(D3DXMATRIX *)pModelInstance->GetBoneMatrixPointer(rInstance.dwBoneIndex);

  000e7	ff 76 14	 push	 DWORD PTR [esi+20]
  000ea	8b c8		 mov	 ecx, eax
  000ec	e8 00 00 00 00	 call	 ?GetBoneMatrixPointer@CGrannyModelInstance@@QBEPBMH@Z ; CGrannyModelInstance::GetBoneMatrixPointer
  000f1	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  000f5	f3 0f 7f 45 bc	 movdqu	 XMMWORD PTR _matCenter$[ebp], xmm0
  000fa	f3 0f 6f 40 10	 movdqu	 xmm0, XMMWORD PTR [eax+16]
  000ff	f3 0f 7f 45 cc	 movdqu	 XMMWORD PTR _matCenter$[ebp+16], xmm0
  00104	f3 0f 6f 40 20	 movdqu	 xmm0, XMMWORD PTR [eax+32]
  00109	f3 0f 7f 45 dc	 movdqu	 XMMWORD PTR _matCenter$[ebp+32], xmm0
  0010e	f3 0f 6f 40 30	 movdqu	 xmm0, XMMWORD PTR [eax+48]

; 139  : 			matCenter *= m_worldMatrix;

  00113	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 512  :     D3DXMatrixMultiply(this, this, &mat);

  00116	50		 push	 eax
  00117	8d 45 bc	 lea	 eax, DWORD PTR _matCenter$[ebp]
  0011a	50		 push	 eax
  0011b	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 138  : 			matCenter = *(D3DXMATRIX *)pModelInstance->GetBoneMatrixPointer(rInstance.dwBoneIndex);

  0011c	f3 0f 7f 45 ec	 movdqu	 XMMWORD PTR _matCenter$[ebp+48], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 512  :     D3DXMatrixMultiply(this, this, &mat);

  00121	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 141  : 		else

  00126	eb 2e		 jmp	 SHORT $LN5@UpdateAdva
$LN9@UpdateAdva:

; 142  : 		{
; 143  : 			matCenter = m_worldMatrix;

  00128	f3 0f 6f 43 6c	 movdqu	 xmm0, XMMWORD PTR [ebx+108]
  0012d	f3 0f 7f 45 bc	 movdqu	 XMMWORD PTR _matCenter$[ebp], xmm0
  00132	f3 0f 6f 43 7c	 movdqu	 xmm0, XMMWORD PTR [ebx+124]
  00137	f3 0f 7f 45 cc	 movdqu	 XMMWORD PTR _matCenter$[ebp+16], xmm0
  0013c	f3 0f 6f 83 8c
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [ebx+140]
  00144	f3 0f 7f 45 dc	 movdqu	 XMMWORD PTR _matCenter$[ebp+32], xmm0
  00149	f3 0f 6f 83 9c
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [ebx+156]
  00151	f3 0f 7f 45 ec	 movdqu	 XMMWORD PTR _matCenter$[ebp+48], xmm0
$LN5@UpdateAdva:

; 144  : 		}
; 145  : 
; 146  : 		// Update Collision Sphere
; 147  : 		const NRaceData::TCollisionData * c_pCollisionData = rInstance.c_pCollisionData;

  00156	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00159	89 85 1c ff ff
	ff		 mov	 DWORD PTR _c_pCollisionData$1$[ebp], eax

; 148  : 		if (c_pCollisionData)

  0015f	85 c0		 test	 eax, eax
  00161	0f 84 6d 01 00
	00		 je	 $LN11@UpdateAdva

; 150  : 			for (DWORD j = 0; j < c_pCollisionData->SphereDataVector.size(); ++j)

  00167	33 c9		 xor	 ecx, ecx
  00169	89 8d 34 ff ff
	ff		 mov	 DWORD PTR _j$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0016f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00172	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  00175	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0017a	f7 e9		 imul	 ecx
  0017c	c1 fa 03	 sar	 edx, 3
  0017f	8b c2		 mov	 eax, edx
  00181	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00184	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 150  : 			for (DWORD j = 0; j < c_pCollisionData->SphereDataVector.size(); ++j)

  00186	0f 84 48 01 00
	00		 je	 $LN11@UpdateAdva
  0018c	8b 9d 1c ff ff
	ff		 mov	 ebx, DWORD PTR _c_pCollisionData$1$[ebp]
  00192	33 ff		 xor	 edi, edi
  00194	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv627[ebp], 0
  0019e	89 bd 30 ff ff
	ff		 mov	 DWORD PTR tv626[ebp], edi
$LL3@UpdateAdva:
; File a:\vs\vc\include\vector

; 1193 : 		return (*(this->_Myfirst + _Pos));

  001a4	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  001a7	03 cf		 add	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 152  : 				const TSphereData & c = c_pCollisionData->SphereDataVector[j].GetAttribute();

  001a9	e8 00 00 00 00	 call	 ?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  001ae	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 155  : 				D3DXMatrixTranslation(&matPoint, c.v3Position.x, c.v3Position.y, c.v3Position.z);

  001b1	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  001b4	03 bd 38 ff ff
	ff		 add	 edi, DWORD PTR tv627[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 155  : 				D3DXMatrixTranslation(&matPoint, c.v3Position.x, c.v3Position.y, c.v3Position.z);

  001ba	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001bf	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001c5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001ca	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001d0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001d4	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matPoint$[ebp]
  001da	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  001e5	8d 45 bc	 lea	 eax, DWORD PTR _matCenter$[ebp]
  001e8	50		 push	 eax
  001e9	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matPoint$[ebp]
  001ef	50		 push	 eax
  001f0	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 156  : 				matPoint = matPoint * matCenter;

  001fc	f3 0f 6f 85 3c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T1[ebp]
  00204	ff 85 34 ff ff
	ff		 inc	 DWORD PTR _j$1$[ebp]
  0020a	83 85 38 ff ff
	ff 1c		 add	 DWORD PTR tv627[ebp], 28 ; 0000001cH
  00211	f3 0f 7f 85 7c
	ff ff ff	 movdqu	 XMMWORD PTR _matPoint$[ebp], xmm0
  00219	f3 0f 6f 85 4c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T1[ebp+16]
  00221	f3 0f 7f 45 8c	 movdqu	 XMMWORD PTR _matPoint$[ebp+16], xmm0
  00226	f3 0f 6f 85 5c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T1[ebp+32]
  0022e	f3 0f 7f 45 9c	 movdqu	 XMMWORD PTR _matPoint$[ebp+32], xmm0
  00233	f3 0f 6f 85 6c
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T1[ebp+48]
  0023b	f3 0f 7f 45 ac	 movdqu	 XMMWORD PTR _matPoint$[ebp+48], xmm0

; 157  : 
; 158  : 				rSphereInstance.v3LastPosition.x = matPoint._41;

  00240	f3 0f 11 47 0c	 movss	 DWORD PTR [edi+12], xmm0

; 159  : 				rSphereInstance.v3LastPosition.y = matPoint._42;

  00245	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _matPoint$[ebp+52]
  0024a	f3 0f 11 47 10	 movss	 DWORD PTR [edi+16], xmm0

; 160  : 				rSphereInstance.v3LastPosition.z = matPoint._43;

  0024f	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _matPoint$[ebp+56]
  00254	f3 0f 11 47 14	 movss	 DWORD PTR [edi+20], xmm0

; 161  : 				rSphereInstance.v3Position = rSphereInstance.v3LastPosition;

  00259	f3 0f 7e 47 0c	 movq	 xmm0, QWORD PTR [edi+12]
  0025e	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00261	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
  00265	89 47 08	 mov	 DWORD PTR [edi+8], eax
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00268	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  0026d	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00271	f3 0f 58 85 24
	ff ff ff	 addss	 xmm0, DWORD PTR _v3Movement$[ebp]
  00279	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 205  :     y += v.y;

  0027d	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  00282	f3 0f 58 85 28
	ff ff ff	 addss	 xmm0, DWORD PTR _v3Movement$[ebp+4]
  0028a	f3 0f 11 47 04	 movss	 DWORD PTR [edi+4], xmm0

; 206  :     z += v.z;

  0028f	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]
  00294	f3 0f 58 85 2c
	ff ff ff	 addss	 xmm0, DWORD PTR _v3Movement$[ebp+8]
  0029c	f3 0f 11 47 08	 movss	 DWORD PTR [edi+8], xmm0
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002a1	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  002a4	2b 4b 08	 sub	 ecx, DWORD PTR [ebx+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 150  : 			for (DWORD j = 0; j < c_pCollisionData->SphereDataVector.size(); ++j)

  002a7	8b bd 30 ff ff
	ff		 mov	 edi, DWORD PTR tv626[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002ad	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 150  : 			for (DWORD j = 0; j < c_pCollisionData->SphereDataVector.size(); ++j)

  002af	83 c7 14	 add	 edi, 20			; 00000014H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002b2	c1 fa 03	 sar	 edx, 3
  002b5	8b c2		 mov	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 150  : 			for (DWORD j = 0; j < c_pCollisionData->SphereDataVector.size(); ++j)

  002b7	89 bd 30 ff ff
	ff		 mov	 DWORD PTR tv626[ebp], edi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002bd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002c0	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 150  : 			for (DWORD j = 0; j < c_pCollisionData->SphereDataVector.size(); ++j)

  002c2	39 85 34 ff ff
	ff		 cmp	 DWORD PTR _j$1$[ebp], eax
  002c8	0f 82 d6 fe ff
	ff		 jb	 $LL3@UpdateAdva
  002ce	8b 9d 20 ff ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
$LN11@UpdateAdva:
; File a:\vs\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  002d4	8b 36		 mov	 esi, DWORD PTR [esi]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  002d6	3b b3 6c 02 00
	00		 cmp	 esi, DWORD PTR [ebx+620]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 111  : 	for (; itor != m_BodyPointInstanceList.end(); ++itor)

  002dc	0f 85 93 fd ff
	ff		 jne	 $LL35@UpdateAdva
  002e2	5f		 pop	 edi
$LN10@UpdateAdva:

; 162  : 				rSphereInstance.v3Position += v3Movement;
; 163  : 			}
; 164  : 		}
; 165  : 	}
; 166  : }

  002e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e6	5e		 pop	 esi
  002e7	33 cd		 xor	 ecx, ebp
  002e9	5b		 pop	 ebx
  002ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ef	8b e5		 mov	 esp, ebp
  002f1	5d		 pop	 ebp
  002f2	c3		 ret	 0
?UpdateAdvancingPointInstance@CActorInstance@@QAEXXZ ENDP ; CActorInstance::UpdateAdvancingPointInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?TestCollisionWithDynamicSphere@CActorInstance@@UAE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_dsi$ = 8						; size = 4
?TestCollisionWithDynamicSphere@CActorInstance@@UAE_NABUCDynamicSphereInstance@@@Z PROC ; CActorInstance::TestCollisionWithDynamicSphere, COMDAT
; _this$ = ecx

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b c1		 mov	 eax, ecx
  00008	89 45 f8	 mov	 DWORD PTR _this$1$[ebp], eax
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0000d	8b 80 6c 02 00
	00		 mov	 eax, DWORD PTR [eax+620]
  00013	57		 push	 edi

; 44   : 		{	// construct with node pointer _Pnode

  00014	8b 30		 mov	 esi, DWORD PTR [eax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00016	3b f0		 cmp	 esi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 729  : 	for (; itorMain != m_BodyPointInstanceList.end(); ++itorMain)

  00018	74 70		 je	 SHORT $LN61@TestCollis
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL24@TestCollis:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00020	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 732  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00023	33 c9		 xor	 ecx, ecx
  00025	89 4d fc	 mov	 DWORD PTR _i$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00028	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0002d	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00030	2b cb		 sub	 ecx, ebx
  00032	f7 e9		 imul	 ecx
  00034	03 d1		 add	 edx, ecx
  00036	c1 fa 04	 sar	 edx, 4
  00039	8b c2		 mov	 eax, edx
  0003b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003e	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 732  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00040	74 3b		 je	 SHORT $LN6@TestCollis

; 730  : 	{
; 731  : 		const CDynamicSphereInstanceVector & c_rMainSphereVector = (*itorMain).SphereInstanceVector;

  00042	33 ff		 xor	 edi, edi
$LL4@TestCollis:

; 736  : 			if (DetectCollisionDynamicSphereVSDynamicSphere(c_rMainSphere, dsi))

  00044	ff 75 08	 push	 DWORD PTR _dsi$[ebp]
; File a:\vs\vc\include\vector

; 1193 : 		return (*(this->_Myfirst + _Pos));

  00047	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 736  : 			if (DetectCollisionDynamicSphereVSDynamicSphere(c_rMainSphere, dsi))

  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z ; DetectCollisionDynamicSphereVSDynamicSphere
  00050	83 c4 08	 add	 esp, 8
  00053	84 c0		 test	 al, al
  00055	75 3e		 jne	 SHORT $LN54@TestCollis
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00057	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0005a	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0005f	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 732  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00062	83 c7 1c	 add	 edi, 28			; 0000001cH
  00065	ff 45 fc	 inc	 DWORD PTR _i$1$[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00068	2b cb		 sub	 ecx, ebx
  0006a	f7 e9		 imul	 ecx
  0006c	03 d1		 add	 edx, ecx
  0006e	c1 fa 04	 sar	 edx, 4
  00071	8b c2		 mov	 eax, edx
  00073	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00076	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 732  : 		for (DWORD i = 0; i < c_rMainSphereVector.size(); ++i)

  00078	39 45 fc	 cmp	 DWORD PTR _i$1$[ebp], eax
  0007b	72 c7		 jb	 SHORT $LL4@TestCollis
$LN6@TestCollis:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00080	8b 36		 mov	 esi, DWORD PTR [esi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00082	3b b0 6c 02 00
	00		 cmp	 esi, DWORD PTR [eax+620]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 729  : 	for (; itorMain != m_BodyPointInstanceList.end(); ++itorMain)

  00088	75 96		 jne	 SHORT $LL24@TestCollis
$LN61@TestCollis:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 739  : 			}
; 740  : 		}
; 741  : 	}
; 742  : 	
; 743  : 	return false;

  0008c	32 c0		 xor	 al, al
  0008e	5b		 pop	 ebx

; 744  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
$LN54@TestCollis:
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi

; 737  : 			{
; 738  : 				return true;

  00097	b0 01		 mov	 al, 1
  00099	5b		 pop	 ebx

; 744  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
?TestCollisionWithDynamicSphere@CActorInstance@@UAE_NABUCDynamicSphereInstance@@@Z ENDP ; CActorInstance::TestCollisionWithDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?CheckCollisionDetection@CActorInstance@@QAE_NPBV?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@PAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 12
_c_rAttackingSphere$1$ = -20				; size = 4
_this$1$ = -16						; size = 4
_c_rDefendingSphere$1$ = -12				; size = 4
tv509 = -12						; size = 4
tv506 = -8						; size = 4
_i$1$ = -4						; size = 4
_c_pAttackingSphereVector$ = 8				; size = 4
_pv3Position$ = 12					; size = 4
?CheckCollisionDetection@CActorInstance@@QAE_NPBV?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@PAUD3DXVECTOR3@@@Z PROC ; CActorInstance::CheckCollisionDetection, COMDAT
; _this$ = ecx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx

; 170  : 	if (!c_pAttackingSphereVector)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _c_pAttackingSphereVector$[ebp]
  0000a	8b c1		 mov	 eax, ecx
  0000c	89 45 f0	 mov	 DWORD PTR _this$1$[ebp], eax
  0000f	85 db		 test	 ebx, ebx
  00011	75 09		 jne	 SHORT $LN11@CheckColli

; 171  : 	{
; 172  : 		assert(!"CActorInstance::CheckCollisionDetection - c_pAttackingSphereVector is NULL"); //  
; 173  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	5b		 pop	 ebx

; 197  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN11@CheckColli:
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  0001c	8b 80 74 02 00
	00		 mov	 eax, DWORD PTR [eax+628]
  00022	56		 push	 esi
  00023	57		 push	 edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 177  : 	for (itor = m_DefendingPointInstanceList.begin(); itor != m_DefendingPointInstanceList.end(); ++itor)

  00024	8b 30		 mov	 esi, DWORD PTR [eax]
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00026	3b f0		 cmp	 esi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 177  : 	for (itor = m_DefendingPointInstanceList.begin(); itor != m_DefendingPointInstanceList.end(); ++itor)

  00028	0f 84 09 01 00
	00		 je	 $LN102@CheckColli
  0002e	8b ff		 npad	 2
$LL34@CheckColli:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00030	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00033	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00038	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  0003a	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 181  : 		for (DWORD i = 0; i < c_pAttackingSphereVector->size(); ++i)

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00043	03 d1		 add	 edx, ecx
  00045	c1 fa 04	 sar	 edx, 4
  00048	8b c2		 mov	 eax, edx
  0004a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004d	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 181  : 		for (DWORD i = 0; i < c_pAttackingSphereVector->size(); ++i)

  0004f	0f 84 d1 00 00
	00		 je	 $LN9@CheckColli

; 178  : 	{
; 179  : 		const CDynamicSphereInstanceVector * c_pDefendingSphereVector = &(*itor).SphereInstanceVector;

  00055	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv506[ebp], 0
  0005c	8d 64 24 00	 npad	 4
$LL7@CheckColli:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00060	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00063	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00068	2b 4e 18	 sub	 ecx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 182  : 		for (DWORD j = 0; j < c_pDefendingSphereVector->size(); ++j)

  0006b	33 db		 xor	 ebx, ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0006d	f7 e9		 imul	 ecx
  0006f	03 d1		 add	 edx, ecx
  00071	c1 fa 04	 sar	 edx, 4
  00074	8b fa		 mov	 edi, edx
  00076	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00079	03 fa		 add	 edi, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 182  : 		for (DWORD j = 0; j < c_pDefendingSphereVector->size(); ++j)

  0007b	74 7b		 je	 SHORT $LN6@CheckColli
  0007d	89 5d f4	 mov	 DWORD PTR tv509[ebp], ebx
$LL4@CheckColli:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00080	8b 4d 08	 mov	 ecx, DWORD PTR _c_pAttackingSphereVector$[ebp]
  00083	8b 01		 mov	 eax, DWORD PTR [ecx]
  00085	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00088	2b c8		 sub	 ecx, eax
  0008a	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0008f	f7 e9		 imul	 ecx
  00091	03 d1		 add	 edx, ecx
  00093	c1 fa 04	 sar	 edx, 4
  00096	8b c2		 mov	 eax, edx
  00098	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009b	03 c2		 add	 eax, edx

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)

  0009d	3b 45 fc	 cmp	 eax, DWORD PTR _i$1$[ebp]
  000a0	0f 86 f2 00 00
	00		 jbe	 $LN106@CheckColli

; 1170 : 		return (*(this->_Myfirst + _Pos));

  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _c_pAttackingSphereVector$[ebp]
  000a9	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR tv506[ebp]
  000ae	03 c8		 add	 ecx, eax
  000b0	89 4d ec	 mov	 DWORD PTR _c_rAttackingSphere$1$[ebp], ecx

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)

  000b3	3b fb		 cmp	 edi, ebx
  000b5	0f 86 dd 00 00
	00		 jbe	 $LN106@CheckColli

; 1170 : 		return (*(this->_Myfirst + _Pos));

  000bb	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000be	8b 7d f4	 mov	 edi, DWORD PTR tv509[ebp]
  000c1	03 c7		 add	 eax, edi
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 187  : 			if (DetectCollisionDynamicSphereVSDynamicSphere(c_rAttackingSphere, c_rDefendingSphere))

  000c3	50		 push	 eax
  000c4	51		 push	 ecx
; File a:\vs\vc\include\vector

; 1170 : 		return (*(this->_Myfirst + _Pos));

  000c5	89 45 f4	 mov	 DWORD PTR _c_rDefendingSphere$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 187  : 			if (DetectCollisionDynamicSphereVSDynamicSphere(c_rAttackingSphere, c_rDefendingSphere))

  000c8	e8 00 00 00 00	 call	 ?DetectCollisionDynamicSphereVSDynamicSphere@@YA_NABUCDynamicSphereInstance@@0@Z ; DetectCollisionDynamicSphereVSDynamicSphere
  000cd	83 c4 08	 add	 esp, 8
  000d0	84 c0		 test	 al, al
  000d2	75 6e		 jne	 SHORT $LN92@CheckColli
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000d4	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000d7	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000dc	2b 4e 18	 sub	 ecx, DWORD PTR [esi+24]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 182  : 		for (DWORD j = 0; j < c_pDefendingSphereVector->size(); ++j)

  000df	83 c7 1c	 add	 edi, 28			; 0000001cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000e2	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 182  : 		for (DWORD j = 0; j < c_pDefendingSphereVector->size(); ++j)

  000e4	89 7d f4	 mov	 DWORD PTR tv509[ebp], edi
  000e7	43		 inc	 ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000e8	03 d1		 add	 edx, ecx
  000ea	c1 fa 04	 sar	 edx, 4
  000ed	8b fa		 mov	 edi, edx
  000ef	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  000f2	03 fa		 add	 edi, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 182  : 		for (DWORD j = 0; j < c_pDefendingSphereVector->size(); ++j)

  000f4	3b df		 cmp	 ebx, edi
  000f6	72 88		 jb	 SHORT $LL4@CheckColli
$LN6@CheckColli:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000f8	8b 5d 08	 mov	 ebx, DWORD PTR _c_pAttackingSphereVector$[ebp]
  000fb	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 181  : 		for (DWORD i = 0; i < c_pAttackingSphereVector->size(); ++i)

  00100	8b 7d fc	 mov	 edi, DWORD PTR _i$1$[ebp]
  00103	83 45 f8 1c	 add	 DWORD PTR tv506[ebp], 28 ; 0000001cH
  00107	47		 inc	 edi
  00108	89 7d fc	 mov	 DWORD PTR _i$1$[ebp], edi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0010b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0010e	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00110	f7 e9		 imul	 ecx
  00112	03 d1		 add	 edx, ecx
  00114	c1 fa 04	 sar	 edx, 4
  00117	8b c2		 mov	 eax, edx
  00119	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0011c	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 181  : 		for (DWORD i = 0; i < c_pAttackingSphereVector->size(); ++i)

  0011e	3b f8		 cmp	 edi, eax
  00120	0f 82 3a ff ff
	ff		 jb	 $LL7@CheckColli
$LN9@CheckColli:
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00126	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00129	8b 36		 mov	 esi, DWORD PTR [esi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0012b	3b b0 74 02 00
	00		 cmp	 esi, DWORD PTR [eax+628]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 177  : 	for (itor = m_DefendingPointInstanceList.begin(); itor != m_DefendingPointInstanceList.end(); ++itor)

  00131	0f 85 f9 fe ff
	ff		 jne	 $LL34@CheckColli
$LN102@CheckColli:
  00137	5f		 pop	 edi
  00138	5e		 pop	 esi

; 192  : 			}
; 193  : 		}
; 194  : 	}
; 195  : 
; 196  : 	return false;

  00139	32 c0		 xor	 al, al
  0013b	5b		 pop	 ebx

; 197  : }

  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 08 00	 ret	 8
$LN92@CheckColli:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00142	8b 4d f4	 mov	 ecx, DWORD PTR _c_rDefendingSphere$1$[ebp]
  00145	8b 45 ec	 mov	 eax, DWORD PTR _c_rAttackingSphere$1$[ebp]

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  00148	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00150	5f		 pop	 edi

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00151	f3 0f 10 19	 movss	 xmm3, DWORD PTR [ecx]
  00155	f3 0f 58 18	 addss	 xmm3, DWORD PTR [eax]
  00159	f3 0f 10 51 04	 movss	 xmm2, DWORD PTR [ecx+4]
  0015e	f3 0f 58 50 04	 addss	 xmm2, DWORD PTR [eax+4]
  00163	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  00168	f3 0f 58 48 08	 addss	 xmm1, DWORD PTR [eax+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 190  : 				*pv3Position = (c_rAttackingSphere.v3Position + c_rDefendingSphere.v3Position) / 2.0f;

  0016d	8b 4d 0c	 mov	 ecx, DWORD PTR _pv3Position$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  00170	f3 0f 59 d8	 mulss	 xmm3, xmm0
  00174	5e		 pop	 esi
  00175	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00179	5b		 pop	 ebx
  0017a	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 190  : 				*pv3Position = (c_rAttackingSphere.v3Position + c_rDefendingSphere.v3Position) / 2.0f;

  0017e	0f 14 da	 unpcklps xmm3, xmm2
  00181	66 0f d6 19	 movq	 QWORD PTR [ecx], xmm3
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00185	f3 0f 11 4d e8	 movss	 DWORD PTR $T1[ebp+8], xmm1
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 190  : 				*pv3Position = (c_rAttackingSphere.v3Position + c_rDefendingSphere.v3Position) / 2.0f;

  0018a	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp+8]
  0018d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 191  : 				return true;

  00190	b0 01		 mov	 al, 1

; 197  : }

  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c2 08 00	 ret	 8
$LN106@CheckColli:
; File a:\vs\vc\include\vector

; 1759 : 		_Xout_of_range("invalid vector<T> subscript");

  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  0019d	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN107@CheckColli:
$LN105@CheckColli:
  001a2	cc		 int	 3
?CheckCollisionDetection@CActorInstance@@QAE_NPBV?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@PAUD3DXVECTOR3@@@Z ENDP ; CActorInstance::CheckCollisionDetection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?UpdatePointInstance@CActorInstance@@QAEXPAUSCollisionPointInstance@1@@Z
_TEXT	SEGMENT
_pModelInstance$1$ = -200				; size = 4
_matPoint$1 = -196					; size = 64
$T2 = -132						; size = 64
_matBone$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pPointInstance$ = 8					; size = 4
?UpdatePointInstance@CActorInstance@@QAEXPAUSCollisionPointInstance@1@@Z PROC ; CActorInstance::UpdatePointInstance, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _pPointInstance$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx

; 35   : 	if (!pPointInstance)

  0001a	85 db		 test	 ebx, ebx
  0001c	0f 84 89 01 00
	00		 je	 $LN1@UpdatePoin

; 36   : 	{
; 37   : 		assert(!"CActorInstance::UpdatePointInstance - pPointInstance is NULL"); //  
; 38   : 		return;
; 39   : 	}
; 40   : 
; 41   : 	D3DXMATRIX matBone;
; 42   : 
; 43   : 	if (pPointInstance->isAttached)

  00022	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00026	56		 push	 esi
  00027	0f 84 ad 00 00
	00		 je	 $LN8@UpdatePoin
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002d	8b 87 c0 01 00
	00		 mov	 eax, DWORD PTR [edi+448]
  00033	2b 87 bc 01 00
	00		 sub	 eax, DWORD PTR [edi+444]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 45   : 		if (pPointInstance->dwModelIndex>=m_LODControllerVector.size())

  00039	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0003c	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 45   : 		if (pPointInstance->dwModelIndex>=m_LODControllerVector.size())

  0003f	3b c8		 cmp	 ecx, eax
  00041	0f 83 63 01 00
	00		 jae	 $LN120@UpdatePoin

; 46   : 		{
; 47   : 			//Tracenf("CActorInstance::UpdatePointInstance - rInstance.dwModelIndex=%d >= m_LODControllerVector.size()=%d", 
; 48   : 			//		pPointInstance->dwModelIndex>m_LODControllerVector.size());
; 49   : 			return;
; 50   : 		}
; 51   : 
; 52   : 		CGrannyLODController* pGrnLODController=m_LODControllerVector[pPointInstance->dwModelIndex];

  00047	8b 87 bc 01 00
	00		 mov	 eax, DWORD PTR [edi+444]
  0004d	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]

; 53   : 		if (!pGrnLODController)

  00050	85 c9		 test	 ecx, ecx
  00052	0f 84 52 01 00
	00		 je	 $LN120@UpdatePoin

; 54   : 		{
; 55   : 			//Tracenf("CActorInstance::UpdatePointInstance - m_LODControllerVector[pPointInstance->dwModelIndex=%d] is NULL", pPointInstance->dwModelIndex);
; 56   : 			return;
; 57   : 		}
; 58   : 
; 59   : 		CGrannyModelInstance * pModelInstance = pGrnLODController->GetModelInstance();

  00058	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
  0005d	89 85 38 ff ff
	ff		 mov	 DWORD PTR _pModelInstance$1$[ebp], eax

; 60   : 		if (!pModelInstance)

  00063	85 c0		 test	 eax, eax
  00065	0f 84 3f 01 00
	00		 je	 $LN120@UpdatePoin

; 61   : 		{
; 62   : 			//Tracenf("CActorInstance::UpdatePointInstance - pGrnLODController->GetModelInstance() is NULL");
; 63   : 			return;
; 64   : 		}
; 65   : 
; 66   : 		D3DXMATRIX * pmatBone = (D3DXMATRIX *)pModelInstance->GetBoneMatrixPointer(pPointInstance->dwBoneIndex);

  0006b	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0006e	8b c8		 mov	 ecx, eax
  00070	e8 00 00 00 00	 call	 ?GetBoneMatrixPointer@CGrannyModelInstance@@QBEPBMH@Z ; CGrannyModelInstance::GetBoneMatrixPointer

; 67   : 		matBone = *(D3DXMATRIX *)pModelInstance->GetCompositeBoneMatrixPointer(pPointInstance->dwBoneIndex);

  00075	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00078	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _pModelInstance$1$[ebp]
  0007e	8b f0		 mov	 esi, eax
  00080	e8 00 00 00 00	 call	 ?GetCompositeBoneMatrixPointer@CGrannyModelInstance@@QBEPBMH@Z ; CGrannyModelInstance::GetCompositeBoneMatrixPointer
  00085	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00089	f3 0f 7f 45 bc	 movdqu	 XMMWORD PTR _matBone$[ebp], xmm0
  0008e	f3 0f 6f 40 10	 movdqu	 xmm0, XMMWORD PTR [eax+16]
  00093	f3 0f 7f 45 cc	 movdqu	 XMMWORD PTR _matBone$[ebp+16], xmm0
  00098	f3 0f 6f 40 20	 movdqu	 xmm0, XMMWORD PTR [eax+32]
  0009d	f3 0f 7f 45 dc	 movdqu	 XMMWORD PTR _matBone$[ebp+32], xmm0
  000a2	f3 0f 6f 40 30	 movdqu	 xmm0, XMMWORD PTR [eax+48]

; 71   : 		matBone *= m_worldMatrix;

  000a7	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 512  :     D3DXMatrixMultiply(this, this, &mat);

  000aa	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 67   : 		matBone = *(D3DXMATRIX *)pModelInstance->GetCompositeBoneMatrixPointer(pPointInstance->dwBoneIndex);

  000ab	f3 0f 7f 45 ec	 movdqu	 XMMWORD PTR _matBone$[ebp+48], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 512  :     D3DXMatrixMultiply(this, this, &mat);

  000b0	8d 45 bc	 lea	 eax, DWORD PTR _matBone$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 68   : 		matBone._41 = pmatBone->_41;

  000b3	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  000b8	f3 0f 11 45 ec	 movss	 DWORD PTR _matBone$[ebp+48], xmm0

; 69   : 		matBone._42 = pmatBone->_42;

  000bd	f3 0f 10 46 34	 movss	 xmm0, DWORD PTR [esi+52]
  000c2	f3 0f 11 45 f0	 movss	 DWORD PTR _matBone$[ebp+52], xmm0

; 70   : 		matBone._43 = pmatBone->_43;

  000c7	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 512  :     D3DXMatrixMultiply(this, this, &mat);

  000cc	50		 push	 eax
  000cd	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 70   : 		matBone._43 = pmatBone->_43;

  000ce	f3 0f 11 45 f4	 movss	 DWORD PTR _matBone$[ebp+56], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 512  :     D3DXMatrixMultiply(this, this, &mat);

  000d3	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 73   : 	else

  000d8	eb 2e		 jmp	 SHORT $LN4@UpdatePoin
$LN8@UpdatePoin:

; 74   : 	{
; 75   : 		matBone = m_worldMatrix;

  000da	f3 0f 6f 47 6c	 movdqu	 xmm0, XMMWORD PTR [edi+108]
  000df	f3 0f 7f 45 bc	 movdqu	 XMMWORD PTR _matBone$[ebp], xmm0
  000e4	f3 0f 6f 47 7c	 movdqu	 xmm0, XMMWORD PTR [edi+124]
  000e9	f3 0f 7f 45 cc	 movdqu	 XMMWORD PTR _matBone$[ebp+16], xmm0
  000ee	f3 0f 6f 87 8c
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [edi+140]
  000f6	f3 0f 7f 45 dc	 movdqu	 XMMWORD PTR _matBone$[ebp+32], xmm0
  000fb	f3 0f 6f 87 9c
	00 00 00	 movdqu	 xmm0, XMMWORD PTR [edi+156]
  00103	f3 0f 7f 45 ec	 movdqu	 XMMWORD PTR _matBone$[ebp+48], xmm0
$LN4@UpdatePoin:

; 76   : 	}
; 77   : 
; 78   : 	// Update Collsion Sphere
; 79   : 	CSphereCollisionInstanceVector::const_iterator sit = pPointInstance->c_pCollisionData->SphereDataVector.begin();

  00108	8b 03		 mov	 eax, DWORD PTR [ebx]
; File a:\vs\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

  0010a	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  0010d	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00110	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 81   : 	for (;sit!=pPointInstance->c_pCollisionData->SphereDataVector.end();++sit,++dit)

  00113	0f 84 91 00 00
	00		 je	 $LN120@UpdatePoin
  00119	8d a4 24 00 00
	00 00		 npad	 7
$LL38@UpdatePoin:

; 82   : 	{
; 83   : 		const TSphereData & c = sit->GetAttribute();//c_pCollisionData->SphereDataVector[j].GetAttribute();

  00120	8b cf		 mov	 ecx, edi
  00122	e8 00 00 00 00	 call	 ?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute

; 84   : 
; 85   : 		D3DXMATRIX matPoint;
; 86   : 		D3DXMatrixTranslation(&matPoint, c.v3Position.x, c.v3Position.y, c.v3Position.z);

  00127	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0012a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0012f	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00135	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0013a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00140	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00144	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matPoint$1[ebp]
  0014a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00155	8d 45 bc	 lea	 eax, DWORD PTR _matBone$[ebp]
  00158	50		 push	 eax
  00159	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matPoint$1[ebp]
  0015f	50		 push	 eax
  00160	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 89   : 		dit->v3LastPosition = dit->v3Position;

  0016c	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  00170	8d 76 1c	 lea	 esi, DWORD PTR [esi+28]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 89   : 		dit->v3LastPosition = dit->v3Position;

  00173	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  00176	83 c7 14	 add	 edi, 20			; 00000014H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 89   : 		dit->v3LastPosition = dit->v3Position;

  00179	66 0f d6 46 f0	 movq	 QWORD PTR [esi-16], xmm0

; 90   : 		dit->v3Position.x = matPoint._41;

  0017e	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR $T2[ebp+48]
  00183	f3 0f 11 46 e4	 movss	 DWORD PTR [esi-28], xmm0

; 91   : 		dit->v3Position.y = matPoint._42;

  00188	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR $T2[ebp+52]
  0018d	f3 0f 11 46 e8	 movss	 DWORD PTR [esi-24], xmm0

; 92   : 		dit->v3Position.z = matPoint._43;

  00192	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR $T2[ebp+56]
  00197	89 46 f8	 mov	 DWORD PTR [esi-8], eax
  0019a	f3 0f 11 46 ec	 movss	 DWORD PTR [esi-20], xmm0
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0019f	8b 03		 mov	 eax, DWORD PTR [ebx]
  001a1	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 81   : 	for (;sit!=pPointInstance->c_pCollisionData->SphereDataVector.end();++sit,++dit)

  001a4	0f 85 76 ff ff
	ff		 jne	 $LL38@UpdatePoin
$LN120@UpdatePoin:
  001aa	5e		 pop	 esi
$LN1@UpdatePoin:

; 93   : 	}
; 94   : }

  001ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ae	5f		 pop	 edi
  001af	33 cd		 xor	 ecx, ebp
  001b1	5b		 pop	 ebx
  001b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c2 04 00	 ret	 4
?UpdatePointInstance@CActorInstance@@QAEXPAUSCollisionPointInstance@1@@Z ENDP ; CActorInstance::UpdatePointInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\list
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?UpdatePointInstance@CActorInstance@@QAEXXZ
_TEXT	SEGMENT
?UpdatePointInstance@CActorInstance@@QAEXXZ PROC	; CActorInstance::UpdatePointInstance, COMDAT
; _this$ = ecx

; 27   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\list

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00004	8b 87 74 02 00
	00		 mov	 eax, DWORD PTR [edi+628]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 29   : 	for (itor = m_DefendingPointInstanceList.begin(); itor != m_DefendingPointInstanceList.end(); ++itor)

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
; File a:\vs\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0000c	3b f0		 cmp	 esi, eax
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 29   : 	for (itor = m_DefendingPointInstanceList.begin(); itor != m_DefendingPointInstanceList.end(); ++itor)

  0000e	74 15		 je	 SHORT $LN1@UpdatePoin
$LL26@UpdatePoin:
; File a:\vs\vc\include\list

; 543  : 		return ((reference)_Pnode->_Myval);

  00010	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 30   : 		UpdatePointInstance(&(*itor));

  00013	8b cf		 mov	 ecx, edi
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?UpdatePointInstance@CActorInstance@@QAEXPAUSCollisionPointInstance@1@@Z ; CActorInstance::UpdatePointInstance
; File a:\vs\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0001b	8b 36		 mov	 esi, DWORD PTR [esi]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0001d	3b b7 74 02 00
	00		 cmp	 esi, DWORD PTR [edi+628]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 29   : 	for (itor = m_DefendingPointInstanceList.begin(); itor != m_DefendingPointInstanceList.end(); ++itor)

  00023	75 eb		 jne	 SHORT $LL26@UpdatePoin
$LN1@UpdatePoin:
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 31   : }

  00027	c3		 ret	 0
?UpdatePointInstance@CActorInstance@@QAEXXZ ENDP	; CActorInstance::UpdatePointInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xstring
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\xstring
; File a:\vs\vc\include\xstddef
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp
;	COMDAT ?CreateCollisionInstancePiece@CActorInstance@@QAE_NKPBUSAttachingData@NRaceData@@PAUSCollisionPointInstance@1@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 12
$T2 = -48						; size = 12
_iAttachingBoneIndex$3 = -36				; size = 4
_dsi$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_dwAttachingModelIndex$ = 8				; size = 4
_c_pAttachingData$ = 12					; size = 4
_pPointInstance$ = 16					; size = 4
?CreateCollisionInstancePiece@CActorInstance@@QAE_NKPBUSAttachingData@NRaceData@@PAUSCollisionPointInstance@1@@Z PROC ; CActorInstance::CreateCollisionInstancePiece, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _dwAttachingModelIndex$[ebp]
  00013	56		 push	 esi
  00014	8b 75 10	 mov	 esi, DWORD PTR _pPointInstance$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _c_pAttachingData$[ebp]

; 201  : 	if (!c_pAttachingData)

  0001b	85 ff		 test	 edi, edi
  0001d	75 14		 jne	 SHORT $LN9@CreateColl
$LN67@CreateColl:
  0001f	5f		 pop	 edi

; 202  : 	{
; 203  : 		assert(!"CActorInstance::CreateCollisionInstancePiece - c_pAttachingData is NULL"); //  
; 204  : 		return false;

  00020	32 c0		 xor	 al, al
  00022	5e		 pop	 esi

; 260  : 	}
; 261  : 
; 262  : 	return true;
; 263  : }

  00023	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00026	33 cd		 xor	 ecx, ebp
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN9@CreateColl:

; 205  : 	}
; 206  : 
; 207  : 	if (!c_pAttachingData->pCollisionData)

  00033	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  00037	74 e6		 je	 SHORT $LN67@CreateColl

; 208  : 	{
; 209  : 		assert(!"CActorInstance::CreateCollisionInstancePiece - c_pAttachingData->pCollisionData is NULL"); //  
; 210  : 		return false;
; 211  : 	}
; 212  : 
; 213  : 	if (!pPointInstance)

  00039	85 f6		 test	 esi, esi
  0003b	74 e2		 je	 SHORT $LN67@CreateColl

; 214  : 	{
; 215  : 		assert(!"CActorInstance::CreateCollisionInstancePiece - pPointInstance is NULL"); //  
; 216  : 		return false;
; 217  : 	}
; 218  : 
; 219  : 	pPointInstance->dwModelIndex = dwAttachingModelIndex;

  0003d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 220  : 	pPointInstance->isAttached = FALSE;

  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 221  : 	pPointInstance->dwBoneIndex = 0;

  00047	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 222  : 	pPointInstance->c_pCollisionData = c_pAttachingData->pCollisionData;

  0004e	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00051	89 06		 mov	 DWORD PTR [esi], eax

; 223  : 
; 224  : 	if (c_pAttachingData->isAttaching)

  00053	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00057	74 43		 je	 SHORT $LN4@CreateColl
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00059	8b 89 bc 01 00
	00		 mov	 ecx, DWORD PTR [ecx+444]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 228  : 		CGrannyModelInstance * pModelInstance = m_LODControllerVector[dwAttachingModelIndex]->GetModelInstance();

  0005f	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  00062	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance

; 231  : 												&iAttachingBoneIndex))

  00067	85 c0		 test	 eax, eax
  00069	74 23		 je	 SHORT $LN5@CreateColl
; File a:\vs\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  0006b	83 7f 20 10	 cmp	 DWORD PTR [edi+32], 16	; 00000010H
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 231  : 												&iAttachingBoneIndex))

  0006f	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
; File a:\vs\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

  00072	72 02		 jb	 SHORT $LN18@CreateColl
; File a:\vs\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00074	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN18@CreateColl:
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 231  : 												&iAttachingBoneIndex))

  00076	8d 55 dc	 lea	 edx, DWORD PTR _iAttachingBoneIndex$3[ebp]
  00079	52		 push	 edx
  0007a	51		 push	 ecx
  0007b	8b c8		 mov	 ecx, eax
  0007d	e8 00 00 00 00	 call	 ?GetBoneIndexByName@CGrannyModelInstance@@QBE_NPBDPAH@Z ; CGrannyModelInstance::GetBoneIndexByName
  00082	84 c0		 test	 al, al
  00084	74 08		 je	 SHORT $LN5@CreateColl

; 232  : 		{
; 233  : 			pPointInstance->isAttached = TRUE;
; 234  : 			pPointInstance->dwBoneIndex = iAttachingBoneIndex;

  00086	8b 45 dc	 mov	 eax, DWORD PTR _iAttachingBoneIndex$3[ebp]
  00089	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 235  : 		}
; 236  : 		else

  0008c	eb 07		 jmp	 SHORT $LN66@CreateColl
$LN5@CreateColl:

; 240  : 			pPointInstance->dwBoneIndex = 0;

  0008e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN66@CreateColl:

; 237  : 		{
; 238  : 			//TraceError("CActorInstance::CreateCollisionInstancePiece: Cannot get matrix of bone %s ModelInstance 0x%p",	c_pAttachingData->strAttachingBoneName.c_str(), pModelInstance);
; 239  : 			pPointInstance->isAttached = TRUE;

  00095	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1
$LN4@CreateColl:

; 241  : 		}
; 242  : 	}
; 243  : 
; 244  : 
; 245  : 	const CSphereCollisionInstanceVector & c_rSphereDataVector = c_pAttachingData->pCollisionData->SphereDataVector;

  0009c	8b 7f 24	 mov	 edi, DWORD PTR [edi+36]
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0009f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a2	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000a5	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000aa	53		 push	 ebx
  000ab	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 247  : 	pPointInstance->SphereInstanceVector.clear();

  000ae	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000b1	2b 4f 08	 sub	 ecx, DWORD PTR [edi+8]
  000b4	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 248  : 	pPointInstance->SphereInstanceVector.reserve(c_rSphereDataVector.size());

  000b6	8b cb		 mov	 ecx, ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000b8	c1 fa 03	 sar	 edx, 3
  000bb	8b c2		 mov	 eax, edx
  000bd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c0	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 248  : 	pPointInstance->SphereInstanceVector.reserve(c_rSphereDataVector.size());

  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::reserve

; 255  : 	for (it = c_rSphereDataVector.begin(); it!=c_rSphereDataVector.end(); ++it)

  000c8	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  000cb	0f 57 c9	 xorps	 xmm1, xmm1
  000ce	f3 0f 10 c1	 movss	 xmm0, xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000d2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 253  : 	dsi.v3LastPosition = D3DXVECTOR3(0.0f,0.0f,0.0f);

  000d9	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp+8]
  000dc	0f 14 c1	 unpcklps xmm0, xmm1
  000df	89 45 f4	 mov	 DWORD PTR _dsi$[ebp+20], eax
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000e2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 254  : 	dsi.v3Position = D3DXVECTOR3(0.0f,0.0f,0.0f);

  000e9	8b 45 d8	 mov	 eax, DWORD PTR $T1[ebp+8]
  000ec	0f 14 c9	 unpcklps xmm1, xmm1
  000ef	66 0f d6 45 ec	 movq	 QWORD PTR _dsi$[ebp+12], xmm0
  000f4	66 0f d6 4d e0	 movq	 QWORD PTR _dsi$[ebp], xmm1
  000f9	89 45 e8	 mov	 DWORD PTR _dsi$[ebp+8], eax
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  000fc	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 255  : 	for (it = c_rSphereDataVector.begin(); it!=c_rSphereDataVector.end(); ++it)

  000ff	74 24		 je	 SHORT $LN1@CreateColl
$LL40@CreateColl:

; 256  : 	{
; 257  : 		const TSphereData & c_rSphereData = it->GetAttribute();

  00101	8b ce		 mov	 ecx, esi
  00103	e8 00 00 00 00	 call	 ?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute

; 258  : 		dsi.fRadius = c_rSphereData.fRadius;
; 259  : 		pPointInstance->SphereInstanceVector.push_back(dsi);

  00108	8b cb		 mov	 ecx, ebx
  0010a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0010f	8d 45 e0	 lea	 eax, DWORD PTR _dsi$[ebp]
  00112	50		 push	 eax
  00113	f3 0f 11 45 f8	 movss	 DWORD PTR _dsi$[ebp+24], xmm0
  00118	e8 00 00 00 00	 call	 ?push_back@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXABUCDynamicSphereInstance@@@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::push_back
; File a:\vs\vc\include\vector

; 112  : 		++this->_Ptr;

  0011d	83 c6 14	 add	 esi, 20			; 00000014H

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00120	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
; File a:\from c\desktop\serwer\source\source client\client\gamelib\actorinstancecollisiondetection.cpp

; 255  : 	for (it = c_rSphereDataVector.begin(); it!=c_rSphereDataVector.end(); ++it)

  00123	75 dc		 jne	 SHORT $LL40@CreateColl
$LN1@CreateColl:

; 260  : 	}
; 261  : 
; 262  : 	return true;
; 263  : }

  00125	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00128	b0 01		 mov	 al, 1
  0012a	5b		 pop	 ebx
  0012b	5f		 pop	 edi
  0012c	33 cd		 xor	 ecx, ebp
  0012e	5e		 pop	 esi
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 0c 00	 ret	 12			; 0000000cH
?CreateCollisionInstancePiece@CActorInstance@@QAE_NKPBUSAttachingData@NRaceData@@PAUSCollisionPointInstance@1@@Z ENDP ; CActorInstance::CreateCollisionInstancePiece
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
;	COMDAT ??1?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ PROC ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::~map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\xtree

; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ ENDP ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::~map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\map
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\map
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\map
;	COMDAT ??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@$$QAV01@@Z PROC ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >, COMDAT
; _this$ = ecx

; 158  : 		{	// construct map by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  0000c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  00013	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00018	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  0001b	89 06		 mov	 DWORD PTR [esi], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0001d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001f	89 0e		 mov	 DWORD PTR [esi], ecx

; 54   : 	_Right = _Move(_Tmp);

  00021	89 02		 mov	 DWORD PTR [edx], eax

; 52   : 	_Ty _Tmp = _Move(_Left);

  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00026	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00029	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\map

; 159  : 		}

  0002c	8b c6		 mov	 eax, esi
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  0002e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00031	5e		 pop	 esi
; File a:\vs\vc\include\map

; 159  : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@$$QAV01@@Z ENDP ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\map
;	COMDAT ??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@ABV01@@Z PROC ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >, COMDAT
; _this$ = ecx

; 109  : 		{	// construct map by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >

; 110  : 		}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@ABV01@@Z ENDP ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\map
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\map
;	COMDAT ??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ PROC ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\xtree

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax
; File a:\vs\vc\include\map

; 96   : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c3		 ret	 0
??0?$map@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@@std@@QAE@XZ ENDP ; std::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >::map<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\map
; File a:\vs\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Key, COMDAT
; _this$ = ecx

; 2239 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\map

; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File a:\vs\vc\include\xtree

; 2241 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2234 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2236 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEABQAVCActorInstance@@ABU?$pair@QAVCActorInstance@@M@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2230 : 		erase(begin(), end());

  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	ff 30		 push	 DWORD PTR [eax]
  00009	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase

; 2231 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2157 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2174 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Rrotate:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2174 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2174 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Root, COMDAT
; _this$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2144 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Lrotate:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2144 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2144 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2123 : 		return (this->_Left(this->_Myhead));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2124 : 		}

  00002	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@ABQAVCActorInstance@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@ABQAVCActorInstance@@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 2105 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2106 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN32@Lbound
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL4@Lbound:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00016	73 05		 jae	 SHORT $LN2@Lbound

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001b	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Lbound:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL4@Lbound
$LN32@Lbound:

; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate

  00027	8b c2		 mov	 eax, edx

; 2119 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@ABQAVCActorInstance@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2074 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f7		 mov	 esi, edi

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 1d		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00013	ff 76 08	 push	 DWORD PTR [esi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00028	8b fe		 mov	 edi, esi
  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e3		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx

; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1648 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Newnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 1653 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN42@lower_boun
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL6@lower_boun:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00016	73 05		 jae	 SHORT $LN4@lower_boun

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001b	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:

; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL6@lower_boun
$LN42@lower_boun:

; 44   : 		{	// construct with node pointer _Pnode

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::find, COMDAT
; _this$ = ecx

; 1548 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00004	8b 31		 mov	 esi, DWORD PTR [ecx]

; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00006	8b ce		 mov	 ecx, esi
  00008	57		 push	 edi

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00013	75 16		 jne	 SHORT $LN9@find
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00015	8b 17		 mov	 edx, DWORD PTR [edi]
$LL10@find:
  00017	39 50 10	 cmp	 DWORD PTR [eax+16], edx
; File a:\vs\vc\include\xtree

; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  0001a	73 05		 jae	 SHORT $LN8@find

; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2112 : 			else

  0001f	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:

; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;

  00021	8b c8		 mov	 ecx, eax

; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:

; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))

  00025	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00029	74 ec		 je	 SHORT $LL10@find
$LN9@find:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0002b	3b ce		 cmp	 ecx, esi

; 1553 : 					? end() : _Where);

  0002d	74 0a		 je	 SHORT $LN3@find
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
; File a:\vs\vc\include\xtree

; 1553 : 					? end() : _Where);

  00031	89 4d 0c	 mov	 DWORD PTR $T1[ebp], ecx
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  00034	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
; File a:\vs\vc\include\xtree

; 1553 : 					? end() : _Where);

  00037	73 03		 jae	 SHORT $LN82@find
$LN3@find:

; 44   : 		{	// construct with node pointer _Pnode

  00039	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
$LN82@find:

; 1553 : 					? end() : _Where);

  0003c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003f	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]
  00042	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 08		 mov	 DWORD PTR [eax], ecx

; 1554 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@ABQAVCActorInstance@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::clear, COMDAT
; _this$ = ecx

; 1535 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

  00005	8b 07		 mov	 eax, DWORD PTR [edi]
  00007	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

  0000a	8b f3		 mov	 esi, ebx

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000c	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  00010	75 1d		 jne	 SHORT $LN7@clear
$LL9@clear:

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

  00012	ff 76 08	 push	 DWORD PTR [esi+8]
  00015	8b cf		 mov	 ecx, edi
  00017	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

  0001c	8b 36		 mov	 esi, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0001e	53		 push	 ebx
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00027	8b de		 mov	 ebx, esi
  00029	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002d	74 e3		 je	 SHORT $LL9@clear
$LN7@clear:

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]

; 1541 : 		_Root() = this->_Myhead;

  00031	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1542 : 		_Lmost() = this->_Myhead;

  00034	8b 07		 mov	 eax, DWORD PTR [edi]
  00036	89 00		 mov	 DWORD PTR [eax], eax

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00038	8b 07		 mov	 eax, DWORD PTR [edi]

; 1543 : 		_Rmost() = this->_Myhead;

  0003a	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1544 : 		this->_Mysize = 0;

  0003d	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx

; 1545 : 		}

  00047	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase, COMDAT
; _this$ = ecx

; 1511 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 1512 : 		if (_First == begin() && _Last == end())

  00007	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0000e	8b 37		 mov	 esi, DWORD PTR [edi]

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00010	3b 06		 cmp	 eax, DWORD PTR [esi]

; 1512 : 		if (_First == begin() && _Last == end())

  00012	75 1a		 jne	 SHORT $LN97@erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00014	3b d6		 cmp	 edx, esi

; 1512 : 		if (_First == begin() && _Last == end())

  00016	75 16		 jne	 SHORT $LN97@erase

; 1513 : 			{	// erase all
; 1514 : 			clear();

  00018	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::clear

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 44   : 		{	// construct with node pointer _Pnode

  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx

; 1522 : 			}
; 1523 : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase:

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0002e	3b c2		 cmp	 eax, edx

; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  00030	74 5d		 je	 SHORT $LN1@erase
$LL2@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  00036	8b c8		 mov	 ecx, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00038	75 41		 jne	 SHORT $LN59@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  0003a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0003d	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00041	75 19		 jne	 SHORT $LN99@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00043	8b 02		 mov	 eax, DWORD PTR [edx]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00045	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00049	75 2d		 jne	 SHORT $LN109@erase
  0004b	eb 03 8d 49 00	 npad	 5
$LL74@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00050	8b d0		 mov	 edx, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00052	8b 02		 mov	 eax, DWORD PTR [edx]

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00054	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00058	74 f6		 je	 SHORT $LL74@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else

  0005a	eb 1c		 jmp	 SHORT $LN109@erase
$LN99@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0005c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00063	75 13		 jne	 SHORT $LN109@erase
$LL58@erase:
  00065	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00068	75 0e		 jne	 SHORT $LN109@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0006a	8b c2		 mov	 eax, edx
  0006c	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  0006f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00072	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00076	74 ed		 je	 SHORT $LL58@erase
$LN109@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00078	89 55 0c	 mov	 DWORD PTR __First$[ebp], edx
$LN59@erase:

; 1520 : 				erase(_First++);

  0007b	51		 push	 ecx
  0007c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0007f	8b cf		 mov	 ecx, edi
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00087	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0008a	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]

; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

  0008d	75 a3		 jne	 SHORT $LL2@erase
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	89 01		 mov	 DWORD PTR [ecx], eax

; 1521 : 			return (iterator(_First._Ptr, this));

  00096	8b c1		 mov	 eax, ecx

; 1522 : 			}
; 1523 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv848 = -8						; size = 4
tv827 = -8						; size = 4
__Erasednode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase, COMDAT
; _this$ = ecx

; 1328 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1328 : 		{	// erase element at _Where

  0000b	8b d9		 mov	 ebx, ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  0000d	89 45 fc	 mov	 DWORD PTR __Erasednode$1$[ebp], eax
  00010	57		 push	 edi

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00014	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00019	8b 4d fc	 mov	 ecx, DWORD PTR __Erasednode$1$[ebp]
  0001c	8b 31		 mov	 esi, DWORD PTR [ecx]

; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0001e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00022	74 05		 je	 SHORT $LN39@erase

; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00024	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00027	eb 1b		 jmp	 SHORT $LN322@erase
$LN39@erase:
  00029	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0002c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00030	74 04		 je	 SHORT $LN37@erase

; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00032	8b fe		 mov	 edi, esi

; 1349 : 		else

  00034	eb 0e		 jmp	 SHORT $LN322@erase
$LN37@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00036	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]

; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00039	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]

; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)

  0003c	3b d1		 cmp	 edx, ecx
  0003e	0f 85 83 00 00
	00		 jne	 $LN35@erase
$LN322@erase:

; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))

  00044	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00048	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0004b	75 03		 jne	 SHORT $LN34@erase

; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  0004d	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00050	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)

  00052	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00055	75 05		 jne	 SHORT $LN33@erase

; 1362 : 				_Root() = _Fixnode;	// link down from root

  00057	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  0005a	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0005c	39 0e		 cmp	 DWORD PTR [esi], ecx
  0005e	75 04		 jne	 SHORT $LN31@erase

; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00060	89 3e		 mov	 DWORD PTR [esi], edi

; 1365 : 			else

  00062	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right

  00064	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00067	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)

  00069	39 08		 cmp	 DWORD PTR [eax], ecx
  0006b	75 22		 jne	 SHORT $LN29@erase

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0006d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00071	74 04		 je	 SHORT $LN42@erase
  00073	8b d6		 mov	 edx, esi
  00075	eb 16		 jmp	 SHORT $LN43@erase
$LN42@erase:

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00077	8b 07		 mov	 eax, DWORD PTR [edi]

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00079	8b d7		 mov	 edx, edi

; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  0007b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007f	75 0a		 jne	 SHORT $LN92@erase
$LL93@erase:

; 617  : 			_Pnode = _Left(_Pnode);

  00081	8b d0		 mov	 edx, eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  00083	8b 02		 mov	 eax, DWORD PTR [edx]

; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00085	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00089	74 f6		 je	 SHORT $LL93@erase
$LN92@erase:
  0008b	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN43@erase:

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0008d	89 10		 mov	 DWORD PTR [eax], edx
$LN29@erase:

; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0008f	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)

  00091	39 48 08	 cmp	 DWORD PTR [eax+8], ecx
  00094	0f 85 8b 00 00
	00		 jne	 $LN180@erase

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  0009a	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0009e	74 0a		 je	 SHORT $LN44@erase
  000a0	8b d6		 mov	 edx, esi
  000a2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1378 : 			}
; 1379 : 		else

  000a5	e9 7b 00 00 00	 jmp	 $LN180@erase
$LN44@erase:

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  000aa	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000ad	8b d7		 mov	 edx, edi

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  000af	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000b3	75 0b		 jne	 SHORT $LN112@erase
$LL113@erase:

; 610  : 			_Pnode = _Right(_Pnode);

  000b5	8b d0		 mov	 edx, eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);

  000b7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))

  000ba	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000be	74 f5		 je	 SHORT $LL113@erase
$LN112@erase:
  000c0	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000c2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1378 : 			}
; 1379 : 		else

  000c5	eb 5e		 jmp	 SHORT $LN180@erase
$LN35@erase:

; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up

  000c7	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down

  000ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cc	89 02		 mov	 DWORD PTR [edx], eax

; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))

  000ce	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000d1	75 04		 jne	 SHORT $LN26@erase

; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000d3	8b f2		 mov	 esi, edx

; 1388 : 			else

  000d5	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))

  000d7	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000db	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000de	75 03		 jne	 SHORT $LN24@erase

; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000e0	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000e3	89 3e		 mov	 DWORD PTR [esi], edi

; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down

  000e5	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000e8	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up

  000eb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000ee	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN25@erase:

; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  000f1	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)

  000f3	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  000f6	75 05		 jne	 SHORT $LN23@erase

; 1402 : 				_Root() = _Pnode;	// link down from root

  000f8	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000fb	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:

; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  000fd	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  00100	39 08		 cmp	 DWORD PTR [eax], ecx
  00102	75 04		 jne	 SHORT $LN21@erase

; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left

  00104	89 10		 mov	 DWORD PTR [eax], edx

; 1406 : 			else

  00106	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right

  00108	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN20@erase:

; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up

  0010b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0010e	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00111	8b 45 fc	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  00114	8a 4a 0c	 mov	 cl, BYTE PTR [edx+12]
  00117	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  0011a	88 42 0c	 mov	 BYTE PTR [edx+12], al

; 54   : 	_Right = _Move(_Tmp);

  0011d	8b 45 fc	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  00120	88 48 0c	 mov	 BYTE PTR [eax+12], cl
  00123	8b c8		 mov	 ecx, eax
$LN180@erase:
; File a:\vs\vc\include\xtree

; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)

  00125	80 79 0c 01	 cmp	 BYTE PTR [ecx+12], 1
  00129	0f 85 12 01 00
	00		 jne	 $LN19@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0012f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00131	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00134	0f 84 03 01 00
	00		 je	 $LN16@erase
  0013a	8d 9b 00 00 00
	00		 npad	 6
$LL18@erase:
  00140	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  00144	0f 85 f0 00 00
	00		 jne	 $LN325@erase

; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  0014a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0014c	3b f9		 cmp	 edi, ecx
  0014e	75 70		 jne	 SHORT $LN15@erase

; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);

  00150	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1424 : 					if (this->_Color(_Pnode) == this->_Red)

  00153	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00157	75 13		 jne	 SHORT $LN14@erase

; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;

  00159	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);

  0015d	8b cb		 mov	 ecx, ebx
  0015f	56		 push	 esi
  00160	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00164	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lrotate

; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);

  00169	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN14@erase:

; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))

  0016c	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00170	0f 85 7d 00 00
	00		 jne	 $LN326@erase

; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00176	8b 01		 mov	 eax, DWORD PTR [ecx]
  00178	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0017c	75 09		 jne	 SHORT $LN11@erase
  0017e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00181	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00185	74 68		 je	 SHORT $LN327@erase
$LN11@erase:

; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)

  00187	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0018a	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0018e	75 15		 jne	 SHORT $LN9@erase

; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  00190	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);

  00192	51		 push	 ecx
  00193	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00197	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  0019b	8b cb		 mov	 ecx, ebx
  0019d	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rrotate

; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);

  001a2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN9@erase:

; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  001a5	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  001a8	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;

  001ab	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001af	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1454 : 						_Lrotate(_Fixnodeparent);

  001b2	8b cb		 mov	 ecx, ebx
  001b4	56		 push	 esi
  001b5	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001b9	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lrotate

; 1455 : 						break;	// tree now recolored/rebalanced

  001be	eb 7a		 jmp	 SHORT $LN325@erase
$LN15@erase:

; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)

  001c0	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001c4	75 12		 jne	 SHORT $LN7@erase

; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;

  001c6	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);

  001ca	8b cb		 mov	 ecx, ebx
  001cc	56		 push	 esi
  001cd	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  001d1	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rrotate

; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);

  001d6	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN7@erase:

; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))

  001d8	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001dc	75 15		 jne	 SHORT $LN326@erase

; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001de	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001e1	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001e5	75 1e		 jne	 SHORT $LN4@erase
  001e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e9	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001ed	75 16		 jne	 SHORT $LN4@erase
$LN327@erase:

; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;

  001ef	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN326@erase:

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001f3	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1476 : 						_Fixnode = _Fixnodeparent;

  001f5	8b fe		 mov	 edi, esi
  001f7	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001fa	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001fd	0f 85 3d ff ff
	ff		 jne	 $LL18@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00203	eb 35		 jmp	 SHORT $LN325@erase
$LN4@erase:

; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00205	8b 01		 mov	 eax, DWORD PTR [ecx]
  00207	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0020b	75 15		 jne	 SHORT $LN2@erase

; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  0020d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);

  00210	51		 push	 ecx
  00211	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00215	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00219	8b cb		 mov	 ecx, ebx
  0021b	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Lrotate

; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);

  00220	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN2@erase:

; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00222	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00225	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00228	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  0022c	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1491 : 						_Rrotate(_Fixnodeparent);

  0022e	8b cb		 mov	 ecx, ebx
  00230	56		 push	 esi
  00231	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00235	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Rrotate
$LN325@erase:
  0023a	8b 4d fc	 mov	 ecx, DWORD PTR __Erasednode$1$[ebp]
$LN16@erase:

; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0023d	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
$LN19@erase:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00241	51		 push	 ecx
  00242	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File a:\vs\vc\include\xtree

; 1504 : 		if (0 < this->_Mysize)

  00247	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0024a	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  0024d	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]

; 1504 : 		if (0 < this->_Mysize)

  00250	85 c0		 test	 eax, eax
  00252	74 04		 je	 SHORT $LN324@erase

; 1505 : 			--this->_Mysize;

  00254	48		 dec	 eax
  00255	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN324@erase:

; 44   : 		{	// construct with node pointer _Pnode

  00258	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5b		 pop	 ebx
  0025e	89 08		 mov	 DWORD PTR [eax], ecx

; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}

  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 1291 : 		{	// return object for comparing keys

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 		return (this->_Getcomp());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1293 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::key_comp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1277 : 		return (this->_Getal().max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1278 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::size, COMDAT
; _this$ = ecx

; 1272 : 		return (this->_Mysize);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1273 : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::end, COMDAT
; _this$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::begin, COMDAT
; _this$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::~_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >, COMDAT
; _this$ = ecx

; 1191 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
; File a:\vs\vc\include\xtree

; 1193 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::~_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
;	COMDAT ?_Assign_rv@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1119 : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
; File a:\vs\vc\include\xtree

; 1119 : 		{	// move from _Right, stealing its contents

  00008	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	8b 17		 mov	 edx, DWORD PTR [edi]
  0000e	89 07		 mov	 DWORD PTR [edi], eax

; 54   : 	_Right = _Move(_Tmp);

  00010	89 16		 mov	 DWORD PTR [esi], edx

; 52   : 	_Ty _Tmp = _Move(_Left);

  00012	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 53   : 	_Left = _Move(_Right);

  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001b	5f		 pop	 edi

; 54   : 	_Right = _Move(_Tmp);

  0001c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0001f	5e		 pop	 esi
; File a:\vs\vc\include\xtree

; 1124 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?_Assign_rv@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >, COMDAT
; _this$ = ecx

; 1094 : 		{	// construct tree by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  0000c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 773  : 		this->_Myhead = _Buyheadnode();

  00013	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  00018	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
; File a:\vs\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

  0001b	89 06		 mov	 DWORD PTR [esi], eax
; File a:\vs\vc\include\utility

; 53   : 	_Left = _Move(_Right);

  0001d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001f	89 0e		 mov	 DWORD PTR [esi], ecx

; 54   : 	_Right = _Move(_Tmp);

  00021	89 02		 mov	 DWORD PTR [edx], eax

; 52   : 	_Ty _Tmp = _Move(_Left);

  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 53   : 	_Left = _Move(_Right);

  00026	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00029	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File a:\vs\vc\include\xtree

; 1096 : 		}

  0002c	8b c6		 mov	 eax, esi
; File a:\vs\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

  0002e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00031	5e		 pop	 esi
; File a:\vs\vc\include\xtree

; 1096 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T2 = -20						; size = 1
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 4
__Right$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >, COMDAT
; _this$ = ecx

; 1083 : 		{	// construct tree by copying _Right, allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi

; 569  : 		this->_Myhead = 0;

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00036	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  0003d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00042	89 06		 mov	 DWORD PTR [esi], eax

; 1084 : 		_TRY_BEGIN
; 1085 : 		_Copy(_Right, false_type());

  00044	c6 45 ec 00	 mov	 BYTE PTR $T2[ebp], 0
  00048	8b ce		 mov	 ecx, esi
  0004a	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00054	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0005b	e8 00 00 00 00	 call	 ??$_Copy@U?$integral_constant@_N$0A@@std@@@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@IAEXABV01@U?$integral_constant@_N$0A@@1@@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Copy<std::integral_constant<bool,0> >

; 1089 : 		_CATCH_END
; 1090 : 		}

  00060	8b c6		 mov	 eax, esi
  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
__catch$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z$0:

; 1091 : 
; 1092 : 	_Tree(_Myt&& _Right)
; 1093 : 		: _Mybase(_Right.key_comp(), _Right._Getal())
; 1094 : 		{	// construct tree by moving _Right
; 1095 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1096 : 		}
; 1097 : 
; 1098 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1099 : 		: _Mybase(_Right.key_comp(), _Al)
; 1100 : 		{	// construct tree by moving _Right, allocator
; 1101 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1102 : 		}
; 1103 : 
; 1104 : 	_Myt& operator=(_Myt&& _Right)
; 1105 : 		{	// assign by moving _Right
; 1106 : 		if (this != &_Right)
; 1107 : 			{	// different, move it
; 1108 : 			clear();
; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Change_alloc(_Right._Getal());
; 1112 : 
; 1113 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1114 : 			}
; 1115 : 		return (*this);
; 1116 : 		}
; 1117 : 
; 1118 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1119 : 		{	// move from _Right, stealing its contents
; 1120 : 		this->_Swap_all(_Right);
; 1121 : 		this->_Swapcomp(_Right._Getcomp());
; 1122 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1123 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1127 : 		{	// move from _Right, possibly moving its contents
; 1128 : 		if (get_allocator() == _Right.get_allocator())
; 1129 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1130 : 		else
; 1131 : 			_Copy(_Right, true_type());
; 1132 : 		}
; 1133 : 
; 1134 : 	void _Assign_rv(_Myt&& _Right)
; 1135 : 		{	// assign by moving _Right
; 1136 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1137 : 			typename _Alty::propagate_on_container_move_assignment());
; 1138 : 		}
; 1139 : 
; 1140 : 
; 1141 : 	_Pairib insert(value_type&& _Val)
; 1142 : 		{	// try to insert node with value _Val, favoring right side
; 1143 : 		return (_Insert_nohint(false,
; 1144 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1145 : 		}
; 1146 : 
; 1147 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1148 : 		{	// try to insert node with value _Val using _Where as a hint
; 1149 : 		return (_Insert_hint(_Where,
; 1150 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1151 : 		}
; 1152 : 
; 1153 : 	template<class _Valty>
; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));
; 1161 : 		}
; 1162 : 
; 1163 : 	template<class _Valty>
; 1164 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1165 : 			iterator>::type
; 1166 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1167 : 		{	// try to insert node with value _Val using _Where as a hint
; 1168 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1169 : 		return (_Insert_hint(_Where,
; 1170 : 			this->_Myval(_Newnode), _Newnode));
; 1171 : 		}
; 1172 : 
; 1173 : 	template<class... _Valty>
; 1174 : 		_Pairib emplace(_Valty&&... _Val)
; 1175 : 		{	// try to insert value_type(_Val...), favoring right side
; 1176 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1177 : 		return (_Insert_nohint(false,
; 1178 : 			this->_Myval(_Newnode), _Newnode));
; 1179 : 		}
; 1180 : 
; 1181 : 	template<class... _Valty>
; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));
; 1187 : 		}
; 1188 : 
; 1189 : 
; 1190 : 	~_Tree() _NOEXCEPT
; 1191 : 		{	// destroy tree
; 1192 : 		_Tidy();
; 1193 : 		}
; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

  00076	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007b	50		 push	 eax
  0007c	ff 30		 push	 DWORD PTR [eax]
  0007e	8d 45 08	 lea	 eax, DWORD PTR $T3[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::erase

; 1086 : 		_CATCH_ALL
; 1087 : 		_Tidy();
; 1088 : 		_RERAISE;

  00087	6a 00		 push	 0
  00089	6a 00		 push	 0
  0008b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN51@Tree:
$LN50@Tree:
  00090	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z$2:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >, COMDAT
; _this$ = ecx

; 1066 : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1067 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree<std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::~_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::~_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Swapcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXABU?$less@PAVCActorInstance@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swapcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXABU?$less@PAVCActorInstance@@@2@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Swapcomp, COMDAT
; _this$ = ecx

; 1016 : 		}

  00000	c2 04 00	 ret	 4
?_Swapcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAEXABU?$less@PAVCActorInstance@@@2@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Swapcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1006 : 		{	// get ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 		return (key_compare());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QBE?AU?$less@PAVCActorInstance@@@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// construct ordering predicate

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1003 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@PAVCActorInstance@@MU?$less@PAVCActorInstance@@@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCActorInstance@@@1@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >::_Tree_comp<0,std::_Tmap_traits<CActorInstance *,float,std::less<CActorInstance *>,std::allocator<std::pair<CActorInstance * const,float> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??1?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::~_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >, COMDAT
; _this$ = ecx

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::~_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Freenode0, COMDAT
; _this$ = ecx

; 912  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 920  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ PROC ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode0, COMDAT
; _this$ = ecx

; 893  : 		{	// allocate a non-value node

  00000	56		 push	 esi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00001	6a 18		 push	 24			; 00000018H
; File a:\vs\vc\include\xtree

; 893  : 		{	// allocate a non-value node

  00003	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	8b d0		 mov	 edx, eax
  0000c	83 c4 04	 add	 esp, 4
  0000f	85 d2		 test	 edx, edx
  00011	74 1e		 je	 SHORT $LN96@Buynode0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00015	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 04		 je	 SHORT $LN61@Buynode0
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buynode0:
; File a:\vs\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00022	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00025	85 c9		 test	 ecx, ecx
  00027	74 04		 je	 SHORT $LN83@Buynode0
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buynode0:
; File a:\vs\vc\include\xtree

; 908  : 		return (_Pnode);

  0002d	8b c2		 mov	 eax, edx
  0002f	5e		 pop	 esi

; 909  : 		}

  00030	c3		 ret	 0
$LN96@Buynode0:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN98@Buynode0:
$LN95@Buynode0:
  00036	cc		 int	 3
?_Buynode0@?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ENDP ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >, COMDAT
; _this$ = ecx

; 889  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 890  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_buy@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >::_Tree_buy<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Getal, COMDAT
; _this$ = ecx

; 868  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 857  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\xtree

; 865  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode, COMDAT
; _this$ = ecx
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 18		 push	 24			; 00000018H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 00 00 00
	00		 je	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
; File a:\vs\vc\include\xtree

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00012	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	85 c9		 test	 ecx, ecx
  00019	74 02		 je	 SHORT $LN61@Buyheadnod
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buyheadnod:
; File a:\vs\vc\include\xtree

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  0001d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN83@Buyheadnod
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buyheadnod:
; File a:\vs\vc\include\xtree

; 851  : 		this->_Color(_Pnode) = this->_Black;

  00026	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}

  0002c	c3		 ret	 0
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File a:\vs\vc\include\xtree

; 779  : 		}

  00008	c3		 ret	 0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >, COMDAT
; _this$ = ecx

; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 569  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 570  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 774  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@QAVCActorInstance@@M@std@@V?$allocator@U?$pair@QAVCActorInstance@@M@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCActorInstance@@M@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<CActorInstance * const,float>,std::allocator<std::pair<CActorInstance * const,float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Min, COMDAT

; 615  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 0c		 jne	 SHORT $LN15@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 617  : 			_Pnode = _Left(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN15@Min:

; 618  : 		return (_Pnode);

  0001a	8b c1		 mov	 eax, ecx

; 619  : 		}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Max, COMDAT

; 608  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00009	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000d	75 0c		 jne	 SHORT $LN15@Max
  0000f	90		 npad	 1
$LL2@Max:

; 610  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 609  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 611  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 612  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAU?$pair@QAVCActorInstance@@M@2@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAU?$pair@QAVCActorInstance@@M@2@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Myval, COMDAT

; 603  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 604  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 605  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAU?$pair@QAVCActorInstance@@M@2@PAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Right, COMDAT

; 598  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 600  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Parent, COMDAT

; 593  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 595  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Left, COMDAT

; 588  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 590  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Isnil, COMDAT

; 583  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 585  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Color, COMDAT

; 578  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  : 		return ((char&)_Pnode->_Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 580  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >, COMDAT
; _this$ = ecx

; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 570  : 		this->_Mysize = 0;
; 571  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCActorInstance@@M@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >::_Tree_val<std::_Tree_simple_types<std::pair<CActorInstance * const,float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00011	77 1b		 ja	 SHORT $LN14@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 03	 shl	 eax, 3
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00028	8b c1		 mov	 eax, ecx

; 848  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00033	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >, COMDAT
; _this$ = ecx

; 807  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00011	77 1b		 ja	 SHORT $LN11@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 03	 shl	 eax, 3
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00028	8b c1		 mov	 eax, ecx

; 579  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00033	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBE?AV12@XZ PROC ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 533  : 		return (*this);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$allocator@U?$_Tree_node@U?$pair@QAVCActorInstance@@M@std@@PAX@std@@@std@@QBE?AV12@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<CActorInstance * const,float>,void *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<CActorInstance * const,float> >::allocator<std::pair<CActorInstance * const,float> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$pair@QAVCActorInstance@@M@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<CActorInstance * const,float> >::allocator<std::pair<CActorInstance * const,float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??R?$less@PAVCActorInstance@@@std@@QBE_NABQAVCActorInstance@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVCActorInstance@@@std@@QBE_NABQAVCActorInstance@@0@Z PROC ; std::less<CActorInstance *>::operator(), COMDAT
; _this$ = ecx

; 192  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	1b c0		 sbb	 eax, eax
  0000f	f7 d8		 neg	 eax

; 194  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??R?$less@PAVCActorInstance@@@std@@QBE_NABQAVCActorInstance@@0@Z ENDP ; std::less<CActorInstance *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ?end@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ PROC ; std::list<CActorInstance::SCollisionPointInstance,std::allocator<CActorInstance::SCollisionPointInstance> >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 		return (iterator(this->_Myhead, this));
; 1127 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ ENDP ; std::list<CActorInstance::SCollisionPointInstance,std::allocator<CActorInstance::SCollisionPointInstance> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ?begin@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ PROC ; std::list<CActorInstance::SCollisionPointInstance,std::allocator<CActorInstance::SCollisionPointInstance> >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 475  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 476  : 
; 477  : 
; 478  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 479  : 		_Voidptr;
; 480  : 	typedef _List_node<typename _Alty::value_type,
; 481  : 		_Voidptr> _Node;
; 482  : 
; 483  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 484  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 485  : 	typedef _Nodeptr& _Nodepref;
; 486  : 
; 487  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 488  : 		_List_simple_types<typename _Alty::value_type>,
; 489  : 		_List_iter_types<typename _Alty::value_type,
; 490  : 			typename _Alty::size_type,
; 491  : 			typename _Alty::difference_type,
; 492  : 			typename _Alty::pointer,
; 493  : 			typename _Alty::const_pointer,
; 494  : 			typename _Alty::reference,
; 495  : 			typename _Alty::const_reference,
; 496  : 			_Nodeptr> >::type
; 497  : 		_Val_types;
; 498  : 	};
; 499  : 
; 500  : 		// TEMPLATE CLASS _List_val
; 501  : template<class _Val_types>
; 502  : 	class _List_val
; 503  : 		: public _Container_base
; 504  : 	{	// base class for list to hold data
; 505  : public:
; 506  : 	typedef _List_val<_Val_types> _Myt;
; 507  : 
; 508  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 509  : 	typedef _Nodeptr& _Nodepref;
; 510  : 
; 511  : 	typedef typename _Val_types::value_type value_type;
; 512  : 	typedef typename _Val_types::size_type size_type;
; 513  : 	typedef typename _Val_types::difference_type difference_type;
; 514  : 	typedef typename _Val_types::pointer pointer;
; 515  : 	typedef typename _Val_types::const_pointer const_pointer;
; 516  : 	typedef typename _Val_types::reference reference;
; 517  : 	typedef typename _Val_types::const_reference const_reference;
; 518  : 
; 519  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 520  : 	typedef _List_iterator<_Myt> iterator;
; 521  : 
; 522  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 523  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 524  : 
; 525  : 	_List_val()
; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;
; 528  : 		this->_Mysize = 0;
; 529  : 		}
; 530  : 
; 531  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 532  : 		{	// return reference to successor pointer in node
; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 44   : 		{	// construct with node pointer _Pnode

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1117 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@USCollisionPointInstance@CActorInstance@@V?$allocator@USCollisionPointInstance@CActorInstance@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@@2@XZ ENDP ; std::list<CActorInstance::SCollisionPointInstance,std::allocator<CActorInstance::SCollisionPointInstance> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAUSCollisionPointInstance@CActorInstance@@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAUSCollisionPointInstance@CActorInstance@@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >::_Myval, COMDAT

; 542  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 543  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 544  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAUSCollisionPointInstance@CActorInstance@@PAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAPAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAPAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >::_Nextnode, COMDAT

; 532  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 533  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 534  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@USCollisionPointInstance@CActorInstance@@@std@@@std@@SAAAPAU?$_List_node@USCollisionPointInstance@CActorInstance@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<CActorInstance::SCollisionPointInstance> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXPAUCDynamicSphereInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXPAUCDynamicSphereInstance@@0@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXPAUCDynamicSphereInstance@@0@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xran@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xran@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Xran, COMDAT
; _this$ = ecx

; 1759 : 		_Xout_of_range("invalid vector<T> subscript");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00008	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000d	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00010	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00013	2b f3		 sub	 esi, ebx
  00015	f7 ee		 imul	 esi
  00017	03 d6		 add	 edx, esi

; 1613 : 		if (_Unused_capacity() < _Count)

  00019	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]

; 1015 : 		return (this->_Myend - this->_Mylast);

  0001c	c1 fa 04	 sar	 edx, 4
  0001f	8b ca		 mov	 ecx, edx
  00021	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00024	03 ca		 add	 ecx, edx

; 1613 : 		if (_Unused_capacity() < _Count)

  00026	3b ce		 cmp	 ecx, esi
  00028	73 33		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002a	2b 1f		 sub	 ebx, DWORD PTR [edi]
  0002c	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00031	f7 eb		 imul	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00033	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00038	03 d3		 add	 edx, ebx
  0003a	c1 fa 04	 sar	 edx, 4
  0003d	8b ca		 mov	 ecx, edx
  0003f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00042	03 ca		 add	 ecx, edx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00044	2b c1		 sub	 eax, ecx
  00046	3b c6		 cmp	 eax, esi
  00048	72 1a		 jb	 SHORT $LN25@Reserve

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004a	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0004d	8b cf		 mov	 ecx, edi
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?_Grow_to@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEII@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Grow_to
  00055	50		 push	 eax
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reallocate
$LN2@Reserve:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 1618 : 			}
; 1619 : 		}

  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
$LN25@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00069	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN27@Reserve:
$LN24@Reserve:
  0006e	cc		 int	 3
?_Reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Ptr$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Size$1$ = 8						; size = 4
__Cat$3 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$4 = 11						; size = 1
?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00030	33 f6		 xor	 esi, esi
  00032	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00035	85 ff		 test	 edi, edi
  00037	74 2b		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00039	81 ff 49 92 24
	09		 cmp	 edi, 153391689		; 09249249H
  0003f	77 1e		 ja	 SHORT $LN15@Reallocate
  00041	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  00048	2b c7		 sub	 eax, edi
  0004a	c1 e0 02	 shl	 eax, 2
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00053	8b f0		 mov	 esi, eax
  00055	83 c4 04	 add	 esp, 4
  00058	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  0005b	85 f6		 test	 esi, esi
  0005d	75 05		 jne	 SHORT $LN16@Reallocate
$LN15@Reallocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0005f	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN60@Reallocate:
$LN16@Reallocate:
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00064	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  00067	8d 45 0b	 lea	 eax, DWORD PTR __Alval$4[ebp]
; File a:\vs\vc\include\vector

; 1590 : 		_TRY_BEGIN

  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00071	6a 00		 push	 0
  00073	50		 push	 eax
  00074	56		 push	 esi
  00075	ff 73 04	 push	 DWORD PTR [ebx+4]
  00078	ff 33		 push	 DWORD PTR [ebx]
  0007a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUCDynamicSphereInstance@@PAU1@V?$allocator@UCDynamicSphereInstance@@@std@@U1@@std@@YAPAUCDynamicSphereInstance@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDynamicSphereInstance *,CDynamicSphereInstance *,std::allocator<CDynamicSphereInstance>,CDynamicSphereInstance>
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00082	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00087	2b 0b		 sub	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00089	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0008c	f7 e9		 imul	 ecx

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0008e	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00090	03 d1		 add	 edx, ecx
  00092	c1 fa 04	 sar	 edx, 4
  00095	8b ca		 mov	 ecx, edx
  00097	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0009a	03 ca		 add	 ecx, edx
  0009c	89 4d 08	 mov	 DWORD PTR __Size$1$[ebp], ecx

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0009f	85 c0		 test	 eax, eax
  000a1	74 0c		 je	 SHORT $LN54@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  000ac	83 c4 04	 add	 esp, 4
$LN54@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  000af	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  000b6	89 33		 mov	 DWORD PTR [ebx], esi
  000b8	2b c7		 sub	 eax, edi
  000ba	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000bd	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000c0	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  000c7	2b c1		 sub	 eax, ecx
  000c9	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000cc	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1609 : 		}

  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000e3	ff 75 ec	 push	 DWORD PTR __Ptr$2[ebp]
  000e6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000eb	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1594 : 		_RERAISE;

  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN61@Reallocate:
$LN59@Reallocate:
  000f7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reallocate
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBE_NPBUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBE_NPBUCDynamicSphereInstance@@@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBE_NPBUCDynamicSphereInstance@@@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000c	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000e	f7 ee		 imul	 esi

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00015	03 d6		 add	 edx, esi
  00017	c1 fa 04	 sar	 edx, 4
  0001a	8b f2		 mov	 esi, edx
  0001c	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001f	03 f2		 add	 esi, edx

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00021	8b ce		 mov	 ecx, esi
  00023	d1 e9		 shr	 ecx, 1
  00025	2b c1		 sub	 eax, ecx
  00027	3b c6		 cmp	 eax, esi
  00029	73 10		 jae	 SHORT $LN4@Grow_to
  0002b	33 f6		 xor	 esi, esi

; 1576 : 		if (_Capacity < _Count)

  0002d	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  00030	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi

; 1579 : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0003b	03 f1		 add	 esi, ecx

; 1576 : 		if (_Capacity < _Count)

  0003d	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  00040	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi

; 1579 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?_Grow_to@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXPAUCDynamicSphereInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXPAUCDynamicSphereInstance@@0@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXPAUCDynamicSphereInstance@@0@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXABUCDynamicSphereInstance@@@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 60		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 5a		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0001e	f7 ef		 imul	 edi
  00020	03 d7		 add	 edx, edi
  00022	c1 fa 04	 sar	 edx, 4
  00025	8b fa		 mov	 edi, edx
  00027	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0002a	03 fa		 add	 edi, edx

; 1247 : 			if (this->_Mylast == this->_Myend)

  0002c	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00031	6a 01		 push	 1
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  00043	2b cf		 sub	 ecx, edi
  00045	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00048	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 4f		 je	 SHORT $LN49@push_back
  0004f	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00053	5f		 pop	 edi
  00054	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00058	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0005d	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00062	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00065	89 41 18	 mov	 DWORD PTR [ecx+24], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00068	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH
  0006c	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
$LN4@push_back:

; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00071	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00074	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00076	6a 01		 push	 1
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0007f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00082	85 c9		 test	 ecx, ecx
  00084	74 18		 je	 SHORT $LN49@push_back
  00086	f3 0f 6f 07	 movdqu	 xmm0, XMMWORD PTR [edi]
  0008a	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  0008e	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  00093	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00098	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0009b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0009e	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
?push_back@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXABUCDynamicSphereInstance@@@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEAAUCDynamicSphereInstance@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEAAUCDynamicSphereInstance@@I@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000d	2b d0		 sub	 edx, eax
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1210 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEAAUCDynamicSphereInstance@@I@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::operator[], COMDAT
; _this$ = ecx

; 1181 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000d	2b d0		 sub	 edx, eax
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1194 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??A?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?at@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?at@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::at, COMDAT
; _this$ = ecx

; 1167 : 		{	// subscript nonmutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00004	8b 31		 mov	 esi, DWORD PTR [ecx]
  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000e	2b ce		 sub	 ecx, esi
  00010	f7 e9		 imul	 ecx
  00012	03 d1		 add	 edx, ecx

; 1168 : 		if (size() <= _Pos)

  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00017	c1 fa 04	 sar	 edx, 4
  0001a	8b c2		 mov	 eax, edx
  0001c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001f	03 c2		 add	 eax, edx

; 1168 : 		if (size() <= _Pos)

  00021	3b c1		 cmp	 eax, ecx
  00023	76 11		 jbe	 SHORT $LN10@at

; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));

  00025	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0002c	2b c1		 sub	 eax, ecx
  0002e	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00031	5e		 pop	 esi

; 1171 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN10@at:

; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");
; 1755 : 		}
; 1756 : 
; 1757 : 	__declspec(noreturn) void _Xran() const
; 1758 : 		{	// report an out_of_range error
; 1759 : 		_Xout_of_range("invalid vector<T> subscript");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  0003b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN12@at:
$LN9@at:
  00040	cc		 int	 3
?at@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEABUCDynamicSphereInstance@@I@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::at
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::size, COMDAT
; _this$ = ecx

; 1147 : 		{	// return length of sequence

  00000	56		 push	 esi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1149 : 		}

  0001a	c3		 ret	 0
?size@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UCDynamicSphereInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

  00000	56		 push	 esi

; 1015 : 		return (this->_Myend - this->_Mylast);

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 71 04	 sub	 esi, DWORD PTR [ecx+4]
  0000c	f7 ee		 imul	 esi
  0000e	03 d6		 add	 edx, esi
  00010	c1 fa 04	 sar	 edx, 4
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
  0001a	5e		 pop	 esi

; 1016 : 		}

  0001b	c3		 ret	 0
?_Unused_capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::capacity, COMDAT
; _this$ = ecx

; 1009 : 		{	// return current length of allocated storage

  00000	56		 push	 esi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1011 : 		}

  0001a	c3		 ret	 0
?capacity@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::reserve, COMDAT
; _this$ = ecx

; 999  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00007	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H

; 1000 : 		if (capacity() < _Count)

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000f	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00012	2b 37		 sub	 esi, DWORD PTR [edi]
  00014	f7 ee		 imul	 esi
  00016	03 d6		 add	 edx, esi
  00018	c1 fa 04	 sar	 edx, 4
  0001b	8b c2		 mov	 eax, edx
  0001d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00020	03 c2		 add	 eax, edx

; 1000 : 		if (capacity() < _Count)

  00022	3b c1		 cmp	 eax, ecx
  00024	73 10		 jae	 SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

  00026	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  0002c	77 0e		 ja	 SHORT $LN21@reserve

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  0002e	51		 push	 ecx
  0002f	8b cf		 mov	 ecx, edi
  00031	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@IAEXI@Z ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::_Reallocate
$LN2@reserve:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 1005 : 			}
; 1006 : 		}

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN21@reserve:

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00041	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN23@reserve:
$LN20@reserve:
  00046	cc		 int	 3
?reserve@?$vector@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UCDynamicSphereInstance@@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CDynamicSphereInstance,std::allocator<CDynamicSphereInstance> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEPAUCDynamicSphereInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEPAUCDynamicSphereInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 21		 je	 SHORT $LN1@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00012	77 1d		 ja	 SHORT $LN14@allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 02	 shl	 eax, 2
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN14@allocate
$LN1@allocate:

; 847  : 		return (_Mybase::allocate(_Count));
; 848  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00036	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAEPAUCDynamicSphereInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >::_Wrap_alloc<std::allocator<CDynamicSphereInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAIABV?$allocator@UCDynamicSphereInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAIABV?$allocator@UCDynamicSphereInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UCDynamicSphereInstance@@@std@@@std@@SAIABV?$allocator@UCDynamicSphereInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CDynamicSphereInstance> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UCDynamicSphereInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UCDynamicSphereInstance@@@std@@QBEIXZ PROC ; std::allocator<CDynamicSphereInstance>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UCDynamicSphereInstance@@@std@@QBEIXZ ENDP ; std::allocator<CDynamicSphereInstance>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@ABU3@@Z PROC ; std::allocator<CDynamicSphereInstance>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [eax]
  00011	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  00015	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0001a	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN3@construct:

; 594  : 		}

  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?construct@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@ABU3@@Z ENDP ; std::allocator<CDynamicSphereInstance>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEPAUCDynamicSphereInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEPAUCDynamicSphereInstance@@I@Z PROC ; std::allocator<CDynamicSphereInstance>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 21		 je	 SHORT $LN1@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00012	77 1d		 ja	 SHORT $LN11@allocate
  00014	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001b	2b c1		 sub	 eax, ecx
  0001d	c1 e0 02	 shl	 eax, 2
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN11@allocate
$LN1@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));
; 579  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00036	cc		 int	 3
?allocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEPAUCDynamicSphereInstance@@I@Z ENDP ; std::allocator<CDynamicSphereInstance>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z PROC ; std::allocator<CDynamicSphereInstance>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@UCDynamicSphereInstance@@@std@@QAEXPAUCDynamicSphereInstance@@I@Z ENDP ; std::allocator<CDynamicSphereInstance>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@UCDynamicSphereInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UCDynamicSphereInstance@@@std@@QAE@XZ PROC ; std::allocator<CDynamicSphereInstance>::allocator<CDynamicSphereInstance>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UCDynamicSphereInstance@@@std@@QAE@XZ ENDP ; std::allocator<CDynamicSphereInstance>::allocator<CDynamicSphereInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QAEAAPAVCGrannyLODController@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QAEAAPAVCGrannyLODController@@I@Z PROC ; std::vector<CGrannyLODController *,std::allocator<CGrannyLODController *> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1210 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QAEAAPAVCGrannyLODController@@I@Z ENDP ; std::vector<CGrannyLODController *,std::allocator<CGrannyLODController *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QBEIXZ PROC ; std::vector<CGrannyLODController *,std::allocator<CGrannyLODController *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGrannyLODController@@V?$allocator@PAVCGrannyLODController@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGrannyLODController *,std::allocator<CGrannyLODController *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCRotationDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CRotationDecorator *>::allocator<NEffectUpdateDecorator::CRotationDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::~vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCGravityDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CGravityDecorator *>::allocator<NEffectUpdateDecorator::CGravityDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::~vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::~vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::~vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCNullDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CNullDecorator *>::allocator<NEffectUpdateDecorator::CNullDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::~vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@IAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@0@Z ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@2@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >::_Vector_alloc<0,std::_Vec_base_types<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Wrap_alloc<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z PROC ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAEXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@I@Z ENDP ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ PROC ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@QAE@XZ ENDP ; std::allocator<NEffectUpdateDecorator::CHeaderDecorator *>::allocator<NEffectUpdateDecorator::CHeaderDecorator *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 224  : 			::operator delete(pkData);

  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX@Z		; operator delete
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 150  : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 163  : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv463 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  00033	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00036	33 d2		 xor	 edx, edx
  00038	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003b	33 db		 xor	 ebx, ebx
  0003d	2b cf		 sub	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 132  : 		{

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	83 c1 03	 add	 ecx, 3
  00049	c1 e9 02	 shr	 ecx, 2
  0004c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0004f	0f 47 ca	 cmova	 ecx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00052	85 c9		 test	 ecx, ecx
  00054	74 17		 je	 SHORT $LN33@CDynamicPo
  00056	8b f1		 mov	 esi, ecx
$LL35@CDynamicPo:

; 24   : 		_Func(*_First);

  00058	ff 37		 push	 DWORD PTR [edi]
  0005a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  0005f	43		 inc	 ebx
  00060	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00063	83 c4 04	 add	 esp, 4
  00066	3b de		 cmp	 ebx, esi
  00068	75 ee		 jne	 SHORT $LL35@CDynamicPo
  0006a	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN33@CDynamicPo:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00073	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00076	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00079	85 c0		 test	 eax, eax
  0007b	74 1e		 je	 SHORT $LN50@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00083	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00086	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  0008d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00094	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN50@CDynamicPo:

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN63@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a8	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ab	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  000b2	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  000b9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN63@CDynamicPo:
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 142  : 		}

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
__unwindfunclet$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAE@XZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::~vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
__ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 130  : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 128  : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 129  : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 130  : 		}

  00040	c3		 ret	 0
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
;	COMDAT ?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
tv168 = 8						; size = 4
_c_rv3Source$ = 8					; size = 4
_c_rv3Target$ = 12					; size = 4
?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z PROC	; GetVector3Distance, COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _c_rv3Source$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  00009	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00016	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  0001b	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0001f	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00023	f3 0f 58 c1	 addss	 xmm0, xmm1
  00027	f3 0f 11 45 08	 movss	 DWORD PTR tv168[ebp], xmm0
  0002c	d9 45 08	 fld	 DWORD PTR tv168[ebp]

; 45   : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?GetVector3Distance@@YAMABUD3DXVECTOR3@@0@Z ENDP	; GetVector3Distance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEABVCSphereCollisionInstance@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEABVCSphereCollisionInstance@@I@Z PROC ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::operator[], COMDAT
; _this$ = ecx

; 1181 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1194 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEABVCSphereCollisionInstance@@I@Z ENDP ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1149 : 		}

  00016	c3		 ret	 0
?size@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@VCSphereCollisionInstance@@V?$allocator@VCSphereCollisionInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VCSphereCollisionInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CSphereCollisionInstance,std::allocator<CSphereCollisionInstance> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ PROC ; std::vector<NRaceData::SHitData,std::allocator<NRaceData::SHitData> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ ENDP ; std::vector<NRaceData::SHitData,std::allocator<NRaceData::SHitData> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ PROC ; std::vector<NRaceData::SHitData,std::allocator<NRaceData::SHitData> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USHitData@NRaceData@@V?$allocator@USHitData@NRaceData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USHitData@NRaceData@@@std@@@std@@@2@XZ ENDP ; std::vector<NRaceData::SHitData,std::allocator<NRaceData::SHitData> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\map
; File a:\vs\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Key, COMDAT
; _this$ = ecx

; 2239 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\map

; 59   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File a:\vs\vc\include\xtree

; 2241 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMABU?$pair@$$CBMUCDynamicSphereInstance@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMABU?$pair@$$CBMUCDynamicSphereInstance@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2234 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2236 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEABMABU?$pair@$$CBMUCDynamicSphereInstance@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z PROC ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Ubound, COMDAT
; _this$ = ecx

; 2177 : 		{	// find leftmost node greater than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2178 : 		_Nodeptr _Pnode = _Root();

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))

  00008	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0000c	75 20		 jne	 SHORT $LN32@Ubound
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00011	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
$LL4@Ubound:
  00015	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  0001a	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\xtree

; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

  0001d	76 06		 jbe	 SHORT $LN2@Ubound

; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;

  0001f	8b d1		 mov	 edx, ecx

; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 2186 : 				}
; 2187 : 			else

  00023	eb 03		 jmp	 SHORT $LN1@Ubound
$LN2@Ubound:

; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$LN1@Ubound:

; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))

  00028	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002c	74 e7		 je	 SHORT $LL4@Ubound
$LN32@Ubound:

; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate

  0002e	8b c2		 mov	 eax, edx

; 2191 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Ubound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z ENDP ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Ubound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Root, COMDAT
; _this$ = ecx

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z PROC ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 2088 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 2089 : 		_Nodeptr _Pnode = _Root();

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))

  00008	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0000c	75 1c		 jne	 SHORT $LN32@Lbound
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00011	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
$LL4@Lbound:
  00015	0f 2f 41 10	 comiss	 xmm0, DWORD PTR [ecx+16]
; File a:\vs\vc\include\xtree

; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00019	76 05		 jbe	 SHORT $LN2@Lbound

; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 2095 : 			else

  0001e	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;

  00020	8b d1		 mov	 edx, ecx

; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))

  00024	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00028	74 eb		 je	 SHORT $LL4@Lbound
$LN32@Lbound:

; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate

  0002a	8b c2		 mov	 eax, edx

; 2102 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@ABM@Z ENDP ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?upper_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z PROC ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::upper_bound, COMDAT
; _this$ = ecx

; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))

  00008	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0000c	75 20		 jne	 SHORT $LN40@upper_boun
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00011	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
$LL6@upper_boun:
  00015	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [ecx+16]
  0001a	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\xtree

; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

  0001d	76 06		 jbe	 SHORT $LN4@upper_boun

; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;

  0001f	8b d1		 mov	 edx, ecx

; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 2186 : 				}
; 2187 : 			else

  00023	eb 03		 jmp	 SHORT $LN3@upper_boun
$LN4@upper_boun:

; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$LN3@upper_boun:

; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))

  00028	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002c	74 e7		 je	 SHORT $LL6@upper_boun
$LN40@upper_boun:

; 44   : 		{	// construct with node pointer _Pnode

  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	89 10		 mov	 DWORD PTR [eax], edx

; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?upper_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z ENDP ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::upper_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
; File a:\vs\vc\include\xstddef
; File a:\vs\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z PROC ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))

  00008	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0000c	75 1c		 jne	 SHORT $LN40@lower_boun
; File a:\vs\vc\include\xstddef

; 193  : 		return (_Left < _Right);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00011	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
$LL6@lower_boun:
  00015	0f 2f 41 10	 comiss	 xmm0, DWORD PTR [ecx+16]
; File a:\vs\vc\include\xtree

; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00019	76 05		 jbe	 SHORT $LN4@lower_boun

; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 2095 : 			else

  0001e	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:

; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;

  00020	8b d1		 mov	 edx, ecx

; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN3@lower_boun:

; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))

  00024	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00028	74 eb		 je	 SHORT $LL6@lower_boun
$LN40@lower_boun:

; 44   : 		{	// construct with node pointer _Pnode

  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	89 10		 mov	 DWORD PTR [eax], edx

; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@@2@ABM@Z ENDP ; std::_Tree<std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@M@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@M@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1006 : 		{	// get ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 		return (key_compare());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@MUCDynamicSphereInstance@@U?$less@M@std@@V?$allocator@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@M@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<float,CDynamicSphereInstance,std::less<float>,std::allocator<std::pair<float const ,CDynamicSphereInstance> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Min, COMDAT

; 615  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 0c		 jne	 SHORT $LN15@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 617  : 			_Pnode = _Left(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 584  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]

; 616  : 		while (!_Isnil(_Left(_Pnode)))

  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN15@Min:

; 618  : 		return (_Pnode);

  0001a	8b c1		 mov	 eax, ecx

; 619  : 		}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAU?$pair@$$CBMUCDynamicSphereInstance@@@2@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAU?$pair@$$CBMUCDynamicSphereInstance@@@2@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Myval, COMDAT

; 603  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 604  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 605  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAU?$pair@$$CBMUCDynamicSphereInstance@@@2@PAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Right, COMDAT

; 598  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 600  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Parent, COMDAT

; 593  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 595  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Left, COMDAT

; 588  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 589  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 590  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Isnil, COMDAT

; 583  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 585  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBMUCDynamicSphereInstance@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<float const ,CDynamicSphereInstance> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??R?$less@M@std@@QBE_NABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@M@std@@QBE_NABM0@Z PROC			; std::less<float>::operator(), COMDAT
; _this$ = ecx

; 192  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		return (_Left < _Right);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al

; 194  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??R?$less@M@std@@QBE_NABM0@Z ENDP			; std::less<float>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CDynamicSphereInstance@@QAE@XZ
_TEXT	SEGMENT
??0CDynamicSphereInstance@@QAE@XZ PROC			; CDynamicSphereInstance::CDynamicSphereInstance, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0CDynamicSphereInstance@@QAE@XZ ENDP			; CDynamicSphereInstance::CDynamicSphereInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ PROC	; CSingleton<CTimer>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ENDP	; CSingleton<CTimer>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3LengthSq, COMDAT

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0000b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00014	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00018	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00020	f3 0f 58 d1	 addss	 xmm2, xmm1
  00024	f3 0f 58 d0	 addss	 xmm2, xmm0
  00028	f3 0f 11 55 08	 movss	 DWORD PTR tv160[ebp], xmm2
  0002d	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1254 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00003	ff 75 0c	 push	 DWORD PTR _mat$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 582  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??XD3DXMATRIX@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
??XD3DXMATRIX@@QAEAAU0@ABU0@@Z PROC			; D3DXMATRIX::operator*=, COMDAT
; _this$ = ecx

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 512  :     D3DXMatrixMultiply(this, this, &mat);

  00004	ff 75 08	 push	 DWORD PTR _mat$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	56		 push	 esi
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 513  :     return *this;

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 514  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??XD3DXMATRIX@@QAEAAU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??D@YA?AUD3DXVECTOR3@@MABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_v$ = 16						; size = 4
??D@YA?AUD3DXVECTOR3@@MABU0@@Z PROC			; operator*, COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]

; 180  :     x = fx;

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00016	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0001a	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00023	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00028	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002d	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  00031	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 284  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??D@YA?AUD3DXVECTOR3@@MABU0@@Z ENDP			; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??KD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??KD3DXVECTOR3@@QBE?AU0@M@Z PROC			; D3DXVECTOR3::operator/, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 275  :     FLOAT fInv = 1.0f / f;

  00003	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0000b	f3 0f 5e 4d 0c	 divss	 xmm1, DWORD PTR _f$[ebp]

; 180  :     x = fx;

  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  00013	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00017	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  0001b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  0001f	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00024	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00028	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  0002d	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00032	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  00036	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 277  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??KD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator/
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXVECTOR3@@QBE?AU0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
??DD3DXVECTOR3@@QBE?AU0@M@Z PROC			; D3DXVECTOR3::operator*, COMDAT
; _this$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00003	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _f$[ebp]
  00008	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0000f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00013	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00017	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001c	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 181  :     y = fy;

  00020	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00025	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002a	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 270  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??DD3DXVECTOR3@@QBE?AU0@M@Z ENDP			; D3DXVECTOR3::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  0000a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000d	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00015	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001a	f3 0f 5c 42 04	 subss	 xmm0, DWORD PTR [edx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 5c 42 08	 subss	 xmm0, DWORD PTR [edx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 264  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]

; 180  :     x = fx;

  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00009	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0000d	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]

; 180  :     x = fx;

  00011	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00015	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [edx+4]
  0001a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]

; 181  :     y = fy;

  0001f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00024	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [edx+8]
  00029	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 258  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HD3DXVECTOR3@@QBE?AU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??XD3DXVECTOR3@@QAEAAU0@M@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
??XD3DXVECTOR3@@QAEAAU0@M@Z PROC			; D3DXVECTOR3::operator*=, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 222  :     x *= f;

  00003	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]

; 223  :     y *= f;
; 224  :     z *= f;
; 225  :     return *this;

  00007	8b c1		 mov	 eax, ecx
  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _f$[ebp]
  0000e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00012	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00016	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001b	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0001f	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00024	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00029	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0002d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 226  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??XD3DXVECTOR3@@QAEAAU0@M@Z ENDP			; D3DXVECTOR3::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC			; D3DXVECTOR3::operator+=, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  :     x += v.x;

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00006	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000a	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  0000e	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 205  :     y += v.y;

  00012	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00017	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0001c	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 206  :     z += v.z;

  00021	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]

; 207  :     return *this;

  00026	8b c1		 mov	 eax, ecx
  00028	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  0002d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 208  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??YD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 520  : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN5@c_str

; 1739 : 		return (this->_Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1740 : 		}

  00008	c3		 ret	 0
$LN5@c_str:

; 1739 : 		return (this->_Myptr());

  00009	8b c1		 mov	 eax, ecx

; 1740 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 521  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

  00009	8b c1		 mov	 eax, ecx

; 521  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 48   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 764  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 765  :     return (float)sin(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  00010	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00014	f3 0f 11 45 08	 movss	 DWORD PTR tv68[ebp], xmm0
  00019	d9 45 08	 fld	 DWORD PTR tv68[ebp]

; 766  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 663  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 664  :     return (float)cos(_X);

  00008	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000b	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  00010	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00014	f3 0f 11 45 08	 movss	 DWORD PTR tv68[ebp], xmm0
  00019	d9 45 08	 fld	 DWORD PTR tv68[ebp]

; 665  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
